<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-06-23T11:41:35.192Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp输入方式</title>
    <link href="https://penge666.github.io/posts/2fa03bf9.html"/>
    <id>https://penge666.github.io/posts/2fa03bf9.html</id>
    <published>2024-06-23T09:07:53.000Z</published>
    <updated>2024-06-23T11:41:35.192Z</updated>
    
    <content type="html"><![CDATA[<p>在算竞中经常需要读取数据，这篇文章对Cpp的输入方式总结。</p><h2 id="输入方式">输入方式</h2><h3 id="1-cin"><strong>1.cin</strong></h3><p>（1）cin&gt;&gt;等价于cin.operator&gt;&gt;()，即调用成员函数operator&gt;&gt;()进行读取数据。</p><p>（2）当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。<strong>但是如果读取成功，字符后面的分隔符是残留在</strong>缓冲区的，cin&gt;&gt;不做处理。如果后续接getline()要记得处理换行符！</p><p>补充：</p><ul><li><p><strong>Tab键</strong>：通常在键盘上标记为<code>Tab</code>，按下后插入一个制表符（Tab字符）。制表符的长度通常为多个空格，可以在不同的编辑器或环境中设置长度，常见的设置是4个或8个空格。【在计算机中用于对齐文本的特殊字符】</p></li><li><p><strong>空格键</strong>：按下后插入一个空格字符。每次按下空格键插入一个空格，长度固定。</p></li></ul><p>（3）不想略过空白字符，那就使用 noskipws 流控制。比如：cin&gt;&gt;noskipws&gt;&gt;input;</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, std::string&amp; str) &#123;</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">// 清空字符串</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    is &gt;&gt; std::ws; <span class="comment">// 跳过前导的空白字符</span></span><br><span class="line">    <span class="keyword">while</span> (is.<span class="built_in">get</span>(ch) &amp;&amp; !<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">        str += ch; <span class="comment">// 将字符添加到字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is; <span class="comment">// 返回输入流对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><p>C 库函数 <strong>int isspace(int c)</strong> 检查所传的字符是否是空白字符。</p><p>标准的空白字符包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>     (0x20)    space (SPC) 空格符</span><br><span class="line"><span class="string">&#x27;\t&#x27;</span>    (0x09)    horizontal tab (TAB) 水平制表符    </span><br><span class="line"><span class="string">&#x27;\n&#x27;</span>    (0x0a)    newline (LF) 换行符</span><br><span class="line"><span class="string">&#x27;\v&#x27;</span>    (0x0b)    vertical tab (VT) 垂直制表符</span><br><span class="line"><span class="string">&#x27;\f&#x27;</span>    (0x0c)    feed (FF) 换页符</span><br><span class="line"><span class="string">&#x27;\r&#x27;</span>    (0x0d)    carriage <span class="built_in">return</span> (CR) 回车符</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> n,m,k,p,q;</span><br><span class="line">cin&gt;&gt;std::noskipws&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p&gt;&gt;q;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;q&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q w e a z</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q w e a z</span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-cin-get"><strong>2.cin.get()</strong></h3><p>单用cin.get()只能读取其中一个字符，不能存储为string全部的字符。</p><p>若要存储全部则必须传入一个数组以及长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">main</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[n];</span><br><span class="line">    cin.<span class="built_in">get</span>(a,n); <span class="comment">//实际包括空格只能存n-1个字符，最后一个字符</span></span><br><span class="line">是<span class="string">&#x27;\n&#x27;</span>以回车作为结束符。</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-cin-getline"><strong>3.cin.getline()</strong></h3><p>接受一个字符串，可以接收空格并输出,吃掉末尾的换行符的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(m,<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>cin.getline(m, 5)</code> 时，函数从输入流中读取最多 <code>5 - 1 = 4</code> 个字符，并在读取到的字符后添加一个终止空字符 <code>\0</code>。</p><p>延伸：</p><p>cin.getline()实际上有三个参数，<code>cin.getline(接受字符串的看中间的m,接受个数5,结束字符) </code></p><p>当第三个参数省略时，系统默认为’\0’ 。</p><p>如果将例子中cin.getline()改为cin.getline(m,5,‘a’);当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</p><p>当用在多维数组中的时候，也可以用cin.getline(m[i],20)之类的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> m[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin.<span class="built_in">getline</span>(m[i], <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输出m[&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;]的值:&quot;</span> &lt;&lt; m[j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string输入">string输入</h2><h3 id="4-getline"><strong>4.getline()</strong></h3><p>接受一个字符串，可以接收空格并输出，需包含“#include”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str); <span class="comment">// 和cin.getline()一样可以按某个字符结尾</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-getchar"><strong>5.getchar()</strong></h3><p>函数原型：int getchar(void);</p><p>返回类型为int,参数为void</p><p>头  文  件：#include&lt;stdio.h&gt;</p><p>返  回  值：</p><ol><li>getchar返回的是字符的ASCII码值（整数）</li><li>getchar在读取结束或者失败的时候，会返回EOF。(EOF意思是end of file,本质上是-1）</li></ol><p>读取方式：只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符。<br>结束输入的方式：以Enter结束输入（空格不结束），接受空格符。<br>舍弃回车符的方法：以Enter结束输入时，接受空格，会舍弃最后的回车符。</p><p><strong>getchar函数执行过程详解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">getchar</span>();<span class="comment">//输入字符</span></span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的简单意思就是从键盘读入一个字符，然后输出到屏幕。理所当然，我们输入A，输出就是A，输入B，输出就是B。</p><p>那么我们如果输出的是ABC呢？答案是A。</p><p>解释如下：当我们从键盘输入字符‘A’，‘B’,  ‘C’，并按下回车后，我们的输入被放入了输入缓冲区，这个时候getchar()会从缓冲区中读取我们刚才的输入，一次只读一个字符，所以字符A就被拿出来了，赋值给了ch，然后putchar()又将ch放在了标准输出，也就是这里的屏幕，所以我们看见了最终的显示结果A。同时字符‘A’也被缓冲区释放了，而字符‘B’,'C’仍然被留在了缓冲区。而这样是很不安全的，有可能下次使用的时候，我们的缓冲区会读到一些垃圾，但是当程序结束的时候，它会自动刷新。</p><p>解释：现在，考虑这样一个场景：你的程序在接收了用户的一些输入之后，由于某种原因突然终止了，没有正常退出。这种情况下，这些未处理的输入可能会留在输入缓冲区中，没有被清理掉。当你的程序下次运行并再次试图从输入缓冲区获取输入时，它可能会先读取到这些残留的旧数据，而不是新的用户输入。这就是我们所说的&quot;可能会读到一些垃圾&quot;的含义。</p><h3 id="6-gets">6.gets()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gets</span>(m)用于string类的，需包含<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>。可以接收空格，遇回车结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span><span class="comment">//必须是cstring，否则strlen()方法不能用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">40000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(a);<span class="comment">//必须是char型数组，不能是其他类型数组</span></span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(a);<span class="comment">//得到char型数组的实际长度</span></span><br><span class="line">    <span class="comment">//执行其余操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于多维数组。</p><p>可用于多维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">　　<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">　　<span class="built_in">main</span> ()</span><br><span class="line">　　&#123;</span><br><span class="line">    　　<span class="type">char</span> m[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;\n请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">gets_s</span>(m[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"> <span class="type">int</span> len = <span class="built_in">strlen</span>(m[j]);<span class="comment">//得到char型数组的实际长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;输出m[&quot;</span> &lt;&lt; j &lt;&lt; k &lt;&lt; <span class="string">&quot;]的值:&quot;</span> &lt;&lt; m[j][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="算竞输入补充">算竞输入补充</h2><ul><li><a href="https://blog.csdn.net/ZER00000001/article/details/126345457">竞赛中应该用scanf还是cin？ scanf&amp;printf与cin&amp;cout的比较+快读快写</a></li></ul><p>我利用代码生成了<strong>三千万</strong>个【1，100】以内的随机数，并且将分别用<code>cin</code>和<code>scanf</code>输入到一个数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXNUM  = <span class="number">30000000</span>;</span><br><span class="line"><span class="type">int</span> RandomNumber;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    RandomNumber = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//scanf(&quot;%d &quot;, &amp;number[i]);</span></span><br><span class="line">cin &gt;&gt; number[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;scanf用时：%.3lf\n&quot;</span>, <span class="built_in">double</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在Windows系统<a href="https://so.csdn.net/so/search?q=GCC%E7%BC%96%E8%AF%91%E5%99%A8&amp;spm=1001.2101.3001.7020">GCC编译器</a>下得出的用时数据（单位：秒），且已验证过不存在偶然性：</p><table><thead><tr><th>scanf</th><th>cin</th></tr></thead><tbody><tr><td>6.836</td><td>11.303</td></tr></tbody></table><p>同时，我用printf和cout分别输出<strong>十万个正整数</strong>。</p><table><thead><tr><th>printf</th><th>cout</th></tr></thead><tbody><tr><td>6.172</td><td>11.509</td></tr></tbody></table><p>于是可以得出结论：<strong>cin&amp;cout的确在效率上是低于scanf&amp;printf的</strong></p><p>而我们可以通过std::ios::sync_with_stdio(false);指令关闭同步（这里要注意：当关闭同步之后为了确保准确，不要使用 printf&amp;scanf了），除此之外我们还可以通过std::cin.tie(nullptr);获取cin更优的性能（解除std :: cin和std :: cout之间的绑定，来降低IO的负担使效率提升）。那么在对iostream优化之后的 printf&amp;scanf 和 cin&amp;cout效率差距又有多大呢？我通过上述的实验得出以下数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world!Hello,</span><br></pre></td></tr></table></figure><p>Note：<code>std::ios::sync_with_stdio(false);</code> 这条语句的作用是关闭C++的iostream和C的stdio之间的同步。</p><p>在默认情况下（同步开启），程序的输出会是 “Hello, world!”。因为cout和printf是同步的，所以他们的输出顺序是按照我们写的顺序来的。</p><p>但是，如果我们关闭同步，那么程序的输出就可能不是&quot;Hello, world!&quot;了。可能cout的输出先出现，也可能printf的输出先出现，这取决于哪个操作更快。所以，在关闭同步后，我们就不能再预期混合使用C++的iostream和C的stdio时的输出顺序了。</p><p><strong>疑问：关闭C++的iostream和C的stdio之间的同步为什么能提高速度？</strong></p><p><strong>有趣的解答：</strong></p><p>假设你正在举办一场派对，你邀请了两个DJ，一个是专门播放摇滚音乐的，另一个是专门播放爵士乐的。你希望他们能够交替播放音乐，这样你的派对就可以同时享受到摇滚和爵士的风格。</p><p>但是，为了确保他们能够顺利地交替播放，你需要找一个协调员来时刻注意两位DJ的状态，告诉他们什么时候该停，什么时候该播。这个协调员就相当于同步机制，他确保了摇滚DJ和爵士DJ（相当于iostream和stdio）能够和谐工作。</p><p>然而，这个协调员并不是免费的。他需要时间去观察和指挥，这就可能会延迟音乐的切换，也就是说，派对的整体节奏可能会因为等待协调员的指示而变慢。这就像为了维持iostream和stdio的同步，系统需要做额外的工作（比如刷新缓冲区），这会导致效率的降低。</p><p>现在假设你决定不再需要协调员，让两位DJ自己决定何时播放音乐。这样，你就节省了协调员的成本，派对的节奏也可能会更快。但是，你也无法再保证摇滚音乐和爵士乐能够完美交替，他们可能会同时播放，也可能会有短暂的静音。这就像当你关闭iostream和stdio的同步时，虽然提高了效率，但也无法保证他们的操作顺序。</p><p>总的来说，关闭iostream和stdio的同步可以提高效率，但同时也会牺牲他们的协调性。在某些情况下，这可能是值得的，但在其他情况下，可能就需要考虑其他解决方案了。</p><table><thead><tr><th>scanf</th><th>cin（优化后）</th></tr></thead><tbody><tr><td>6.836</td><td>2.695</td></tr></tbody></table><table><thead><tr><th>printf</th><th>cout （优化后）</th></tr></thead><tbody><tr><td>6.172</td><td>6.178</td></tr></tbody></table><p>可以看见在关闭同步之后cin的效率已经是高于scanf了，并且cout的速度与printf的速度也相差无几，那我们还能不能继续优化呢？</p><p>我们注意到通常在用cout输出的时候，更习惯去使用endl，它既可以达到换行的需求又可以刷新缓冲区，然而在如此高度的循环下它一直对缓冲区的操作却降低了效率，所以将endl换成’\n’cout的效率将会起飞</p><p>（顺带一提，我在开启同步的条件发现endl或是<code>\n</code> 对cout效率的影响并不大，不知道是不是我的问题，希望各位指出）</p><table><thead><tr><th>printf</th><th>cout（‘\n’）</th></tr></thead><tbody><tr><td>6.172</td><td>1.106</td></tr></tbody></table><p>如此一来我们再一次得出结论：<strong>在同步开启时，scanf&amp;printf的效率要高于cin&amp;cout；当同步关闭时，cin&amp;cout的效率要高于scanf&amp;printf。</strong></p><p>最后，附上ACMer喜欢的快读模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*快读快写*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span><span class="comment">//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//自定义的类型T</span></span><br><span class="line">   <span class="keyword">register</span> T sum = <span class="number">0</span>, f1 = <span class="number">1</span>;<span class="comment">//f1是标志位</span></span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="comment">//如果输入的是负数</span></span><br><span class="line">   <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           f1 = <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       sum = sum * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum * f1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int a = read&lt;int&gt;();</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> stk[<span class="number">20</span>];<span class="comment">//模拟压栈</span></span><br><span class="line">   <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       stk[top++] = x % <span class="number">10</span>;</span><br><span class="line">       x /= <span class="number">10</span>;</span><br><span class="line">   &#125;<span class="keyword">while</span>(x);</span><br><span class="line">   <span class="keyword">while</span>(top)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//write(a);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>read</th><th>cin</th></tr></thead><tbody><tr><td>0.485</td><td>2.695</td></tr></tbody></table><table><thead><tr><th>write</th><th>cout</th></tr></thead><tbody><tr><td>18.908</td><td>1.106</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Cpp输入方式总结</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp异常机制</title>
    <link href="https://penge666.github.io/posts/85e41e12.html"/>
    <id>https://penge666.github.io/posts/85e41e12.html</id>
    <published>2024-06-22T13:46:01.000Z</published>
    <updated>2024-06-23T14:32:05.912Z</updated>
    
    <content type="html"><![CDATA[<h1>C++异常机制概述</h1><p>异常处理是C++ 的一项语言机制，用于在程序中处理异常事件。异常事件在C++中表示为异常对象。异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为<strong>异常出现点</strong>，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块，在包含了异常出现点的最内层的try块，依次匹配catch语句中的异常对象（<strong>只进行类型匹配，catch参数有时在catch语句中并不会使用到</strong>）。<strong>若匹配成功，则执行catch块内的异常处理语句，然后接着执行try…catch…块之后的代码</strong>。如果在当前的try…catch…块内找不到匹配该异常对象的catch语句,则由更外层的try…catch…块来处理该异常；<strong>如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常</strong>。<strong>如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序。</strong></p><p>一个最简单的try…catch…的例子如下所示。我们有个程序用来记班级学生考试成绩，考试成绩分数的范围在0-100之间，不在此范围内视为数据异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> score;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将分数写入文件或进行其他操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> score)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;你输入的分数数值有问题，请重新输入！&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>throw 关键字</h1><p>在上面这个示例中，throw是个关键字，与抛出表达式构成了throw语句。其语法为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw 表达式<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>throw语句必须包含在try块中，也可以是被包含在调用栈的外层函数的try块中，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：throw包含在外层函数的try块中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> score; <span class="comment">//throw语句被包含在外层main的try语句块中</span></span><br><span class="line">    <span class="comment">//将分数写入文件或进行其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">registerScore</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> score)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;你输入的分数数值有问题，请重新输入！&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行throw语句时，==throw表达式将作为对象被复制构造为一个新的对象，称为异常对象==。异常对象放在内存的特殊位置，<strong>该位置既不是栈也不是堆</strong>，<strong>在window上是放在线程信息块TIB中</strong>。这个构造出来的新对象与本级的try所对应的catch语句进行类型匹配，类型匹配的原则在下面介绍.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240623222008901.png" alt="image-20240623222008901"></p><p>在本例中，依据score构造出来的对象类型为int，与catch(int score)匹配上，程序控制权转交到catch的语句块，进行异常处理代码的执行。如果在本函数内与catch语句的类型匹配不成功，则在调用栈的外层函数继续匹配，如此递归执行直到匹配上catch语句，或者直到main函数都没匹配上而调用系统函数terminate()终止程序。 当执行一个throw语句时，跟在throw语句之后的语句将不再被执行，throw语句的语法有点类似于return，因此导致在调用栈上的函数可能提早退出。</p><h1>异常对象</h1><p>异常对象是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型。不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的。【因为要复制构造异常对象以及catch之后析构对象，因此不应该将其设置为private】</p><p>异常对象不同于函数的局部对象，局部对象在函数调用结束后就被自动销毁，<strong>而异常对象将驻留在所有可能被激活的catch语句都能访问到的内存空间中，也即上文所说的TIB。当异常对象与catch语句成功匹配上后，在该catch语句的结束处被自动析构。</strong></p><p>在函数中返回局部变量的引用或指针几乎肯定会造成错误，同样的道理，<strong>在throw语句中抛出局部变量的指针或引用也几乎是错误的行为</strong>。如果指针所指向的变量在执行catch语句时已经被销毁，对指针进行解引用将发生意想不到的后果。</p><p>throw出一个表达式时，<strong>该表达式的静态编译类型将决定异常对象的类型</strong>。所以当throw出的是基类指针的解引用，而该指针所指向的实际对象是派生类对象，此时将发生派生类对象切割。</p><p>来看个例子解释下：</p><p>在C++中，如果你抛出一个基类的引用或者指针，但它实际上指向一个派生类对象，那么在抛出异常时，只有基类部分会被抛出，派生类的部分会被切割掉。这就是所谓的&quot;对象切割&quot;问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived d;</span><br><span class="line">        <span class="built_in">foo</span>(d);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (Base&amp; b) &#123;</span><br><span class="line">        b.<span class="built_in">print</span>(); <span class="comment">// 输出 &quot;Base&quot; 而不是 &quot;Derived&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在这个例子中，<code>Derived</code>是<code>Base</code>的派生类。<code>foo</code>函数接收一个<code>Base</code>的引用，并抛出这个引用。在<code>main</code>函数中，我们创建了一个<code>Derived</code>对象<code>d</code>，并将它作为<code>Base</code>的引用传递给<code>foo</code>函数。当<code>foo</code>函数抛出这个引用时，只有<code>Base</code>部分被抛出，<code>Derived</code>部分被切割掉。所以，当我们在<code>catch</code>块中捕获这个异常并调用<code>print</code>函数时，输出的是&quot;Base&quot;，而不是&quot;Derived&quot;。</p><p>除了抛出用户自定义的类型外，C++标准库定义了一组类，用户报告标准库函数遇到的问题。这些标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。</p><table><thead><tr><th>标准异常类</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>exception</td><td>最通用的异常类，只报告异常的发生而不提供任何额外的信息</td><td>exception</td></tr><tr><td>runtime_error</td><td>只有在运行时才能检测出的错误</td><td>stdexcept</td></tr><tr><td>rang_error</td><td>运行时错误：产生了超出有意义值域范围的结果</td><td>stdexcept</td></tr><tr><td>overflow_error</td><td>运行时错误：计算上溢</td><td>stdexcept</td></tr><tr><td>underflow_error</td><td>运行时错误：计算下溢</td><td>stdexcept</td></tr><tr><td>logic_error</td><td>程序逻辑错误</td><td>stdexcept</td></tr><tr><td>domain_error</td><td>逻辑错误：参数对应的结果值不存在</td><td>stdexcept</td></tr><tr><td>invalid_argument</td><td>逻辑错误：无效参数</td><td>stdexcept</td></tr><tr><td>length_error</td><td>逻辑错误：试图创建一个超出该类型最大长度的对象</td><td>stdexcept</td></tr><tr><td>out_of_range</td><td>逻辑错误：使用一个超出有效范围的值</td><td>stdexcept</td></tr><tr><td>bad_alloc</td><td>内存动态分配错误</td><td>new</td></tr><tr><td>bad_cast</td><td>dynamic_cast类型转换出错</td><td>type_info</td></tr></tbody></table><h1>catch 关键字</h1><p>catch语句匹配被抛出的异常对象。如果catch语句的参数是引用类型，则该参数可直接作用于异常对象，即参数的改变也会改变异常对象，==而且在catch中<strong>重新抛出异常</strong>时会继续传递这种改变==。如果catch参数是传值的，则复制构函数将依据异常对象来构造catch参数对象。在该catch语句结束的时候，先析构catch参数对象，然后再析构异常对象。</p><p>在进行异常对象的匹配时，<strong>编译器不会做任何的隐式类型转换或类型提升</strong>。</p><p>除了以下几种情况外，异常对象的类型必须与catch语句的声明类型完全匹配：</p><ul><li>允许从非常量到常量的类型转换。</li><li>允许派生类到基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针。</li><li>函数被转换成指向函数类型的指针。</li></ul><p>寻找catch语句的过程中，匹配上的未必是类型完全匹配那项，而在是最靠前的第一个匹配上的catch语句（我称它为<strong>最先匹配原则</strong>）。<strong>所以，派生类的处理代码catch语句应该放在基类的处理catch语句之前，否则先匹配上的总是参数类型为基类的catch语句，而能够精确匹配的catch语句却不能够被匹配上。</strong></p><p>解释：</p><p>在查找适合的<code>catch</code>块以处理抛出的异常时，C++会按照代码的顺序从上到下查找，当找到第一个能够匹配抛出的异常类型的<code>catch</code>块时，就会执行这个<code>catch</code>块。如果派生类的<code>catch</code>块被放在了基类的<code>catch</code>块之后，那么基类的<code>catch</code>块就会先被匹配上，派生类的<code>catch</code>块就无法被执行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Derived</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Base&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Base\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Derived&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Derived\n&quot;</span>; <span class="comment">// 这个catch块永远不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>foo</code>函数抛出了一个<code>Derived</code>类型的异常，但是在<code>main</code>函数中，先匹配上的是<code>Base</code>类型的<code>catch</code>块，所以输出的是&quot;Caught Base&quot;。尽管有一个精确匹配<code>Derived</code>类型的<code>catch</code>块，但是由于它被放在了<code>Base</code>类型的<code>catch</code>块之后，所以它永远不会被执行。</p><p>为了避免这种情况，我们应该将派生类的<code>catch</code>块放在基类的<code>catch</code>块之前，就像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Derived&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Derived\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Base&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Base\n&quot;</span>; <span class="comment">// 只有当抛出的异常不是Derived类型时，这个catch块才会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当<code>foo</code>函数抛出一个<code>Derived</code>类型的异常时，就会先匹配上<code>Derived</code>类型的<code>catch</code>块，输出的就是&quot;Caught Derived&quot;了。</p><hr><p>在catch块中，如果在当前函数内无法解决异常，可以继续向外层抛出异常，让外层catch异常处理块接着处理。此时可以使用不带表达式的throw语句将捕获的异常重新抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(type x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//做了一部分处理</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被重新抛出的异常对象为保存在TIB中的那个异常对象</strong>，与catch的参数对象没有关系，若catch参数对象是引用类型，<strong>可能在catch语句内已经对异常对象进行了修改，那么重新抛出的是修改后的异常对象</strong>；若catch参数对象是非引用类型，则重新抛出的异常对象并没有受到修改。</p><p>使用<code>catch(...)&#123;&#125;</code>可以捕获所有类型的异常，根据最先匹配原则，<code>catch(...)&#123;&#125;</code>应该<strong>放在所有catch语句的最后面</strong>，否则无法让其他可以精确匹配的catch语句得到匹配。通常在catch(…){}语句中执行当前可以做的处理，然后再重新抛出异常。<strong>注意，catch中重新抛出的异常只能被外层的catch语句捕获。</strong></p><h1>栈展开、RAII</h1><p>其实栈展开已经在前面说过，就是从异常抛出点一路向外层函数寻找匹配的catch语句的过程，寻找结束于某个匹配的catch语句或标准库函数terminate。这里重点要说的是栈展开过程中对局部变量的销毁问题。我们知道，在函数调用结束时，函数的局部变量会被系统自动销毁，类似的，<strong>throw可能会导致调用链上的语句块提前退出，此时，语句块中的局部变量将按照构成生成顺序的逆序，依次调用析构函数进行对象的销毁</strong>。例如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个没有任何意义的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() :<span class="built_in">a</span>(<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;A默认构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span>  A&amp; rsh)&#123; cout &lt;&lt; <span class="string">&quot;A复制构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; cout &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a ;</span><br><span class="line">            <span class="keyword">throw</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (A a)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A默认构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br></pre></td></tr></table></figure><p>定义变量a时调用了默认构造函数，使用a初始化异常变量时调用了复制构造函数，使用异常变量复制构造catch参数对象时同样调用了复制构造函数。三个构造对应三个析构，也即try语句块中局部变量a自动被析构了。然而，如果a是在自由存储区上分配的内存时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        A * a= <span class="keyword">new</span> A;</span><br><span class="line">        <span class="keyword">throw</span> *a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (A a)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A默认构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br></pre></td></tr></table></figure><p>同样的三次构造，却只调用了两次的析构函数！说明a的内存在发生异常时并没有被释放掉，发生了内存泄漏。 ==RAII机制有助于解决这个问题==，RAII（Resource acquisition is initialization，资源获取即初始化）。它的思想是以对象管理资源。为了更为方便、鲁棒地释放已获取的资源，避免资源死锁，一个办法是把资源数据用对象封装起来。程序发生异常，执行栈展开时，封装了资源的对象会被自动调用其析构函数以释放资源。C++ 中的智能指针便符合RAII。关于这个问题详细可以看《Effective C++》条款13.</p><p><strong>条款13：以对象管理资源</strong></p><p>为了防止资源泄漏，请使用RAII(Resource Acquisition Is Initialization)对象，在构造函数里面获得资源，在析构函数里面释放资源 <code>auto_ptr</code>(c++11废弃，原因见笔记)，<code>shared_ptr</code>，<code>unique_lock</code>都是RAII类。</p><h1>异常机制与构造函数</h1><p>异常机制的一个合理的使用是在构造函数中。<strong>构造函数没有返回值，所以应该使用异常机制来报告发生的问题</strong>。更重要的是，构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用，因此析构函数应该先析构所有所有已初始化的基对象，成员对象，再抛出异常。 C++类<strong>构造函数初始化列表的异常机制</strong>，称为function-try block。一般形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myClass::<span class="built_in">myClass</span>(type1 pa1)</span><br><span class="line">    <span class="keyword">try</span>:  _myClass_val (初始化值) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">/*构造函数的函数体 */</span></span><br><span class="line">&#125; </span><br><span class="line">  <span class="built_in">catch</span> ( exception&amp; err ) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 构造函数的异常处理部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用.可能会存在内存泄漏。因此提出<strong>构造函数初始化列表的异常机制</strong></p><h1>异常机制与析构函数</h1><p>C++不禁止析构函数向外界抛出异常，==但析构函数被期望不向外界函数抛出异常==。析构函数中向函数外抛出异常，将直接调用terminator()系统函数终止程序。如果一个析构函数内部抛出了异常，就应该在析构函数的内部捕获并处理该异常，不能让异常被抛出析构函数之外。可以如此处理：</p><ul><li>若析构函数抛出异常，调用std::abort()来终止程序。</li><li>在析构函数中catch捕获异常并作处理。</li></ul><p>关于具体细节，有兴趣可以看《Effective C++》条款08：别让异常逃离析构函数。</p><p><strong>解释</strong></p><p>在C++中，析构函数是不应该抛出异常的。如果析构函数中抛出了异常，那么当对象被销毁，或者在异常处理过程中，对象被销毁时，如果析构函数再次抛出异常，程序就会调用<code>std::terminate</code>函数，导致程序立即崩溃。</p><p>这是因为在C++中，如果一个异常没有被捕获，那么程序就会调用<code>std::terminate</code>函数，结束程序的运行。而在一个异常处理过程中，如果又抛出了新的异常，那么这个新的异常就无法被捕获，因为异常处理机制已经在处理一个异常了。</p><p>此外，如果析构函数在执行过程中抛出异常并且没有被正确处理，那么对象可能无法被完全销毁，这就可能导致内存泄漏。</p><p>所以，为了避免这种情况，我们通常推荐在析构函数中使用try/catch块来捕获并处理可能的异常，或者设计析构函数使其不会抛出异常。如果必须在析构函数中执行可能会抛出异常的操作，那么应该将这些操作放在一个单独的函数中，而不是直接放在析构函数中。</p><h1>noexcept修饰符与noexcept操作符</h1><p>noexcept修饰符是C++ 11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中你可能会看到这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span> ,<span class="type">double</span> )</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这是throw作为函数异常说明，前者表示func（）这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++ 11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//等价于void func() throw()&#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此，被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是阻止异常的传播,提高安全性.</p><p>上面一点提到了，我们不能让异常逃出析构函数，因为那将导致程序的不明确行为或直接终止程序。实际上出于安全的考虑，<strong>C++ 11标准中让类的析构函数默认也是noexcept的</strong>。 <strong>同样是为了安全性的考虑，经常被析构函数用于释放资源的delete函数，C++11也默认将其设置为noexcept</strong>。</p><p>noexcept也可以接受一个常量表达式作为参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure><p>常量表达式的结果会被转换成bool类型，noexcept(bool)表示函数不会抛出异常，noexcept(false)则表示函数有可能会抛出异常。<strong>故若你想更改析构函数默认的noexcept声明，可以显式地加上noexcept(false)声明，但这并不会带给你什么好处</strong>。</p><p>【异常后果自负】</p><p><strong>在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是阻止异常的传播,提高安全性.</strong></p><h1>异常处理的性能分析</h1><p>异常处理机制的主要环节是运行期类型检查。当抛出一个异常时，必须确定异常是不是从try块中抛出。异常处理机制为了完善异常和它的处理器之间的匹配，需要存储每个异常对象的类型信息以及catch语句的额外信息。由于异常对象可以是任何类型（如用户自定义类型），并且也可以是多态的，获取其动态类型必须要使用运行时类型检查（RTTI），此外还需要运行期代码信息和关于每个函数的结构。</p><p>当异常抛出点所在函数无法解决异常时，异常对象沿着调用链被传递出去，程序的控制权也发生了转移。转移的过程中为了将异常对象的信息携带到程序执行处（如对异常对象的复制构造或者catch参数的析构），在时间和空间上都要付出一定的代价，本身也有不安全性，特别是异常对象是个复杂的类的时候。</p><p>异常处理技术在不同平台以及编译器下的实现方式都不同，但都会给程序增加额外的负担，当异常处理被关闭时，额外的数据结构、查找表、一些附加的代码都不会被生成，正是因为如此，对于明确不抛出异常的函数，我们需要使用noexcept进行声明。</p>]]></content>
    
    
    <summary type="html">Cpp异常机制</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>动态内存分配</title>
    <link href="https://penge666.github.io/posts/49f482c.html"/>
    <id>https://penge666.github.io/posts/49f482c.html</id>
    <published>2024-06-21T07:32:17.000Z</published>
    <updated>2024-06-21T07:40:17.931Z</updated>
    
    <content type="html"><![CDATA[<p>虽然可以mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当需要额外的虚拟内存时，用<strong>动态内存分配器</strong>更方便，也有更好的可移植性。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种基本风格，<strong>显式分配器</strong>要求应用显式释放分配的块，而<strong>隐式分配器</strong>(<strong>也叫做垃圾收集器</strong>)则要求分配器检查不再使用的块并释放。本文将对显示分配器和隐式分配器做更深入的讨论。</p><h3 id="1、malloc和free函数">1、malloc和free函数</h3><h4 id="1-1-malloc函数">1.1 malloc函数</h4><p>c标准库提供了一个称为malloc程序包的显式分配器。程序通过调用malloc函数来从堆中分配块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>; <span class="comment">//返回：若成功则为已分配块的指针，若出错则为null.</span></span><br></pre></td></tr></table></figure><p>malloc函数返回一个指针，指向大小至少为size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。如果malloc遇到问题，那么它就返回null，并设置errno。<strong>malloc不初始化它返回的内存，如果想要已初始化的内存则通过calloc分配，如果想要改变已分配块的大小则使用realloc函数</strong>。</p><h4 id="1-2-malloc的底层——sbrk函数">1.2 malloc的底层——sbrk函数</h4><p>malloc可以通过mmap和munmap来显式分配和释放堆内存，或则还可以使用sbrk函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span></span>; <span class="comment">//成功返回brk的旧值，出错返回-1</span></span><br></pre></td></tr></table></figure><p>sbrk函数通过将内核的brk(指向堆顶部)指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1并设置errno为ENOMEM。如果sbrk的参数为0，则返回的为原来的brk地址。</p><h4 id="1-3-free函数">1.3 free函数</h4><p>程序通过调用free函数来释放已分配的堆块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span>; <span class="comment">//不返回值</span></span><br></pre></td></tr></table></figure><p>ptr必须指向一个已分配块的起始位置，如果不是，那么free的行为就是未定义的。</p><h3 id="2、为什么要使用动态内存">2、为什么要使用动态内存</h3><p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。比如我们需要根据输入的n分配一个对应大小的数据来临时存储数据，这是就用动态分配比较好。</p><blockquote><p>值得注意的是，c99提供了动态的数组大小分配，可以不再需要由程序员显式分配动态空间。不过这种分配方式是否是堆上的空间就需要进一步验证了。</p></blockquote><h3 id="3、分配器的要求和目标">3、分配器的要求和目标</h3><p>显式分配器必须在一些相当严格的约束条件下工作：</p><ul><li><strong>处理任意请求序列</strong>：一个应用可以有任意的分配请求和释放请求序列，分配器不可以假设分配和释放请求的顺序。</li><li><strong>立即响应请求</strong>：分配器必须立即响应分配请求。因此不允许分配器提高性能，从新排列或者缓冲请求。</li><li><strong>只使用堆</strong>：分配器使用的任何数据结构都保存在堆里。</li><li><strong>对齐块</strong>：比如8个字节的对齐。</li><li><strong>不修改已分配的块</strong>：分配器只能操作或者改变空闲块，不允许不能压缩已分配的块。</li></ul><p>分配器在满足上述要求的情况下，需要达到以下两个目标：</p><ul><li>(1)最大化吞吐率,单位时间完成尽可能多的请求。</li><li>(2)最大化存储器的利用率。天真的程序员经常不正确的假设虚拟存储器是一个无限的资源**，事实上，一个系统中被所有进程分配的虚拟存储器的全部数量是受磁盘上交换空间的数量限制的**。好的程序员知道虚拟内存是一个有限的空间，必须高效地使用。</li></ul><p>分配器设计中一个有趣的挑战就是在上述两个目标之间找到一个适当的平衡。</p><h3 id="3、碎片">3、碎片</h3><p>造成堆的空间利用率很低的主要原因是一种被称为碎片的现象，当虽然有未使用的内存但这块内存并不能满足分配请求时，就会产生碎片。有以下两种形式的碎片：内部碎片和外部碎片。</p><ul><li><strong>内部碎片</strong>：在一个已分配块比有效载荷大时发生。比如分配器限制的最小分配至比实际请求值要大，又或者为了对齐而增加块的大小。意味着已分配但是未使用。</li><li>外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大到可以来处理这个请求时发生。<strong>外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块</strong>。</li></ul><h3 id="4、分配器设计">4、分配器设计</h3><p>一个分配器需要在吞吐率和利用率之间把握好平衡，必须要考虑以下几个因素：</p><ul><li>组织空闲块：如何组织</li><li>放置：怎么选择一个合适的块来放置新分配的块。</li><li>分割：新分配的块放到某个空闲块后，如何处理剩余部分。</li><li>合并：如何处理一个刚刚被释放的块。</li></ul><blockquote><p><strong>动态内存分配器补充</strong></p></blockquote><p>动态内存分配器可以是内核的一部分，也可以是运行在用户空间的库。这取决于具体的操作系统和编程环境。</p><p>在许多操作系统中，如Unix和Windows，动态内存分配器是作为C标准库的一部分提供的，例如<code>malloc</code>，<code>calloc</code>，<code>realloc</code>和<code>free</code>函数。这些库函数在用户空间运行，并通过系统调用来请求内核分配或释放内存。</p><p>然而，这些函数的实现通常是建立在操作系统内核提供的更底层的内存管理机制之上的。例如，Unix系统的<code>brk</code>和<code>sbrk</code>系统调用，或者Windows的<code>VirtualAlloc</code>函数。这些底层的内存管理函数是由内核直接提供的，因此可以说，动态内存分配器的这一部分是内核程序。</p><h3 id="5、隐式空闲链表">5、隐式空闲链表</h3><h4 id="5-1-组织空闲块">5.1 组织空闲块</h4><p>假设用下图结构来组织堆块，并且已知采用双字对齐，头部后面的就是应用调用malloc时请求的有效载荷。</p><p><strong>双字对齐(Double Word Alignment)指的是数据在内存中的存储方式,使其地址是4字节(即32位)的倍数。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153323077.png" alt="image-20240621153323077"></p><p>分配器将堆组织为下图式样的一个连续的已分配块和空闲块的序列，该序列被称为<strong>隐式空闲链表</strong>。之所以称为隐式空闲链表是因为分配需要遍历堆中所有的块，才能知道空闲块的集合。注意，<strong>图中用一个已分配而大小为的零的块来标记结束</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153332878.png" alt="image-20240621153332878"></p><p>隐式空闲链表的有点是简单，缺点是放置开销会与已分配块和空闲块块的总数呈线性关系。</p><h4 id="5-2-放置已分配的块">5.2 放置已分配的块</h4><p>当应用发起一个分配请求时，分配器需要从空闲链表中选择一个合适的块来满足请求。分配器的选择方式称为<strong>放置策略</strong>。常见的放置策略有以下几种：</p><ul><li><strong>首次适配</strong>：从头开始搜索空闲链表，选择第一个遇见的合适的空闲块。它的优点在于趋向于将大的空闲块保留在链表的后面，缺点是它趋向于在靠近链表前部处留下小空闲块的碎片，从而增加较大请求块的放置时间。</li><li><strong>下一次适配</strong>：每次从上一次查询结束的地方开始进行搜索，直到遇见合适的空闲块。这种策略通常比首次适配效率高，但是内存利用率则要低得多了</li><li><strong>最佳适配</strong>：检查每个空闲块，选择适合所需请求大小的最小空闲块。最佳适配的内存利用率是三种策略中最高的，但它需要对堆进行彻底的搜索。</li></ul><h4 id="5-3-分割空闲块">5.3 分割空闲块</h4><p>分配器在匹配到一个合适的空闲块后，就需要决定分配这个空闲块中多少空间，可以称之为分割策略，一般有以下两种方式：</p><p>（1）选择用整个空闲块，这个方式简单而且快捷，缺点是可能会造成很多内部碎片。</p><p>（2）分配器嫁给你空闲块分为两个部分，第一部分变成分配块，而剩下的那部分则组织成一个新的空闲块。</p><h4 id="5-4-合并空闲块">5.4 合并空闲块</h4><p>为了避免假碎片问题，分配器需要在释放一个已分配块时，除了重新标记当前块外也需要合并相邻空闲块。合并空闲块的方式称为合并策略，主要分为两种：</p><p>（1）立即合并：就是在每次释放块时，就立即合并所有相邻块，这种方式可能会产生抖动（比如频繁在一个8字节的空闲块中执行3字节的分配与释放，就可能产生大量不必要的分割与合并）。</p><p>（2）推迟合并：即推迟合并空闲块的时机，比如直到某个分配请求失败才扫描整个堆，合并所有的空闲块。快速的分配器通常会选择某种形式的推迟合并。</p><h4 id="5-5-合并空闲块的具体实现">5.5 合并空闲块的具体实现</h4><p>对于向后合并，我们可以通过当前块的头部指针判断下一个块是否空闲，从而进行合并，但是如何合并前面的块呢？搜索整个链表？</p><p>Knuth提出了一种叫做<strong>边界标记</strong>的技术用于常数时间对前面的块进行合并。其实现如下图，通过在每个块的结尾处添加一个脚部，其是头部的一个副本。这样分配器就可以通过检查当前块的前一个字节的内容从而判断前一个块的起始位置和状态。</p><p>比如有一个释放当前块，其前一个块和后一块都是空闲的，此时需要将三块的大小求和然后更新前一块的头部和后一块脚部，明显能在常数时间内完成。</p><p>边界标记的一个缺陷是每一块都要保持一个头部和一个脚部，这会导致显著的内存开销。一种可能的优化方案是在已分配的块剩余部分保存脚部信息，从而减小开销。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153338881.png" alt="image-20240621153338881"></p><h3 id="6、显式空闲链表">6、显式空闲链表</h3><h4 id="6-1-空闲块组织">6.1 空闲块组织</h4><p>其实对于通用的分配器来说，隐式空闲链表是不适合的，一种更好的方法是将空闲块组织为某种形式的显式空闲链表。</p><p>如下图，我们用一个双向链表组织空闲块，为了节省空间，我们将前驱指针pred和后继指针succ放在空闲块的主体当中。双向链表使得首次适配的时间从块总数的线性时间减少到了空闲块总数的线性时间。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153345698.png" alt="image-20240621153345698"></p><p>在释放分配块时，有两种方式，分别为：</p><ul><li><strong>后进先出</strong>LIFO顺序维护链表：将新释放的块放在链表的开始处，加上边界标记后能快速合并完成并放置。</li><li><strong>按照地址顺序维护链表</strong>：这种方式使得每个块的地址都小于它后继的地址。释放一个块比较麻烦，但是首次适配有更高的内存利用率。</li></ul><p>显式空闲链表的需要存储前向和后向指针，这会限制最小块的大小，从而增加内存碎片。</p><h4 id="6-2-分离的空闲链表">6.2 分离的空闲链表</h4><p>为了减少分配时间，人们想出了另一种叫做<strong>分离存储</strong>的方法，主要是通过维护多个空闲链表，其中每个链表中的块有大致相等的大小。也即是分配器维护一个空闲链表数组，然后每个空闲链表中的空闲块按照大小进行升序排序。<strong>简单分离存储</strong>中采用的方式是每个空闲链中的空闲块大小一样，而<strong>分离适配</strong>方式的每个空闲链表中的块大小却不一样，这样适配时需要在空闲链表中进行匹配。</p><p>当有一个分配请求时，我们检查相应的空闲链表。如果链表非空，那么就分配其中第一块的全部。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，然后将这些块链接起来形成新的空闲链表。类型vector中的free list。</p><p>要释放一个块，分配器只需要简单地将这个块插入到相应的空闲链表的头部。</p><h3 id="7、垃圾收集">7、垃圾收集</h3><p>在编写C程序时，一般只能显式地分配与释放堆中的内存（malloc()与free()），程序员不仅需要分配内存，还需要负责内存的释放。但如果能自动回收是不是更好呢？</p><p><strong>垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块</strong>。这些块被称为垃圾，自动回收堆存储的过程叫做垃圾收集。接下来讨论一种垃圾收集算法——Mark&amp;Sweep法，可以称为标记清除法。</p><h4 id="7-1-垃圾收集器垃圾组织">7.1 垃圾收集器垃圾组织</h4><p>垃圾器将内存视为一张有向可达图，组织如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153351873.png" alt="image-20240621153351873"></p><p>垃圾收集器一般采用以下两种（之一）的策略来判断一块堆内存是否为垃圾内存：</p><ul><li>引用计数器：在数据的物理空间中添加一个计数器，当有其他数据与其相关时（引用），该计数器加一，反之则减一。通过定期检查计数器的值，只要为0则认为是垃圾内存，可以释放它所占用的已分配块。使用引用计数器，实现简单直接，但缺点也很明显，它无法回收循环引用的两个对象（假设有对象A与对象B，它们2个互相引用，但实际上对象A与对象B都已经是没用的对象了）。</li><li>可达性分析：垃圾收集器将堆内存视为一张有向图，然后选出一组根节点（例如，在Java中一般为类加载器、全局变量、运行时常量池中的引用类型变量等），根节点必须是足够“活跃“的对象。然后计算从根节点集合出发的可达路径，只要从根节点出发不可达的节点，都视为垃圾内存。</li></ul><h4 id="7-2-Mark-Sweep垃圾收集器">7.2 Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记阶段和清除阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。标记-清除算法实现简单，但它的效率不高，而且会产生许多内存碎片。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153403384.png" alt="image-20240621153403384"></p><p>再介绍两种垃圾收集器进行回收的算法：</p><ul><li>复制：将程序所拥有的内存空间划分为大小相等的两块，每次都只使用其中的一块。当这一块的内存用完了，就把还存活着的对象复制到另一块内存上，然后将已使用过的内存空间进行清理。这种方法不必考虑内存碎片问题，但内存利用率很低。这个比例不是绝对的，像HotSpot虚拟机为了避免浪费，将内存划分为Eden空间与两个Survivor空间，每次都只使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一个Survivor空间上，然后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例为8：1，只有10%的内存空间会被闲置浪费。</li><li>分代：分代算法根据对象的存活周期的不同将内存划分为多块，这样就可以对不同的年代采用不同的回收算法。一般分为新生代与老年代，新生代存放的是存活率较低的对象，可以采用复制算法；老年代存放的是存活率较高的对象，如果使用复制算法，那么内存空间会不够用，所以必须使用标记-清除或标记-整理算法。</li></ul><h3 id="8、小结">8、小结</h3><p>本节主要讨论动态内存的分配与垃圾回收，主要是大概了解常见的内存管理方式。</p><p>学习自：<a href="https://wendeng.github.io/2019/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/#5%E3%80%81%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">第9章 虚拟内存之动态内存分配与垃圾收集</a></p>]]></content>
    
    
    <summary type="html">VM之动态内存分配</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL-第五章</title>
    <link href="https://penge666.github.io/posts/130ee7c0.html"/>
    <id>https://penge666.github.io/posts/130ee7c0.html</id>
    <published>2024-06-21T02:40:39.000Z</published>
    <updated>2024-06-21T03:23:30.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>所谓关联式容器，观念上类似于关联式数据库，每个元素都有一个键值key和一个实值value</strong>。当向容器插入元素时，容器根据其key值将实值放到适当的位置。关联式容器没有头尾的概念，所以也不会有push_front()，push_back()等操作函数。</p><p>STL关联容器分为set（集合）和map（映射表）两大类，及其衍生体multiset和multimap。这些容器的底层机制均以RB-tree（红黑树）实现。RB-tree也是一个独立容器，但并不开放使用。</p><p>SGI STL还提供一个不在标准规格的关联式容器 hash_table（散列表），以及以 hash_table 为底层机制而完成的 hash_set散列集合、hash_map散列映射表、hash_multiset散列多键集合、hash_multimap散列多键映射表。</p><p>本章我们将主要学习各种容器对应的底层实现原理和应该注意的地方。</p><h3 id="1、树的基本的概念"><a href="#1、树的基本的概念" class="headerlink" title="1、树的基本的概念"></a>1、树的基本的概念</h3><p>一个关于树的比较重要且容易模糊的概念是：</p><ul><li>节点路径长度（也叫深度）：根节点到当前节点所经过的边数和。</li><li>节点的高度：某节点至其最远叶子节点的路径长度的值。</li></ul><p>二叉搜索树在一些情况下不能很好地保持平衡性，所以引入了AVL树（带额外平衡条件的二叉搜索树），其保证任意节点的左右两颗子树的高度差不超过1，这就要求每插入一个节点<br>时都需要进行调整以保证平衡性。调整分为四种情况对应两种调整方式：单旋转和双旋转。</p><p>AVL的不足之处在于过分追求平衡，从而导致插入效率变低，在不大影响查找效率的基础上同时满足大概的平衡就好了，于是人们引入了RB-Tree。</p><h3 id="2、RB-tree"><a href="#2、RB-tree" class="headerlink" title="2、RB-tree"></a>2、RB-tree</h3><p>RB-tree（红黑树）是一种被广泛使用的平衡二搜索树，其通过一些着色法则确保没有一条路径会比其它路径长两倍，从而达到接近平衡目的。RB-tree必须满足以下规则：</p><p>（1）每个节点不是红色就是黑色；</p><p>（2）根节点为黑色；</p><p>（3）如果节点为红，其子节点必须为黑；</p><p>（4）任一节点至NULL（树尾端）的任何路径，所含之黑节点数必须相同。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621105234761.png" alt="image-20240621105234761"></p><p>根据规则（4），新增节点必须为红，根据规则（3），新增节点之父节点必须为黑。当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调整颜色并旋转树形。</p><h4 id="2-1-RB-tree效率所在"><a href="#2-1-RB-tree效率所在" class="headerlink" title="2.1 RB-tree效率所在"></a>2.1 RB-tree效率所在</h4><p>红黑树之所以为红黑树的原因：红黑颜色用来检测树的平衡性，达到AVL树的平衡要求，降低了对旋转的要求，从而提高了统计性能。红黑树相对AVL树能够给我们一个比较便宜的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更好。</p><p>RB-tree不仅在树性的平衡上表现不错，在效率表现和实现复杂度上也保持相当的平衡，所以运用甚广。主要用于存储有序的数据，它的时间复杂度为O(logn)效率非常之高，Java集合中的TreeSet和TreeMap，C++的STL中的set，map以及Linux虚拟内存的管理，都通过红黑树去实现。</p><h4 id="2-2-RB-tree插入节点的调整"><a href="#2-2-RB-tree插入节点的调整" class="headerlink" title="2.2 RB-tree插入节点的调整"></a>2.2 RB-tree插入节点的调整</h4><p>假设新节点为X，其父节点为P，祖父节点为G，伯父节点（父节点的兄弟节点）为S，曾祖父节点为GG。当向RB插入一个节点时，主要讨论四种情况：</p><ul><li>（1）状况1：S为黑且X为外侧插入。对此情况，先对P,G做一次单选转，再更改P,G颜色，即可重新满足红黑树的规则3。</li><li>（2）状况2：S为黑且X为内测插入。对此情况，必须现对P,X做一次单选转并更改G,X颜色，再将结果对G做一次单选转，即可再次满足红黑树规则3。</li><li>（3）状况3：S为红且X为外侧插入。对此情况，现对P和G做一次单选转，并改变X的颜色。此时如果GG为黑，一切搞定，但如果GG为红，则问题比较大，见状况4。</li><li>（4）状况4：S为红且X为外侧插入。对此情况，先对P和G做一次单选转，并改便X的颜色。此时如果GG也为红。害的持续网上做，直到不再有父子连续为红的情况。</li></ul><p>红黑树删除基本思想是：删除后，用其子树替换，这部分与二叉搜索树的删除的思想本质一样，但是红黑树删除后，可能会破坏红黑树的性质，此时就需要进行树的调整操作即可。</p><h4 id="2-3-RB-tree节点设计和迭代器"><a href="#2-3-RB-tree节点设计和迭代器" class="headerlink" title="2.3 RB-tree节点设计和迭代器"></a>2.3 RB-tree节点设计和迭代器</h4><p>RB-tree有红黑二色，并且拥有左右子节点，很容易勾勒出其结构风貌。实现上，为了有更大的弹性，节点分为两层。同时由于RB-tree的各种操作时常需要上溯其父节点，所以特别在数据结构中安排了一个parent指针。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621105252305.png" alt="image-20240621105252305"></p><p>SGI将RB-tree迭代器实现分为两层。上图是两层节点结构和双层迭代器结构间的关系，其中_ rb_tree_node继承自rb_tree_node_base，rb_tree_iterator继承自_rb_tree_base_iterator。</p><h4 id="2-4-RB-tree的元素插入接口"><a href="#2-4-RB-tree的元素插入接口" class="headerlink" title="2.4 RB-tree的元素插入接口"></a>2.4 RB-tree的元素插入接口</h4><p>RB-tree提供两种插入操作：insert_unique()和insert_equal()，前者标识被插入节点的键值（key）在整棵树中必须独一无二,如果整棵树中已存在相同的键值，插入操作就不会真正进行;后者标识被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功。</p><p>当然插入元素后是需要对RB-tree进行调整的，这里不进行讲解了。</p><h3 id="3、set和multiset"><a href="#3、set和multiset" class="headerlink" title="3、set和multiset"></a>3、set和multiset</h3><p>set的所有特性可以归纳为以下几点：</p><p>（1）所有元素都会根据元素的键值自动被排序。</p><p>（2）set是集合，它的元素的键值就是实值，实值就是键值，不允许两个元素有相同的值。</p><p>（3）<strong>不可以通过set的iterator来改变元素的值，因为set的元素值就是键值，改变键值会违反元素排列的规则</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  *it = (*it) * <span class="number">2</span>; <span class="comment">// 编译错误，set的元素不能被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; new_s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  new_s.<span class="built_in">insert</span>((*it) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>是C++中的一个关联容器，它包含的元素都是唯一的，且自动按照顺序排序。这个规则是由<span class="built_in">set</span>的内部实现决定的，它使用了一种名为红黑树的数据结构。在红黑树中，每个节点的键值对应着<span class="built_in">set</span>中的一个元素，而且这些节点按照键值的大小进行排序。</span><br><span class="line">当我们试图改变<span class="built_in">set</span>中的一个元素值时，实际上就是试图改变红黑树中的一个节点的键值。但是，由于红黑树中的节点是按照键值大小排序的，所以如果我们改变了一个节点的键值，就可能破坏树的排序，使得它不再满足红黑树的性质。</span><br><span class="line">举个简单的例子，比如我们有一个<span class="built_in">set</span>，它包含三个元素：1，2，3，对应着红黑树中的三个节点。这三个节点是按照键值大小排序的：1 &lt; 2 &lt; 3。如果我们试图将元素2改为4，那么原本的排序就会被破坏：1 &lt; 4 &lt; 3，这就不再满足红黑树的性质了。</span><br><span class="line">因此，为了保持<span class="built_in">set</span>的顺序性和元素唯一性，我们不能通过迭代器来直接改变<span class="built_in">set</span>中的元素值。如果我们需要改变元素值，可以先删除原来的元素，然后再插入新的元素。</span><br></pre></td></tr></table></figure><p>（4）<strong>在客户端对set进行插入或删除操作后，之前的迭代器依然有效。当然，被删除的元素的迭代器是个例外。</strong></p><p>解释：在C++的<code>set</code>容器中，元素的插入和删除操作都是通过调整红黑树的节点来完成的，而不是通过移动元素。这就意味着当你插入或删除元素时，其他元素的位置并不会发生改变，所以指向这些元素的迭代器依然有效。</p><p>（5）它的底层机制是RB-tree，几乎所有的操作都只是转调用RB-tree的操作行为而已。</p><p>（6）set提供的算法包括交集、并集、差集、对称差集等。</p><p>multiset和set几乎一样，唯一的区别是，multiset允许键值重复。因此set使用底层RB-tree的insert_unique()实现插入，而multiset插入采用的是RB-tree的insert_equal()而非insert_unique()。</p><h3 id="4、map和multimap"><a href="#4、map和multimap" class="headerlink" title="4、map和multimap"></a>4、map和multimap</h3><p>map的特性可以归纳为以下几条：</p><p>（1）所有元素都会根据元素的键值自动被排序。</p><p>（2）map的所有元素都是pair，第一个值是键值，第二个是实值。</p><p>（3）map不允许两个元素拥有相同的键值。</p><p>（4）可以通过map的迭代器来改变元素的实值，但不可以改变键值，那样会违反元素的排列规则。</p><p>（5）在客户端对map进行插入或删除操作后，之前的迭代器依然有效。当然，被删除的元素的迭代器是个例外。</p><p>（6）它的底层机制是RB-tree。几乎所有的操作都只是转调用RB-tree的操作行为而已。</p><p>multimap和map几乎一样，唯一的区别是，multimap允许键值重复。因此map使用底层RB-tree的insert_unique()实现插入，而multimap插入采用的是RB-tree的insert_equal()而非insert_unique()。</p><h3 id="5、hashtable"><a href="#5、hashtable" class="headerlink" title="5、hashtable"></a>5、hashtable</h3><p>二叉搜索树具有对数平均时间的表现，但这样的表现依赖于一个假设：<strong>输入的数据有足够的随机性</strong>。本节要结束一种名为hash table(散列表)的数据结构，这种结构使得插入、删除、搜寻等操作上都具有“常数平均时间”的表现，而且这种表现以统计为基础，不依赖于输入元素的随机性。</p><h4 id="5-1-hashtable的散列函数和碰撞冲突问题"><a href="#5-1-hashtable的散列函数和碰撞冲突问题" class="headerlink" title="5.1 hashtable的散列函数和碰撞冲突问题"></a>5.1 hashtable的散列函数和碰撞冲突问题</h4><p>hashtable可以提供对任意有名项的存取和删除操作，这种结构的用意在于提供常数时间的的基本操作，而不依赖于插入元素的随机性，是以统计为基础的。</p><p>为了将特定键值key输入转为hash table的索引，就需要<strong>散列函数hash function</strong>，其主要负责将某一元素映射为一个”大小可接受之索引”。使用hash function带来的问题：可能有不同元素映射到相同的位置，即具有相同索引，这便是<strong>碰撞或冲突问题</strong>。</p><p>解决碰撞问题的方法常见的有线性探测、二次探测、开链等。<strong>stl hashtable采用的hash方式是开链法</strong>。</p><ul><li>（1）线性探测：当hash function计算出某个元素的插入位置，而该位置空间不再可用时，就循序往下一一寻找，直到找到一个可用空间为止。线性探测会造成<strong>主集团问题</strong>：平均插入成本的成长幅度，远高于<strong>负载系数</strong>的成长幅度。</li><li>（2）二次探测：主要用来解决主集团问题。解决碰撞的方程式为F(i) = i^2。如果hash function计算出新元素的位置为H,而该位置实际上已被使用，那么就依次尝试H+1^2,H+2^2,H+3^2,H+4^2,….,H+i^2，而不像线性探测尝试的是H+1,H+2,H+3,H+4,….,H+i。<strong>二次探测可以消除主集团，却可能造成次集团</strong>：两个元素经hash function计算出来的位置若相同，则插入时所探测的位置也相同，形成某种浪费。消除次集团的方法如复式散列。</li><li>（3）开链：这种做法是在每一个表格元素中维护一个list。hash function为选择某一个list，然后我们在那个list身上执行元素的插入、搜寻、删除等操作。若list够短，速度还是够快。使用开链法，表格的负载系数将大于1。</li></ul><h4 id="5-2-STI-STL的hashtable的数据结构"><a href="#5-2-STI-STL的hashtable的数据结构" class="headerlink" title="5.2 STI STL的hashtable的数据结构"></a>5.2 STI STL的hashtable的数据结构</h4><p>SGI STL中hash table使用的是开链法进行的冲突处理，其结构如图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621110618363.png" alt="image-20240621110618363"></p><p><strong>bucket所维护的linked list不采用STL的list或者slist，而是自行维护hash table node</strong>。而至于<strong>buckets聚合体，则使用vector来完成</strong>，以便有动态扩容能力。</p><p>STL中的hash迭代器，是一种forward迭代器，只能++。有指向当前节点的指针和指向对应的vector的指针，没有后退操作，也就是没有所谓的逆向迭代器。有过next到list的尾端，就跳至下一个bucket。</p><p>设计思想：hashtable以质数来设计表格大小，预先计算好了28个质数，以备随时访问，大约都是两倍的关系递增，同时提供一个函数，查询28个质数中“最接近某数且大于某数”的质数作为vector的长度，如果需要重新分配，则分配下一个质数长度的vector。<br><strong>stl hash table扩张表格的触发条件是：当元素的数目大于或等于表格的大小</strong>。（这个条件应该是为了保证常数操作时间，在统计基础上得出的）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621110704901.png" alt="image-20240621110704901"></p><p>insert分为insert_unique和insert_equal操作，前者保证插入的数不能有重复，后者可以插入键值相同的数。可以先用unique之后再用equal。insert_unique：先调用resize函数，看是否需要增大vector，然后插入，vector的索引通过取余得到。</p><p>resize：如果已有元素的个数大于vector的size，需要根据得到的最新质数，分配新的空间，将在旧空间的元素，重新计算hash，复制到新的空间，最后旧空间与新空间swap一下即可。insert_equal:也是先调用resize，遍历找到和他相同的节点，在该节点的前面插入。</p><p><strong>hashtable有一些无法处理的型别，比如string，double，float。除非用户为那些型别写了相应的hash function</strong>。</p><h3 id="6、hash-set和hash-multiset"><a href="#6、hash-set和hash-multiset" class="headerlink" title="6、hash_set和hash_multiset"></a>6、hash_set和hash_multiset</h3><p><strong>hash_set是以hashtable为底层机制</strong>。因hash_set所供应的操作接口，hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为。</p><p>set是为了能够快速搜寻元素。其底层是Rb-tree有自动排序功能，但hashtable没有自动排序功能，故hash_set没有自动排序功能。hash_set和set一样，元素的键值就是实值，实值就是键值。hash_set和set使用方式基本相同。</p><p><strong>hash_multiset和multiset完全相同</strong>，唯一差别是底层实现机制不同，hash_multiset的底层实现机制是hashtable，multiset的底层实现机制是Rb-tree。<strong>hash_multiset和hash_set实现上的唯一差别是</strong>，hash_set的插入操作采用hashtable中的insert_unique()，而hash_multiset的插入操作采用hashtable中的insert_euqal()。hash_multiset和hash_set使用方式基本相同。</p><p>解释：</p><p><code>set</code>是基于红黑树实现的，红黑树是一种自平衡二叉搜索树，它可以保证元素按照一定的顺序排列。因此，<code>set</code>中的元素是自动排序的。在<code>set</code>中插入、删除和查找元素的时间复杂度都是O(log n)。</p><p><code>hash_set</code>是基于哈希表实现的。哈希表是一种使用哈希函数将元素映射到表中一个位置的数据结构，因此，<code>hash_set</code>中的元素不是有序的。在理想情况下，<code>hash_set</code>中插入、删除和查找元素的时间复杂度都是O(1)，但这取决于哈希函数的质量和哈希表的负载因子。如果哈希函数的质量不好，或者哈希表的负载因子过高，那么这些操作的时间复杂度可能会增大</p><p><strong>输出是无序的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> si:s) </span><br><span class="line">cout&lt;&lt;si&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较：</p><ol><li><code>set</code>：<ul><li>查找、插入和删除操作的时间复杂度都是O(log n)。</li><li><code>set</code>是基于红黑树实现的，因此元素会自动排序。</li><li>如果你的应用需要有序的数据，并且/或者你预期会有大量的查找操作，那么<code>set</code>可能是更好的选择。</li></ul></li><li><code>hash_set</code>：<ul><li>在理想情况下（也就是哈希函数的质量好，哈希冲突少），查找、插入和删除操作的时间复杂度都是O(1)。但如果哈希冲突多，最坏的情况下，这些操作的时间复杂度可能会达到O(n)。</li><li><code>hash_set</code>是基于哈希表实现的，因此元素不会自动排序。</li><li>如果你的应用不需要有序的数据，且预期会有大量的插入和删除操作，那么<code>hash_set</code>可能提供更好的性能。</li></ul></li></ol><h3 id="7、hash-map和hash-multimap"><a href="#7、hash-map和hash-multimap" class="headerlink" title="7、hash_map和hash_multimap"></a>7、hash_map和hash_multimap</h3><p>hash_map的底层实现机制也是hashtable。故hash_map所供应的操作接口，hashtable都提供了，所以几乎所有的hash_map操作行为，都只是转调用hashtable的操作行为而已。</p><p>map能够根据键值快速搜索元素，其底层实现机制是Rb-tree，Rb-tree具有自动排序功能，故map具有自动排序功能，但hashtable没有自动排序功能，故hash_map没有自动排序功能。hash_map和map都有相同的特性，即每一个元素都同时拥有一个实值（value）和一个键值（key）。hash_map和map使用方式大体相同。</p><p><strong>hash_multimap的特征与multimap完全相同</strong>，唯一差别为它的底层实现机制是hashtable，故hash_multimap的元素并不会被自动排序<strong>。hash_multimap和hash_map实现上的唯一差别是</strong>，hash_multimap的插入操作使用底层机制hashtable中的insert_equal()，而hahs_map使用的是底层机制hashtable中的insert_unique()。hash_multimap使用方式与hash_map完全相同。</p><h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><p>在实际使用过程中，到底选择这几种容器中的哪一个？通常应该根据遵循以下原则：</p><p>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p><p>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p><p>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p><p>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p><p>（5）如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p><p>学习自：<a href="https://wendeng.github.io/2019/05/18/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC5%E7%AB%A0%20%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/">《STL源码剖析》第5章 关联式容器</a></p>]]></content>
    
    
    <summary type="html">STL-关联式容器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://penge666.github.io/posts/d5c4ed7d.html"/>
    <id>https://penge666.github.io/posts/d5c4ed7d.html</id>
    <published>2024-06-20T02:52:56.000Z</published>
    <updated>2024-06-20T03:50:16.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树为何必须掌握？">红黑树为何必须掌握？</h2><p>来看看，红黑树的广泛的应用</p><ul><li>JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树</li><li>Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构</li><li>Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。</li><li>多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。</li></ul><p>面试过程中，HashMap 常常是面试的重点， 而且会以<strong>连环炮 的方式</strong>进行发问，</p><p>所以， <strong>红黑树基本是 面试必须的 要点</strong>， <strong>如果 答不上来，面试就有 很大程度 就黄了</strong>。</p><p>红黑树，又比较复杂，有非常多的场景, 大家记住不容易。</p><h3 id="本文的介绍次序">本文的介绍次序</h3><p>本文，从 BST二叉查找树， 到AVL 平衡二叉树， 再到 RBT 红黑树，</p><p>为大家 做好 <strong>清晰的场景分析</strong>， 帮助大家记忆。</p><h2 id="BST二叉查找树">BST二叉查找树</h2><h3 id="什么是二叉查找树呢？">什么是二叉查找树呢？</h3><p>二叉查找树（BST）具备以下特性：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ol><h3 id="二叉搜索树-BST的完美情况">二叉搜索树 BST的完美情况</h3><p>一般人们理解的二叉树（<strong>又叫二叉搜索树 BST</strong>）会出现一个问题，完美的情况下，它是这样的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105359350.png" alt="image-20240620105359350"></p><h3 id="二叉搜索树的查找流程"><strong>二叉搜索树的查找流程</strong></h3><p>如何查找值为7的节点？<br>1.查看根节点8，因为7&lt;8，所以再查看它的左子节点6<br>2.查看左子节点6，因为7&gt;6，所以再查看它的右子节点7<br>3.查看右子节点7，因为7=7，所以就找到啦，</p><h3 id="二叉搜索树的极端情况">二叉搜索树的极端情况</h3><p>二叉查找树是有缺点的，在不断插入的时候，**有可能出现这样一种情况：**很容易“退化”成链表，</p><p>如果bst 树的节点正好从大到小的插入，此时树的结构也类似于链表结构，这时候的查询或写入耗时与链表相同。</p><h4 id="退化成为了-链表的特殊BST">退化成为了 链表的特殊BST</h4><p>一颗特殊BST，退化成为了 链表，如下图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105443483.png" alt="image-20240620105443483"></p><p>它和链表一样，搜索的时候，最坏情况的时间复杂度O(n) 。</p><h4 id="那么我们怎么避免这种情况呢？">那么我们怎么避免这种情况呢？</h4><p>为了避免这种特殊的情况发生，引入了平衡二叉树（AVL）和红黑树（red-black tree）。</p><p>AVL 、rbt 都是通过本身的建树原则来控制树的层数和节点位置，</p><p>因为rbtree是由AVL演变而来，所以我们从了解AVL开始。</p><h2 id="AVL平衡二叉树">AVL平衡二叉树</h2><p>平衡二叉树也叫AVL（发明者名字简写），也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡。</p><blockquote><p>AVL树是最先发明的自平衡二叉查找树。</p><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。</p><p>增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p></blockquote><h3 id="AVL树的特性">AVL树的特性</h3><p>AVL树本质上还是一棵二叉搜索树，它有以下特性：</p><ul><li>特性1： 对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li><li>特性2：对于AVL树而言，其中任何子树仍然是AVL树；</li><li>特性3：每个节点的左右子节点的高度之差的绝对值最多为1；</li></ul><blockquote><p>特性1表明，AVL 继承于 BST , 所以:</p><p>1.AVL本身首先是一棵BST 二叉搜索树。<br>2.AVL带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p></blockquote><p>在插入、删除树节点的时候，如果破坏了以上的原则，<strong>AVL树会自动进行调整</strong>使得以上三条原则仍然成立。</p><p>也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。</p><h3 id="AVL树的平衡功能">AVL树的平衡功能</h3><p>举个例子，下左图为AVL树最长的2节点与最短的8节点高度差为1；</p><p>当插入一个新的节点后，根据上面第一条原则，它会出现在2节点的左子树，但这样一来就违反了原则3。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105501175.png" alt="image-20240620105501175"></p><p>此时AVL树会通过节点的旋转进行进行平衡，</p><p>AVL调整的过程称之为左旋和右旋，</p><h3 id="AVL平衡的调整过程">AVL平衡的调整过程</h3><p><strong>旋转之前，首先确定旋转支点（pivot）：</strong> 这个旋转支点就是失去平衡这部分树，在自平衡之后的根节点，</p><p>平衡的调整过程，需要根据pivot它来进行旋转。</p><p>我们在学习AVL树的旋转时，不要将失衡问题扩大到整个树来看，这样会扰乱你的思路，</p><p>我们只关注<strong>失衡子树的根结点</strong> 及它的子节点和孙子节点即可。</p><p>事实上，AVL树的旋转，我们权且叫“AVL旋转”是有规律可循的，因为只要聚焦到**失衡子树，**然后进行左旋、右旋即可。</p><blockquote><p>很多人在左旋和右旋有时候弄不明白，</p><p>其实左旋就是逆时针转，右旋是顺时针转</p></blockquote><h2 id="AVL子树失衡的四大场景">AVL子树失衡的四大场景</h2><p>导致AVL失衡的场景就是有限的4个：</p><ul><li>左左结构失衡（LL型失衡）</li><li>右右结构失衡（RR型失衡）</li><li>左右结构失衡（LR型失衡）</li><li>右左结构失衡（RL型失衡）</li></ul><p>删除元素，也会导致AVL失衡，需要再平衡，但是原理和插入元素是类似的。</p><p>这里聚焦 介绍插入元素的平衡过程， 删除元素，不做介绍。</p><h3 id="场景1-LL型失衡-左左结构失衡（右旋）：">场景1: LL型失衡-左左结构失衡（右旋）：</h3><blockquote><p>场景： 插入的元素在子树root的左侧不平衡元素的左侧</p><p>此时，以root的左儿为支点，也就是，左侧的不平衡元素为pivot(支点), 进行右旋</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105528496.png" alt="image-20240620105528496"></p><blockquote><p>右旋过程中，如果pivot有右子树，则作为 原root的 左子树， 保障AVL的特性1</p></blockquote><h4 id="记忆要点">记忆要点</h4><p>尼恩备注记忆要点，LL型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，与失衡的方向相反，</p><p>LL 型失衡，与左边 相反的方向， 是右边，所以是右旋</p></blockquote><h3 id="场景2-RR型失衡：右右结构失衡（左旋）">场景2 RR型失衡：右右结构失衡（左旋）</h3><blockquote><p>场景：插入的元素在子树root右侧的不平衡子树的右侧</p><p>此时，以root的右儿为支点，也就是，右侧的不平衡元素 为 pivot(支点)， 进行左旋</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105559041.png" alt="image-20240620105559041"></p><blockquote><p>左旋过程中，如果pivot有左子树，则作为 原root的 右子树，</p><p>保障AVL的特性1，</p></blockquote><h4 id="记忆要点-2">记忆要点</h4><p>尼恩备注记忆要点，RR型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RR 型失衡，与右边 相反的方向， 是左边，所以是左旋</p></blockquote><h3 id="场景3-LR型失衡：左右结构失衡（左旋-右旋）："><strong>场景3 LR型失衡：左右结构失衡（左旋+右旋）：</strong></h3><blockquote><p>场景： 插入的元素在左侧的不平衡元素的右侧</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105626532.png" alt="image-20240620105626532"></p><h4 id="记忆要点-3">记忆要点</h4><p>尼恩备注记忆要点，LR型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>LR型失衡，与只相反的方向是 RL，但是先旋转底部，再旋转顶部，RL进行次序颠倒，LR</p><p>所以， LR型失衡，旋转的方式，是先左旋， 再右旋</p></blockquote><h3 id="场景4-RL失衡-右左结构-（右旋-左旋）："><strong>场景4 RL失衡: 右左结构 （右旋+左旋）：</strong></h3><p>场景： 插入的元素在右侧的不平衡元素的左侧</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105648900.png" alt="image-20240620105648900"></p><h4 id="记忆要点-4">记忆要点</h4><p>尼恩备注记忆要点，RL型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RL型失衡，与只相反的方向是 LR，但是先旋转底部，再旋转顶部，所以，LR进行次序颠倒，RL</p><p>最终， RL型失衡，旋转的方式，是先右旋， 再左旋</p></blockquote><h3 id="AVL树平衡总结">AVL树平衡总结</h3><p>可见无论哪种情况的失衡，都可以通过旋转来调整。</p><p>不难看出，旋转在图上像是将pivot(支点)节点向上提（将它提升为root节点），而后两边的节点会物理的分布在新root节点的两边，</p><p>接下来按照AVL二叉树的要求：</p><blockquote><p>左子树小于root，右子树大于root进行调整。</p></blockquote><p>从图LL结构可以看出，当右旋时原来pivot（7）的右子树（8）会转变到原root点（9）的左子树处；</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105713476.png" alt="image-20240620105713476"></p><p>从图右右结构可见，当左旋时，原来pivot（18）的左子树会分布到原root点（9）的右子树。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105728010.png" alt="image-20240620105728010"></p><p>对于左右结构和右左结构无非是经过多次旋转达到稳定，旋转的方式并没有区别，</p><p>AVL树本质上还是一棵<strong>二叉搜索树</strong>，它有以下特性：<br>1.本身首先是一棵二叉搜索树。<br>2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p><p>也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。</p><h3 id="AVL树的删除">AVL树的删除</h3><p><strong>删除的判断标准</strong></p><ol><li>要删除的节点是什么类型的节点？；</li><li>删除后是否会破坏平衡 ；</li></ol><p><strong>节点类型</strong></p><ol><li>叶子节点；</li><li>节点只有左子树或只有右子树 ；</li><li>既有左右子树都有。</li></ol><p><strong>处理的思路</strong></p><ol><li>当删除为叶子节点，则直接删除，并从父亲节点开始往上看，判断是否失衡；如果没有失衡，再判断父亲的父节点是否失衡，直到根节点。若失衡则判断失衡类型（LL、LR、RR、RL），再进行相应的调整。</li><li>删除的节点只有左子树或只有右子树，那么将节点删除，以左子树或右子树进行代替，并进行相应的平衡判断，若失衡则调整，一直到根节点 ；</li><li>删除的节点既有左子树又有右子树，找到其前驱或者后驱节点将其替换，再判断是否失衡，然后根据失衡情况调整，直到根节点。</li></ol><h2 id="常见AVL面试题">常见AVL面试题</h2><h3 id="问：什么是AVL左旋和右旋？">问：什么是AVL左旋和右旋？</h3><blockquote><p>加入节点后，左旋和右旋 ，维护AVL平衡性</p></blockquote><p>右旋转</p><p>场景： 插入的元素在不平衡元素的左侧的左侧</p><blockquote><p>x.right = y</p><p>y.left = xxx(原x.right)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对节点y进行向右旋转操作，返回旋转后新的根节点x</span><br><span class="line">         y                             x</span><br><span class="line">        / \                          /   \</span><br><span class="line">       x   <span class="variable constant_">T4</span>     向右旋转 (y)        z     y</span><br><span class="line">      / \       - - - - - - - -&gt;    <span class="regexp">/ \   /</span> \</span><br><span class="line">     z   <span class="variable constant_">T3</span>                       <span class="variable constant_">T1</span>  <span class="variable constant_">T2</span> <span class="variable constant_">T3</span> <span class="variable constant_">T4</span></span><br><span class="line">    / \</span><br><span class="line">  <span class="variable constant_">T1</span>   <span class="variable constant_">T2</span></span><br></pre></td></tr></table></figure><blockquote><p>场景：插入的元素在不平衡元素的右侧的右侧</p><p>// 向左旋转过程</p><p>x.left = y;</p><p>y.right =(原x.left )</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对节点y进行向左旋转操作，返回旋转后新的根节点x</span><br><span class="line">        y                             x</span><br><span class="line">      /  \                          /   \</span><br><span class="line">     <span class="variable constant_">T1</span>   x      向左旋转 (y)       y     z</span><br><span class="line">         / \   - - - - - - - -&gt;   <span class="regexp">/ \   /</span> \</span><br><span class="line">       <span class="variable constant_">T2</span>  z                     <span class="variable constant_">T1</span> <span class="variable constant_">T2</span> <span class="variable constant_">T3</span> <span class="variable constant_">T4</span></span><br><span class="line">          / \</span><br><span class="line">         <span class="variable constant_">T3</span> <span class="variable constant_">T4</span></span><br></pre></td></tr></table></figure><h3 id="AVL树的问题">AVL树的问题</h3><p>既然AVL树可以保证二叉树的平衡，这就意味着AVL搜索的时候，它最坏情况的时间复杂度O(logn) ，要低于普通二叉树BST和链表的最坏情况O(n)。</p><p>那么HashMap直接使用AVL树来替换链表就好了，为什么选择用红黑树呢？</p><p>原因是：</p><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;= 1，</p><p>所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p><p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是 <strong>增加删除 频繁</strong>的场景。</p><p><strong>红黑树(rbt)做了什么优化呢？</strong></p><p>红黑树(rbt)继承了AVL可自平衡的优点，</p><p>同时, 红黑树(rbt)在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除 频繁</strong>的场景。</p><p>在实际应用中，红黑树的使用要多得多。</p><h2 id="红黑树（RBTree）">红黑树（RBTree）</h2><p>红黑树是一种特化的AVL树（平衡二叉树）</p><p>红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）.</p><p>在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”.</p><h3 id="什么是红黑树？">什么是红黑树？</h3><p>红黑树也是一种自平衡二叉查找树，它与AVL树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。</p><p>与AVL树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时<strong>较少的旋转</strong>操作，整体来说性能要优于AVL树。</p><p>虽然RBTree是复杂的, 但它的<strong>最坏情况运行时间</strong>也是非常良好的,并且在实践中是高效的：</p><blockquote><p>它可以在<strong>O(log n)<strong>时间内做查找,插入和删除,这里的</strong>n 是树中元素的数目.</strong></p></blockquote><h3 id="红黑树的特性">红黑树的特性</h3><p>红黑树是实际应用中最常用的平衡二叉查找树，它不严格的具有平衡属性，但平均的使用性能非常良好。</p><p>在红黑树中，节点被标记为红色和黑色两种颜色。</p><p>红黑树的原则有以下几点：</p><ul><li>特性1：节点非黑即红</li><li>特性2：根节点一定是黑色</li><li>特性3：叶子节点（NIL）一定是黑色</li><li>特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620110228778.png" alt="image-20240620110228778"></p><p><strong>红色属性</strong> 说明，红色节点的孩子，一定是黑色。 但是，RBTree 黑色节点的孩子，可以是红色，也可以是黑色，具体如下图。</p><p><strong>叶子属性</strong> 说明， 叶子节点可以是空nil ，AVL的叶子节点不是空的，具体如下图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620112849376.png" alt="image-20240620112849376"></p><p><strong>Note：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</strong></p><blockquote><p><strong>Q&amp;A环节</strong></p></blockquote><p><strong>疑问</strong>：为什么红黑树的特性：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。可以保证 从根节点到叶子节点的最长可能路径不会超过最短可能路径的两倍长度。</p><p><strong>解释：</strong></p><p>首先，我们需要明白这个性质的含义：在从根节点到任何叶子节点的所有路径中，黑色节点的数量是相同的。</p><p>那么，考虑红黑树的两个规则：</p><ol><li>每个节点不是红色就是黑色。</li><li>不允许有两个连续的红色节点（即，红色节点的子节点也不能是红色）。</li></ol><p>基于这两点，我们可以得出以下结论：</p><ul><li>最短的可能路径全是黑色节点（因为不能有两个连续的红色节点）。</li><li>最长的可能路径是红色和黑色节点交替（因为不能有两个连续的红色节点）。</li></ul><p>因此，从根节点到叶子节点的最长可能路径（红黑交替）长度是最短可能路径（全黑）长度的两倍。这就是为什么红黑树的性质能保证树的高度平衡，进而保证了查找、插入和删除操作的效率。</p><p>插入的操作</p><p>基于上面的原则，我们一般在插入红黑树节点的时候，会将这个节点设置为红色，</p><p>原因参照最后一条原则： <strong>红色破坏原则的可能性最小</strong>，如果是黑色, 很可能<strong>导致这条支路的黑色节点比其它支路的要多1</strong>，破坏了平衡。</p><h4 id="记忆要点：">记忆要点：</h4><p>可以按照括号里边的分类，记住 红黑树的几个原则：</p><ul><li>（<strong>颜色属性</strong>）性质1：节点非黑即红</li><li>（<strong>根属性</strong>）性质2：根节点一定是黑色</li><li>（<strong>叶子属性</strong>）性质3：叶子节点（NIL）一定是黑色</li><li>（<strong>红色属性</strong>）性质4：每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>**（黑色属性）性质5：**从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p>黑色属性，可以理解为<strong>平衡特征</strong>， 如果满足不了平衡特征，就要进行平衡操作。</p><p><strong>空间换时间</strong></p><p>RBT有点属于一种<strong>空间换时间</strong>类型的优化，</p><p>在avl的节点上，增加了 <strong>颜色属性的 数据</strong>，相当于 增加了空间的消耗。 通过颜色属性的增加， 换取，后面平衡操作的次数 减少。</p><h3 id="黑色完美平衡">黑色完美平衡</h3><p>红黑树并不是一颗<strong>AVL平衡二叉搜索树</strong>，从图上可以看到，根节点P的左子树显然比右子树高</p><p>根据 红黑树的特性5，从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点， 说明：</p><blockquote><p>rbt 的 左子树和右子树的黑节点的层数是相等的</p><p>红黑树的平衡条件，不是以整体的高度来约束的，而是以黑色 节点的 高度，来约束的。</p></blockquote><p>所以称红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113125056.png" alt="image-20240620113125056"></p><p>看看<strong>黑色完美平衡</strong>的效果，</p><p>去掉 rbt中的红色节点，会得到 一个四叉树， 从根节点到每一个叶子，高度相同，就是rbt的root到叶子的黑色路径长度。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113216714.png" alt="image-20240620113216714"></p><h2 id="红黑树的恢复平衡过程的三个操作">红黑树的恢复平衡过程的三个操作</h2><p>一旦红黑树5个原则有不满足的情况，我们视为平衡被打破，如何 恢复平衡？</p><p>靠它的三种操作：<strong>变色、左旋、右旋</strong>。</p><h3 id="1-变色">1.变色</h3><p>节点的颜色由红变黑或由黑变红。（这个操作很好了解）</p><h3 id="2-左旋">2.左旋</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的左子树（左旋），pivot的原左子树变成 原root节点的 右子树，pivot的原右子树保持不变。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113236142.png" alt="image-20240620113236142"></p><h3 id="3-右旋：">3.右旋：</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的右子树（<strong>右旋</strong>），pivot的原右子树变成 原root节点的 左子树，pivot的原左子树保持不变。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113251895.png" alt="image-20240620113251895"></p><p>红黑树的左旋、右旋操作，AVL树的左旋，右旋操作 差不多</p><h2 id="红黑树插入节点情景分析">红黑树插入节点情景分析</h2><p>【重点】</p><p>新插入的节点都是红色</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620112811187.png" alt="image-20240620112811187"></p><h3 id="红黑树的节点结构">红黑树的节点结构</h3><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="默认新插入的节点为红色：">默认新插入的节点为红色：</h4><p>因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突</p><h3 id="场景1：红黑树为空树">场景1：红黑树为空树</h3><p>直接把插入结点作为根节点就可以了</p><p>另外：根据红黑树性质 2根节点是黑色的。还需要把插入节点设置为黑色。</p><h3 id="场景2：插入节点的Key已经存在">场景2：插入节点的Key已经存在</h3><p>更新当前节点的值，为插入节点的值。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113320622.png" alt="image-20240620113320622"></p><h3 id="情景3：插入节点的父节点为黑色">情景3：插入节点的父节点为黑色</h3><p>由于插入的节点是红色的，当插入节点的父节点是黑色时，不会影响红黑树的平衡，</p><p>所以： <strong>直接插入无需做自平衡</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113338000.png" alt="image-20240620113338000"></p><h3 id="情景4：插入节点的父节点为红色">情景4：插入节点的父节点为红色</h3><p>根据性质2：根节点是黑色。</p><p>如果插入节点的父节点为红色节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点(三代关系)。</p><p>根据性质4：每个<strong>红色</strong>节点的两个子节点一定是<strong>黑色</strong>的。不能有<strong>两个红色节点相连</strong>。</p><p>此时会出现两种状态：</p><ul><li>父亲和叔叔为红色</li><li>父亲为红色，叔叔为黑色</li></ul><p>如图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113425244.png" alt="image-20240620113425244"></p><h4 id="场景4-1：父亲和叔叔为红色节点">场景4.1：父亲和叔叔为红色节点</h4><p>根据性质4：<strong>红色节点不能相连 ==》祖父节点肯定为黑色节点：</strong></p><p>父亲为红色，那么此时该插入子树的红黑树层数的情况是：黑红红。</p><p>因为不可能同时存在两个相连的红色节点，需要进行 变色， 显然处理方式是把其改为：红黑红</p><p><strong>变色 处理</strong>：黑红红 ==&gt; 红黑红</p><p>1.将F和V节点改为黑色</p><p>2.将P改为红色</p><p>3.将P设置为当前节点，进行后续处理</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113440304.png" alt="image-20240620113440304"></p><p>可以看到，将P设置为红色了，</p><p>如果<strong>P的父节点是黑色</strong>，那么无需做处理；</p><p>但如果P的父节点是红色，则违反红黑树性质了，所以需要将P设置为当前节点，继续插入操作, 作自平衡处理，直到整体平衡为止。</p><h4 id="场景4-2：叔叔为黑色，父亲为红色，并且插在父亲的左节点">场景4.2：叔叔为黑色，父亲为红色，并且插在父亲的左节点</h4><p>分为两种情况</p><ul><li>LL 红色插入</li></ul><p>叔叔为黑色，或者不存在（NIL）也是黑节点，并且节点的父亲节点是祖父节点的左子节点</p><p>注意：单纯从插入来看，叔叔节点非红即黑(NIL节点)，否则破坏了红黑树性质5，此时路径会比其他路径多一个黑色节点。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113455760.png" alt="image-20240620113455760"></p><h5 id="场景4-2-1-LL型失衡">场景4.2.1 LL型失衡</h5><p>细分场景 1： 新插入节点，为其父节点的左子节点(LL红色情况)， 插入后 就是LL 型失衡</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113518798.png" alt="image-20240620113518798"></p><h6 id="自平衡处理：">自平衡处理：</h6><p>1.变颜色：</p><p>将F设置为黑色，将P设置为红色</p><p>2.对F节点进行<strong>右旋</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113531635.png" alt="image-20240620113531635"></p><h5 id="场景4-2-2-LR型失衡">场景4.2.2 LR型失衡</h5><p>细分场景 2： 新插入节点，为其父节点的右子节点(LR红色情况)， 插入后 就是LR 型失衡</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113547703.png" alt="image-20240620113547703"></p><h6 id="自平衡处理：-2">自平衡处理：</h6><p>1.对F进行左旋</p><p>2.将F设置为当前节点，得到LL红色情况</p><p>3.按照LL红色情况处理(1.变色 2.右旋P节点)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113601729.png" alt="image-20240620113601729"></p><h4 id="情景4-3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点">情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点</h4><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113619641.png" alt="image-20240620113619641"></p><h5 id="情景4-3-1：RR型失衡">情景4.3.1：RR型失衡</h5><p>新插入节点，为其父节点的右子节点(RR红色情况)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113648077.png" alt="image-20240620113648077"></p><h6 id="自平衡处理：-3">自平衡处理：</h6><p>1.变色：</p><p>将F设置为黑色，将P设置为红色</p><p>2.对P节点进行<strong>左旋</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113700149.png" alt="image-20240620113700149"></p><h5 id="情景4-3-2：RL型失衡">情景4.3.2：RL型失衡</h5><p>新插入节点，为其父节点的左子节点(RL红色情况)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113712441.png" alt="image-20240620113712441"></p><h6 id="自平衡处理：-4">自平衡处理：</h6><p>1.对F进行右旋</p><p>2.将F设置为当前节点，得到RR红色情况</p><p>3.按照RR红色情况处理(1.变色 2.左旋 P节点)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113724640.png" alt="image-20240620113724640"></p><h2 id="RBT面试题：">RBT面试题：</h2><h3 id="问：有了二叉搜索树，为什么还需要平衡二叉树？"><strong>问：有了二叉搜索树，为什么还需要平衡二叉树？</strong></h3><p>二叉搜索树容易退化成一条链</p><p>这时，查找的时间复杂度从O ( log n）也将退化成O ( N )</p><p>引入对左右子树高度差有限制的平衡二叉树 AVL，保证查找操作的最坏时间复杂度也为O ( log n）</p><h3 id="问：有了平衡二叉树，为什么还需要红黑树？">问：有了平衡二叉树，为什么还需要红黑树？</h3><p>AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡</p><p>在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣</p><p>红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，</p><p>整体性能优于AVL</p><ul><li><strong>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</strong></li><li><strong>红黑树的红黑规则，保证最坏的情况下，也能在O ( log n）时间内完成查找操作。</strong></li></ul><h3 id="问：红黑树那几个原则，你还记得么？">问：红黑树那几个原则，你还记得么？</h3><p>可以按照括号里边的分类，记住 红黑树的几个原则：</p><ul><li>（<strong>颜色属性</strong>）节点非黑即红</li><li>（<strong>根属性</strong>）根节点一定是黑色</li><li>（<strong>叶子属性</strong>）叶子节点（NIL）一定是黑色</li><li>（<strong>红色属性</strong>）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>**（黑色属性）**从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><h3 id="问：红黑树写入操作-，是如何找到它的父节点的？">问：红黑树写入操作 ，是如何找到它的父节点的？</h3><p>红黑树的节点 TreeNode它就是继承Node结构，</p><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TreeNode在Node基础上加了几个字段，分别指向父节点parent，然后指向左子节点left，还有指向右子节点的right，</p><p>然后还有表示颜色red属性</p><h6 id="红黑树的插入操作：">红黑树的插入操作：</h6><p>首先是找到一个合适的插入点，就是找到插入节点的父节点，</p><p>由于红黑树 它又满足BST二叉查找树的 有序特性，这个找父节点的操作和二叉查找树是完全一致的。</p><p>二叉查找树，左子节点小于当前节点，右子节点大于当前节点，</p><p>然后每一次向下查找一层就可以排除掉一半的数据，查找的效率在log(N)</p><p>最终查找到nil节点或者 key一样的节点。</p><p>如果最终查找到 key一样的节点，进行更新操作。这个TreeNode.key 与当前 put.key 完全一致。这就不需要插入，替换value就可以了，父节点就是当前节点的父节点</p><p>如果最终查找到nil节点，进行插入操作。nil节点的父节点，就是当前节点的父节点，把插入的节点替换nil节点。然后进行红黑树的 平衡处理。</p><h3 id="问：红黑树的有那些内部操作">问：红黑树的有那些内部操作</h3><p><strong>变色</strong></p><p>把一个红色的节点变成黑色，或者把一个黑色的节点变成红色，就是对这个节点的<code>变色</code>。</p><p><strong>旋转</strong></p><p>与平衡二叉树的旋转操作类似。</p><h3 id="红黑树与AVL树区别">红黑树与AVL树区别</h3><p><strong>1、调整平衡的实现机制不同</strong></p><p>红黑树根据路径上黑色节点数目一致，来确定是否失衡，如果失衡，就通过变色和旋转来恢复</p><p>AVL根据树的<a href="https://so.csdn.net/so/search?q=%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90&amp;spm=1001.2101.3001.7020">平衡因子</a>(<strong>所有节点的左右子树高度差的绝对值不超过1</strong>)，来确定是否失衡，如果失衡，就通过旋转来恢复</p><p><strong>2、红黑树的插入效率更高</strong></p><p>红黑树是用<strong>非严格的平衡</strong>来换取增删节点时候旋转次数的降低，<strong>任何不平衡都会在三次旋转之内解决</strong>，</p><p>红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能</p><p>而AVL是<strong>严格平衡树</strong>(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</p><p>所以红黑树的插入效率更高</p><p><strong>3、红黑树统计性能比AVL树更高</strong></p><p>红黑树能够以<strong>O(log n)</strong> 的时间复杂度进行查询、插入、删除操作。</p><p>AVL树查找、插入和删除在平均和最坏情况下都是<strong>O(log n)</strong>。</p><p>红黑树的算法时间复杂度和AVL相同，<strong>但统计性能比AVL树更高</strong>。</p><p><strong>解释：</strong></p><p>&quot;统计性能&quot;这个词在这里是指红黑树在插入和删除操作上的性能比AVL树更高。</p><p>红黑树和AVL树都是自平衡的二叉查找树，它们都可以在对数时间内完成查找、插入和删除操作。然而，由于它们的平衡条件和调整策略不同，它们在不同操作上的性能表现也有所不同。</p><ol><li>AVL树要求每个节点的左右子树的高度差最多为1，这是一种较为严格的平衡条件。这使得AVL树的查找性能非常高，因为每次查找的复杂度都是严格的对数级别。然而，每次插入和删除节点时，都可能需要进行一系列的旋转操作来重新达到平衡，这就导致了AVL树在插入和删除操作上的性能可能不如红黑树。</li><li>红黑树的平衡条件相对较松，只要求任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。这意味着红黑树在插入和删除节点时，需要进行旋转操作的频率较低，因此在插入和删除操作上的性能比AVL树更高。</li></ol><p>所以，当我们说&quot;红黑树的统计性能比AVL树更高&quot;时，我们是在说在进行大量的插入和删除操作时，红黑树的性能表现可能会优于AVL树。然而，如果你的应用场景主要是进行查找操作，那么AVL树可能会是更好的选择，因为它的查找性能更高。</p><p><strong>4、适用性：AVL查找效率高</strong></p><p><strong>如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树</strong>。</p><p>即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。</p><p>学习自：<a href="https://www.cnblogs.com/crazymakercircle/p/16320430.html">红黑树（图解+秒懂+史上最全）</a></p>]]></content>
    
    
    <summary type="html">图解红黑树</summary>
    
    
    
    <category term="数据结构" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="数据结构" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>STL-第四章</title>
    <link href="https://penge666.github.io/posts/7c902287.html"/>
    <id>https://penge666.github.io/posts/7c902287.html</id>
    <published>2024-06-19T11:43:55.000Z</published>
    <updated>2024-06-19T13:26:24.330Z</updated>
    
    <content type="html"><![CDATA[<p>所谓序列式容器，其中的元素<strong>都可序，但未必有序</strong>，C++语言本身提供了一个序列式容器array，STL另外再提供vector、list、deque、stack、queue、priority-queue等序列容器。<strong>其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器。</strong></p><p>本文将主要总结各种序列式容器的实现和用法。</p><h3 id="1、vector容器">1、vector容器</h3><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置就不能改变，如果要换个大点的空间，需要程序员自己来；<strong>vector是动态空间</strong>，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。</p><p>vector的实现技术，<strong>关键在于其对大小的控制以及重新配置时的数据移动效率</strong>。因为“配置新空间/数据移动/释放旧空间”是一个大工程。</p><h4 id="1-1-vector的迭代器">1.1 vector的迭代器</h4><p>由于vector使用的是连续线性的空间，普通指针能满足所有vector迭代器的所需的操作行为，所以其迭代器实际就是原生指针，支持随机存取，为Random Access Iterator。</p><h4 id="1-2-vector的数据结构">1.2 vector的数据结构</h4><p>vector所采用的数据结构：线性连续空间。</p><p>它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619194653351.png" alt="image-20240619194653351"></p><p>vector的空间配置策略为：</p><ul><li>当插入元素的时候，如果配置的空间不足，则扩充空间至当前的两倍，如果仍然不足则扩充至所需空间。</li><li>容量的扩张必须经历“重新配置、元素移动、释放原空间”等过程。</li></ul><p><strong>Note</strong>：Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍。</p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在Linux + GCC下</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//4</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在 win 10 + VS2019下</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//3</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//6 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时已占用的长度为3，再继续两个数据，此时长度变为8，可以清晰的看到空间的变化过程</p><p>需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响。</p><blockquote><p><strong>emplace_back()和push_back()的区别</strong></p></blockquote><p>总结：</p><p>1、push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p>2、push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>3、emplace_back不能完全代替push_back。</p><p>举例说明：</p><p><strong>总结1，2</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.<span class="built_in">emplace_back</span>(<span class="number">2</span>);  </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>这里将移动构造函数注释掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure><p>因此，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p><strong>总结3：</strong></p><p><a href="https://www.zhihu.com/question/387522517/answer/1151089633">https://www.zhihu.com/question/387522517/answer/1151089633</a></p><p>例子1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// error</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">v.emplace_back&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为不知道你{1,2,3}是什么类型。</p><p>例子2：直接构造的坏处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 编译出错</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 通过编译，但运行时抛出异常并且难以定位</span></span><br></pre></td></tr></table></figure><p>例子3：特殊情况只能用push_back</p><p><a href="https://www.zhihu.com/question/347743586/answer/835340740">https://www.zhihu.com/question/347743586/answer/835340740</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;S&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>&#125;);    <span class="comment">// 没问题</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(&#123;<span class="number">0</span>&#125;); <span class="comment">// 编不过</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>resize()和reserve()的区别</strong></p></blockquote><p><strong>resize用法</strong></p><ol><li>resize(n)</li></ol><ul><li><p>调整容器的长度大小，使其能容纳n个元素。</p></li><li><p>如果n小于容器的当前的size，则删除多出来的元素。</p></li><li><p>否则，添加采用值初始化的元素。</p></li></ul><ol start="2"><li>resize(n，t)</li></ol><ul><li>多一个参数t，将所有新添加的元素初始化为t。</li></ul><p><strong>reserve用法</strong></p><ul><li>预分配n个元素的存储空间。</li></ul><p>看个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">150</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">50  100</span><br><span class="line">150  150</span><br><span class="line">150  150</span><br><span class="line">50  150</span><br></pre></td></tr></table></figure><p><strong>容器的capacity（容量）与size（长度）</strong></p><p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，</p><p>因为此时容器中还没有创建任何对象。</p><p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。</p><h3 id="2、list容器">2、list容器</h3><p><strong>list是一个双list是一个双向链表，每次插入或删除一个元素，就分配或释放一个元素的空间</strong>；所以list对空间的控制十分精确，而且任何位置的插入或删除需要的时间都是常数，即时间复杂度为o(1)。</p><p>list和vector是两种最常用的容器，什么时候选用哪种容器，视元素的多寡、元素的构造复杂度以及元素存取的行为特性，一般来说查找比较多的情况用vector,而插入和删除比较多的场景则比较适合list。</p><p>list节点的结构见如下源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-list的迭代器">2.1 list的迭代器</h4><p>list迭代器正确的递增、递减、取值、成员取用操作是指，递增指向下一个节点，递减指向上一个节点，取值取的是节点的数据值，成员取用时取用的是节点的成员。list不能再以原生指针作为迭代器，而需要定义特定的iterator类。<strong>list迭代器是一种Bidirectional Iterator</strong>，支持单步的前进或后退操作。</p><p>list迭代器有一个重要性质：<strong>插入和结合操作都不会有list迭代器失效</strong>，这在vector是不成立的，因为vector的插入操作可能造成原来的重新配置，导致原有的迭代器全部失效。<strong>list的元素删除操作也只有指向删除元素的那个迭代器失效，其他迭代器不受影响</strong>。</p><p><strong>这是因为 <code>std::list</code> 使用链表实现,插入和删除只需要修改指针</strong>。</p><h4 id="2-2-list的数据结构">2.2 list的数据结构</h4><p>list的结构如下图，SGI list不仅是一个双向链表，而且还是一个<strong>环状双向链表</strong>，所以它只需一个指针，便可完整表现整个链表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619202315033.png" alt="image-20240619202315033"></p><p>list缺省使用alloc作为空间配置器，以节点大小为配置单位。</p><p>当我们以push_back()将元素插入list尾部时，此函数内部调用insert()，insert()是一个重载函数，有多种形式最简单的一种是：首先配置并构造一个节点，然后在尾端进行适当的指针操作，最后将节点插入进去，list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效。由于list是一个双向循环链表，只要我们把边界条件处理好，那么，在头部或者尾部插入元素的操作几乎是一样的，list内部提供一个所谓的迁移操作：将某连续范围的元素迁移到某个特定位置之前，节点间的指针移动而已。</p><blockquote><p>需要注意的是：list不能使用stl提供的通用sort算法，因为sort算法只接受Random Access Iterator，所以提供了自己的sort方法,可以直接调用，其内部好像是将原链分解为多个链表，然后依次进行合并。</p></blockquote><h3 id="3、deque容器">3、deque容器</h3><p>vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾分别做元素的的安插和删除操作；vector当然也可以在头尾两端做动作，但是其头部动作效率奇差。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619205225280.png" alt="image-20240619205225280"></p><p>deque和vector的差异：</p><ul><li>一在于deque允许常数时间内对头端进行元素的插入或移除操作</li><li>二在于deque没有所谓容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。deque没有必要提供所谓的空间保留功能。vector只能向尾端“生长”，而deque可以在前端或者尾端增加新空间。不存在像vector那样“因空间不足而分配一块更大的空间然后复制元素”问题。</li></ul><h4 id="3-1-deque的迭代器">3.1 deque的迭代器</h4><p>deque提供random access iterator，但并不是原生指针。其实现的复杂度也很大，这也影响到相关算法的效率。所以<strong>如非必要，应该尽量使用vector而不是deque</strong>。对的确需要进行排序时，可以先将元素复制到一个vector，排序后再复制回deque。</p><h4 id="3-2-deque的数据结构">3.2 deque的数据结构</h4><p>deque的数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//指向map指针的指针</span></span><br><span class="line">    map_pointer map;<span class="comment">//指向map</span></span><br><span class="line">    size_type map_size;<span class="comment">//map的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">itertator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deque采用的是一种<strong>分段连续空间存储结构</strong>，采用一个map来管理这些空间段，这里所谓map是一小块连续空间，其中每个元素都是指针，指向另外一段较大的连续线性空间，称为缓冲区，<strong>缓冲区才是deque的存储空间主体</strong>，SGI STL允许我们指定缓冲区大小，默认值0表示使用512bytes缓冲区。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619205752980.png" alt="image-20240619205752980"></p><p>由于<strong>每个缓冲区的大小是固定的</strong>，当有新元素加入而空间不足时，就分配一个新的缓冲区,配置策略为reallocate_map()。 deque的这种结构，使得其迭代器上的操作可能需要跨越多个缓冲区，这使得迭代器的实现非常复杂。</p><p>deque的迭代器数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    T* cur;<span class="comment">//迭代器所指缓冲区当前的元素</span></span><br><span class="line">    T* first;<span class="comment">//迭代器所指缓冲区第一个元素</span></span><br><span class="line">    T* last;<span class="comment">//迭代器所指缓冲区最后一个元素</span></span><br><span class="line">    map_pointer node;<span class="comment">//指向map中的node</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619210621348.png" alt="image-20240619210621348"></p><p>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p><p><strong>Note</strong>：deque 并不是每个缓冲区都对应一个迭代器。deque 只有一个整体的迭代器,它负责在整个 deque 的缓冲区之间进行跳转。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619210258680.png" alt="image-20240619210258680"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619210248652.png" alt="image-20240619210248652"></p><h3 id="4、stack容器">4、stack容器</h3><p>stack是一种<strong>先进后出</strong>的数据结构，它只有一个出口,stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端元素外，没有任何其他方式可以存取stack的其他元素，换言之，<strong>stack不允许有遍历行为</strong>。</p><p>stack不支持对元素的遍历，因此<strong>没有迭代器</strong>。</p><h4 id="4-1-stack的数据结构">4.1 stack的数据结构</h4><p>stack是一种先进后出的数据结构，只可以在顶端进行元素操作。如果有某种双向开口的数据结构，将其接口改变，符合“先进后出”的特性，就可以形成一个stack：deque和list都是这样的结构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619205935560.png" alt="image-20240619205935560"></p><p>SGI STL便以deque作为缺省情况下的stack底部结构。由于stack是以底部容器deque完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为<strong>adapter（配接器）</strong>,因此，STL stack往往不被归类为container（容器），而被归类为container adapter。</p><h3 id="5、queue容器">5、queue容器</h3><p>queue是一种先进先出的数据结构，它有两个出口。queue允许新增元素、移除元素、从底端加入元素、取得最顶端元素（queue不允许有遍历行为）。</p><p>与stack一样，queue也不允许有遍历行为，queue没有迭代器。</p><p>与stack类似，SGI STL默认情况下以deque作为queue的底部结构。也是一种container adapter。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211611039.png" alt="image-20240619211611039"></p><h3 id="6、heap">6、heap</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演priority queue的助手,它分为 max heap 和min heap，在缺省情况下，<strong>max-heap是priority queue的底层实现机制</strong>。</p><h4 id="6-1-heap的数据结构">6.1 heap的数据结构</h4><p>以array表达tree的方式，称为<strong>隐式表述法</strong>,这样就可以使用一个array表示出一颗完全二叉树。array的缺点是无法动态的改变大小，所以实际实现机制中的<strong>max-heap实际上是以一个vector表现的完全二叉树</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211707150.png" alt="image-20240619211707150"></p><p>从上图可以看出，第0号元素保留，这样就可以使得从arry[1]开始保存A，位于位置i的某个结点arry[i]，他的左子结点必然在arry[2<em>i]中，右子结点必然位于arry[2</em>i+1]，其父亲结点必然位于arry[i/2]处。</p><h4 id="6-2-heap的相关算法">6.2 heap的相关算法</h4><ul><li>（1）建立堆：make_heap(_First, _Last, _Comp)<br>传入vector的迭代器，默认是建立最大堆的。对int类型，<strong>可以在第三个参数传入greater()得到最小堆</strong>。</li><li>（2）在堆中添加数据：push_heap(_First, _Last)<br>要先在容器中加入数据push_back()，再调用push_heap()，vector的元素放在尾端，所以实际上push_heap所做的操作就是将尾端元素和其父节点进行比较，如果大于父节点则交换并不断上溯<strong>直到不满足大于为止</strong>。</li><li>（3）在堆中删除数据：pop_heap(_First, _Last)<br>该算法主要是先将vector的根节点即最大值放到vector的尾端，然后处理[start,end-1)区间的元素，从根节点开始，<strong>只要父节点的元素小于某个子节点的元素就进行交换并继续下溯</strong>，否则停止。 调用pop_heap()结束后vector()可以通过pop_back()取出最大元素。</li><li>（4）堆排序sort_heap(_First, _Last)<br>sort_heap算法的内部实现原理：每次pop_heap可获得heap中键值最大的元素，如果持续对整个heap做pop_heap操作，每次将操作范围从后向前缩减一个元素，当整个程序执行完毕时，便有了一个递增的序列。</li></ul><h4 id="6-3-heap的迭代器">6.3 heap的迭代器</h4><p><strong>heap本身并不是一个容器，它更多的是依靠vector容器底层，并在上面实现算法从而实现对tree的表达。heap不提供遍历功能，也没有对应的迭代器。</strong></p><h3 id="7、priority-queue">7、priority__queue</h3><p>priority_queue是一个拥有权值观念的queue，它允许加入新元素、移除旧元素、审视新元素等功能。由于是一个queue，所以只能在底端加入元素，在顶端取出元素。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211809000.png" alt="image-20240619211809000"></p><p>priority_queue带有权值概念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列。<strong>priority_queue缺省情况下是以vector为底层容器，并加上heap处理规则实现</strong>，因此，STL priority_queue往往不被归类为container(容器)，而被归类为container adapter。</p><p>与queue一样，priority_queue也没有迭代器。</p><h3 id="8、slist">8、slist</h3><p>list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前<strong>者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator</strong>。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。</p><p>考虑到效率问题，<strong>slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的.</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619212132376.png" alt="image-20240619212132376"></p><p>slist的单向迭代器如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211824831.png" alt="image-20240619211824831"></p><p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Allco</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">slist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> list_node* <span class="title function_">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span>&#123;&#125;<span class="comment">//配置空间、构造元素</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">destroy_node</span><span class="params">(list_node* node)</span>&#123;&#125;<span class="comment">//析构函数、释放空间</span></span><br><span class="line">private:</span><br><span class="line">    list_node_base head; <span class="comment">//头部</span></span><br><span class="line">public:</span><br><span class="line">    iterator <span class="title function_">begin</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    iterator <span class="title function_">end</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    size_type <span class="title function_">size</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">swap</span><span class="params">(slist&amp; L)</span>&#123;&#125;<span class="comment">//交换两个slist，只需要换head即可</span></span><br><span class="line">    reference <span class="title function_">front</span><span class="params">()</span>&#123;&#125; <span class="comment">//取头部元素</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">const</span> value&amp; x)</span>&#123;&#125;<span class="comment">//头部插入元素</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pop_front</span><span class="params">()</span>&#123;&#125;<span class="comment">//从头部取走元素</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line">fl.push_front(<span class="number">1</span>);</span><br><span class="line">fl.push_front(<span class="number">3</span>);</span><br><span class="line">fl.push_front(<span class="number">2</span>);</span><br><span class="line">fl.push_front(<span class="number">6</span>);</span><br><span class="line">fl.push_front(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator ite1 = fl.begin();</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator ite2 = fl.end();</span><br><span class="line"><span class="keyword">for</span>(;ite1 != ite2; ++ite1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ite1 &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 5 6 2 3 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ite1 = find(fl.begin(), fl.end(), <span class="number">2</span>); <span class="comment">//寻找2的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ite1 != ite2)</span><br><span class="line">fl.insert_after(ite1, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : fl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//5 6 2 99 3 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ite1 = find(fl.begin(), fl.end(), <span class="number">6</span>); <span class="comment">//寻找6的位置</span></span><br><span class="line"><span class="keyword">if</span> (ite1 != ite2)</span><br><span class="line">fl.erase_after(ite1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : fl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//5 6 99 3 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、总结">9、总结</h3><p>在实际使用过程中，到底选择这几种容器中的哪一个？通常应该根据遵循以下原则：</p><p>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p><p>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p><p>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p><p>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p><p>（5）如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p>]]></content>
    
    
    <summary type="html">STL-序列式容器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存工作原理</title>
    <link href="https://penge666.github.io/posts/b1b4d1ef.html"/>
    <id>https://penge666.github.io/posts/b1b4d1ef.html</id>
    <published>2024-06-18T07:57:06.000Z</published>
    <updated>2024-06-18T09:30:32.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导言"><strong>导言</strong></h3><p>虚拟内存是当今计算机系统中最重要的抽象概念之一，它的提出是为了更加有效地管理内存并且降低内存出错的概率。虚拟内存影响着计算机的方方面面，包括硬件设计、文件系统、共享对象和进程/线程调度等等，每一个致力于编写高效且出错概率低的程序的程序员都应该深入学习虚拟内存。</p><p>本文全面而深入地剖析了虚拟内存的工作原理，帮助读者快速而深刻地理解这个重要的概念。</p><h3 id="计算机存储器"><strong>计算机存储器</strong></h3><p>存储器是计算机的核心部件之一，在完全理想的状态下，存储器应该要同时具备以下三种特性：</p><ol><li>速度足够快：存储器的存取速度应当快于 CPU 执行一条指令，这样 CPU 的效率才不会受限于存储器</li><li>容量足够大：容量能够存储计算机所需的全部数据</li><li>价格足够便宜：价格低廉，所有类型的计算机都能配备</li></ol><p>但是现实往往是残酷的，我们目前的计算机技术无法同时满足上述的三个条件，于是现代计算机的存储器设计采用了一种分层次的结构：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172131123.png" alt="image-20240618172131123"></p><p>从顶至底，现代计算机里的存储器类型分别有：寄存器、高速缓存、主存和磁盘，这些存储器的速度逐级递减而容量逐级递增。存取速度最快的是寄存器，因为寄存器的制作材料和 CPU 是相同的，所以速度和 CPU 一样快，CPU 访问寄存器是没有时延的，然而因为价格昂贵，因此容量也极小，一般 32 位的 CPU 配备的寄存器容量是 32✖️32 Bit，64 位的 CPU 则是 64✖️64 Bit，不管是 32 位还是 64 位，寄存器容量都小于 1 KB，且寄存器也必须通过软件自行管理。</p><p>第二层是高速缓存，也即我们平时了解的 CPU 高速缓存 L1、L2、L3，一般 L1 是每个 CPU 独享，L3 是全部 CPU 共享，而 L2 则根据不同的架构设计会被设计成独享或者共享两种模式之一，比如 Intel 的多核芯片采用的是共享 L2 模式而 AMD 的多核芯片则采用的是独享 L2 模式。</p><p>第三层则是主存，也即主内存，通常称作随机访问存储器（Random Access Memory, RAM）。是与 CPU 直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质。</p><p>最后则是磁盘，磁盘和主存相比，每个二进制位的成本低了两个数量级，因此容量比之会大得多，动辄上 GB、TB，而缺点则是访问速度则比主存慢了大概三个数量级。机械硬盘速度慢主要是因为机械臂需要不断在金属盘片之间移动，等待磁盘扇区旋转至磁头之下，然后才能进行读写操作，因此效率很低。</p><h3 id="主存"><strong>主存</strong></h3><h4 id="物理内存">物理内存</h4><p>我们平时一直提及的物理内存就是上文中对应的第三种计算机存储器，RAM 主存，它在计算机中以内存条的形式存在，嵌在主板的内存槽上，用来加载各式各样的程序与数据以供 CPU 直接运行和使用。</p><h4 id="虚拟内存">虚拟内存</h4><p>在计算机领域有一句如同摩西十诫般神圣的哲言：“<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>”，从内存管理、网络模型、并发调度甚至是硬件架构，都能看到这句哲言在闪烁着光芒，而虚拟内存则是这一哲言的完美实践之一。</p><p>虚拟内存是现代计算机中的一个非常重要的存储器抽象，主要是用来解决应用程序日益增长的内存使用需求：现代物理内存的容量增长已经非常快速了，然而还是跟不上应用程序对主存需求的增长速度，对于应用程序来说内存还是可能会不够用，因此便需要一种方法来解决这两者之间的容量差矛盾。为了更高效地管理内存并尽可能消除程序错误，现代计算机系统对物理主存 RAM 进行抽象，实现了***虚拟内存 (Virtual Memory, VM)***技术。</p><h3 id="虚拟内存-2"><strong>虚拟内存</strong></h3><p>虚拟内存的核心原理是：为每个程序设置一段&quot;连续&quot;的虚拟地址空间，把这个地址空间分割成多个具有连续地址范围的页 (Page)，并把这些页和物理内存做映射，在程序运行期间动态映射到物理内存。当程序引用到一段在物理内存的地址空间时，由硬件立刻执行必要的映射；而当程序引用到一段不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><p>其实虚拟内存技术从某种角度来看的话，很像是糅合了基址寄存器和界限寄存器之后的新技术。它使得整个进程的地址空间可以通过较小的虚拟单元映射到物理内存，而不需要为程序的代码和数据地址进行重定位。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172246028.png" alt="image-20240618172246028"></p><p>虚拟地址空间按照固定大小划分成被称为页（Page）的若干单元，物理内存中对应的则是页框（Page Frame）。这两者一般来说是一样的大小，如上图中的是 4KB，不过实际上计算机系统中一般是 512 字节到 1 GB，这就是虚拟内存的分页技术。因为是虚拟内存空间，每个进程分配的大小是 4GB (32 位架构)，而实际上当然不可能给所有在运行中的进程都分配 4GB 的物理内存，所以虚拟内存技术还需要利用到一种 <code>交换（swapping）</code>技术，也就是通常所说的页面置换算法，在进程运行期间只分配映射当前使用到的内存，暂时不使用的数据则写回磁盘作为副本保存，需要用的时候再读入内存，动态地在磁盘和内存之间交换数据。</p><h4 id="页表">页表</h4><p>页表（Page Table），每次进行虚拟地址到物理地址的映射之时，都需要读取页表，从数学角度来说页表就是一个函数，入参是虚拟页号（Virtual Page Number，简称 VPN），输出是物理页框号（Physical Page Number，简称 PPN，也就是物理地址的基址）。</p><p>页表由多个页表项（Page Table Entry, 简称 PTE）组成，页表项的结构取决于机器架构，不过基本上都大同小异。一般来说页表项中都会存储物理页框号、修改位、访问位、保护位和 “在/不在” 位（有效位）等信息。</p><ul><li>物理页框号：这是 PTE 中最重要的域值，毕竟页表存在的意义就是提供 VPN 到 PPN 的映射。</li><li>有效位：表示该页面当前是否存在于主存中，1 表示存在，0 表示缺失，当进程尝试访问一个有效位为 0 的页面时，就会引起一个缺页中断。</li><li>保护位：指示该页面所允许的访问类型，比如 0 表示可读写，1 表示只读。</li><li>修改位和访问位：为了记录页面使用情况而引入的，一般是页面置换算法会使用到。比如当一个内存页面被程序修改过之后，硬件会自动设置修改位，如果下次程序发生缺页中断需要运行页面置换算法把该页面调出以便为即将调入的页面腾出空间之时，就会先去访问修改位，从而得知该页面被修改过，也就是脏页 (Dirty Page)，则需要把最新的页面内容写回到磁盘保存，否则就表示内存和磁盘上的副本内容是同步的，无需写回磁盘；而访问位同样也是系统在程序访问页面时自动设置的，它也是页面置换算法会使用到的一个值，系统会根据页面是否正在被访问来觉得是否要淘汰掉这个页面，一般来说不再使用的页面更适合被淘汰掉。</li><li>高速缓存禁止位：用于禁止页面被放入 CPU 高速缓存，这个值主要适用于那些映射到寄存器等实时 I/O 设备而非普通主存的内存页面，这一类实时 I/O 设备需要拿到最新的数据，而 CPU 高速缓存中的数据可能是旧的拷贝。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172300555.png" alt="image-20240618172300555"></p><h4 id="地址翻译">地址翻译</h4><p>进程在运行期间产生的内存地址都是虚拟地址，如果计算机没有引入虚拟内存这种存储器抽象技术的话，则 CPU 会把这些地址直接发送到内存地址总线上，然后访问和虚拟地址相同值的物理地址；如果使用虚拟内存技术的话，CPU 则是把这些虚拟地址通过地址总线送到内存管理单元（Memory Management Unit，简称 MMU），MMU 将虚拟地址翻译成物理地址之后再通过内存总线去访问物理内存：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172315295.png" alt="image-20240618172315295"></p><p>虚拟地址（比如 16 位地址 8196=0010 000000000100）分为两部分：虚拟页号（Virtual Page Number，简称 VPN，这里是高 4 位部分）和偏移量（Virtual Page Offset，简称 VPO，这里是低 12 位部分），虚拟地址转换成物理地址是通过页表（page table）来实现的。</p><p>这里我们基于一个例子来分析当页面命中时，计算机各个硬件是如何交互的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172327132.png" alt="image-20240618172327132"></p><ul><li><strong>第 1 步</strong>：处理器生成一个虚拟地址 VA，通过总线发送到 MMU；</li><li><strong>第 2 步</strong>：MMU 通过虚拟页号得到页表项的地址 PTEA，通过内存总线从 CPU 高速缓存/主存读取这个页表项 PTE；</li><li><strong>第 3 步</strong>：CPU 高速缓存或者主存通过内存总线向 MMU 返回页表项 PTE；</li><li><strong>第 4 步</strong>：MMU 先把页表项中的物理页框号 PPN 复制到寄存器的高三位中，接着把 12 位的偏移量 VPO 复制到寄存器的末 12 位构成 15 位的物理地址，即可以把该寄存器存储的物理内存地址 PA 发送到内存总线，访问高速缓存/主存；</li><li><strong>第 5 步</strong>：CPU 高速缓存/主存返回该物理地址对应的数据给处理器。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172339034.png" alt="image-20240618172339034"></p><p>在 MMU 进行地址转换时，如果页表项的有效位是 0，则表示该页面并没有映射到真实的物理页框号 PPN，则会引发一个<strong>缺页中断</strong>，CPU 陷入操作系统内核，接着操作系统就会通过页面置换算法选择一个页面将其换出 (swap)，以便为即将调入的新页面腾出位置，如果要换出的页面的页表项里的修改位已经被设置过，也就是被更新过，则这是一个脏页 (Dirty Page)，需要写回磁盘更新该页面在磁盘上的副本，如果该页面是&quot;干净&quot;的，也就是没有被修改过，则直接用调入的新页面覆盖掉被换出的旧页面即可。</p><p>缺页中断的具体流程如下：</p><ul><li><strong>第 1 步到第 3 步</strong>：和前面的页面命中的前 3 步是一致的；</li><li><strong>第 4 步</strong>：检查返回的页表项 PTE 发现其有效位是 0，则 MMU 触发一次缺页中断异常，然后 CPU 转入到操作系统内核中的缺页中断处理器；</li><li><strong>第 5 步</strong>：缺页中断处理程序检查所需的虚拟地址是否合法，确认合法后系统则检查是否有空闲物理页框号 PPN 可以映射给该缺失的虚拟页面，如果没有空闲页框，则执行页面置换算法寻找一个现有的虚拟页面淘汰，如果该页面已经被修改过，则写回磁盘，更新该页面在磁盘上的副本；</li><li><strong>第 6 步</strong>：缺页中断处理程序从磁盘调入新的页面到内存，更新页表项 PTE；</li><li><strong>第 7 步</strong>：缺页中断程序返回到原先的进程，重新执行引起缺页中断的指令，CPU 将引起缺页中断的虚拟地址重新发送给 MMU，此时该虚拟地址已经有了映射的物理页框号 PPN，因此会按照前面『Page Hit』的流程走一遍，最后主存把请求的数据返回给处理器。</li></ul><p><strong>解释下</strong>：PTE和PTEA的概念</p><ol><li>PTE（Page Table Entry）：在虚拟内存系统中，PTE是页表中的一个条目，用于映射虚拟地址到物理地址。每一个PTE都包含一些控制位，如有效位（表示这个条目是否有效）和脏位（表示这个页面是否被修改过）等。</li><li>PTEA（Page Table Entry Address）：PTEA则是页表条目的地址，也就是指向PTE的指针。PTEA通常由虚拟地址的一部分（例如高位）来生成，用于在页表中查找对应的PTE。</li></ol><p>因此，PTE和PTEA的主要区别在于，PTE是用于虚拟到物理地址映射的条目，而PTEA则是这些条目在内存中的地址。</p><p>我认为，作者之所以在上述图中那么画是为了更加精准的说明概念！</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172350174.png" alt="image-20240618172350174"></p><h4 id="虚拟内存和高速缓存">虚拟内存和高速缓存</h4><p>前面在分析虚拟内存的工作原理之时，谈到页表的存储位置，为了简化处理，都是默认把主存和高速缓存放在一起，而实际上更详细的流程应该是如下的原理图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172403418.png" alt="image-20240618172403418"></p><p>如果一台计算机同时配备了虚拟内存技术和 CPU 高速缓存，那么 MMU 每次都会优先尝试到高速缓存中进行寻址，如果缓存命中则会直接返回，只有当缓存不命中之后才去主存寻址。</p><p>通常来说，大多数系统都会选择利用物理内存地址去访问高速缓存，因为高速缓存相比于主存要小得多，所以使用物理寻址也不会太复杂；另外也因为高速缓存容量很小，所以系统需要尽量在多个进程之间共享数据块，而使用物理地址能够使得多进程同时在高速缓存中存储数据块以及共享来自相同虚拟内存页的数据块变得更加直观。</p><h4 id="加速翻译-优化页表">加速翻译&amp;优化页表</h4><p>经过前面的剖析，相信读者们已经了解了虚拟内存及其分页&amp;地址翻译的基础和原理。现在我们可以引入虚拟内存中两个核心的需求，或者说瓶颈：</p><ul><li>虚拟地址到物理地址的映射过程必须要非常快，地址翻译如何加速。</li><li>虚拟地址范围的增大必然会导致页表的膨胀，形成大页表。</li></ul><p>这两个因素决定了虚拟内存这项技术能不能真正地广泛应用到计算机中，如何解决这两个问题呢？</p><p>正如文章开头所说：“<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>”。因此，虽然虚拟内存本身就已经是一个中间层了，但是中间层里的问题同样可以通过再引入一个中间层来解决。</p><p>加速地址翻译过程的方案目前是通过引入页表缓存模块 – TLB，而大页表则是通过实现多级页表或倒排页表来解决。</p><h5 id="TLB-加速"><strong>TLB 加速</strong></h5><p><strong>翻译后备缓冲器</strong>（Translation Lookaside Buffer，TLB），也叫快表，是用来加速虚拟地址翻译的，因为虚拟内存的分页机制，页表一般是保存在内存中的一块固定的存储区，而 MMU 每次翻译虚拟地址的时候都需要从页表中匹配一个对应的 PTE，导致进程通过 MMU 访问指定内存数据的时候比没有分页机制的系统多了一次内存访问，一般会多耗费几十到几百个 CPU 时钟周期，性能至少下降一半，如果 PTE 碰巧缓存在 CPU L1 高速缓存中，则开销可以降低到一两个周期，但是我们不能寄希望于每次要匹配的 PTE 都刚好在 L1 中，因此需要引入加速机制，即 TLB 快表。</p><p>TLB 可以简单地理解成页表的高速缓存，保存了最高频被访问的页表项 PTE。由于 TLB 一般是硬件实现的，因此速度极快，MMU 收到虚拟地址时一般会先通过硬件 TLB 并行地在页表中匹配对应的 PTE，若命中且该 PTE 的访问操作不违反保护位（比如尝试写一个只读的内存地址），则直接从 TLB 取出对应的物理页框号 PPN 返回，若不命中则会穿透到主存页表里查询，并且会在查询到最新页表项之后存入 TLB，以备下次缓存命中，如果 TLB 当前的存储空间不足则会替换掉现有的其中一个 PTE。</p><p>下面来具体分析一下 TLB 命中和不命中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172417006.png" alt="image-20240618172417006"></p><p><strong>TLB 命中</strong>：</p><ul><li><strong>第 1 步</strong>：CPU 产生一个虚拟地址 VA；</li><li><strong>第 2 步和第 3 步</strong>：MMU 从 TLB 中取出对应的 PTE；</li><li><strong>第 4 步</strong>：MMU 将这个虚拟地址 VA 翻译成一个真实的物理地址 PA，通过地址总线发送到高速缓存/主存中去；</li><li><strong>第 5 步</strong>：高速缓存/主存将物理地址 PA 上的数据返回给 CPU。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172440033.png" alt="image-20240618172440033"></p><p><strong>TLB 不命中</strong>：</p><ul><li><strong>第 1 步</strong>：CPU 产生一个虚拟地址 VA；</li><li><strong>第 2 步至第 4 步</strong>：查询 TLB 失败，走正常的主存页表查询流程拿到 PTE，然后把它放入 TLB 缓存，以备下次查询，如果 TLB 此时的存储空间不足，则这个操作会汰换掉 TLB 中另一个已存在的 PTE；</li><li><strong>第 5 步</strong>：MMU 将这个虚拟地址 VA 翻译成一个真实的物理地址 PA，通过地址总线发送到高速缓存/主存中去；</li><li><strong>第 6 步</strong>：高速缓存/主存将物理地址 PA 上的数据返回给 CPU。</li></ul><h5 id="多级页表"><strong>多级页表</strong></h5><p>TLB 的引入可以一定程度上解决虚拟地址到物理地址翻译的开销问题，接下来还需要解决另一个问题：大页表。</p><p>理论上一台 32 位的计算机的寻址空间是 4GB，也就是说每一个运行在该计算机上的进程理论上的虚拟寻址范围是 4GB。到目前为止，我们一直在讨论的都是单页表的情形，如果每一个进程都把理论上可用的内存页都装载进一个页表里，但是实际上进程会真正使用到的内存其实可能只有很小的一部分，而我们也知道页表也是保存在计算机主存中的，那么势必会造成大量的内存浪费，甚至有可能导致计算机物理内存不足从而无法并行地运行更多进程。</p><p>这个问题一般通过<strong>多级页表</strong>（Multi-Level Page Tables）来解决，通过把一个大页表进行拆分，形成多级的页表，我们具体来看一个二级页表应该如何设计：假定一个虚拟地址是 32 位，由 10 位的一级页表索引、10 位的二级页表索引以及 12 位的地址偏移量，则 PTE 是 4 字节，页面 page 大小是 2^12 = 4KB，总共需要 2^20 个 PTE，一级页表中的每个 PTE 负责映射虚拟地址空间中的一个 4MB 的 chunk，每一个 chunk 都由 1024 个连续的页面 Page 组成，如果寻址空间是 4GB，那么一共只需要 1024 个 PTE 就足够覆盖整个进程地址空间。二级页表中的每一个 PTE 都负责映射到一个 4KB 的虚拟内存页面，和单页表的原理是一样的。</p><p>多级页表的关键在于，我们并不需要为一级页表中的每一个 PTE 都分配一个二级页表，而只需要为进程当前使用到的地址做相应的分配和映射。因此，对于大部分进程来说，它们的一级页表中有大量空置的 PTE，那么这部分 PTE 对应的二级页表也将无需存在，这是一个相当可观的内存节约，事实上对于一个典型的程序来说，理论上的 4GB 可用虚拟内存地址空间绝大部分都会处于这样一种未分配的状态；更进一步，在程序运行过程中，只需要把一级页表放在主存中，虚拟内存系统可以在实际需要的时候才去创建、调入和调出二级页表，这样就可以确保只有那些最频繁被使用的二级页表才会常驻在主存中，此举亦极大地缓解了主存的压力。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172454801.png" alt="image-20240618172454801"></p><p>多级页表的层级深度可以按照需求不断扩充，一般来说，级数越多，灵活性越高。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172505424.png" alt="image-20240618172505424"></p><p>比如有个一个 k 级页表，虚拟地址由 k 个 VPN 和 1 个 VPO 组成，每一个 VPN i 都是一个到第 i 级页表的索引，其中 1 &lt;= i &lt;= k。第 j 级页表中的每一个 PTE（1 &lt;= j &lt;= k-1）都指向第 j+1 级页表的基址。第 k 级页表中的每一个 PTE 都包含一个物理地址的页框号 PPN，或者一个磁盘块的地址（该内存页已经被页面置换算法换出到磁盘中）。MMU 每次都需要访问 k 个 PTE 才能找到物理页框号 PPN 然后加上虚拟地址中的偏移量 VPO 从而生成一个物理地址。这里读者可能会对 MMU 每次都访问 k 个 PTE 表示性能上的担忧，此时就是 TLB 出场的时候了，计算机正是通过把每一级页表中的 PTE 缓存在 TLB 中从而让多级页表的性能不至于落后单页表太多。</p><h5 id="倒排页表"><strong>倒排页表</strong></h5><p>另一种针对页式虚拟内存管理大页表问题的解决方案是<strong>倒排页表</strong>（Inverted Page Table，简称 IPT）。倒排页表的原理和搜索引擎的倒排索引相似，都是通过反转映射过程来实现。</p><p>在搜索引擎中，有两个概念：文档 doc 和 关键词 keyword，我们的需求是通过 keyword 快速找到对应的 doc 列表，如果搜索引擎的存储结构是正向索引，也即是通过 doc 映射到其中包含的所有 keyword 列表，那么我们要找到某一个指定的 keyword 所对应的 doc 列表，那么便需要扫描索引库中的所有 doc，找到包含该 keyword 的 doc，再根据打分模型进行打分，排序后返回，这种设计无疑是低效的；所以我们需要反转一下正向索引从而得到倒排索引，也即通过 keyword 映射到所有包含它的 doc 列表，这样当我们查询包含某个指定 keyword 的 doc 列表时，只需要利用倒排索引就可以快速定位到对应的结果，然后还是根据打分模型进行排序返回。</p><p>上面的描述只是搜索引擎倒排索引的简化原理，实际的倒排索引设计是要复杂很多的，有兴趣的读者可以自行查找资料学习，这里就不再展开。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172519621.png" alt="image-20240618172519621"></p><p>回到虚拟内存的倒排页表，它正是采用了和倒排索引类似的思想，反转了映射过程：前面我们学习到的页表设计都是以虚拟地址页号 VPN 作为页表项 PTE 索引，映射到物理页框号 PPN，而在倒排页表中则是以 PPN 作为 PTE 索引，映射到 (进程号，虚拟页号 VPN)。</p><p>倒排页表在寻址空间更大的 CPU 架构下尤其高效，或者应该说更适合那些『虚拟内存空间/物理内存空间』比例非常大的场景，因为这种设计是以实际物理内存页框作为 PTE 索引，而不是以远超物理内存的虚拟内存作为索引。例如，以 64 位架构为例，如果是单页表结构，还是用 12 位作为页面地址偏移量，也就是 4KB 的内存页大小，那么以最理论化的方式来计算，则需要 2^52 个 PTE，每个 PTE 占 8 个字节，那么整个页表需要 32PB 的内存空间，这完全是不可接受的，而如果采用倒排页表，假定使用 4GB 的 RAM，则只需要 2^20 个 PTE，极大减少内存使用量。</p><p>倒排页表虽然在节省内存空间方面效果显著，但同时却引入了另一个重大的缺陷：地址翻译过程变得更加低效。我们都清楚 MMU 的工作就是要把虚拟内存地址翻译成物理内存地址，现在索引结构变了，物理页框号 PPN 作为索引，从原来的 VPN --&gt; PPN 变成了 PPN --&gt; VPN，那么当进程尝试访问一个虚拟内存地址之时，CPU 在通过地址总线把 VPN 发送到 MMU 之后，基于倒排页表的设计，MMU 并不知道这个 VPN 对应的是不是一个缺页，所以不得不扫描整个倒排页表来找到该 VPN，而最要命的是就算是一个非缺页的 VPN，每次内存访问还是需要执行这个全表扫描操作，假设是前面提到的 4GB RAM 的例子，那么相当于每次都要扫描 2^20 个 PTE，相当低效。</p><p>这时候又是我们的老朋友 – TLB 出场的时候了，我们只需要把高频使用的页面缓存在 TLB 中，借助于硬件，在 TLB 缓存命中的情况下虚拟内存地址的翻译过程就可以像普通页表那样快速，然而当 TLB 失效的时候，则还是需要通过软件的方式去扫描整个倒排页表，线性扫描的方式非常低效，因此一般倒排页表会基于哈希表来实现，假设有 1G 的物理内存，那么这里就一共有 2^18 个 4KB 大小的页框，建立一张以 PPN 作为 key 的哈希表，则可以划分成 2^18 个 4KB 大小的页框，假设 0 作为 PPN 的起点，则 [0, 2^18 - 1] 就是 PPN 的取值范围，以此作为 Hash map 的 key，然后实现一个哈希函数，使用 VPN 作为入参，使得哈希函数最后输出的哈希值落在 [0, 2^18 - 1] 区间内，每一个 key 值对应的 value 中存储的是 (VPN, PNN)，那么所有具有相同哈希值的 VPN 会被链接在一起形成一个冲突链，如果我们把哈希表的槽数设置成跟物理页框数量一致的话，那么这个倒排哈希表中的冲突链的平均长度将会是 1 个 PTE，可以大大提高查询速度。当 VPN 通过倒排页表匹配到 PPN 之后，这个 (VPN, PPN) 映射关系就会马上被缓存进 TLB，以加速下次虚拟地址翻译。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172533984.png" alt="image-20240618172533984"></p><p>倒排页表在 64 位架构的计算机中很常见，因为在 64 位架构下，基于分页的虚拟内存中即便把页面 Page 的大小从一般的 4KB 提升至 4MB，依然需要一个拥有 2^42 个 PTE 的巨型页表放在主存中（理论上，实际上不会这么实现），极大地消耗内存。</p><p>简单来说：</p><p>倒排页表是一种用于操作系统内存管理的技术，主要用于解决传统页表在处理大量内存时所需的过多内存空间问题。</p><p>在传统的页表系统中，操作系统为每个进程都维护一个页表，用于将进程的虚拟地址映射到物理地址。然而，随着内存大小的增长，这种方式需要的页表空间也会急剧增加，这在一些内存资源紧张的环境下，如嵌入式系统，是无法接受的。</p><p>倒排页表的思想是，<strong>不再为每个进程维护一个页表，而是只维护一个全局的页表。这个全局页表的每个条目不再是虚拟地址到物理地址的映射，而是物理地址到虚拟地址的映射，因此被称为“倒排”。</strong></p><p><strong>倒排页表中的每个条目，包含了物理地址、对应的虚拟地址、以及这个虚拟地址所属的进程ID。当一个进程需要访问内存时，操作系统会在倒排页表中查找，找到与进程ID和虚拟地址都匹配的条目，然后使用条目中的物理地址来访问内存。</strong></p><p>这种方式的优点是，表的大小与物理内存的大小成正比，而不是与虚拟内存的大小成正比，因此大大减小了页表所需的内存空间。然而，这也带来了一些缺点，比如查找页表的速度会比传统的页表慢，因为需要遍历整个倒排页表来找到匹配的条目。</p><h3 id="总结"><strong>总结</strong></h3><p>现在让我们来回顾一下本文的核心内容：虚拟内存是存在于计算机 CPU 和物理内存之间一个中间层，主要作用是高效管理内存并减少内存出错。虚拟内存的几个核心概念有：</p><ol><li><strong>页表</strong>：从数学角度来说页表就是一个函数，入参是虚拟页号 VPN，输出是物理页框号 PPN，也就是物理地址的基址。页表由页表项组成，页表项中保存了所有用来进行地址翻译所需的信息，页表是虚拟内存得以正常运作的基础，每一个虚拟地址要翻译成物理地址都需要借助它来完成。<strong>页表通常保存在计算机的内存中。每个进程都有它自己的页表，它是操作系统用来管理虚拟内存的一种重要数据结构。每个进程的页表都是独立的，用于将该进程的虚拟内存地址映射到物理内存地址。当进程需要访问内存时，它会提供一个虚拟内存地址，操作系统会通过查找该进程的页表，将虚拟内存地址转换为对应的物理内存地址，然后才能进行实际的内存访问。因此，可以说每个进程都有一个页表，这个页表存储在内存中，并由操作系统进行管理。这样做的好处是每个进程都有自己的独立地址空间，互不干扰，提高了系统的稳定性和安全性。</strong></li><li><strong>TLB</strong>：计算机硬件，主要用来解决引入虚拟内存之后寻址的性能问题，加速地址翻译。如果没有 TLB 来解决虚拟内存的性能问题，那么虚拟内存将只可能是一个学术上的理论而无法真正广泛地应用在计算机中。</li><li><strong>多级页表和倒排页表</strong>：用来解决虚拟地址空间爆炸性膨胀而导致的大页表问题，多级页表通过将单页表进行分拆并按需分配虚拟内存页而倒排页表则是通过反转映射关系来实现节省内存的效果。</li></ol><p>最后，虚拟内存技术中还需要涉及到操作系统的页面置换机制，由于页面置换机制也是一个较为庞杂和复杂的概念，本文便不再继续剖析这一部分的原理，我们在以后的文章中再单独拿来讲解。</p><p>原文作者：allanpan，腾讯 IEG 后台开发工程师</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g">https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g</a></p>]]></content>
    
    
    <summary type="html">深入剖析虚拟内存工作原理</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket协议</title>
    <link href="https://penge666.github.io/posts/5447b09e.html"/>
    <id>https://penge666.github.io/posts/5447b09e.html</id>
    <published>2024-06-18T02:20:28.000Z</published>
    <updated>2024-06-18T02:35:07.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言">0.前言</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102135047.png" alt="image-20240618102135047"></p><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p><p>WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。</p><h2 id="1-WebSocket简介">1.WebSocket简介</h2><p>webSocket是什么:</p><p>1、WebSocket是一种在单个TCP连接上进行全双工通信的协议</p><p>2、WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据</p><p>3、在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输</p><p>4、需要安装第三方包：cmd中：go get -u -v <a href="https://link.zhihu.com/?target=http%3A//github.com/gorilla/websocket">github.com/gorilla/websocket</a></p><p>WebSocket 是一种标准协议，用于在客户端和服务端之间进行双向数据传输。但它跟 HTTP 没什么关系，它是一种基于 TCP 的一种独立实现。</p><p>以前客户端想知道服务端的处理进度，要不停地使用 Ajax 进行轮询，让浏览器隔个几秒就向服务器发一次请求，这对服务器压力较高。另外一种轮询就是采用 long poll 的方式，这就跟打电话差不多，没收到消息就一直不挂电话，也就是说，客户端发起连接后，如果没消息，就一直不返回 Response 给客户端，连接阶段一直是阻塞的。</p><p>而 WebSocket 解决了 HTTP 的这几个难题。首先，当服务器完成协议升级后（ HTTP -&gt; WebSocket ），服务端可以主动推送信息给客户端，解决了轮询造成的同步延迟问题。由于 WebSocket 只需要一次 HTTP 握手，服务端就能一直与客户端保持通讯，直到关闭连接，这样就解决了服务器需要反复解析 HTTP 协议，减少了资源的开销。</p><p>WebSocket协议支持（在受控环境中运行不受信任的代码的）客户端与（选择加入该代码的通信的）远程主机之间进行全双工通信。用于此的安全模型是Web浏览器常用的基于原始的安全模式。 协议包括一个开放的握手以及随后的TCP层上的消息帧。 该技术的目标是为基于浏览器的、需要和服务器进行双向通信的（服务器不能依赖于打开多个HTTP连接（例如，使用XMLHttpRequest或和长轮询））应用程序提供一种通信机制。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102203194.png" alt="image-20240618102203194"></p><p>websocket 是一个基于应用层的网络协议，建立在tcp 协议之上，和 http 协议可以说是兄弟的关系，但是这个兄弟有点依赖 http ，为什么这么说呢？我们都知道 HTTP 实现了三次握手来建立通信连接，实际上 websocket 的创始人很聪明，他不想重复的去造轮子，反正我兄弟已经实现了握手了，我干嘛还要重写一套呢？先让它去冲锋陷阵呢，我坐收渔翁之利不是更香 吗，所以一般来说，我们会先用 HTTP 先进行三次握手，再向服务器请求升级为websocket 协议，这就好比说，嘿兄弟你先去给我排个队占个坑位建个小房子，到时候我在把这房子改造成摩天大楼。而且一般来说 80 和 443 端口一般 web 服务端都会外放出去，这样可以有效的避免防火墙的限制。当然，你创建的 websocket 服务端进程的端口也需要外放出去。</p><p>很多人会想问，web开发 使用 HTTP 协议不是已经差不多够用了吗？为什么还要我再多学一种呢？这不是搞事情嘛，仔细想想，一门新技术的产生必然有原因的，如果没有需求，我们干嘛那么蛋疼去写那么多东西，就是因为 HTTP 这个协议有些业务需求支持太过于鸡肋了，从 HTTP 0.9 到现在的 HTTP3.0 ，HTTP协议可以说说是在普通的web开发领域已经是十分完善且高效的了，说这个协议养活了全球半数的公司也不为过吧，像 2.0 服务器推送技术，3.0 采用了 UDP 而放弃了原来的 TCP ,这些改动都是为了进一步提升协议的性能，然而大家现在还是基本使用的 HTTP 1.1 这个最为经典的协议, 也是让开发者挺尴尬的。</p><p>绝大多数的web开发都是应用层开发者,大多数都是基于已有的应用层去开发应用，可以说我们最熟悉、日常打交道最多的就是应用层协议了，底下 TCP/IP 协议我们基本很少会去处理，当然大厂可能就不一样了，自己弄一套协议也是正常的，这大概也是程序员和码农的区别吧，搬砖还是创新，差别还是很大的。网络这种分层协议的好处我在之前的文章也说过了，这种隔离性很方便就可以让我们基于原来的基础去拓展，具有较好的兼容性。</p><p>总的来说，它就是一种依赖HTTP协议的，支持全双工通信的一种应用层网络协议。</p><h2 id="2-WebSocket产生背景">2.WebSocket产生背景</h2><p>简单的说，WebSocket协议之前，双工通信是通过多个http链接来实现，这导致了效率低下。WebSocket解决了这个问题。下面是标准RFC6455中的产生背景概述。</p><p>长久以来, 创建实现客户端和用户端之间双工通讯的web app都会造成HTTP轮询的滥用: 客户端向主机不断发送不同的HTTP呼叫来进行询问。</p><p><strong>这会导致一系列的问题：</strong></p><ul><li>1.服务器被迫为每个客户端使用许多不同的底层TCP连接：一个用于向客户端发送信息，其它用于接收每个传入消息。</li><li>2.有些协议有很高的开销，每一个客户端和服务器之间都有HTTP头。</li><li>3.客户端脚本被迫维护从传出连接到传入连接的映射来追踪回复。</li></ul><p>一个更简单的解决方案是使用单个TCP连接双向通信。 这就是WebSocket协议所提供的功能。 结合WebSocket API ，WebSocket协议提供了一个用来替代HTTP轮询实现网页到远程主机的双向通信的方法。</p><p>WebSocket协议被设计来取代用HTTP作为传输层的双向通讯技术,这些技术只能牺牲效率和可依赖性其中一方来提高另一方，因为HTTP最初的目的不是为了双向通讯。</p><h2 id="3-WebSocket实现原理">3.WebSocket实现原理</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102242067.png" alt="image-20240618102242067"></p><p>在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：</p><ol><li><p>Header：互相沟通的Header是很小的-大概只有 2 Bytes。</p></li><li><p>Server Push：服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。</p></li></ol><h2 id="4-WebSocket协议举例">4.WebSocket协议举例</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102254393.png" alt="image-20240618102254393"></p><p>浏览器请求:</p><ul><li>GET /webfin/websocket/ HTTP/1.1。</li><li>Host: localhost。</li><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==。</li><li>Origin: <a href="https://link.zhihu.com/?target=http%3A//xn--zfru1gfr6bz63i/">http://服务器地址</a>。</li><li>Sec-WebSocket-Version: 13。</li></ul><p>服务器回应:</p><ul><li>HTTP/1.1 101 Switching Protocols。</li><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=。</li><li>WebSocket借用http请求进行握手，相比正常的http请求，多了一些内容。其中：</li><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>表示希望将http协议升级到Websocket协议。Sec-WebSocket-Key是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。</li></ul><p>服务器返回:</p><ul><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>告诉浏览器即将升级的是Websocket协议</li></ul><p>Sec-WebSocket-Accept是将请求包“Sec-WebSocket-Key”的值，与”258EAFA5-E914-47DA-95CA-C5AB0DC85B11″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码得到的。用来说明自己是WebSocket助理服务器。</p><p>Sec-WebSocket-Version是WebSocket协议版本号。RFC6455要求使用的版本是13，之前草案的版本均应当被弃用。</p><h2 id="5-WebSocket使用">5.WebSocket使用</h2><h3 id="5-1-WebSocket-介绍">5.1 WebSocket 介绍</h3><p>WebSocket 发起单个请求，服务端不需要等待客服端，客户端在任何时候也能发消息到服务端，减少了轮询时候的延迟.经历一次连接后，服务器能给客户端发多次。下图是轮询与WebSocket的区别。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102307422.png" alt="image-20240618102307422"></p><p>基于http的实时消息是相当的复杂，在无状态的请求中维持回话的状态增加了复杂度，跨域也很麻烦，使用ajax处理请求有序请求需要考虑更多。通过ajax进行交流也不简单。每一个延伸http功能的目的不是增加他的复杂度。websocket 可以大大简化实时通信应用中的链接。</p><p>Websocket是一种底层网络协议，可以让你在这个基础上建立别的标准协议。比如在WebSocket的客户端的基础上使用XMPP登录不同的聊天服务器，因为所有的XMPP服务理解相同的标准协议。WebSocket是web应用的一种创新。</p><p>为了与其他平台竞争，WebSocket是H5应用提供的一部分先进功能。每个操作系统都需要网络功能，能够让应用使用Sockets与别的主机进行通信，是每个大平台的核心功能。在很多方面，让Web应用表现的像操作系统平台是html5的趋势。像socket这样底层的网络协议APIs不会符合原始的安全模型，也不会有web api那样的设计风格。WebSocket给H5应用提供TCP的方式不会消弱网络安全且有现代的Api。</p><p>WebSocket是Html5平台的一个重要组件也是开发者强有力的工具。简单的说，你需要WebSocket创建世界级的web应用。它弥补了http不适合实时通信的重大缺陷。异步、双向通信模式，通过传输层协议使WebSocket具有普遍灵活性。想象一下你能用WebSocket创建正真实实时应用的所有方式。比如聊天、协作文档编辑、大规模多人在线游戏（MMO）,股票交易应用等等。</p><p>WebSocket是一个协议，但也有一个WebSocket API，这让你的应用去控制WebSocket的协议去响应被服务端触发的事件。API是W3C开发，协议是IETE制定。现代浏览器支持WebSocket API，这包括使用全双工和双向链接的方法和特性。让你执行像打开关闭链接、发送接收消息、监听服务端事件等必要操作。</p><h3 id="5-2-WebSocket-API">5.2 WebSocket API</h3><p>WebSocket API其实就是一个使用WebSocket协议的接口，通过它来建立全双工通道来收发消息，简单易学，要连接远程服务器，只需要创建一个WebSocket对象实体，并传入一个服务端的URL。在客户端和服务端一开始握手的期间，http协议升级到WebSocket协议就建立了连接，底层都是TCP协议。一旦建立连接，通过WebSocket接口可以反复的发送消息。在你的代码里面，你可以使用异步事件监听连接生命周期的每个阶段。</p><p>WebSocket API是纯事件驱动，一旦建立全双工连接，当服务端给客户端发送数据或者资源，它能自动发送状态改变的数据和通知。所以你不需要为了状态的更新而去轮训Server，在客户端监听即可。</p><p>首先，我们需要通过调用WebSocket构造函数来创建一个WebSocket连接，构造函数会返回一个WebSocket实例，可以用来监听事件。这些事件会告诉你什么时候连接建立，什么时候消息到达，什么时候连接关闭了，以及什么时候发生了错误。WebSocket协议定义了两种URL方案，WS和WSS分别代表了客户端和服务端之间未加密和加密的通信。WS(WebSocket)类似于Http URL，而WSS（WebSocket Security）URL 表示连接是基于安全传输层（TLS/SSL）和https的连接是同样的安全机制。</p><p>WebSocket的构造函数需要一个URL参数和一个可选的协议参数（一个或者多个协议的名字），协议的参数例如XMPP（Extensible Messaging and Presence Protocol）、SOAP（Simple Object Access Protocol）或者自定义协议。而URL参数需要以WS://或者WSS://开头，例如：ws://<a href="https://link.zhihu.com/?target=http%3A//www.websocket.org">http://www.websocket.org</a>，如果URL有语法错误，构造函数会抛出异常。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create new WebSocket connection</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.websocket.org&quot;</span>);</span><br><span class="line"><span class="comment">//测试了下链接不上。</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102319312.png" alt="image-20240618102319312"></p><p>第二个参数是协议名称，是可选的，服务端和客服端使用的协议必须一致，这样收发消息彼此才能理解，你可以定义一个或多个客户端使用的协议，服务端会选择一个来使用，一个客服端和一个服务端之间只能有一个协议。当然都得基于WebSocket，WebSocket的重大好处之一就是基于WebSocket协议的广泛使用，让你的Web能够拥有传统桌面程序那样的能力。</p><p>言归正传，我们回到构造函数，在第一次握手之后，和协议的名称一起，客户端会发送一个Sec-WebSocket-Protocol 头，服务端会选择0个或一个协议，响应会带上同样的Sec-WebSocket-Protocol 头，否则会关闭连接。通过协议协商（Protocol negotiation ），我们可以知道给定的WebSocket服务器所支持的协议和版本，然后应用选择协议使用。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connecting to the server with one protocol called myProtocol</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="type">WebSocket</span>(<span class="string">&quot;ws://echo.websocket.org&quot;</span>, <span class="string">&quot;myProtocol&quot;</span>);</span><br><span class="line"><span class="comment">//myProtocol 是假设的一个定义好的且符合标准的协议。</span></span><br></pre></td></tr></table></figure><p>你可以传递一个协议的数组。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> echoSocket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org&quot;</span>, [<span class="string">&quot;com.kaazing.echo&quot;</span>,<span class="string">&quot;example.imaginary.protocol&quot;</span>])</span><br><span class="line"><span class="comment">//服务端会选择其中一个使用</span></span><br><span class="line">echoSocket.onopen = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="comment">// Check the protocol chosen by the server</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(echoSocket.protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：com.kaazing.ech</p><p>协议这个参数有三种。</p><p>1.注册协议：根据RFC6455（WebSocket 协议）和IANA被官方注册的标准协议。例如 微软的SOAP。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102325187.png" alt="image-20240618102325187"></p><p>看到两个华为的：</p><p>2.开放协议：被广泛使用的标注协议，例如XMPP和STOMP。但没有被正式注册。</p><p>3.自定义协议：自己编写和使用的WebSocket的协议。 协议会再后续章节给出详细介绍，下面先看事件、对象和方法以及实例。</p><h3 id="5-3-WebSocket事件">5.3 WebSocket事件</h3><p>WebSocket API是纯事件驱动，通过监听事件可以处理到来的数据和改变的链接状态。客户端不需要为了更新数据而轮训服务器。服务端发送数据后，消息和事件会异步到达。WebSocket编程遵循一个异步编程模型，只需要对WebSocket对象增加回调函数就可以监听事件。你也可以使用addEventListener()方法来监听。而一个WebSocket对象分四类不同事件。</p><h4 id="5-3-1-open">5.3.1 open</h4><p>一旦服务端响应WebSocket连接请求，就会触发open事件。响应的回调函数称为onopen。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Event handler for the WebSocket connection opening</span></span><br><span class="line">ws.onopen = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Connection open...&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>open事件触发的时候，意味着协议握手结束，WebSocket已经准备好收发数据。如果你的应用收到open事件，就可以确定服务端已经处理了建立连接的请求，且同意和你的应用通信。</p><h4 id="5-3-2-Message"><strong>5.3.2 Message</strong></h4><p>当消息被接受会触发消息事件，响应的回调函数叫做onmessage。如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受文本消息的事件处理实例：</span></span><br><span class="line">ws.onmessage = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeof</span> e.data === <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;String message received&quot;</span>, e, e.data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Other message received&quot;</span>, e, e.data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了文本消息，WebSocket消息机制还能处理二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置二进制数据类型为blob（默认类型）</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line"><span class="comment">// Event handler for receiving Blob messages</span></span><br><span class="line">ws.onmessage = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(e.data instanceof Blob)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Blob message received&quot;</span>, e.data);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(e.data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayBuffer</span></span><br><span class="line">ws.<span class="property">binaryType</span> = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">ArrayBuffer</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ArrayBuffer Message Received&quot;</span>, + e.<span class="property">data</span>);</span><br><span class="line"><span class="comment">// e.data即ArrayBuffer类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-3-3-Error">5.3.<strong>3 Error</strong></h4><p>如果发生意外的失败会触发error事件，相应的函数称为onerror,错误会导致连接关闭。如果你收到一个错误事件，那么你很快会收到一个关闭事件，在关闭事件中也许会告诉你错误的原因。而对错误事件的处理比较适合做重连的逻辑。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">ws.onerror = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;WebSocket Error: &quot;</span> , e);</span><br><span class="line"><span class="comment">//Custom function for handling errors</span></span><br><span class="line">handleErrors(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-3-4-Close"><strong>5.3.4 Close</strong></h4><p>不言而喻，当连接关闭的时候回触发这个事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再收发消息。</p><p>WebSocket的规范其实还定义了ping和pong 架构（frames），可以用来做keep-alive，心跳，网络状态查询，latency instrumentation（延迟仪表？），但是目前 WebSocket API还没有公布这些特性，尽管浏览器支持了ping，但不会触发ping事件，相反，浏览器会自动响应pong，第八章会将更多关于ping和pong的细节。</p><p>当然你可以调用close方法断开与服务端的链接来触发onclose事件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Connection closed&quot;</span>, e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>连接失败和成功的关闭握手都会触发关闭事件，WebSocket的对象的readyState属性就代表连接的状态（2代表正在关闭，3代表已经关闭）。关闭事件有三个属性可以用来做异常处理和重获： wasClean,code和reason。wasClean是一个bool值，代表连接是否干净的关闭。 如果是响应服务端的close事件，这个值为true，如果是别的原因，比如因为是底层TCP连接关闭，wasClean为false。code和reason代表关闭连接时服务端发送的状态，这两个属性和给入close方法的code和reason参数是对应的，稍后会描述细节。</p><h3 id="5-4-WebSocket-方法">5.4 WebSocket 方法</h3><p><strong>WebSocket 对象有两个方法：send()和close()。</strong></p><h4 id="5-4-1-send">5.4.1 send()</h4><p>一旦在服务端和客户端建立了全双工的双向连接，可以使用send方法去发送消息。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送一个文本消息</span></span><br><span class="line">ws.send(<span class="string">&quot;Hello WebSocket!&quot;</span>);</span><br></pre></td></tr></table></figure><p>当连接是open的时候send()方法传送数据，当连接关闭或获取不到的时候回抛出异常。一个通常的错误是人们喜欢在连接open之前发送消息。如下所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将不会工作</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="type">WebSocket</span>(<span class="string">&quot;ws://echo.websocket.org&quot;</span>)</span><br><span class="line">ws.send(<span class="string">&quot;Initial data&quot;</span>);</span><br></pre></td></tr></table></figure><p>正确的姿势如下，应该等待open事件触发后再发送消息。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">ws</span> = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org&quot;</span>)</span><br><span class="line"><span class="keyword">ws</span>.onopen = <span class="keyword">function</span>(<span class="keyword">e</span>) &#123;</span><br><span class="line"><span class="keyword">ws</span>.s</span><br></pre></td></tr></table></figure><p>如果想通过响应别的事件去发送消息，可以检查readyState属性的值为open的时候来实现。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">myEventHandler</span>(data) &#123;</span><br><span class="line">if (ws.readyState === WebSocket.OPEN) &#123;</span><br><span class="line"><span class="comment">//open的时候即可发送</span></span><br><span class="line">ws<span class="selector-class">.send</span>(data);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"><span class="comment">// Do something else in this case.</span></span><br><span class="line"><span class="comment">//Possibly ignore the data or enqueue it.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送二进制数据：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a Blob</span></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="type">Blob</span>(<span class="string">&quot;blob contents&quot;</span>);</span><br><span class="line">ws.send(blob);</span><br><span class="line"><span class="comment">// Send an ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="type">Uint8Array</span>([<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">9</span>]);</span><br><span class="line">ws.send(a.buffer);</span><br></pre></td></tr></table></figure><p>Blob对象和JavaScript File API一起使用的时候相当有用，可以发送或接受文件，大部分的多媒体文件，图像，视频和音频文件。这一章末尾会结合File API提供读取文件内容来发送WebSocket消息的实例代码。</p><h4 id="5-4-2-close"><strong>5.4.2 close()</strong></h4><p>使用close方法来关闭连接，如果连接以及关闭，这方法将什么也不做。调用close方法只后，将不能发送数据。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>close方法可以传入两个可选的参数，code（numerical）和reason（string）,以告诉服务端为什么终止连接。第三章讲到关闭握手的时候再详细讨论这两个参数。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功结束会话</span></span><br><span class="line">ws.<span class="keyword">close</span>(<span class="number">1000</span>, <span class="string">&quot;Closing normally&quot;</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment">//1000是状态码，代表正常结束。</span></span><br></pre></td></tr></table></figure><h3 id="5-5-WebSocket-属性">5.5 WebSocket 属性</h3><p>WebSocket对象有三个属性，readyState，bufferedAmount和Protocol。</p><h4 id="5-5-1-readyState"><strong>5.5.1 readyState</strong></h4><p>WebSocket对象通过只读属性readyState来传达连接状态，它会更加连接状态自动改变。下表展示了readyState属性的四个不同的值。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102337677.png" alt="image-20240618102337677"></p><p>了解当前连接的状态有助于我们调试。</p><h4 id="5-5-2-bufferedAmount"><strong>5.5.2 bufferedAmount</strong></h4><p>有时候需要检查传输数据的大小，尤其是客户端传输大量数据的时候。虽然send()方法会马上执行，但数据并不是马上传输。浏览器会缓存应用流出的数据，你可以使用bufferedAmount属性检查已经进入队列但还未被传输的数据大小。这个值不包含协议框架、操作系统缓存和网络软件的开销。</p><p>下面这个例子展示了如何使用bufferedAmount属性每秒更新发送。如果网络不能处理这个频率，它会自适应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10k</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">THRESHOLD</span> = <span class="number">10240</span>;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://echo.websocket.org&quot;</span>);</span><br><span class="line"><span class="comment">// Listen for the opening event</span></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">setInterval</span>( <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//缓存未满的时候发送</span></span><br><span class="line"><span class="keyword">if</span> (ws.<span class="property">bufferedAmount</span> &lt; <span class="variable constant_">THRESHOLD</span>) &#123;</span><br><span class="line">ws.<span class="title function_">send</span>(<span class="title function_">getApplicationState</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用bufferedAmount属性发送数据可以避免网络饱和。</span></span><br></pre></td></tr></table></figure><h4 id="5-5-3-protocol"><strong>5.5.3 protocol</strong></h4><p>在构造函数中，protocol参数让服务端知道客户端使用的WebSocket协议。而WebSocket对象的这个属性就是指的最终服务端确定下来的协议名称，当服务端没有选择客户端提供的协议或者在连接握手结束之前，这个属性都是空的。</p><p>完整实例：</p><p>现在我们已经过了一遍WebSocket的构造函数、事件、属性和方法，接下来通过一个完整的实例来学习WebSocket API。实例使用“Echo”服务器：ws://<a href="https://link.zhihu.com/?target=http%3A//echo.websocket.org">http://echo.websocket.org</a>，它能够接受和返回发过去的数据。这样有助于理解WebSocket API是如何和服务器交互的。</p><p>首先，我们先建立连接，让页面展示客户端连接服务端的信息，然后发送、接受消息，最后关闭连接。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Websocket Echo Client<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化连接和事件</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">            output = document.getElementById(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">            ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org/echo&quot;</span>);</span><br><span class="line">            <span class="comment">// 监听open</span></span><br><span class="line">            ws.onopen = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">                sendMessage(<span class="string">&quot;Hello WebSocket!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听close</span></span><br><span class="line">            ws.onclose = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Disconnected: &quot;</span> + e.reason);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听errors</span></span><br><span class="line">            ws.onerror = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Error &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听 messages </span></span><br><span class="line">            ws.onmessage = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Message received: &quot;</span> + e.data);</span><br><span class="line">                <span class="comment">//收到消息后关闭</span></span><br><span class="line">                ws.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">            ws.send(msg);</span><br><span class="line">            <span class="built_in">log</span>(<span class="string">&quot;Message sent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// logging</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">s</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> p = document.createElement(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">            p.style.wordWrap = <span class="string">&quot;break-word&quot;</span>;</span><br><span class="line">            p.textContent = s;</span><br><span class="line">            output.appendChild(p);</span><br><span class="line">            <span class="comment">// Also log information on the javascript console</span></span><br><span class="line">            <span class="built_in">console</span>.<span class="built_in">log</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Start </span></span><br><span class="line">        setup();</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102346962.png" alt="image-20240618102346962"></p><p>判断浏览器是否支持：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (window.WebSocket)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;This browser supports WebSocket!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;This browser does not support WebSocket.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102427323.png" alt="image-20240618102427323"></p><h2 id="6-WebSocket语言支持">6.WebSocket语言支持</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102445482.png" alt="image-20240618102445482"></p><ul><li>所有主流浏览器都支持RFC6455。但是具体的WebSocket版本有区别。</li><li>php jetty netty ruby Kaazing nginx python Tomcat Django erlang</li><li>WebSocket浏览器支持</li><li>WebSocket浏览器支持</li><li>netty .net等语言均可以用来实现支持WebSocket的服务器。</li><li>websocket api在浏览器端的广泛实现似乎只是一个时间问题了, 值得注意的是服务器端没有标准的api, 各个实现都有自己的一套api, 并且tcp也没有类似的提案, 所以使用websocket开发服务器端有一定的风险.可能会被锁定在某个平台上或者将来被迫升级。</li></ul><p>WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）。</p><ul><li>首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解：</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102450054.png" alt="image-20240618102450054"></p><ul><li>有交集，但是并不是全部。另外Html5是指的一系列新的API，或- 者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。</li><li>通俗来说，你可以用HTTP 协议 传输非Html 数据 ，就是这样=。=</li><li>再简单来说， 层级不一样 。</li></ul><h2 id="7-WebSocket通信">7.WebSocket通信</h2><h3 id="7-1-连接握手">7.1 连接握手</h3><p>连接握手分为两个步骤：请求和应答。WebSocket利用了HTTP协议来建立连接，使用的是HTTP的协议升级机制。</p><h4 id="7-1-1-请求">7.1.1 请求</h4><p>一个标准的HTTP请求，格式如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102455041.png" alt="image-20240618102455041"></p><p>请求头的具体格式定义参见**<a href="https://link.zhihu.com/?target=https%3A//link.csdn.net/%3Ftarget%3Dhttps%3A//www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">Request-Line格式</a>**。</p><p><strong>请求header中的字段解析:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102500391.png" alt="image-20240618102500391"></p><p>协议升级机制</p><p>Origin</p><p>所有浏览器将会发送一个 Origin请求头。 你可以将这个请求头用于安全方面（检查是否是同一个域，白名单/ 黑名单等），如果你不喜欢这个请求发起源，你可以发送一个403 Forbidden。需要注意的是非浏览器只能发送一个模拟的 Origin。大多数应用会拒绝不含这个请求头的请求。</p><p>Sec-WebSocket-Key</p><p>由客户端随机生成的，提供基本的防护，防止恶意或者无意的连接。</p><h4 id="7-1-2-应答">7.1.2 应答</h4><p><strong>返回字段解析：</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102505962.png" alt="image-20240618102505962"></p><p>Connection</p><p>可以参见 rfc7230 6.1 和 rfc7230 6.7。</p><p>Sec-WebSocket-Accept</p><p>它通过客户端发送的Sec-WebSocket-Key 计算出来。计算方法：</p><p>将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；</p><p>通过 SHA1 计算出摘要，并转成 base64 字符串。</p><p>Sec-WebSocket-Key / Sec-WebSocket-Accept 的主要作用还是为了避免一些网络通信过程中，一些非期待的数据包，”乱入“进来，导致一些错误的响应，并不能用于实现登录认证和数据安全，这些功能还需要应用层自己实现。</p><h3 id="7-2-数据传输（双工）">7.2 数据传输（双工）</h3><p>WebSocket 以 frame 为单位传输数据, frame 是客户端和服务端数据传输的最小单元。当一条消息过长时, 通信方可以将该消息拆分成多个 frame 发送, 接收方收到以后重新拼接、解码从而还原出完整的消息, 在 WebSocket 中, frame 有多种类型, frame 的类型由 frame 头部的 Opcode 字段指示, WebSocket frame 的结构如下所示:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102511307.png" alt="image-20240618102511307"></p><p>该结构的字段语义如下:</p><p>FIN, 长度为 1 比特, 该标志位用于指示当前的 frame 是消息的最后一个分段, 因为 WebSocket 支持将长消息切分为若干个 frame 发送, 切分以后, 除了最后一个 frame, 前面的 frame 的 FIN 字段都为 0, 最后一个 frame 的 FIN 字段为 1, 当然, 若消息没有分段, 那么一个 frame 便包含了完成的消息, 此时其 FIN 字段值为 1。</p><p>RSV 1 ~ 3, 这三个字段为保留字段, 只有在 WebSocket 扩展时用, 若不启用扩展, 则该三个字段应置为 1, 若接收方收到 RSV 1 ~ 3 不全为 0 的 frame, 并且双方没有协商使用 WebSocket 协议扩展, 则接收方应立即终止 WebSocket 连接。</p><p>Opcode, 长度为 4 比特, 该字段将指示 frame 的类型, RFC 6455 定义的 Opcode 共有如下几种:</p><ul><li>0x0, 代表当前是一个 continuation frame，既被切分的长消息的每个分片frame</li><li>0x1, 代表当前是一个 text frame</li><li>0x2, 代表当前是一个 binary frame</li><li>0x3 ~ 7, 目前保留, 以后将用作更多的非控制类 frame</li><li>0x8, 代表当前是一个 connection close, 用于关闭 WebSocket 连接</li><li>0x9, 代表当前是一个 ping frame</li><li>0xA, 代表当前是一个 pong frame</li><li>0xB ~ F, 目前保留, 以后将用作更多的控制类 frame</li></ul><ol><li>Mask, 长度为 1 比特, 该字段是一个标志位, 用于指示 frame 的数据 (Payload) 是否使用掩码掩盖, RFC 6455 规定当且仅当由客户端向服务端发送的 frame, 需要使用掩码覆盖, 掩码覆盖主要为了解决代理缓存污染攻击 (更多细节见 RFC 6455 Section 10.3)。</li><li>Payload Len, 以字节为单位指示 frame Payload 的长度, 该字段的长度可变, 可能为 7 比特, 也可能为 7 + 16 比特, 也可能为 7 + 64 比特. 具体来说, 当 Payload 的实际长度在 [0, 125] 时, 则 Payload Len 字段的长度为 7 比特, 它的值直接代表了 Payload 的实际长度; 当 Payload 的实际长度为 126 时, 则 Payload Len 后跟随的 16 位将被解释为 16-bit 的无符号整数, 该整数的值指示 Payload 的实际长度; 当 Payload 的实际长度为 127 时, 其后的 64 比特将被解释为 64-bit 的无符号整数, 该整数的值指示 Payload 的实际长度。</li><li>Masking-key, 该字段为可选字段, 当 Mask 标志位为 1 时, 代表这是一个掩码覆盖的 frame, 此时 Masking-key 字段存在, 其长度为 32 位, RFC 6455 规定所有由客户端发往服务端的 frame 都必须使用掩码覆盖, 即对于所有由客户端发往服务端的 frame, 该字段都必须存在, 该字段的值是由客户端使用熵值足够大的随机数发生器生成, 关于掩码覆盖, 将下面讨论, 若 Mask 标识位 0, 则 frame 中将设置该字段 (注意是不设置该字段, 而不仅仅是不给该字段赋值)。</li><li>Payload, 该字段的长度是任意的, 该字段即为 frame 的数据部分, 若通信双方协商使用了 WebSocket 扩展, 则该扩展数据 (Extension data) 也将存放在此处, 扩展数据 + 应用数据, 它们的长度和便为 Payload Len 字段指示的值。</li></ol><p>以下是一个客户端和服务端相互传递文本消息的示例</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102516687.png" alt="image-20240618102516687"></p><p><strong>其中模拟了长消息被切分为多个帧（continuation frame）的例子。</strong></p><h3 id="7-3-关闭请求">7.3 关闭请求</h3><p><strong>关闭相对简单，由客户端或服务端发送关闭帧，即可完成关闭。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102521173.png" alt="image-20240618102521173"></p><h2 id="8-WebSocket协议进一步理解">8.WebSocket协议进一步理解</h2><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p><h3 id="8-1-WebSocket是什么"><strong>8.1 WebSocket是什么</strong></h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。主流浏览器都已经支持。</p><p>WebSocket 是一种全新的协议。它将 TCP 的 Socket（套接字）应用在了网页上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工通信。</p><p>WebSocket 协议在2008年诞生，2011年成为国际标准。主流浏览器都已经支持。WebSocket 协议借用 HTTP协议 的 101 switch protocol 来达到协议转换，从HTTP协议切换WebSocket通信协议。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。</p><h3 id="8-2-WebSocket出现之前的实时技术">8.2 WebSocket出现之前的实时技术</h3><p>轮询：最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的通信。</p><p>长轮询：长轮询也采用轮询的方式，不过采取的是阻塞模型，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p><p>其他方式：如xhr-streaming、隐藏iframe、ActiveX控件、SSE。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102526317.png" alt="image-20240618102526317"></p><p>轮询技术非真正实时技术。使用 Ajax 方式模拟实时效果，每次客户端和服务器端交互，都是一次 HTTP 的请求和应答过程，且每次的 HTTP 请求和应答都带有完整 HTTP 头信息，增加传输的数据量。需构建两个http连接。客户端和服务器端编程实现比较复杂，为模拟真实的实时效果，需构造两个 HTTP 连接来模拟客户端和服务器的双向通信，一个连接用来处理客户端到服务器端的数据传输，一个连接用来处理服务器端到客户端的数据传输，增加了编程实现的复杂度、服务器端的负载，制约了应用系统的扩展性。</p><h3 id="8-3-WebSocket应用场景">8.3 WebSocket应用场景</h3><p>BS架构下的即时通讯、游戏等应用需要客户端与服务端间的双向通信，而HTTP的请求/响应模型并不适合这种场景。会存在一定的问题：</p><ul><li>服务器端被迫提供两类接口，一类提供给客户端轮询新消息，一类提供给客户端推送消息给服务器端。</li><li>HTTP协议有较多的额外开销，每次发送消息都会有一个HTTP header信息，而且如果不用Keep-Alive每次还都要握手。</li><li>客户端的脚本比如JS可能还需要跟踪整个过程，发送一个消息后，我可能需要跟踪这个消息的返回。</li></ul><p>Websocket出现使得浏览器提供socket的支持成为可能，从而在浏览器和服务器之间建立一条基于tcp的双向连接通道，web开发人员可以很方便的利用websocket构建实时web应用。<strong>WebSocket适用于以下场景:</strong></p><ul><li>在线聊天场景：例如qq聊天、淘宝与客服聊天、在线客服等等。这种场景都是需要实时的接收服务器推送的内容。</li><li>协同办公：例如腾讯在线文档，腾讯的在线文档是支持多人编辑的，在excel中，一旦有人修改就要立即同步给所有人。</li><li>直播弹幕：例如虎牙、斗鱼等各大直播平台，在直播时都是有弹幕的，遇到一些精彩片段时，往往会有弹幕刷屏。在这种情况下使用WebSocket会有一个更好的用户体验。</li><li>位置共享：例如微信里位置共享，这种场景需要用户实时的共享自己的位置给服务器，服务器收到位置信息后，要实时的推送给其它共享者的，实时性要求较高；百度地图导航系统，在自己位置到达某个地方之后，语音会立即播报前面道路情况，比如上高架、下地道、拐弯、直行、学校慢行等等。这种场景实时性特别高，汽车速度很快，延迟1秒钟，可能就错过了最佳提醒时机。</li><li>其他通过定义WebSocket子协议的扩展支持：例如sip、mqtt、xmpp、stomp等。</li></ul><h3 id="8-4-WebSocket协议栈">8.4 WebSocket协议栈</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102531782.png" alt="image-20240618102531782"></p><p>**WebSocket是基于TCP的应用层协议。**需要特别注意的是：虽然WebSocket协议在建立连接时会使用HTTP协议，但这并意味着WebSocket协议是基于HTTP协议实现的。</p><h3 id="8-5-WebSocket与HTTP的区别">8.5 WebSocket与HTTP的区别</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102537661.png" alt="image-20240618102537661"></p><ul><li>通信方式不同。WebSocket是双向通信模式，客户端与服务器之间只有在握手阶段是使用HTTP协议的“请求-响应”模式交互，而一旦连接建立之后的通信则使用双向模式交互，不论是客户端还是服务端都可以随时将数据发送给对方；而HTTP协议则至始至终都采用“请求-响应”模式进行通信。也正因为如此，HTTP协议的通信效率没有WebSocket高。</li><li>协议格式不同。HTTP协议的一个数据包就是一条完整的消息；而WebSocket客户端与服务端通信的最小单位是帧，由1个或多个帧组成一条完整的消息。即：发送端将消息切割成多个帧，并发送给服务端；服务端接收消息帧，并将关联的帧重新组装成完整的消息。</li></ul><h3 id="8-6-WebSocket握手过程">8.6 WebSocket握手过程</h3><p><strong>客户端到服务端:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102545826.png" alt="image-20240618102545826"></p><ul><li>GET ws://localhost…… HTTP/1.1 ：打开阶段握手，使用http1.1协议。</li><li>Upgrade：websocket，表示请求为特殊http请求，请求的目的是要将客户端和服务端的通信协议从http升级为websocket。</li><li>Sec-websocket-key：Base64 encode 的值，是浏览器随机生成的。客户端向服务端提供的握手信息。</li></ul><p><strong>服务端到客户端:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102551698.png" alt="image-20240618102551698"></p><ul><li>101状态码：表示切换协议。服务器根据客户端的请求切换到Websocket协议。</li><li>Sec-websocket-accept: 将请求头中的Set-websocket-key添加字符串并做SHA-1加密后做Base64编码，告知客户端服务器能够发起websocket连接。</li></ul><p><strong>客户端发起连接的约定:</strong></p><ul><li>如果请求为wss,则在TCP建立后，进行TLS连接建立。</li><li>请求的方式必须为GET，HTTP版本至少为HTTP1.1。</li><li>请求头中必须有Host。</li><li>请求头中必须有Upgrade，取值必须为websocket。</li><li>请求头中必须有Connection，取值必须为Upgrade。</li><li>请求头中必须有Sec-WebSocket-Key，取值为16字节随机数的Base64编码。</li><li>请求头中必须有Sec-WebSocket-Version，取值为13。</li><li>请求头中可选Sec-WebSocket-Protocol，取值为客户端期望的一个或多个子协议(多个以逗号分割)。</li><li>请求头中可选Sec-WebSocket-Extensitons，取值为子协议支持的扩展集(一般是压缩方式)。</li><li>可以包含cookie、Authorization等HTTP规范内合法的请求头。</li></ul><p><strong>客户端检查服务端的响应:</strong></p><ul><li>服务端返回状态码为101代表升级成功，否则判定连接失败。</li><li>响应头中缺少Upgrade或取值不是websocket，判定连接失败。</li><li>响应头中缺少Connection或取值不是Upgrade，判定连接失败。</li><li>响应头中缺少Sec-WebSocket-Accept或取值非法（其值为请求头中的Set-websocket-key添加字符串并做SHA-1加密后做Base64编码），判定连接失败。</li><li>响应头中有Sec-WebSocket-Extensions,但取值不是请求头中的子集，判定连接失败。</li><li>响应头中有Sec-WebSocket-Protocol,但取值不是请求头中的子集，判定连接失败。</li></ul><p><strong>服务端处理客户端连接:</strong></p><ul><li>服务端根据请求中的Sec-WebSocket-Protocol 字段，选择一个子协议返回，如果不返回，表示不同意请求的任何子协议。如果请求中未携带，也不返回。</li><li>如果建立连接成功，返回状态码为101。</li><li>响应头Connection设置为Upgrade。</li><li>响应头Upgrade设置为websocket。</li><li>Sec-WebSocket-Accpet根据请求头Set-websocket-key计算得到，计算方式为：Set-websocket-key的值添加字符串： 258EAFA5-E914-47DA-95CA-C5AB0DC85B11并做SHA-1加密后得到16进制表示的字符串，将每两位当作一个字节进行分隔，得到字节数组，对字节数组做Base64编码。</li></ul><h3 id="8-7-WebSocket帧格式">8.7 WebSocket帧格式</h3><p><strong>WebSocket通信流程如下:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102600446.png" alt="image-20240618102600446"></p><p><strong>Websocket帧格式如下:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102605562.png" alt="image-20240618102605562"></p><p><strong>第一部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102609366.png" alt="image-20240618102609366"></p><p>FIN：1位，用于描述消息是否结束，如果为1则该消息为消息尾部，如果为零则还有后续数据包。</p><p>RSV1,RSV2,RSV3：各1位，用于扩展定义，如果没有扩展约定的情况则必须为0。</p><p>OPCODE：4位，用于表示消息接收类型，如果接收到未知的opcode，接收端必须关闭连接。</p><p>OPCODE说明:</p><ul><li>0x0表示附加数据帧，当前数据帧为分片的数据帧。</li><li>0x1表示文本数据帧，采用UTF-8编码。</li><li>0x2表示二进制数据帧。</li><li>0x3-7暂时无定义，为以后的非控制帧保留。</li><li>0x8表示连接关闭。</li><li>0x9表示ping。</li><li>0xA表示pong。</li><li>0xB-F暂时无定义，为以后的控制帧保留。</li></ul><p><strong>第二部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102614081.png" alt="image-20240618102614081"></p><ul><li>MASK：1位，用于标识PayloadData是否经过掩码处理。服务端发送给客户端的数据帧不能使用掩码，客户端发送给服务端的数据帧必须使用掩码。如果一个帧的数据使用了掩码，那么在Maksing-key部分必须是一个32个bit位的掩码，用来给服务端解码数据。</li><li>Payload len：数据的长度：默认位7个bit位。如果数据的长度小于125个字节（注意：是字节）则用默认的7个bit来标示数据的长度。如果数据的长度为126个字节，则用后面相邻的2个字节来保存一个16bit位的无符号整数作为数据的长度。如果数据的长度大于126个字节，则用后面相邻的8个字节来保存一个64bit位的无符号整数作为数据的长度。</li><li>payload len本来是只能用7bit来表达的，也就是最多一个frame的payload只能有127个字节，为了表示更大的长度，给出的解决方案是添加扩展payload len字段。当payload实际长度超过126（包括），但在2^16-1长度内，则将payload len置为126，payload的实际长度由长为16bit的extended payload length来表达。当payload实际长度超过216（包括），但在264-1长度内，则将payload置为127，payload的实际长度由长为64bit的extended payload length来表达。</li></ul><p><strong>第三部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102620063.png" alt="img"></p><p>数据掩码：如果MASK设置位0，则该部分可以省略，如果MASK设置位1，则Masking-key是一个32位的掩码。用来解码客户端发送给服务端的数据帧。</p><p><strong>第四部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102625050.png" alt="image-20240618102625050"></p><p>数据：该部分，也是最后一部分，是帧真正要发送的数据，可以是任意长度。</p><h3 id="8-8-WebSocket分片传输">8.8 WebSocket分片传输</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102630470.png" alt="image-20240618102630470"></p><p>控制帧可能插在一个Message的多个分片之间，但一个Message的分片不能交替传输(除非有扩展特别定义)。</p><p>控制帧不可分片。</p><p>分片需要按照分送方提交顺序传递给接收方，但由于IP路由特性，实际并不能保证顺序到达。</p><p>控制帧包括:</p><ul><li>Close：用于关闭连接，可以携带数据，表示关闭原因。</li><li>Ping：可以携带数据。</li><li>Pong：用于Keep-alive，返回最近一次Ping中的数据，可以只发送Pong帧，做单向心跳。</li></ul><p>连接关闭时状态码说明:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102638253.png" alt="image-20240618102638253"></p><h3 id="8-9-WebSocket相关扩展">8.9 WebSocket相关扩展</h3><p>Stomp：</p><p>STOMP是基于帧的协议，它的前身是TTMP协议（一个简单的基于文本的协议），专为消息中间件设计。是属于消息队列的一种协议, 和AMQP, JMS平级。它的简单性恰巧可以用于定义websocket的消息体格式. STOMP协议很多MQ都已支持, 比如RabbitMq, ActiveMq。生产者（发送消息）、消息代理、消费者（订阅然后收到消息）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102644517.png" alt="image-20240618102644517"></p><p>\2. SockJs：</p><p>SockJS是一个浏览器JavaScript库，它提供了一个类似于网络的对象。SockJS提供了一个连贯的、跨浏览器的Javascript API，它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域通信通道。</p><p>SockJS的一大好处在于提供了浏览器兼容性。优先使用原生WebSocket，如果在不支持websocket的浏览器中，会自动降为轮询的方式。 除此之外，spring也对socketJS提供了支持。</p><p>\3. <a href="https://link.zhihu.com/?target=http%3A//Socket.io">Socket.io</a>：</p><p><a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>实际上是WebSocket的父集，<a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>封装了WebSocket和轮询等方法，会根据情况选择方法来进行通讯。</p><p><a href="https://link.zhihu.com/?target=http%3A//Sockei.io">http://Sockei.io</a>最早由Node.js实现，Node.js提供了高效的服务端运行环境，但由于Browser对HTML5的支持不一，为了兼容所有浏览器，提供实时的用户体验，并为开发者提供客户端与服务端一致的编程体验，于是<a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>诞生了。Java模仿Node.js实现了Java版的<a href="https://link.zhihu.com/?target=http%3A//Netty-socket.io">http://Netty-socket.io</a>库。</p><p><a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>将WebSocket和Polling机制以及其它的实时通信方式封装成通用的接口，并在服务端实现了这些实时机制相应代码，包括：AJAX Long Polling、Adobe Flash Socket、AJAX multipart streaming、Forever Iframem、JSONP Polling。</p><h2 id="9-WebSocket-能解决什么问题">9.WebSocket 能解决什么问题</h2><p>工程师应该是以解决问题为主的，如果不会解决问题，只会伸手，必然不会长远，有思考，才会有突破，才能高效的处理事情，所以 websocket 到底解决了什么问题呢？它存在的价值是什么？</p><p>这还是得从HTTP说起，大家应该都很熟悉这门协议，我们简单说一下它的特点：</p><p>•三次握手、四次挥手 的方式建立连接和关闭连接</p><p>•支持长连接和短连接两种连接方式</p><p>•有同源策略的限制（端口，协议，域名）</p><p>•单次 请求-响应 机制，只支持单向通信</p><p>其中最鸡肋的就是最后一个特点，单向通信，什么意思呐？ 就是说只能由一方发起请求（客户端），另一方响应请求（服务端），而且每一次的请求都是一个单独的事件，请求之间还无法具有关联性，也就是说我上个请求和下个请求完全是隔离的，无法具有连续性。</p><p>也许你觉得这样的说法比较难懂，我们来举一个栗子：</p><p>每个人都打过电话吧，电话打通后可以一直聊天是不是觉得很舒服啊，这是一种全双工的通信方式，双方都可以主动传递信息。彼此的聊天也具有连续性。我们简单把这种方式理解为 websocket 协议支持的方式。</p><p>如果打电话变成了 HTTP 那种方式呢？ 那就不叫打电话了，而是联通爸爸的智能语音助手了，我们知道客户端和服务端本身的身份并不是固定的，只要你可以发起通信，就可以充当客户端，能响应请求，就可以当做服务端，但是在HTTP的世界里一般来说，客户端（大多数情况下是浏览器）和服务器一般是固定的，我们打电话 去查话费，会询问要人工服务还是智能助手，如果选了助手，你只要问她问题，她就会找对应的答案来回答你（响应你），一般都是简单的业务，你不问她也不会跟你闲聊，主动才有故事啊！</p><p>但是实际上有很多的业务是需要双方都有主动性的，半双工的模式肯定是不够用的，例如聊天室，跟机器人聊天没意思啊，又例如主动推送，我无聊的时候手都不想点屏幕，你能不能主动一点给我推一些好玩的信息过来。</p><p>只要做过前后端分离的同学应该都被跨域的问题折磨过。浏览器的这种同源策略，会导致 不同端口/不同域名/不同协议 的请求会有限制，当然这问题前后端都能处理，然而 websocket 就没有这种要求，他支持任何域名或者端口的访问（协议固定了只能是 ws/wss) ,所以它让人用的更加舒服</p><p>所以，上面 HTTP 存在的这些问题，websocket 都能解决！！！</p><h2 id="10-WebSocket工作原理">10.WebSocket工作原理</h2><p>主动是 websocket 的一大特点，像之前如果客户端想知道服务端对某个事件的处理进度，就只能通过轮训( Poll )的方式去询问，十分的耗费资源，会存在十分多的无效请求。下面我简单说推送技术的三种模型区别：</p><ul><li>•pull (主动获取) 即客户端主动发起请求，获取消息</li><li>•poll (周期性主动获取) 即周期性的主动发起请求，获取消息</li><li>•push (主动推送) 服务端主动推送消息给客户端</li></ul><p>pull 和 poll 的唯一区别只在于周期性，但是很明显周期性的去询问，对业务来说清晰度很高，这也是为什么很多小公司都是基于轮训的方式去处理业务，因为简单嘛，能力不够机器来撑。这也是很多公司都会面临的问题，如果业务达到了瓶颈，使劲的堆机器，如果用新技术或者更高级的作法，开发成本和维护成本也会变高，还不如简单一点去增加机器配置。</p><p>如果两个人需要通话，首先需要建立一个连接，而且必须是一个长链接，大家都不希望讲几句话就得重新打吧，根据上面说的，websocket 会复用之前 HTTP 建立好的长链接，然后再进行升级，所以他和轮训的区别大致如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102652651.png" alt="image-20240618102652651"></p><p>图片省去了建立连接的过程，我们可以发现，基于轮训的方式，必须由客户端手动去请求，才会有响应，而基于 websocket 协议，不再需要你主动约妹子了，妹子也可以主动去约你，这才是公平的世界。</p><p>为了更好的阐述这个连接的原理，可以使用swoole 自带的 创建websocket 的功能进行测试，服务端代码如下，如果连接不上，可以看看是不是检查一下端口开放情况（iptables/filewall)和网络的连通性，代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>创建websocket服务器对象，监听<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9501</span>端口</span><br><span class="line"><span class="variable">$ws</span> = new Swoole\WebSocket\Server(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">9501</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>监听WebSocket连接打开事件</span><br><span class="line"><span class="variable">$ws</span>-&gt;on(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$ws</span>, <span class="variable">$request</span>) &#123;</span><br><span class="line">    var_dump(<span class="variable">$request</span>-&gt;fd, <span class="variable">$request</span>-&gt;get, <span class="variable">$request</span>-&gt;server); <span class="regexp">//</span>request 对象包含请求的相关信息</span><br><span class="line">    <span class="regexp">//</span><span class="variable">$ws</span>-&gt;push(<span class="variable">$request</span>-&gt;fd, <span class="string">&quot;hello, welcome\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>监听WebSocket消息事件</span><br><span class="line"><span class="variable">$ws</span>-&gt;on(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$ws</span>, <span class="variable">$frame</span>) &#123;  <span class="regexp">//</span> frame 是存储信息的变量，也就是传输帧</span><br><span class="line">    echo <span class="string">&quot;Message: &#123;$frame-&gt;data&#125;\n&quot;</span>;</span><br><span class="line">    <span class="variable">$ws</span>-&gt;push(<span class="variable">$frame</span>-&gt;fd, <span class="string">&quot;server: &#123;$frame-&gt;data&#125;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>监听WebSocket连接关闭事件</span><br><span class="line"><span class="variable">$ws</span>-&gt;on(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$ws</span>, <span class="variable">$fd</span>) &#123; <span class="regexp">//</span> fd 是客户端的标志</span><br><span class="line">    echo <span class="string">&quot;client-&#123;$fd&#125; is closed\n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$ws</span>-&gt;start(); <span class="regexp">//</span> 启动这个进程</span><br></pre></td></tr></table></figure><p>我们可以发现，相比于 HTTP 的头部，websocket 的数据结构十分的简单小巧，没有像 HTTP 协议一样老是带着笨重的头部，这一设计让websocket的报文可以在体量上更具优势，所以传输效率来说更高 。</p><p>当然，我们传输的文本也不能在大街上裸跑啊，既然 HTTP 都有衣服穿了（HTTPS），websocket（ws) 当然也有 （wss）。</p><p>在以前的文章我们也简单聊过 HTTPS 是个什么东西，大家不了解可以去翻一下之前的文章，总的来说就是使用了非对称加密算法进行了对称加密密钥的传输，后续采用对称加密解密的方式进行数据安全处理。</p><p>如果你的业务需要支撑双全工的通信，那么 websocket 便是一个很不错的选择。网上大多数关于 websocket 的文章，大多是基于前端学习者的角度，他们使用 Chrome 的console 的调试实验，本篇文章更多是基于后端开发者的角度。希望对你有所帮助。</p><h2 id="11-进一步解析什么是WebSocket协议">11.进一步解析什么是WebSocket协议</h2><h3 id="11-1websocket特点">11.1websocket特点</h3><p>1.websocket优点</p><ul><li>保持连接状态：websocket需要先创建连接，使其成为有状态的协议。</li><li>更好支持二进制：定义了二进制帧，增加安全性。</li><li>支持扩展：定义了扩展，可以自己实现部分部分自定义。</li><li>压缩效果好：可以沿用上下文的内容，有更好的压缩效果。</li></ul><p>2.websocket缺点</p><ul><li>开发要求高： 前端后端都增加了一定的难度。</li><li>推送消息相对复杂。</li><li>HTTP协议已经很成熟，现今websocket则太新了一点。</li></ul><h3 id="11-2websocket协议通信过程">11.2websocket协议通信过程</h3><p><strong>协议有两个部分：handshake（握手）和 data transfer（数据传输）。</strong></p><p>1.handshake</p><h4 id="11-2-1-客户端">11.2.1 客户端</h4><p>客户端握手报文是在HTTP的基础上发送一次HTTP协议升级请求。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure><p>Sec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或者无意的连接。</p><p>Sec-WebSocket-Version 表示 WebSocket 的版本，最初 WebSocket 协议太多，不同厂商都有自己的协议版本，不过现在已经定下来了。如果服务端不支持该版本，需要返回一个 Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</p><h4 id="11-2-2-服务端">11.2.2 服务端</h4><p>服务端响应握手也是在HTTP协议基础上回应一个Switching Protocols。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat</span><br></pre></td></tr></table></figure><p>Linux下对应实现代码，注释在代码中。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_handshake</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> sec_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sec_accept[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(linebuf));<span class="comment">//清空以暂存一行报文</span></span><br><span class="line">        index = <span class="built_in">readline</span>(ev-&gt;buffer, index, linebuf);<span class="comment">//获取一行报文</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;Sec-WebSocket-Key&quot;</span>))<span class="comment">//如果一行报文里面包括了Sec-WebSocket-Key</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(linebuf, GUID);<span class="comment">//和GUID连接起来</span></span><br><span class="line">            <span class="built_in">SHA1</span>(linebuf+WEBSOCK_KEY_LENGTH, <span class="built_in">strlen</span>(linebuf+WEBSOCK_KEY_LENGTH), sec_data);<span class="comment">//SHA1</span></span><br><span class="line">            <span class="built_in">base64_encode</span>(sec_data, <span class="built_in">strlen</span>(sec_data), sec_accept);<span class="comment">//base64编码</span></span><br><span class="line">            <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, MAX_BUFLEN);<span class="comment">//清空服务端数据缓冲区</span></span><br><span class="line"></span><br><span class="line">            ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer,<span class="comment">//组装握手响应报文到数据缓冲区，下一步有进行下发</span></span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Upgrade: websocket\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Connection: Upgrade\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Sec-websocket-Accept: %s\r\n\r\n&quot;</span>, sec_accept);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(index != <span class="number">-1</span> &amp;&amp; (ev-&gt;buffer[index] != <span class="string">&#x27;\r&#x27;</span>) || (ev-&gt;buffer[index] != <span class="string">&#x27;\n&#x27;</span>));<span class="comment">//遇到空行之前</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-2-3-data-transfer">11.2.3 data transfer</h4><p>先看数据包格式。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102700462.png" alt="image-20240618102700462"></p><p>FIN：指示这是消息中的最后一个片段。第一个片段也可能是最后的片段。</p><p>RSV1, RSV2, RSV3：一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。</p><p>opcode：操作代码。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">x0</span></span>：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x1</span></span>：表示这是一个文本帧（frame）；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x2</span></span>：表示这是一个二进制帧（frame）；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x3</span></span>-7：保留的操作代码，用于后续定义的非控制帧；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x8</span></span>：表示连接断开；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x9</span></span>：表示这是一个 ping 操作；</span><br><span class="line"><span class="tag">%<span class="selector-tag">xA</span></span>：表示这是一个 pong 操作；</span><br><span class="line"><span class="tag">%<span class="selector-tag">xB</span></span>-F：保留的操作代码，用于后续定义的控制帧。</span><br></pre></td></tr></table></figure><ul><li>mask：是否需要掩码。</li><li>Payload length: 7bit or 7 + 16bit or 7 + 64bit</li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 表示数据载荷的长度</span><br><span class="line"><span class="keyword">x</span> 为 <span class="number">0</span>~<span class="number">126</span>：数据的长度为 <span class="keyword">x</span> 字节；</span><br><span class="line"><span class="keyword">x</span> 为 <span class="number">126</span>：后续 <span class="number">2</span> 个字节代表一个 <span class="number">16</span> 位的无符号整数，该无符号整数的值为数据的长度；</span><br><span class="line"><span class="keyword">x</span> 为 <span class="number">127</span>：后续 <span class="number">8</span> 个字节代表一个 <span class="number">64</span> 位的无符号整数（最高位为 <span class="number">0</span>），该无符号整数的值为数据的长度。</span><br></pre></td></tr></table></figure><p>payload data：消息体。 下面是服务端的代码实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GUID            <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span></span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123; </span><br><span class="line">    WS_HANDSHAKE = <span class="number">0</span>,<span class="comment">//握手</span></span><br><span class="line">    WS_TANSMISSION = <span class="number">1</span>,<span class="comment">//通信</span></span><br><span class="line">    WS_END = <span class="number">2</span>,<span class="comment">//end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_ophdr</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> opcode:<span class="number">4</span>,</span><br><span class="line">    rsv3:<span class="number">1</span>,</span><br><span class="line">    rsv2:<span class="number">1</span>,</span><br><span class="line">    rsv1:<span class="number">1</span>,</span><br><span class="line">    fin:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pl_len:<span class="number">7</span>,</span><br><span class="line">    mask:<span class="number">1</span>;</span><br><span class="line">&#125;ws_ophdr;<span class="comment">//协议前两个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_head_126</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> payload_lenght;</span><br><span class="line">    <span class="type">char</span> mask_key[<span class="number">4</span>];</span><br><span class="line">&#125;ws_head_126;<span class="comment">//协议mask和消息体长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*解码*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">websocket_umask</span><span class="params">(<span class="type">char</span> *payload, <span class="type">int</span> length, <span class="type">char</span> *mask_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;length; i++)</span><br><span class="line">    payload[i] ^= mask_key[i%<span class="number">4</span>];<span class="comment">//异或</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_transmission</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ws_ophdr *ophdr = (ws_ophdr*)ev-&gt;buffer;<span class="comment">//协议前两个自己</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ws_recv_data length=%d\n&quot;</span>, ophdr-&gt;pl_len);</span><br><span class="line">    <span class="keyword">if</span>(ophdr-&gt;pl_len &lt;<span class="number">126</span>)<span class="comment">//如果消息体长度小于126</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * payload = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr) + <span class="number">4</span>;<span class="comment">//获取消息地址</span></span><br><span class="line">        <span class="keyword">if</span>(ophdr-&gt;mask)<span class="comment">//如果消息是掩码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">websocket_umask</span>(payload, ophdr-&gt;pl_len, ev-&gt;buffer+<span class="number">2</span>);<span class="comment">//解码，异或</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;payload:%s\n&quot;</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;payload : %s\n&quot;</span>, payload);<span class="comment">//消息回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;pl_len == <span class="number">126</span>) &#123;</span><br><span class="line">ws_head_126 *hdr126 = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ws_head_127 *hdr127 = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status_machine == WS_HANDSHAKE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">websocket_handshake</span>(ev);<span class="comment">//握手</span></span><br><span class="line">        ev-&gt;status_machine = WS_TANSMISSION;<span class="comment">//设置标志位</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status_machine == WS_TANSMISSION)&#123;</span><br><span class="line">        <span class="built_in">websocket_transmission</span>(ev);<span class="comment">//通信</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码是基于reactor百万并发服务器框架实现的。</strong></p><h3 id="11-3-epoll反应堆模型下实现http协议">11.3.epoll反应堆模型下实现http协议</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102724950.png" alt="image-20240618102724950"></p><p>1.客户端结构体</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//clientfd</span></span><br><span class="line">    <span class="type">int</span> events;<span class="comment">//事件：读、写或异常</span></span><br><span class="line">    <span class="type">int</span> status;<span class="comment">//是否位于epfd红黑监听树上</span></span><br><span class="line">    <span class="type">void</span> *arg;<span class="comment">//参数</span></span><br><span class="line">    <span class="type">long</span> last_active;<span class="comment">//上次数据收发的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);<span class="comment">//回调函数，单回调，后面修改成多回调</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];<span class="comment">//数据缓冲区</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//数据长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*http param*/</span></span><br><span class="line">    <span class="type">int</span> method;<span class="comment">//http协议请求头部</span></span><br><span class="line">    <span class="type">char</span> resource[MAX_BUFLEN];<span class="comment">//请求的资源</span></span><br><span class="line">    <span class="type">int</span> ret_code;<span class="comment">//响应状态码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http%3A//2.int">2.int</a> http_response(struct qsevent *ev)</p><p>当客户端发送tcp连接时，服务端的listenfd会触发输入事件会调用ev-&gt;callback即accept_cb回调函数响应连接并获得clientfd，连接之后，http数据报文发送上来，服务端的clientfd触发输入事件会调用ev-&gt;callback即recv_cb回调函数进行数据接收，并解析http报文。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//用于从buffer中获取每一行的请求报文</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">readline</span>(ev-&gt;buffer, <span class="number">0</span>, linebuf);<span class="comment">//读取第一行请求方法，readline函数，后面介绍</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;GET&quot;</span>))<span class="comment">//strstr判断是否存在GET请求方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;method = HTTP_METHOD_GET;<span class="comment">//GET方法表示客户端需要获取资源</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] != <span class="string">&#x27; &#x27;</span>)i++;<span class="comment">//跳过空格</span></span><br><span class="line">        linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(ev-&gt;resource, <span class="string">&quot;./%s/%s&quot;</span>, HTTP_METHOD_ROOT, linebuf+<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>));<span class="comment">//将资源的名字以文件路径形式存储在ev-&gt;resource中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;resource:%s\n&quot;</span>, ev-&gt;resource);<span class="comment">//回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;POST&quot;</span>))<span class="comment">//POST的请求方法，暂时没写，方法差不多</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http%3A//3.int">http://3.int</a> http_response(struct qsevent *ev)</p><p>服务器对客户端的响应报文数据进行http封装储存在buffer中，事件触发时在send_cb回调函数发送给客户端。详细解释请看代码注释。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">http_response</span>(<span class="params">struct</span> <span class="params">qsevent</span> *<span class="params">ev</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">ev</span> <span class="operator">==</span> <span class="variable">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="title function_">memset</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>, <span class="number">0</span>, <span class="variable">MAX_BUFLEN</span>);<span class="comment">//清空缓冲区准备储存报文</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;resource:%s<span class="char escape_">\n</span>&quot;</span>, <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">resource</span>);<span class="comment">//resource：客户端请求的资源文件，通过http_reques函数获取</span></span><br><span class="line">    int <span class="variable">filefd</span> <span class="operator">=</span> <span class="title function_">open</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">resource</span>, <span class="variable">O_RDONLY</span>);<span class="comment">//只读方式打开获得文件句柄</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">filefd</span> <span class="operator">==</span> <span class="number">-1</span>)<span class="comment">//获取失败则发送404 NOT FOUND</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">ret_code</span> <span class="operator">=</span> <span class="number">404</span>;<span class="comment">//404状态码</span></span><br><span class="line">        <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">length</span> <span class="operator">=</span> <span class="title function_">sprintf</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>,<span class="comment">//将下面数据传入ev-&gt;buffer</span></span><br><span class="line">         <span class="comment">/***状态行***/</span></span><br><span class="line">         <span class="comment">/*版本号 状态码 状态码描述 */</span></span><br><span class="line">                             <span class="string">&quot;HTTP/1.1 404 NOT FOUND<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/***消息报头***/</span></span><br><span class="line">                             <span class="comment">/*获取当前时间*/</span></span><br><span class="line">                             <span class="string">&quot;date: Thu, 11 Nov 2021 12:28:52 GMT<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/*响应正文类型；              编码方式*/</span></span><br><span class="line">                             <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/*响应正文长度          空行*/</span></span><br><span class="line">                             <span class="string">&quot;Content-Length: 85<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/***响应正文***/</span></span><br><span class="line">                             <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">struct</span> <span class="variable">stat</span> <span class="variable">stat_buf</span>;<span class="comment">//文件信息</span></span><br><span class="line">        <span class="title function_">fstat</span>(<span class="variable">filefd</span>, <span class="operator">&amp;</span><span class="variable">stat_buf</span>);<span class="comment">//fstat通过文件句柄获取文件信息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">S_ISDIR</span>(<span class="variable">stat_buf</span>.<span class="property">st_mode</span>))<span class="comment">//如果文件是一个目录</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">printf</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>, <span class="comment">//同上，将404放入buffer中</span></span><br><span class="line">                   <span class="string">&quot;HTTP/1.1 404 Not Found<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Length: 85<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span> );</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">S_ISREG</span>(<span class="variable">stat_buf</span>.<span class="property">st_mode</span>)) <span class="comment">//如果文件是存在</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">ret_code</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">//200状态码</span></span><br><span class="line"></span><br><span class="line">            <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">length</span> <span class="operator">=</span> <span class="title function_">sprintf</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>, <span class="comment">//length记录长度，buffer储存响应报文</span></span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 200 OK<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Length: %ld<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>, </span><br><span class="line">                                 <span class="variable">stat_buf</span>.<span class="property">st_size</span> );<span class="comment">//文件长度储存在stat_buf.st_size中</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">length</span>;<span class="comment">//返回报文长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.总代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_METHOD_ROOT    <span class="string">&quot;html&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFLEN          4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLLSIZE       1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS    1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_METHOD_GET     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_METHOD_POST    1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*NCALLBACK)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> events;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> last_active;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*http param*/</span></span><br><span class="line">    <span class="type">int</span> method;</span><br><span class="line">    <span class="type">char</span> resource[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> ret_code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qseventblock</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *eventsarrry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsreactor</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="type">int</span> blkcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *evblk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readline</span><span class="params">(<span class="type">char</span> *allbuf, <span class="type">int</span> idx, <span class="type">char</span> *linebuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(allbuf);    </span><br><span class="line">    <span class="keyword">for</span>( ; idx&lt;len; idx++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(allbuf[idx] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; allbuf[idx+<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> idx+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        *(linebuf++) = allbuf[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs_event_set</span><span class="params">(<span class="keyword">struct</span> qsevent *ev, <span class="type">int</span> fd, NCALLBACK callback, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_add</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> events, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    epv.events = ev-&gt;events = events;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_MOD error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_ADD error\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_del</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_DEL error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock</span><span class="params">(<span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(fd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listener[%d] lstening..\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">readline</span>(ev-&gt;buffer, <span class="number">0</span>, linebuf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;method = HTTP_METHOD_GET;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] != <span class="string">&#x27; &#x27;</span>)i++;</span><br><span class="line">        linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(ev-&gt;resource, <span class="string">&quot;./%s/%s&quot;</span>, HTTP_METHOD_ROOT, linebuf+<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;resource:%s\n&quot;</span>, ev-&gt;resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_response</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, MAX_BUFLEN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;resource:%s\n&quot;</span>, ev-&gt;resource);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> filefd = <span class="built_in">open</span>(ev-&gt;resource, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(filefd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;ret_code = <span class="number">404</span>;</span><br><span class="line">        ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer,</span><br><span class="line">                             <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;date: Thu, 11 Nov 2021 12:28:52 GMT\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;Content-Length: 85\r\n\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;\r\n\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> stat stat_buf;</span><br><span class="line">        <span class="built_in">fstat</span>(filefd, &amp;stat_buf);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(stat_buf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(ev-&gt;buffer, </span><br><span class="line">                   <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Length: 85\r\n\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;\r\n\r\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISREG</span>(stat_buf.st_mode)) </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ev-&gt;ret_code = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">            ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer, </span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Length: %ld\r\n\r\n&quot;</span>, </span><br><span class="line">                                 stat_buf.st_size );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ev-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_init</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(reactor, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *block = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;blockinit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *evs = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(MAX_EPOLLSIZE * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent));</span><br><span class="line">    <span class="keyword">if</span>(evs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;evsnit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="built_in">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    block-&gt;eventsarrry = evs;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;blkcnt = <span class="number">1</span>;</span><br><span class="line">    reactor-&gt;evblk = block;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_alloc</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *tailblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(tailblock-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    tailblock = tailblock-&gt;next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *newblock = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(newblock == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newblock alloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newblock, <span class="number">0</span>, <span class="built_in">sizeof</span>(newblock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *neweventarray = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent) * MAX_EPOLLSIZE);</span><br><span class="line">    <span class="keyword">if</span>(neweventarray == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;neweventarray malloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(neweventarray, <span class="number">0</span>, <span class="built_in">sizeof</span>(neweventarray));</span><br><span class="line"></span><br><span class="line">    newblock-&gt;eventsarrry = neweventarray;</span><br><span class="line">    newblock-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tailblock-&gt;next = newblock;</span><br><span class="line">    reactor-&gt;blkcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = sockfd / MAX_EPOLLSIZE;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= reactor-&gt;blkcnt)<span class="built_in">qsreactor_alloc</span>(reactor);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *idxblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;index &amp;&amp; idxblock != <span class="literal">NULL</span>)</span><br><span class="line">    idxblock = idxblock-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;idxblock-&gt;eventsarrry[sockfd%MAX_EPOLLSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_destory</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    <span class="built_in">free</span>(reactor-&gt;evblk);</span><br><span class="line">    reactor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_addlistener</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd, NCALLBACK acceptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, sockfd);</span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, sockfd, acceptor, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span>   *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">http_response</span>(ev);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, ev-&gt;buffer, ev-&gt;length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clent[%d] &quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ev-&gt;ret_code == <span class="number">200</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> filefd = <span class="built_in">open</span>(ev-&gt;resource, O_RDONLY);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">stat</span> stat_buf;</span><br><span class="line">            <span class="built_in">fstat</span>(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sendfile</span>(fd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);</span><br><span class="line">            <span class="built_in">close</span>(filefd);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, recv_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">recv</span>(fd, ev-&gt;buffer, MAX_BUFLEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;length = len;</span><br><span class="line">        ev-&gt;buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">http_request</span>(ev);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, send_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] close\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;reacv error,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((flag = <span class="built_in">fcntl</span>(clientfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl noblock error, %d\n&quot;</span>,MAX_BUFLEN);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, clientfd, recv_cb, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d], pos[%d]\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), <span class="built_in">ntohs</span>(client_addr.sin_port), clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_run</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EPOLL_EVENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = (<span class="keyword">struct</span> qsevent*)events[i].data.ptr;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">sock</span>(port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    <span class="built_in">qsreactor_init</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_addlistener</span>(reactor, sockfd, accept_cb);</span><br><span class="line">    <span class="built_in">qsreactor_run</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_destory</span>(reactor);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.epoll反应堆模型下实现websocket协议</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFLEN          4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLLSIZE       1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS    1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GUID            <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123; </span><br><span class="line">    WS_HANDSHAKE = <span class="number">0</span>,</span><br><span class="line">    WS_TANSMISSION = <span class="number">1</span>,</span><br><span class="line">    WS_END = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_ophdr</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> opcode:<span class="number">4</span>,</span><br><span class="line">    rsv3:<span class="number">1</span>,</span><br><span class="line">    rsv2:<span class="number">1</span>,</span><br><span class="line">    rsv1:<span class="number">1</span>,</span><br><span class="line">    fin:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pl_len:<span class="number">7</span>,</span><br><span class="line">    mask:<span class="number">1</span>;</span><br><span class="line">&#125;ws_ophdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_head_126</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> payload_lenght;</span><br><span class="line">    <span class="type">char</span> mask_key[<span class="number">4</span>];</span><br><span class="line">&#125;ws_head_126;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_head_127</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> payload_lenght;</span><br><span class="line">    <span class="type">char</span> mask_key[<span class="number">4</span>];</span><br><span class="line">&#125;ws_head_127;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*NCALLBACK)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> events;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> last_active;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*websocket param*/</span></span><br><span class="line">    <span class="type">int</span> status_machine;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qseventblock</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *eventsarrry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsreactor</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="type">int</span> blkcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *evblk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readline</span><span class="params">(<span class="type">char</span> *allbuf, <span class="type">int</span> idx, <span class="type">char</span> *linebuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(allbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;idx &lt; len;idx ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allbuf[idx] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; allbuf[idx+<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> idx+<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *(linebuf++) = allbuf[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">base64_encode</span><span class="params">(<span class="type">char</span> *in_str, <span class="type">int</span> in_len, <span class="type">char</span> *out_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    BIO *b64, *bio;    </span><br><span class="line">    BUF_MEM *bptr = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_str == <span class="literal">NULL</span> || out_str == <span class="literal">NULL</span>)        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">    b64 = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_f_base64</span>());    </span><br><span class="line">    bio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());    </span><br><span class="line">    bio = <span class="built_in">BIO_push</span>(b64, bio);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_write</span>(bio, in_str, in_len);    </span><br><span class="line">    <span class="built_in">BIO_flush</span>(bio);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_get_mem_ptr</span>(bio, &amp;bptr);    </span><br><span class="line">    <span class="built_in">memcpy</span>(out_str, bptr-&gt;data, bptr-&gt;length);    </span><br><span class="line">    out_str[bptr-&gt;length<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;    </span><br><span class="line">    size = bptr-&gt;length;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_free_all</span>(bio);    </span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCK_KEY_LENGTH  19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_handshake</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> sec_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sec_accept[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(linebuf));</span><br><span class="line">        index = <span class="built_in">readline</span>(ev-&gt;buffer, index, linebuf);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;Sec-WebSocket-Key&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(linebuf, GUID);</span><br><span class="line">            <span class="built_in">SHA1</span>(linebuf+WEBSOCK_KEY_LENGTH, <span class="built_in">strlen</span>(linebuf+WEBSOCK_KEY_LENGTH), sec_data);</span><br><span class="line">            <span class="built_in">base64_encode</span>(sec_data, <span class="built_in">strlen</span>(sec_data), sec_accept);</span><br><span class="line">            <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, MAX_BUFLEN);</span><br><span class="line"></span><br><span class="line">            ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer,</span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Upgrade: websocket\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Connection: Upgrade\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Sec-websocket-Accept: %s\r\n\r\n&quot;</span>, sec_accept);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(index != <span class="number">-1</span> &amp;&amp; (ev-&gt;buffer[index] != <span class="string">&#x27;\r&#x27;</span>) || (ev-&gt;buffer[index] != <span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">websocket_umask</span><span class="params">(<span class="type">char</span> *payload, <span class="type">int</span> length, <span class="type">char</span> *mask_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;length; i++)</span><br><span class="line">    payload[i] ^= mask_key[i%<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_transmission</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ws_ophdr *ophdr = (ws_ophdr*)ev-&gt;buffer;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ws_recv_data length=%d\n&quot;</span>, ophdr-&gt;pl_len);</span><br><span class="line">    <span class="keyword">if</span>(ophdr-&gt;pl_len &lt;<span class="number">126</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * payload = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr) + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(ophdr-&gt;mask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">websocket_umask</span>(payload, ophdr-&gt;pl_len, ev-&gt;buffer+<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;payload:%s\n&quot;</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, ev-&gt;length);</span><br><span class="line">        <span class="built_in">strcpy</span>(ev-&gt;buffer, <span class="string">&quot;00ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status_machine == WS_HANDSHAKE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">websocket_handshake</span>(ev);</span><br><span class="line">        ev-&gt;status_machine = WS_TANSMISSION;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status_machine == WS_TANSMISSION)&#123;</span><br><span class="line">        <span class="built_in">websocket_transmission</span>(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs_event_set</span><span class="params">(<span class="keyword">struct</span> qsevent *ev, <span class="type">int</span> fd, NCALLBACK callback, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_add</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> events, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    epv.events = ev-&gt;events = events;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_MOD error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_ADD error\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_del</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_DEL error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock</span><span class="params">(<span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(fd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listener[%d] lstening..\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_init</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(reactor, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *block = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;blockinit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *evs = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(MAX_EPOLLSIZE * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent));</span><br><span class="line">    <span class="keyword">if</span>(evs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;evsnit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="built_in">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    block-&gt;eventsarrry = evs;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;blkcnt = <span class="number">1</span>;</span><br><span class="line">    reactor-&gt;evblk = block;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_alloc</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *tailblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(tailblock-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    tailblock = tailblock-&gt;next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *newblock = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(newblock == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newblock alloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newblock, <span class="number">0</span>, <span class="built_in">sizeof</span>(newblock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *neweventarray = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent) * MAX_EPOLLSIZE);</span><br><span class="line">    <span class="keyword">if</span>(neweventarray == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;neweventarray malloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(neweventarray, <span class="number">0</span>, <span class="built_in">sizeof</span>(neweventarray));</span><br><span class="line"></span><br><span class="line">    newblock-&gt;eventsarrry = neweventarray;</span><br><span class="line">    newblock-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tailblock-&gt;next = newblock;</span><br><span class="line">    reactor-&gt;blkcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = sockfd / MAX_EPOLLSIZE;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= reactor-&gt;blkcnt)<span class="built_in">qsreactor_alloc</span>(reactor);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *idxblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;index &amp;&amp; idxblock != <span class="literal">NULL</span>)</span><br><span class="line">    idxblock = idxblock-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;idxblock-&gt;eventsarrry[sockfd%MAX_EPOLLSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_destory</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    <span class="built_in">free</span>(reactor-&gt;evblk);</span><br><span class="line">    reactor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_addlistener</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd, NCALLBACK acceptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, sockfd);</span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, sockfd, acceptor, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span>   *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, ev-&gt;buffer, ev-&gt;length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clent[%d] &quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to client[%d]:\n%s\n&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, recv_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">recv</span>(fd, ev-&gt;buffer, MAX_BUFLEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;length = len;</span><br><span class="line">        ev-&gt;buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]:\n%s\n&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">websocket_request</span>(ev);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, send_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] close\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;reacv error,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((flag = <span class="built_in">fcntl</span>(clientfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl noblock error, %d\n&quot;</span>,MAX_BUFLEN);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, clientfd);</span><br><span class="line"></span><br><span class="line">    event-&gt;status_machine = WS_HANDSHAKE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, clientfd, recv_cb, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d], pos[%d]\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), <span class="built_in">ntohs</span>(client_addr.sin_port), clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_run</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EPOLL_EVENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = (<span class="keyword">struct</span> qsevent*)events[i].data.ptr;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">sock</span>(port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    <span class="built_in">qsreactor_init</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_addlistener</span>(reactor, sockfd, accept_cb);</span><br><span class="line">    <span class="built_in">qsreactor_run</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_destory</span>(reactor);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.C1000K reactor模型，epoll实现，连接并回发一段数据，测试正常</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFLEN          4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLLSIZE       1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS    1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*NCALLBACK)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> events;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> last_active;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qseventblock</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *eventsarrry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsreactor</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="type">int</span> blkcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *evblk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs_event_set</span><span class="params">(<span class="keyword">struct</span> qsevent *ev, <span class="type">int</span> fd, NCALLBACK callback, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_add</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> events, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    epv.events = ev-&gt;events = events;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_MOD error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_ADD error\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_del</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_DEL error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock</span><span class="params">(<span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(fd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listener[%d] lstening..\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_init</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(reactor, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *block = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;blockinit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *evs = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(MAX_EPOLLSIZE * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent));</span><br><span class="line">    <span class="keyword">if</span>(evs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;evsnit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="built_in">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    block-&gt;eventsarrry = evs;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;blkcnt = <span class="number">1</span>;</span><br><span class="line">    reactor-&gt;evblk = block;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_alloc</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *tailblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(tailblock-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    tailblock = tailblock-&gt;next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *newblock = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(newblock == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newblock alloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newblock, <span class="number">0</span>, <span class="built_in">sizeof</span>(newblock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *neweventarray = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent) * MAX_EPOLLSIZE);</span><br><span class="line">    <span class="keyword">if</span>(neweventarray == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;neweventarray malloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(neweventarray, <span class="number">0</span>, <span class="built_in">sizeof</span>(neweventarray));</span><br><span class="line"></span><br><span class="line">    newblock-&gt;eventsarrry = neweventarray;</span><br><span class="line">    newblock-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tailblock-&gt;next = newblock;</span><br><span class="line">    reactor-&gt;blkcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = sockfd / MAX_EPOLLSIZE;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= reactor-&gt;blkcnt)<span class="built_in">qsreactor_alloc</span>(reactor);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *idxblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;index &amp;&amp; idxblock != <span class="literal">NULL</span>)</span><br><span class="line">        idxblock = idxblock-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;idxblock-&gt;eventsarrry[sockfd%MAX_EPOLLSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_destory</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    <span class="built_in">free</span>(reactor-&gt;evblk);</span><br><span class="line">    reactor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_addlistener</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd, NCALLBACK acceptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, sockfd);</span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, sockfd, acceptor, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span>   *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, ev-&gt;buffer, ev-&gt;length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clent[%d] &quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, recv_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">recv</span>(fd, ev-&gt;buffer, MAX_BUFLEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;length = len;</span><br><span class="line">        ev-&gt;buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, send_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] close\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;reacv error,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((flag = <span class="built_in">fcntl</span>(clientfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl noblock error, %d\n&quot;</span>,MAX_BUFLEN);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, clientfd, recv_cb, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d], pos[%d]\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), <span class="built_in">ntohs</span>(client_addr.sin_port), clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_run</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EPOLL_EVENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = (<span class="keyword">struct</span> qsevent*)events[i].data.ptr;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">sock</span>(port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    <span class="built_in">qsreactor_init</span>(reactor);</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">qsreactor_addlistener</span>(reactor, sockfd, accept_cb);</span><br><span class="line">    <span class="built_in">qsreactor_run</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_destory</span>(reactor);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问：从协议原理和底层代码实现角度详细说明WebSocket怎么实现由服务器主动发送给客户端的？</p><p>目前的理解：</p><p>在WebSocket协议的底层，实际上是基于TCP协议的。当WebSocket连接建立时，会在客户端和服务器之间建立一个持久的TCP连接。这个TCP连接是全双工的，数据可以在任意方向上流动。因此，服务器可以随时将数据发送到这个TCP连接上，而无需等待客户端的请求。这就是WebSocket如何实现服务器主动向客户端发送数据的原理。</p><p>在代码层面，WebSocket服务器通常会有一个事件循环，用于监听TCP连接上的事件。当服务器有数据需要发送到客户端时，它会将数据写入到TCP连接上，然后由操作系统的网络栈将数据发送到客户端。这个过程是非阻塞的，服务器无需等待数据被发送出去，可以立即继续处理其他任务。这就是WebSocket如何在底层代码实现服务器主动向客户端发送数据的。</p><p>我认为本质还是WebSocket服务器的实现遵循他设计的概念。</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/581974844">https://zhuanlan.zhihu.com/p/581974844</a></p><p>参考：<a href="https://xiaolincoding.com/network/2_http/http_websocket.html#websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">既然有 HTTP 协议，为什么还要有 WebSocket？</a></p>]]></content>
    
    
    <summary type="html">WebSocket协议及原理</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="https://penge666.github.io/posts/3ebec1e4.html"/>
    <id>https://penge666.github.io/posts/3ebec1e4.html</id>
    <published>2024-06-17T02:45:46.000Z</published>
    <updated>2024-06-17T07:32:37.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我们要了解 进程间是如何通信的，那么就需要了解进程是什么。</p><p>进程：其实进程就是运行起来的程序，程序运行起来需要被加载到内存中。进程和可执行文件很像(文件名.exe)-&gt;这就是可执行文件.但是他们又有所不同.可执行文件就像是静态的,躺在我们的硬盘中,但是,我们在任务管理器中可以明显的看到我们的进程是动态的,是在内存中不断被加载的.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617104735563.png" alt="image-20240617104735563"></p><p>进程他是一个运行的程序，是在内存中不断被加载的。那么这些进程是如何通信的？</p><h2 id="进程间通信方式">进程间通信方式</h2><p><strong>1.为什么需要进程间通信?</strong></p><p>每一个进程都拥有自己的独立的进程虚拟地址空间，造成了进程独立性，从而进程间通信技术就是为了各个进程之间可以很好的交换数据或者进程控制等应运而生的。</p><p><strong>2.进程通信的几种方式</strong></p><p>进程间的通信有 ：<strong>管道 消息队列 共享内存 信号  套接字</strong>。</p><p>总结：</p><ol><li><p>管道：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。</p></li><li><p>系统IPC</p></li></ol><ul><li><p>消息队列：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。</p></li><li><p>信号量semaphore：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。</p></li><li><p>信号：用于通知接收进程某个事件的发生。</p></li><li><p>内存共享：使多个进程访问同一块内存空间。</p></li></ul><ol start="3"><li>套接字socket：用于不同主机直接的通信。</li></ol><p><strong>3.进程间通信的目的</strong></p><p>数据传输：一个进程需要将它的数据发送给另一个进程</p><p>资源共享：多个进程之间共享同样的资源。</p><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止 时要通知父进程）</p><p>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另 一个进程的所有陷入和异常，并能够及时知道它的状态改变</p><h2 id="管道">管道</h2><h3 id="匿名管道">匿名管道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep mysql</span><br></pre></td></tr></table></figure><p>了解linux的朋友肯定熟悉   【|】这个符号  其实竖线就是一个管道，管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行，这种管道是没有名字，所以【|】表示的管道称为匿名管道，用完了就销毁。</p><p>匿名管道的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617105408840.png" alt="image-20240617105408840"></p><p>管道就是一端写入数据，另一端读取。 <strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取。</p><p>看到这，你可能会有疑问，两个进程都在一个进程里，怎么实现通信的。</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617105706002.png" alt="image-20240617105706002"></p><p>这样就实现了不同进程之间的通信，但是问题又来了，因为管道是只能一端写一段读，如果两个进程同时写的话，那岂不是会混乱。</p><p>所以我们一般会这样：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><p>通过以上我们知道：匿名管道是一个半双工的通信方式，就是一个发 另一个读。并且只能在具有亲缘关系的进程之间通信。很不方便。于是我们有了命名管道</p><h3 id="命名管道">命名管道</h3><p>命名管道：需要通过 mkfifo 命令来创建并指定好名字。相当提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> Pipe</span></span><br></pre></td></tr></table></figure><p>Pipe就是这个管道的名字。</p><p>接下来，我们往 Pipe 这个管道写入数据：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">echo</span> <span class="string">&quot;hello&quot;</span> &gt; Pipe  <span class="string">//</span> 将数据写进管道</span><br><span class="line">                         <span class="string">//</span> 停住了 <span class="string">...</span></span><br></pre></td></tr></table></figure><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> cat &lt; Pipe  <span class="comment">// 读取管道里的数据</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p><p><strong>总结</strong></p><p>我们发现，不管是匿名管道还是命名管道，都是半双工的通信方式，并且只能一方写，另一方读。通信效率非常低下，所以我们<strong>又引出了消息队列</strong>。</p><h2 id="消息队列">消息队列</h2><p>我们说到，管道的通信效率低下，不适合进程间频繁的交流，于是消息队列很好的解决了这个问题。</p><p>消息队列，<strong>就是一个消息的链表，是一系列保存在内核中消息的列表</strong>。当一个进程需要通信的时候，只需要将数据写入这个消息列表当中，就可以正常退出干其他事情了，另一个进程需要数据的时候只需去读取数据就行了。</p><p>补充：</p><p>消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><ol><li>队列的特性是先进先出，消息队列也是满足先进先出的特性的，内核当中实现消息队列的时候，是采用链表这个结构体。</li><li>消息队列当中的元素是有类型的，每一种类型是有优先级概念的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">同一类型保证先进先出的特性;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>:</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, size t msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//msgflg :</span></span><br><span class="line"><span class="comment">//       IPC NOWAIT : 非阻塞模式</span></span><br><span class="line"><span class="comment">//                 0: 阻塞模式</span></span><br><span class="line"> </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, size t msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  long msgtype : 数据类型</span></span><br><span class="line"><span class="comment">//  ==0:取队列当中的第一个</span></span><br><span class="line"><span class="comment">//  &gt; 0:取和msgtypc相等的元素</span></span><br><span class="line"><span class="comment">//  &lt; 0: 先取绝对值，然后在范围内去最小的优先级的元素</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid ds *buf)</span>;</span><br><span class="line"> </span><br><span class="line">结论:消息队列的生命周期也是跟随内核.</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617110328223.png" alt="image-20240617110328223"></p><p><strong>管道 VS 消息队列</strong></p><p>管道是最基本的 IPC 方法之一，它允许一个进程向另一个进程发送数据。然而，管道是半双工的，这意味着数据只能在一个方向上流动，如果两个进程需要相互通信，就需要建立两个管道。另外，管道的信息传递是无格式的，接收进程需要知道数据的格式才能正确解析。</p><p>消息队列是另一种 IPC 方法，它解决了管道的一些限制。消息队列是全双工的，这意味着数据可以在两个方向上流动，只需要一个<strong>消息队列就可以实现双向通信</strong>。此外，<strong>消息队列发送的是格式化的消息</strong>，每个消息都有一个类型，这使得接收进程可以根据消息类型来选择处理的消息，提高了通信的灵活性。</p><blockquote><p>全双工（Full Duplex）和半双工（Half Duplex）</p></blockquote><p>全双工（Full Duplex）通信允许数据在两个方向上同时进行传输。就像在电话通话中，你可以在同一时间既能听到对方的声音，也能向对方讲话，这就是全双工通信。</p><p>而半双工（Half Duplex）通信则是数据只能在一个方向上流动，同一时间只允许一个方向的通信，不能同时进行接收和发送。例如，对讲机就是典型的半双工通信设备，你在讲话的时候，对方只能听，不能同时与你交谈。</p><p>综上说所，消息队列很好的解决了管道不能频繁交流的问题，但是也存在了不足，就是交流不及时，还有大小受限制。并且<strong>在通信的过程中，会存在大量频繁的用户态和内核态的不断转换</strong>，进程写入消息时，会发生用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><h2 id="共享内存">共享内存</h2><h3 id="共享内存的原理">共享内存的原理</h3><p>首先在物理内存当中创建了一块内存<br>不同的进程通过页表映射， 将同一块物理内存映射到自己的虚拟地址空间<br>不同的进程， 操作进程虚拟地址， 通过页表的映射， 就相当于操作同一块内存，从而完成了数据交换</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617111139897.png" alt="image-20240617111139897"></p><h3 id="共享内存的接口">共享内存的接口</h3><p><strong>创建共享内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, size t size, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    key :共享内存标识符， 这个标识符相当于共享内存的身份证 程序员在第一次创建的时候， 可以随意给 值， 只要和当前操作系统当中的其他的共享内存标识符不重复</span></span><br><span class="line"><span class="comment">//     eg : 0x99999999 0x88888888 0x12345678</span></span><br><span class="line"><span class="comment">//     size : 共享内存的大小，单位字节</span></span><br><span class="line"><span class="comment">//  shmrlg :</span></span><br><span class="line"><span class="comment">//       IPC CREAT : 如果共享内存不存在， 则创建共享内存</span></span><br><span class="line"><span class="comment">//        IPC_EXCL: 需要搭配IPC CREAT一起使用， 这样的宏在搭配使用的时候，  还是采用按位或的方式 </span></span><br><span class="line"><span class="comment">//其实核心的思想就是位图</span></span><br><span class="line"><span class="comment">//     eg :IPC CREAT IPC EXCL:</span></span><br><span class="line"><span class="comment">//           如果想要获取的共享内存，已经存在， 则报错如果想要过去的共享内存，  是刚刚新创建出来的 </span></span><br><span class="line"><span class="comment">  //共享内存，则返回舞作句柄</span></span><br><span class="line"><span class="comment">       总结:使用shmget这个函数的时候一定更自己刚刚创建出来的共享内存</span></span><br><span class="line"><span class="comment">       返回值:返回值是返回共享内存的操作句柄</span></span><br><span class="line"><span class="comment">    共享内存的标识符和共享内存的操作句柄区别是什么?</span></span><br><span class="line"><span class="comment">     标识符:是用来标识共享内存的， 相当于共享内存的身份证，意味者不同的进程可以通过标识符找到这个共享内存</span></span><br><span class="line"><span class="comment">     操作句柄:进程可以通过操作句柄来对共享内存进行操作(附加， 分离， 删除)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>将共享内存附加到进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span> <span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    shmid : 共享内存操作句柄</span></span><br><span class="line"><span class="comment">    shmaddr : 附加到共享内存的什么虚拟地址， 允许传递NULL值， 让操作系统帮我们选择附加到共享区当中的那个地址， 这个地址通过该函数的返回值返回给我们</span></span><br><span class="line"><span class="comment">    shmflgt:</span></span><br><span class="line"><span class="comment">    SHM RDONLY 规定当前进程只能对共享内存进行读操作</span></span><br><span class="line"><span class="comment">    0 : 可读可写</span></span><br><span class="line"><span class="comment">    返回值: 返回共享内存附加到共享区的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>将共享内存和进程分离</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span> </span>;</span><br><span class="line"><span class="comment">//shmaddr : shmat的返回值</span></span><br></pre></td></tr></table></figure><p><strong>操作共享内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span> <span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> emd, <span class="keyword">struct</span> shmid ds *buf)</span> </span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    shmid : 共享操作句柄</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    cmd : 告诉shmct1函数需要做什么操作</span></span><br><span class="line"><span class="comment">         IPC STAT :获取当前共享内存的属性信息，放在buf当中， buf是出参</span></span><br><span class="line"><span class="comment">          IPC SET :设置共享内存的属性信息， 是用buf来进行设置的， bur是入参</span></span><br><span class="line"><span class="comment">          IPC RMID :删除共享内存， buf可以直接传递为NULL</span></span><br><span class="line"><span class="comment">    buf : 共享内存的结构体</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>删除共享内存</strong></p><ol><li>当使用shmct1或者使用ipcrm，删除共享内存之后， 共享内存就实际被释<br>放掉了</li><li>当共享内存被群放掉之后， 共享内存的标识符会被设置成为0x00000000.表示其他进程不能通过之前的标识符找到该共享内存， 并且共享内存的状态会被设置成为dest (destroy)</li><li>当共享内存被群放掉之后了， 但是还是有进程在附加着共享内存，当前描述共享内存的结构体并没有被释放， 直到当前共享内存的附加进程数量为0的时候才会被释放掉</li></ol><p><strong>总结</strong></p><p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。但是也引入了一个问题，就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。为了解决这一问题我们又引入了信号量的概念。</p><h2 id="信号量">信号量</h2><p>为了防止多个进程同时访问公共资源，造成数据混乱，必须想一个保护机制，使得共享的资源，在任意时刻只能被一个进程访问。于是便提出了信号量。</p><p>信号量（semaphore）它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>控制信号量的方式有两种原子操作：</p><ul><li>一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>进程互斥访问资源  初始化信号量为 <code>1</code></strong></p><blockquote><p>假如有A B两个进程  信号量初始化为 1， 现在A 要访问共享内存 进行了p操作，信号量变为 0，说明还有可用资源，A就可以顺利访问共享资源了。</p><p>结果这会B进程又要来访问资源，进行了p操作，信号量变成了-1，说明资源已经有进程占用了，那么B进程就会阻塞等待。</p><p>A进程这会访问完了，出来了，进行了V操作，信号量变成了 0 ，看见了B在哪等待，于是唤醒了B,说你可以进去了，于是B就可以访问了，访问完之后，进行V操作，信号量又变回了1。</p></blockquote><p><strong>进程同步访问资源  初始化信号量为 0</strong></p><p>我们都知道，进程是抢占式占用资源，但是我们有时想让多个进程相互合作，实现同一个任务，比如先让A进程生产数据，B进程才能读取数据。但是我们不知道到底那个进程先抢占了资源。假如A还没有生产数据呢，但是B进程又要读取，我们该如何做？</p><p>于是我们边有了进程同步：</p><blockquote><p>我们可以初始化信号量为 0：<br>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；<br>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；<br>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</p></blockquote><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><p><strong>总结：信号量不是用来通信的，信号量是和共享内存结合，来限制多进程同时访问共享资源的。防止冲突的一种保护机制</strong></p><h2 id="信号">信号</h2><p>我们上述说到的都是正常情况下的进程通信，那么如果进程出现异常了呢，这个时候我们就需要用信号通知的方式，实现通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$  <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>总共定义了62个信号。</p><blockquote><p>非实时信号: 非可靠信号</p><p>特点: 信号可能会丢失</p><p>1~31信号</p><p>实时信号:可靠信号</p><p>特点: 信号不会丢失</p><p>33~64</p></blockquote><p><strong>信号的操作原理：</strong></p><ol><li>信号产生：信号可以由操作系统、进程或用户生成。如硬件错误、软件中断、操作系统异常等情况，操作系统会产生信号。进程也可以使用系统调用，如 kill，给其他进程发送信号。用户通过终端（如按下 ctrl+c）也可以产生信号。</li><li>信号发送：一旦信号产生，它就会被发送给目标进程。信号在发送时会指定信号类型，例如 SIGINT 表示键盘中断信号，SIGKILL 表示终止进程信号等。</li><li>信号接收与处理：进程接收到信号后，有以下几种处理方式：<ul><li>忽略信号</li><li>捕获信号：设置一个函数，当信号发生时，执行该函数</li><li>使用默认操作：每种信号都有一个默认操作，如终止进程、停止进程或忽略信号等。</li></ul></li><li>信号阻塞：进程可以选择阻塞某些信号。被阻塞的信号不会立即被处理，而是被挂起，直到进程解除阻塞。</li></ol><p><strong>举个例子说明下我们经常使用通过终端（如按下 ctrl+c）杀死进程的原理</strong></p><ol><li>用户在终端按 ctrl+c，终端驱动程序会捕获这个键盘事件，并向前台进程组发送 SIGINT 信号。</li><li>收到 SIGINT 信号的进程会查找对应的信号处理函数**。在进程的控制块（PCB，Process Control Block）中，有一个信号处理表，用于存储进程对每种信号的处理方式。如果进程设置了捕获该信号的处理函数，那么就会执行该函数**；如果没有设置，那么执行该信号的默认操作。对于 SIGINT 信号，如果没有捕获，那么默认操作就是终止进程。</li><li>如果进程被终止，操作系统会回收该进程的资源，包括内存资源、文件描述符、环境变量等，并将该进程的状态设置为退出（Exit）。</li><li>进程的父进程会收到 SIGCHLD 信号，通知其子进程已经终止。父进程可以通过 wait() 或 waitpid() 函数获取子进程的退出状态，完成对子进程的回收。</li></ol><p>说到这里，我们发现上面的所有进程间通信方式都只是局限在本机，那我我们自然而然的就引出了网络<strong>Socket 通信，实现不同电脑中的进程通信。</strong></p><h2 id="socket通信">socket通信</h2><p>这个可以看我的多路复用那篇文章</p><p>编程流程：</p><p>服务端:创建套接字，绑定地址信息</p><p>客户端:创建套接字，不推荐绑定地址信息 (可以绑定 )</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617112159033.png" alt="image-20240617112159033"></p><p>创建套接字的含义:</p><p>将进程和网卡进行绑定，进程可以从网卡当中接收数据，也可以通过网卡发送数据。</p><p>绑定地址信息的含义:</p><p>绑定ip，绑定端口，是为了在网络当中可以标识出来一台主机和一个进程。<br>对于接收方而言:发送数据的人就知道接收方在那台机器那个进程了</p><p>对于发送方而言:能标识网络数据从那台机器那个进程发送出去的</p><h2 id="总结">总结</h2><p>如果面试官问你说说，进程间是如何通信的，你该做一下回答。</p><p>首先  进程间的通信有  <strong>管道 消息队列 共享内存 信号  套接字。</strong></p><p><strong>管道分为 匿名管道和命名管道。</strong></p><p>**匿名管道 ：他是一个半双工的通信方式，就是一个发 另一个读。**并且只能在具有亲缘关系的进程之间通信。很不方便，于是便有了命名管道： 同理命名管道也是一个半双工的通信方式，一个发 另一个读。但是可以实现不同进程之间的通信了。</p><p>这又产生了问题，就是这个通信不迅速，效率低下又成了问题，于是又产生出了消息队列。</p><p><strong>消息队列：消息队列是保存在内核中的消息链表</strong>，比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。这样就是像写信一样，一来一封，我回一封，而且消息队列在内核当中，我们去读取的时候，还会有用户态和内核态之间的转换，效率虽然说有所改变，但是还是不够及时。所以共享内存又出来了。</p><p><strong>共享内存：就是两个进程，各拿出一块虚拟内存空间，映射到相同的物理空间</strong>。这样一个进程在进行读写操作的时候，另外一个进程立马就可以看到。通信的效率大大提高，但是又带来了新的问题。就是如果遇到两个或者多个进程同时给这个空间写东西，就会产生冲突。</p><p>那么为了防止多个进程同时共享资源，就提出了信号量，使得在任意时刻资源只能被一个进程访问。信号量说白了就相当于一个计数器，有两个操作：（他不能通信只能配合共享内存）</p><ul><li><p><strong>P操作</strong>：相当于每来一个进程要访问的时候，先给信号量减1，减1之后  如果信号量还&gt;&gt;=0  说明这会这个资源还没有占用可以访问，如果减一之后&lt;0,说明有其他进程正占用着资源，需要等待。</p></li><li><p><strong>V操作</strong>：每个进程要走的时候，先给信号量+1  如果说+1了之后，还&lt;&lt;=0，说明前面还有排队的进程，这个时候就会把前面排队的进程唤醒，说我走了，你可以去访问资源了。如果+1&gt;0   说明前面没有排队的进程，也就是没有阻塞的进程，如果后面有进程要访问的话，直接就可以访问。</p></li></ul><p>说了这些都是在一台主机上的进程间的通信，那么也产生出了Socket，也就是套接字。这实现了不同电脑上的进程通信。</p><p>最后还有个  信号： 信号就是可以给进程发送一个命令，进程就会做相应的工作。</p><p>摘录自：<a href="https://blog.csdn.net/qq_45615577/article/details/129316185#:~:text=%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E3%80%90%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E3%80%91%E6%9C%80%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%B4%201%20%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%202%20%E4%BA%94%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89,3%20%E5%85%AD%E3%80%81%E4%BF%A1%E5%8F%B7%204%20%E4%B8%83%E3%80%81socket%E9%80%9A%E4%BF%A1%205%20%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93">面试常问【进程间通信】最详细解说</a></p>]]></content>
    
    
    <summary type="html">进程间通信机制</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>容器网络模式</title>
    <link href="https://penge666.github.io/posts/c67182ed.html"/>
    <id>https://penge666.github.io/posts/c67182ed.html</id>
    <published>2024-06-16T08:27:10.000Z</published>
    <updated>2024-06-17T02:29:29.821Z</updated>
    
    <content type="html"><![CDATA[<p>《再见少年拉满弓》</p><p>东风吹破少年梦，从此再无赤子心。<br>黄昏重铸英雄梦，再见少年拉满弓。<br>再见少年拉满弓，不惧岁月不惧风，<br>少年扶摇上九重，胸中豪情破苍穹。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617101725751.png" alt="image-20240617101725751"></p><ul><li><strong>bridge模式：–net=bridge 桥接模式（默认设置，自己创建也使用bridge 模式）</strong></li><li><strong>host模式：–net=host 和宿主即共享网络</strong></li><li><strong>container模式：–net=container:NAME_or_ID 容器网络连通!(很少用，局限性很大！)</strong></li><li><strong>none模式：–net=none 不配置网络</strong></li></ul><h2 id="查看所有的docker网络">查看所有的docker网络</h2><p>命令：<code>docker network ls</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@penge ➜ toktik git(main)  docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME           DRIVER    SCOPE</span><br><span class="line">151c5fe4b87c   bridge         bridge    <span class="built_in">local</span></span><br><span class="line">5c21b13981a4   host           host      <span class="built_in">local</span></span><br><span class="line">c51c6b57875f   none           null      <span class="built_in">local</span></span><br><span class="line">b0165c5b9c95   yaml_default   bridge    <span class="built_in">local</span></span><br></pre></td></tr></table></figure><h2 id="bridge-网桥模式">bridge 网桥模式</h2><p>Docker安装启动后会在宿主主机上创建一个名为 docker0 的虚拟网桥，处于七层网络模型的数据链路层，后续每当我们创建一个新的docker容器，在不指定容器网络模式的情况下，docker会通过 docker0 与主机的网络连接，docker0 相当于网桥。</p><p>补充：网桥，也被称为网络桥接器或桥接器，是一种用于连接同一种或不同种类的网络段以形成一个大网络的设备。它的工作方式类似于路由器，但是它通常只用于连接本地网络（LAN）。</p><p>使用 bridge 模式新创建的容器，容器内部都会有一个虚拟网卡，名为 eth0，容器之间可以通过容器内部的IP相互通信。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617102059535.png" alt="image-20240617102059535"></p><p>解释上图：在该模式中，Docker 会创建一个虚拟以太网桥 <code>docker0</code>，新建的容器会自动桥接到这个接口，然后docker会依据docker0在创建的时候设立的网络段给容器分配ip。</p><p><strong>Note</strong>：但默认的方式存在一个问题，就是每次重启docker默认的网络段也会发生变化，而采用该网络段的docker容器也会跟着发生变化。当然我们也可以自定义一个网络段，然后自己给创建的容器分配指定的ip。</p><p>命令：<code>docker run -d -name tomcat01 --net=bridge -p 8085:80 tomcat:latest</code><br>说明：</p><ul><li>–net=bridge 可省略 ，-p 指定端口映射</li><li>网桥默认 IP 范围是一般都是 172.17.x.x</li></ul><h2 id="host-模式">host 模式</h2><p>如果指定的host模式容器不会拥有一个独立network namespace，而是与宿主主机共用network namespace。也就说明容器本身不会有的网卡信息，而是使用宿主主机的网络信息。容器除了网络，其他比如文件系统、进程等依然都是隔离的。</p><ul><li>host 网络模式需要在创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定；</li><li>采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；</li><li>host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617102245846.png" alt="image-20240617102245846"></p><p>说明：</p><ul><li>–net=host 指定</li><li>容器和宿主主机共享 Network namespace</li><li>host模式因为和宿主主机共享network namespace，会有可能出现端口冲突的情况。</li></ul><h2 id="container模式">container模式</h2><p>container模式和host模式很类似，host模式和宿主主机共享network namespace;container模式和指定的容器共享，两者之间除了网络共享（网卡、主机名、IP 地址），其他方面还是隔离的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617102450256.png" alt="image-20240617102450256"></p><p>命令：<code>docker run -d -name tomcat02 --net=container:name/id -p 8000:80 tomcat:latest</code><br>说明：</p><ul><li>–-net={容器id 或容器name} 指定</li><li>当前容器和另外一个容器共享 Network namespace</li></ul><h2 id="none模式">none模式</h2><p>如果dockers容器指定的网络模式为none,该容器没有办法联网，外界也无法访问它，可以用来本次测试。</p><p>命令：<code>docker run -d -name tomcat02 --net=none -p 8000:80 tomcat:latest</code><br>说明：</p><ul><li>–net=none 指定</li><li>容器有独立的Network namespace，但并没有对其进行任何网络设置，如果需要的话，需要自定义配置网络</li></ul><h2 id="Docker-网络桥接模式和-Host-模式的区别">Docker 网络桥接模式和 Host 模式的区别</h2><p>首先，我们需要了解一下 Docker 的两种网络模式之间的区别。在桥接网络模式下，Docker 将为每个容器创建一个独立的网络命名空间，并为容器分配一个|P 地址。而在 Host 网络模式下，容器将直接使用主机的网络栈，与主机共享网络接口和 IP 地址，这意味着容器可以直接访问主机上的所有网络服务，同时也会导致容器与主机网络之间的隔离性降低。</p><p>学习自：<a href="https://www.cnblogs.com/xiongzaiqiren/p/18177383/docker-network">docker网络配置：bridge模式、host模式、container模式、none模式</a></p><p>优秀教程：<a href="https://www.cnblogs.com/taoxiaoxin/p/18082633">Docker 网络模式详解及容器间网络通信 </a></p>]]></content>
    
    
    <summary type="html">容器网络4种模式</summary>
    
    
    
    <category term="Docker" scheme="https://penge666.github.io/categories/Docker/"/>
    
    <category term="微服务" scheme="https://penge666.github.io/categories/Docker/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Docker" scheme="https://penge666.github.io/tags/Docker/"/>
    
    <category term="微服务" scheme="https://penge666.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>内存回收</title>
    <link href="https://penge666.github.io/posts/8ed57ebe.html"/>
    <id>https://penge666.github.io/posts/8ed57ebe.html</id>
    <published>2024-06-16T03:40:35.000Z</published>
    <updated>2024-06-17T07:32:23.329Z</updated>
    
    <content type="html"><![CDATA[<p>如果应用程序申请内存的速度，超过内存回收的速度，内存就会被用满。当内存用满，操作系统就开始需要频繁地切换页面，进行频繁地磁盘读写。<strong>所以我们观察到的系统性能下降，往往是一种突然的崩溃，因为一旦内存被占满，系统性能就开始雪崩式下降</strong>。</p><h2 id="什么是-GC">什么是 GC</h2><p>通常意义上我们说的垃圾回收器（Garbage Collector，GC），和多数同学的理解会有出入。你可能认为 GC 是做内存回收用的模块，而事实上程序语言提供的 GC 往往是应用的实际内存管理者。刚刚入门咱们就遇到了一个容易出现理解偏差的问题，所以 GC 是值得花时间细学的。</p><p>如上图所示，一方面 GC 要承接操作系统虚拟内存的架构，另一方面 GC 还要为应用提供内存管理。GC 有一个含义，就是 Garbage Collection 内存回收的具体动作。无论是名词的回收器，还是动词的回收行为，在下文中我都称作 GC。</p><p>下面我们具体来看一下 GC 都需要承担哪些“工作”，这里我总结为以下 4 种。</p><ol><li>GC 要和操作系统进行交互，负责申请内存，并把不用的内存还给操作系统（释放内存）。</li><li>应用会向 GC 申请内存。</li><li>GC 要承担我们通常意义上说的垃圾回收能力，标记不用的对象，并回收他们。</li><li>GC 还需要针对应用特性进行动态的优化。</li></ol><p>所以现在程序语言实现的 GC 模块通常是实际负责应用内存管理的模块。在程序语言实现 GC 的时候，会关注下面这几个指标。</p><ul><li><strong>吞吐量（Throughput）</strong>：执行程序（不包括 GC 执行的时间）和总是间的占比。注意这个吞吐量和通常意义上应用去处理作业的吞吐量是不一样的，这是从 GC 的角度去看应用。只要不在 GC，就认为是吞吐量的一部分。</li><li><strong>足迹（FootPrint）</strong>： 一个程序使用了多少硬件的资源，也称作程序在硬件上的足迹。GC 里面说的足迹，通常就是应用对内存的占用情况。比如说应用运行需要 2G 内存，但是好的 GC 算法能够帮助我们减少 500MB 的内存使用，满足足迹这个指标。</li><li><strong>暂停时间（Pause Time）</strong>： GC 执行的时候，通常需要停下应用（避免同步问题），这称为 Stop The World，或者暂停。不同应用对某次内存回收可以暂停的时间需求是不同的，比如说一个游戏应用，暂停了几毫秒用户都可能有很大意见；而看网页的用户，稍微慢了几毫秒是没有感觉的。</li></ul><h2 id="GC-目标的思考">GC 目标的思考</h2><p>如果单纯从让 GC 尽快把工作做完的角度来讲，其实是提升吞吐量。比如利用好多核优势就是一种最直观的方法。</p><p>因为涉及并行计算，我这里给你讲讲并行计算领域非常重要的阿姆达定律，这个定律用来衡量并行计算对原有算法的改进，公式如下：</p><p>S = 1 / (1- P)</p><p>你现在看到的是一个简化版的阿姆达定律，P 是任务中可以并发执行部分的占比，S 是并行带来的理论提速倍数的极限。比如说 P 是 0.9，代入公式可得：</p><p>S = 1 / （1 - 0.9） = 10</p><p>上面表达式代表着有 90% 的任务可以并行，只有 10% 的任务不能够并行。假设我们拥有无限多的 CPU 去分担 90% 可以并行的任务，其实就相当于并行的任务可以在非常短的时间内完成。但是还有 10% 的任务不能并行，因此理论极限是 1⁄0.1=10 倍。</p><p>通常我们设计 GC，都希望它能够支持并行处理任务。因为 GC 本身也有着繁重的工作量，需要扫描所有的对象，对内存进行标记清除和整理等。</p><p><strong>经过上述分析，那么我们在设计算法的时候是不是应该尽量做到高并发呢？</strong></p><p>很可惜并不是这样。如果算法支持的并发度非常高，那么和单线程算法相比，它也会带来更多的其他开销。比如任务拆分的开销、解决同步问题的开销，还有就是空间开销，GC 领域空间开销通常称为 FootPrint。理想情况下当然是核越多越好，但是如果考虑计算本身的成本，就需要找到折中的方案。</p><p>还有一个问题是，GC 往往不能拥有太长的暂停时间（Pause Time），因为 GC 和应用是并发的执行。如果 GC 导致应用暂停（Stop The World，STL）太久，那么对有的应用来说是灾难性的。 比如说你用鼠标的时候，如果突然卡了你会很抓狂。如果一个应用提供给百万级的用户用，假设这个应用帮每个用户每天节省了 1s 的等待时间，那么按照乔布斯的说法每天就为用户节省了 11 天的时间，每年是 11 年——5 年就相当于拯救了一条生命。</p><p>如果暂停时间只允许很短，那么 GC 和应用的交替就需要非常频繁。这对 GC 算法要求就会上升，因为每次用户程序执行后，会产生新的变化，甚至会对已有的 GC 结果产生影响。后面我们在讨论标记-清除算法的时候，你会感受到这种情况。</p><p>所以说，吞吐量高，不代表暂停时间少，也不代表空间使用（FootPrint）小。 同样的，使用空间小的 GC 算法，吞吐量反而也会下降。<strong>正因为三者之间存在类似相同成本代价下不可兼得的关系，往往编程语言会提供参数让你选择根据自己的应用特性决定 GC 行为</strong>。</p><h2 id="引用计数算法（Reference-Counter）">引用计数算法（Reference Counter）</h2><p>接下来我们说说，具体怎么去实现 GC。实现 GC 最简单的方案叫作引用计数，下图中节点的引用计数是 2，代表有两个节点都引用了它。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152305818.png" alt="image-20240617152305818"></p><p>如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它——此时，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。</p><p>但是，这个算法可能会出现下图中循环引用的问题（我们写程序的过程中经常会遇到这样的引用关系）。下图中三个节点，因为循环引用，引用计数都是 1。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152317573.png" alt="image-20240617152317573"></p><p>引用计数是 1，因此就算这 3 个对象不会再使用了，GC 不会回收它们。</p><p>另一个考虑是在多线程环境下引用计数的算法一旦算错 1 次（比如因为没有处理好竞争条件），那么就无法再纠正了。而且处理竞争条件本身也比较耗费性能。</p><p>还有就是引用计数法回收内存会产生碎片，当然碎片不是只有引用计数法才有的问题，所有的 GC 都需要面对碎片。下图中内存回收的碎片可以通过整理的方式，清理出更多空间出来。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152356815.png" alt="image-20240617152356815"></p><p>综上，<strong>引用计数法出错概率大</strong>，比如我们编程时会有对象的循环引用；另一方面，<strong>引用计数法容错能力差</strong>，一旦计算错了，就会导致内存永久无法被回收，因此我们需要更好的方式。</p><h2 id="Root-Tracing-算法">Root Tracing 算法</h2><p>下面我再给你介绍一种更好的方式—— Root Tracing 算法。这是一类算法，后面我们会讲解的标记-清除算法和 3 色标记-清除算法都属于这一类。</p><p>Root Tracing 的原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用关系的源头。比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。在 Java 中根对象就包括在栈上创建指向堆的对象；JVM 的一些元数据，包括 Method Area 中的对象等。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152430225.png" alt="image-20240617152430225"></p><p>在 Root Tracing 工作过程中，如果一个对象和根对象间有连通路径，也就是从根节点开始遍历可以找到这个对象，代表有对象可以引用到这个对象，那么这个节点就不需要被回收。所以算法的本质还是引用，只不过判断条件从引用计数变成了有根对象的引用链。</p><p>如果一个对象从根对象不可达，那么这个对象就应该被回收，即便这个对象存在循环引用。可以看到，上图中红色的 3 个对象循环引用，并且到根集合没有引用链，因此需要被回收。这样就解决了循环引用的问题。</p><p>Root Tracing 的容错性很好，GC 通过不断地执行 Root Tracing 算法找到需要回收的元素。如果在这个过程中，有一些本来应该回收的元素没有被计算出（比如并发原因），也不会导致这些对象永久无法回收。因为在下次执行 Root Tracing 的时候，GC 就会通过执行 Root Tracing 算法找到这些元素。不像引用计数法，一旦算错就很难恢复。</p><p><strong>补充</strong>：</p><p>在 Root Tracing 算法中，根节点通常指的是垃圾收集器（Garbage Collector, GC）在执行标记过程时的起始点。这些根节点通常是全局变量或者是当前执行的函数的参数和局部变量，因为它们是可以直接访问的。垃圾收集器从这些根节点开始遍历，找出所有它们能直接或间接引用到的对象，这些对象被认为是&quot;活动的&quot;，也就是说它们在当前的程序执行中仍然有可能被用到。而那些不能从根节点达到的对象，就被认为是&quot;死亡的&quot;，也就是说它们在后续的程序执行中不会再被用到，因此可以被垃圾收集器回收。</p><h3 id="标记-清除（Mark-Sweep）算法">标记-清除（Mark Sweep）算法</h3><p>下面我为你具体介绍一种 Root Tracing 的算法， 就是标记清除-算法。标记-清除算法中，用白色代表一种不确定的状态：可能被回收。 黑色代表一种确定的状态：不会被回收。算法的实现，就是为所有的对象染色。算法执行结束后，所有是白色的对象就需要被回收。</p><p>算法实现过程中，假设有两个全局变量是已知的：</p><ul><li>heapSet 中拥有所有对象</li><li>rootSet 中拥有所有 Root Object</li></ul><p>算法执行的第一步，就是将所有的对象染成白色，代码如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    obj.color = white</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义一个标记函数，它会递归地将一个对象的所有子对象染成黑色，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">mark</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> obj.<span class="property">color</span> == white &#123;</span><br><span class="line"></span><br><span class="line">    obj.<span class="property">color</span> = black</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="title function_">references</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充知识">补充知识</h4><p>上面的 mark 函数对 obj 进行了深度优先搜索。深度优先搜索，就是自然的递归序。随着递归函数执行，遇到子元素就遍历子元素，就构成了天然的深度优先搜索。还有一个相对的概念是广度优先搜索（Breadth First Serach），如果你不知道深度优先搜索和广度优先搜索，可以看下我下面的图例。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152450701.png" alt="image-20240617152450701"></p><p>上图中，深度优先搜索优先遍历完整的子树（递归），广度优先搜索优先遍历所有的子节点（逐层）。</p><p>然后我们从所有的 Root Object 开始执行 mark 函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for root in rootSet &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">mark</span>(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结束后，所有和 Root Object 连通的对象都已经被染成了黑色。然后我们遍历整个 heapSet 找到白色的对象进行回收，这一步开始是<strong>清除（Sweep）阶段</strong>，以上是<strong>标记（Mark）阶段</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> obj.color == white &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上算法就是一个简单的标记-清除算法。相比引用计数，这个算法不需要维护状态。算法执行开始所有节点都被标记了一遍。结束的时候，算法找到的垃圾就被清除了。 算法有两个阶段，标记阶段（Mark），还有清除阶段（Sweep），因此被称为标记-清除算法。</p><p>这里请你思考：如果上面的 GC 程序在某个时刻暂停了下来，然后开始执行用户程序。如果用户程序删除了对某个已经标记为黑色对象的所有引用，用户程序没办法通知 GC 程序。这个节点就会变成浮动垃圾（Floating Garbage），需要等待下一个 GC 程序执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152504217.png" alt="image-20240617152504217"></p><p>假设用户程序和 GC 交替执行，用户程序不断进行修改（Mutation），而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。</p><p>另一方面，考虑到 GC 是一个非常消耗性能程序，在某些情况下，我们希望 GC 能够增量回收。 比如说，用户仅仅是高频删除了一部分对象，那么是否可以考虑设计不需要从整个 Root 集合进行遍历，而是增量的只处理最近这一批变更的算法呢？答案是可以的，我们平时可以多执行增量 GC，偶尔执行一次全量 GC。</p><h2 id="三色标记-清除算法（Tri-Color-Mark-Sweep）">三色标记-清除算法（Tri-Color Mark Sweep）</h2><p>接下来，我会和你讨论这种有<strong>三个颜色标记的算法，通常称作三色标记-清除算法</strong>。首先，我们重新定义黑、白、灰三种颜色的含义：</p><ul><li>白色代表需要 GC 的对象；</li><li>黑色代表<strong>确定</strong>不需要 GC 的对象；</li><li>灰色代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增量任务。</li></ul><p>在三色标记-清除算法中，一开始所有对象都染成白色。初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执行 Mutation。</p><p>算法需要维护 3 个集合，白色集合、黑色集合、灰色集合。3 个集合是互斥的，对象只能在一个集合中。执行之初，所有对象都放入白色集合，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152557659.png" alt="image-20240617152557659"></p><p>第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152620646.png" alt="image-20240617152620646"></p><p>接下来算法会不断从灰色集合中取出元素进行标记，主体标记程序如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> greySet.size() &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> item = greySet.<span class="keyword">remove</span>();</span><br><span class="line"></span><br><span class="line">  mark(item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记的过程主要分为 3 个步骤：</p><ol><li>如果对象在白色集合中，那么先将对象放入灰色集合；</li><li>然后遍历节点的所有的引用对象，并递归所有引用对象；</li><li>当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。</li></ol><p>伪代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">mark</span>(obj) &#123;</span><br><span class="line"></span><br><span class="line">  if obj in whiteSet &#123;</span><br><span class="line"></span><br><span class="line">    greySet<span class="selector-class">.add</span>(obj)</span><br><span class="line"></span><br><span class="line">    for v in <span class="built_in">refs</span>(obj) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">mark</span>(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greySet<span class="selector-class">.remove</span>(obj)</span><br><span class="line"></span><br><span class="line">    blackSet<span class="selector-class">.add</span>(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以观察下上面的程序，这是一个 DFS 的过程。如果多个线程对不同的 Root Object 并发执行这个算法，我们需要保证 3 个集合都是线程安全的，可以考虑利用 ConcurrentSet（这样性能更好），或者对临界区上锁。并发执行这个算法的时候，如果发现一个灰色节点说明其他线程正在处理这个节点，就忽略这个节点。这样，就解决了标记程序可以并发执行的问题。</p><p>当标记算法执行完成的时候，所有不需要 GC 的元素都会涂黑：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152642253.png" alt="image-20240617152642253"></p><p>标记算法完成后，白色集合内就是需要回收的对象。</p><p>以上，是类似双色标记-清除算法的全量 GC 程序，我们从 Root 集合开始遍历，完成了对所有元素的标记（将它们放入对应的集合）。</p><p>接下来我们来考虑增加 GC（Incremental GC）的实现。首先对用户的修改进行分类，有这样 3 类修改（Mutation）需要考虑：</p><ol><li>创建新对象</li><li>删除已有对象</li><li>调整已有引用</li></ol><p>如果用户程序创建了新对象，可以考虑把新对象直接标记为灰色。虽然，也可以考虑标记为黑色，但是标记为灰色可以让 GC 意识到新增了未完成的任务。比如用户创建了新对象之后，新对象引用了之前删除的对象，就需要重新标记创建的部分。</p><p>如果用户删除了已有的对象，通常做法是等待下一次全量 Mark 算法处理。下图中我们删除了 Root Object 到 A 的引用，这个时候如果把 A 标记成白色，那么还需要判断是否还有其他路径引用到 A，而且 B,C 节点的颜色也需要重新计算。关键的问题是，虽然可以实现一个基于 A 的 DFS 去解决这个问题，但实际情况是我们并不着急解决这个问题，因为内存空间往往是有富余的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152654270.png" alt="image-20240617152654270"></p><p><strong>在调整已有的引用关系时，三色标记算法的表现明显更好</strong>。下图是对象 B 将对 C 的引用改成了对 F 的引用，C,F 被加入灰色集合。接下来 GC 会递归遍历 C,F，最终然后 F,E,G 都会进入灰色集合。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152727248.png" alt="image-20240617152727248"></p><p>内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求“Stop The World”。<strong>三色算法的优势就在于它支持多一些情况的 Mutation，这样能够提高“垃圾”被并发回收的概率</strong>。</p><p>目前的 GC 主要都是基于三色标记算法。 至于清除算法，有原地回收算法，也有把存活下来的对象（黑色对象）全部拷贝到一个新的区域的算法。</p><h2 id="总结">总结</h2><p><strong>好处</strong></p><ol><li>用于垃圾回收器升级，将STW变为并发标记。STW就是在标记垃圾的时候，必须暂停程序，而使用并发标记，就是程序一边运行，一边标记垃圾。</li><li>避免重复扫描对象，提升标记阶段的效率。</li></ol><p><strong>存在问题</strong></p><ul><li><p><strong>浮动垃圾</strong>:并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描,所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从GCRoot中去找到，所以成为了浮动垃圾，浮动垃圾对系统的影响不大，留给下一次GC进行处理即可。</p></li><li><p><strong>对象漏标问题（需要的对象被回收)</strong>︰并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用)，同时黑色对象引用了该对象（增加引用)(这两部可以不分先后顺序);因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被GC回收，此问题会导致系统出现问题，而CMS与G1，两种回收器在使用三色标记法时，都采取了一些措施来应对这些问题，<strong>CMS对增加引用环节进行处理(Increment Update)，G1则对删除引用环节进行处理(SATB)。</strong></p></li></ul><p>推荐资料：<a href="https://www.bookstack.cn/books/gc-handbook">https://www.bookstack.cn/books/gc-handbook</a></p>]]></content>
    
    
    <summary type="html">内存回收</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>页面加载过程细说</title>
    <link href="https://penge666.github.io/posts/d312cb1f.html"/>
    <id>https://penge666.github.io/posts/d312cb1f.html</id>
    <published>2024-06-15T07:36:23.000Z</published>
    <updated>2024-06-17T08:55:35.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大纲">大纲</h2><ul><li>对知识体系进行一次预评级</li><li>为什么说知识体系如此重要？</li><li>梳理主干流程</li><li>从浏览器接收url到开启网络请求线程<ul><li>多进程的浏览器</li><li>多线程的浏览器内核</li><li>解析URL</li><li>网络请求都是单独的线程</li><li>更多</li></ul></li><li>开启网络线程到发出一个完整的http请求<ul><li>DNS查询得到IP</li><li>tcp/ip请求</li><li>五层因特网协议栈</li></ul></li><li>从服务器接收到请求到对应后台接收到请求<ul><li>负载均衡</li><li>后台的处理</li></ul></li><li>后台和前台的http交互<ul><li>http报文结构</li><li>cookie以及优化</li><li>gzip压缩</li><li>长连接与短连接</li><li>http 2.0</li><li>https</li></ul></li><li>单独拎出来的缓存问题，http的缓存<ul><li>强缓存与弱缓存</li><li>缓存头部简述</li><li>头部的区别</li></ul></li><li>解析页面流程<ul><li>流程简述</li><li>HTML解析，构建DOM</li><li>生成CSS规则</li><li>构建渲染树</li><li>渲染</li><li>简单层与复合层</li><li>Chrome中的调试</li><li>资源外链的下载</li><li>loaded和domcontentloaded</li></ul></li><li>CSS的可视化格式模型<ul><li>包含块（Containing Block）</li><li>控制框（Controlling Box）</li><li>BFC（Block Formatting Context）</li><li>IFC（Inline Formatting Context）</li><li>其它</li></ul></li><li>JS引擎解析过程<ul><li>JS的解释阶段</li><li>JS的预处理阶段</li><li>JS的执行阶段</li><li>回收机制</li></ul></li><li>其它</li><li>总结</li></ul><h2 id="梳理主干流程">梳理主干流程</h2><p>回到这道题上，如何回答呢？先梳理一个骨架：</p><p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。</p><p>所以，先梳理下<strong>主干流程</strong>：</p><ol><li><p>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</p></li><li><p>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</p></li><li><p>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</p></li><li><p>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</p></li><li><p>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</p></li><li><p>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</p></li><li><p>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</p></li><li><p>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p></li><li><p>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</p></li></ol><p>梳理出主干骨架，然后就需要往骨架上填充细节内容。</p><h2 id="从浏览器接收url到开启网络请求线程">从浏览器接收url到开启网络请求线程</h2><p>这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制</p><h3 id="多进程的浏览器">多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p><p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><h3 id="多线程的浏览器内核">多线程的浏览器内核</h3><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617155831182.png" alt="image-20240617155831182"></p><p>可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的</p><p>JS引擎，也被称为JavaScript引擎，是浏览器中用来解析和执行JavaScript代码的一个组件。它的主要任务是将开发人员编写的JavaScript代码转换（或者说&quot;解释&quot;）为可以被计算机硬件执行的低级机器代码。</p><h3 id="解析URL">解析URL</h3><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p><p>URL一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li><li><code>host</code>，主机域名或IP地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li></ul><h3 id="网络请求都是单独的线程">网络请求都是单独的线程</h3><p><strong>每次网络请求时都需要开辟单独的线程进行</strong>，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p><p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p><h2 id="开启网络线程到发出一个完整的http请求">开启网络线程到发出一个完整的http请求</h2><p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等</p><p>仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）</p><h3 id="DNS查询得到IP">DNS查询得到IP</h3><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p><p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化。</p><p><strong><code>dns-prefetch</code>优化</strong></p><p><code>dns-prefetch</code> 是一种 DNS 预解析技术，它是浏览器用来优化页面加载速度的一种方式。</p><p>当你在网页中使用 <code>dns-prefetch</code>，浏览器会在用户点击链接或者页面开始加载前就去解析这个链接的 DNS。这样当用户真正需要访问这个链接时，DNS 的解析时间就已经被节省下来了，从而可以加速页面的加载。</p><p>在 HTML 中，你可以通过在 <code>&lt;link&gt;</code> 标签中设置 <code>rel=&quot;dns-prefetch&quot;</code> 来使用这个功能，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码会告诉浏览器预先解析 <code>example.com</code> 这个域名的 DNS。这在你的网页中有大量来自 <code>example.com</code> 的资源需要加载，或者预计用户会点击一个指向 <code>example.com</code> 的链接时，可以显著提升页面的加载速度。</p><p>但是，需要注意的是，<code>dns-prefetch</code> 并不是所有的浏览器都支持。在使用时，你应该检查你的目标浏览器是否支持这个功能。</p><p>简单来说：<strong>dns-prefetch可以理解成提前加载浏览器中链接要请求的DNS服务器地址</strong>。</p><p><strong>补充：DNS</strong></p><p>DNS，全称为域名系统（Domain Name System），它是一个用于将域名转换为 IP 地址的分布式数据库系统。在互联网上，每个连接到网络的设备都有一个独一无二的 IP 地址，就像我们的家庭地址一样。但是，记住一串数字并不方便，所以我们使用更易记忆的域名，比如 <a href="https://www.coze.com/">www.coze.com</a>。</p><p>当你在浏览器中输入一个域名并按下 Enter 键时，浏览器并不知道这个域名对应哪个服务器的 IP 地址。这时，它就需要向 DNS 服务器发送一个查询请求，DNS 服务器会查找它的数据库，找到这个域名对应的 IP 地址，并将它返回给浏览器。然后浏览器就可以通过这个 IP 地址连接到对应的服务器。</p><p>因此，我们可以将 DNS 看作是互联网的“电话簿”，它负责将易于人类理解的域名转化为机器可以理解的 IP 地址。</p><h3 id="tcp-ip请求">tcp/ip请求</h3><p>http的本质就是<code>tcp/ip</code>请求</p><p>需要了解3次握手规则建立连接以及断开连接时的四次挥手</p><p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输</p><p><strong>三次握手的步骤：（抽象派）</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是<span class="keyword">server</span>么？</span><br><span class="line">服务端：hello，我是<span class="keyword">server</span>，你是<span class="keyword">client</span>么</span><br><span class="line">客户端：yes，我是<span class="keyword">client</span></span><br></pre></td></tr></table></figure><p>建立连接成功后，接下来就正式传输数据</p><p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p><p><strong>四次挥手的步骤：（抽象派）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><p><strong>tcp/ip的并发限制</strong></p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）</p><p>而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p><p>所以针对这个瓶颈，又出现了很多的资源优化方案</p><p><strong>get和post的区别</strong></p><p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p><p><strong>get会产生一个tcp数据包，post两个</strong></p><p>具体就是：</p><ul><li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应200（返回数据）。</li></ul><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p><p><strong>解释</strong>：</p><p><strong>这种设计主要是基于HTTP/1.1协议中的&quot;Expect: 100-continue&quot;头信息。这是一种优化机制</strong>，<strong>它允许客户端询问服务器是否愿意接收其请求（基于请求头信息），在服务器响应100 Continue后，客户端才会发送请求体内容。</strong></p><p>这种设计的主要优点有两个：</p><ol><li><strong>节省带宽</strong>：在发送大量数据到服务器之前，客户端可以先检查服务器是否会接受这个请求（比如，检查认证是否成功，或者内容类型是否正确）。如果服务器拒绝了请求，那么就可以在发送大量数据并浪费带宽之前就终止这个请求。</li><li><strong>减少服务器负担</strong>：通过这种方式，服务器可以在接收到大量数据之前就拒绝请求，这样可以防止恶意或者错误的请求浪费服务器的资源。</li></ol><p>然而，需要注意的是，并非所有的POST请求都会这样处理，这取决于客户端是否发送了&quot;Expect: 100-continue&quot;头信息。而在某些情况下，例如小数据量的POST请求，或者在低延迟的网络环境下，使用&quot;Expect: 100-continue&quot;可能会导致性能下降，因为它需要等待服务器的100 Continue响应。所以这个特性应该根据具体情况来使用。</p><h3 id="五层因特网协议栈">五层因特网协议栈</h3><p>其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念</p><p>其实就是一个概念： <strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p><p>简括就是：</p><p><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p><p>当然，服务端的接收就是反过来的步骤</p><p>五层因特网协议栈其实就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line"></span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line"></span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line"></span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line"></span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure><p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。</p><p>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line"></span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure><h2 id="从服务器接收到请求到对应后台接收到请求">从服务器接收到请求到对应后台接收到请求</h2><p>服务端在接收到请求时，内部会进行很多的处理</p><p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入</p><h2 id="负载均衡">负载均衡</h2><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</p><p>当然了，负载均衡不止这一种实现方式，这里不深入…</p><p>简单的说：</p><p><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong></p><h2 id="后台的处理">后台的处理</h2><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如tomcat容器）</li><li>然后对应容器中的后台程序接收到请求（如java程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互</li></ul><h2 id="后台和前台的http交互">后台和前台的http交互</h2><p>前后端交互时，http报文作为信息的载体</p><p>所以http是一块很重要的内容，这一部分重点介绍它</p><h3 id="http报文结构">http报文结构</h3><p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p><p><strong>通用头部</strong></p><p>这也是开发人员见过的最多的信息，包括如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line"></span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line"></span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line"></span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure><p>譬如，在跨域拒绝时，可能是method为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p><p>其中，Method的话一般分为两批次：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP1<span class="number">.0</span>定义了三种请求方法： <span class="keyword">GET</span>, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、<span class="keyword">DELETE</span>、LINK、UNLINK</span><br><span class="line"></span><br><span class="line">HTTP1<span class="number">.1</span>定义了八种请求方法：<span class="keyword">GET</span>、POST、HEAD、<span class="keyword">OPTIONS</span>, PUT, <span class="keyword">DELETE</span>, TRACE 和 <span class="keyword">CONNECT</span> 方法。</span><br></pre></td></tr></table></figure><p><code>HTTP 1.0</code>定义参考：<a href="https://tools.ietf.org/html/rfc1945">https://tools.ietf.org/html/rfc1945</a></p><p><code>HTTP 1.1</code>定义参考：<a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a></p><p>这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再列举下大致不同范围状态的意义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617161636603.png" alt="image-20240617161636603"></p><p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索</p><p><strong>请求/响应头部</strong></p><p>请求和响应头部也是分析时常用到的</p><p>常用的请求头部（部分）：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Accept</span><span class="operator">:</span> 接收类型，表示浏览器支持的<span class="variable">MIME</span>类型</span><br><span class="line">（对标服务端返回的<span class="variable">Content</span><span class="operator">-</span><span class="variable">Type</span>）</span><br><span class="line"><span class="variable">Accept</span><span class="operator">-</span><span class="variable">Encoding</span>：浏览器支持的压缩类型<span class="operator">,</span>如<span class="variable">gzip</span>等<span class="operator">,</span>超出类型不能接收</span><br><span class="line"><span class="variable">Content</span><span class="operator">-</span><span class="variable">Type</span>：客户端发送出去实体内容的类型</span><br><span class="line"><span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">:</span> 指定请求和响应遵循的缓存机制，如<span class="variable">no</span><span class="operator">-</span><span class="variable">cache</span></span><br><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="variable">Modified</span><span class="operator">-</span><span class="variable">Since</span>：对应服务端的<span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span>，用来匹配看文件是否变动，只能精确到<span class="number">1</span><span class="variable">s</span>之内，<span class="variable">http1</span><span class="number">.0</span>中</span><br><span class="line"><span class="variable">Expires</span>：缓存控制，在这个时间内不会请求，直接使用缓存，<span class="variable">http1</span><span class="number">.0</span>，而且是服务端时间</span><br><span class="line"><span class="built_in">Max</span><span class="operator">-</span><span class="variable">age</span>：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，<span class="variable">http1</span><span class="number">.1</span>中</span><br><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span>：对应服务端的<span class="variable">ETag</span>，用来匹配文件内容是否改变（非常精确），<span class="variable">http1</span><span class="number">.1</span>中</span><br><span class="line"><span class="variable">Cookie</span><span class="operator">:</span> 有<span class="variable">cookie</span>并且同域访问时会自动带上</span><br><span class="line"><span class="variable">Connection</span><span class="operator">:</span> 当浏览器与服务器通信时对于长连接如何进行处理<span class="operator">,</span>如<span class="variable">keep</span><span class="operator">-</span><span class="variable">alive</span></span><br><span class="line"><span class="variable">Host</span>：请求的服务器<span class="built_in">URL</span></span><br><span class="line"><span class="variable">Origin</span>：最初的请求是从哪里发起的（只会精确到端口）<span class="operator">,</span><span class="variable">Origin</span>比<span class="variable">Referer</span>更尊重隐私</span><br><span class="line"><span class="variable">Referer</span>：该页面的来源<span class="built_in">URL</span><span class="punctuation">(</span>适用于所有类型的请求，会精确到详细页面地址，<span class="variable">csrf</span>拦截常用到这个字段<span class="punctuation">)</span></span><br><span class="line"><span class="variable">User</span><span class="operator">-</span><span class="variable">Agent</span>：用户客户端的一些必要信息，如<span class="variable">UA</span>头部等</span><br></pre></td></tr></table></figure><p>常用的响应头部（部分）：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Access</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">-</span><span class="variable">Allow</span><span class="operator">-</span><span class="built_in">Headers</span><span class="operator">:</span> 服务器端允许的请求<span class="built_in">Headers</span></span><br><span class="line"><span class="variable">Access</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">-</span><span class="variable">Allow</span><span class="operator">-</span><span class="variable">Methods</span><span class="operator">:</span> 服务器端允许的请求方法</span><br><span class="line"><span class="variable">Access</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">-</span><span class="variable">Allow</span><span class="operator">-</span><span class="variable">Origin</span><span class="operator">:</span> 服务器端允许的请求<span class="variable">Origin</span>头部（譬如为<span class="operator">*</span>）</span><br><span class="line"><span class="variable">Content</span><span class="operator">-</span><span class="variable">Type</span>：服务端返回的实体内容的类型</span><br><span class="line"><span class="built_in">Date</span>：数据从服务器发送的时间</span><br><span class="line"><span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span>：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line"><span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span>：请求资源的最后修改时间</span><br><span class="line"><span class="variable">Expires</span>：应该在什么时候认为文档已经过期<span class="operator">,</span>从而不再缓存它</span><br><span class="line"><span class="built_in">Max</span><span class="operator">-</span><span class="variable">age</span>：客户端的本地资源应该缓存多少秒，开启了<span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span>后有效</span><br><span class="line"><span class="variable">ETag</span>：请求变量的实体标签的当前值</span><br><span class="line"><span class="built_in">Set</span><span class="operator">-</span><span class="variable">Cookie</span>：设置和页面关联的<span class="variable">cookie</span>，服务器通过这个头部把<span class="variable">cookie</span>传给客户端</span><br><span class="line"><span class="variable">Keep</span><span class="operator">-</span><span class="variable">Alive</span>：如果客户端有<span class="variable">keep</span><span class="operator">-</span><span class="variable">alive</span>，服务端也会有响应（如<span class="variable">timeout</span><span class="operator">=</span><span class="number">38</span>）</span><br><span class="line"><span class="variable">Server</span>：服务器的一些相关信息</span><br></pre></td></tr></table></figure><p>一般来说，请求头部和响应头部是匹配分析的。</p><p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p><p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p><p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应</p><p>还有很多的分析方法，这里不一一赘述</p><p><strong>请求/响应实体</strong></p><p>http请求时，除了头部，还有消息实体，一般来说</p><p>请求实体中会将一些需要的参数都放入进入（用于post请求）。</p><p>譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等</p><p>而一般响应实体中，就是放服务端需要传给客户端的内容</p><p>一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。</p><p><strong>CRLF</strong></p><p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在</p><p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p><p>一般来说（分隔符类别）：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CRLF</span>-&gt;Windows-style</span><br><span class="line"><span class="keyword">LF</span>-&gt;Unix Style</span><br><span class="line"><span class="keyword">CR</span>-&gt;Mac Style</span><br></pre></td></tr></table></figure><p>如下图是对某请求的http报文结构的简要分析</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617161749694.png" alt="image-20240617161749694"></p><h3 id="cookie以及优化">cookie以及优化</h3><p>cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。</p><p>场景如下（简述）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line"></span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line"></span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line"></span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line"></span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）</p><p>一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）</p><p>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p><p>譬如以下场景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名<span class="selector-tag">A</span>下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line"></span><br><span class="line">然后在域名<span class="selector-tag">A</span>下有一个页面，页面中有很多依赖的静态资源（都是域名<span class="selector-tag">A</span>的，譬如有<span class="number">20</span>个静态资源）</span><br><span class="line"></span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line"></span><br><span class="line">也就是说，这<span class="number">20</span>个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line"></span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li></ul><h3 id="gzip压缩">gzip压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且gzip压缩效率很好（高达70%左右）</p><p>然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启</p><p>当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）</p><p>所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的， 非常方便。</p><h3 id="长连接与短连接">长连接与短连接</h3><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p><h3 id="http-2-0">http 2.0</h3><p>http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）</p><p>然后简述下http2.0与http1.1的显著不同点：</p><ul><li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p><p>然后简述下http2.0的一些特性：</p><ul><li>多路复用（即一个tcp/ip连接可以请求多个资源）</li><li>首部压缩（http头部压缩，减少体积）</li><li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li></ul><p>✳<strong>详细解释</strong>：</p><p>HTTP/2.0引入了一种被称为“多路复用”的技术。在HTTP/1.x中，每个资源请求都需要一个单独的TCP连接，这意味着如果一个网页有多个资源（图片、CSS、JavaScript等），那么浏览器就需要建立多个TCP连接，这会消耗更多时间和网络带宽。</p><p>而在HTTP/2.0中，所有的资源请求都通过一个单一的TCP连接发送，这个连接可以同时处理多个请求和响应，这就是所谓的“多路复用”。</p><p>举个例子，假设有一个网页，这个网页有1个HTML文件，3个CSS文件，5个JavaScript文件和10个图片。在HTTP/1.x中，浏览器需要建立19个TCP连接，每个连接处理一个资源请求。而在HTTP/2.0中，所有的19个资源请求都通过一个TCP连接发送，大大提高了加载速度。</p><p>这就像是你去购物，HTTP/1.x的方式就像是你每买一样商品都要排一次队付款，而HTTP/2.0的方式就像是你把所有的商品都放在购物车里，然后一次性排队付款。显然，后者更加高效。</p><p>再举一个例子，如果你在看一部在线视频，视频被切割成了许多小段。在HTTP/1.x中，每一小段视频都需要一个TCP连接去请求，而在HTTP/2.0中，所有的小段视频都通过一个TCP连接请求，这样可以减少网络延迟，提高视频的加载速度。</p><h3 id="https">https</h3><p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。</p><p>简单来看，https与http的区别就是： <strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p><p>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）</p><p>一般来说，主要关注的就是SSL/TLS的握手流程，如下（简述）：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client <span class="built_in">random</span>和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 服务端从中选出一组加密算法与<span class="built_in">Hash</span>算法，回复一个随机数–Server <span class="built_in">random</span>，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 浏览器收到服务端的证书后</span><br><span class="line">    </span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line">    </span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<span class="string">`Premaster secret`</span>，发送给服务器。</span><br><span class="line">    </span><br><span class="line">    - 利用Client <span class="built_in">random</span>、Server <span class="built_in">random</span>和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-<span class="string">`session key`</span></span><br><span class="line">    </span><br><span class="line">    - 使用约定好的<span class="built_in">HASH</span>算法计算握手消息，并使用生成的<span class="string">`session key`</span>对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span> 服务端收到浏览器的回复</span><br><span class="line"></span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取<span class="string">`Premaster secret`</span></span><br><span class="line">    </span><br><span class="line">    - 和浏览器相同规则生成<span class="string">`session key`</span></span><br><span class="line">    </span><br><span class="line">    - 使用<span class="string">`session key`</span>解密浏览器发来的握手消息，并验证<span class="built_in">Hash</span>是否与浏览器发来的一致</span><br><span class="line">    </span><br><span class="line">    - 使用<span class="string">`session key`</span>加密一段握手消息，发送给浏览器</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 浏览器解密并计算握手消息的<span class="built_in">HASH</span>，如果与服务端发来的<span class="built_in">HASH</span>一致，此时握手过程结束，</span><br></pre></td></tr></table></figure><p><strong>之后所有的https通信数据将由之前浏览器生成的<code>session key</code>并利用对称加密算法进行加密</strong></p><p>这里放一张图（来源：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰-图解SSL/TLS协议</a>）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617162617015.png" alt="image-20240617162617015"></p><h2 id="http的缓存">http的缓存</h2><p>前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的。</p><h3 id="强缓存与弱缓存">强缓存与弱缓存</h3><p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）</p><p>区别简述如下：</p><ul><li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li><li>协商缓存（<code>304</code>）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效</p><p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p><h3 id="缓存头部简述">缓存头部简述</h3><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？</p><p>答案是通过不同的http头部控制</p><p>先看下这几个头部：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span><span class="operator">/</span><span class="built_in">E</span><span class="operator">-</span><span class="variable">tag</span>、<span class="built_in">If</span><span class="operator">-</span><span class="variable">Modified</span><span class="operator">-</span><span class="variable">Since</span><span class="operator">/</span><span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span>、<span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">/</span><span class="built_in">Max</span><span class="operator">-</span><span class="variable">Age</span>、<span class="variable">Pragma</span><span class="operator">/</span><span class="variable">Expires</span></span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。</p><p>属于强缓存控制的：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1<span class="number">.1</span>）<span class="keyword">Cache</span><span class="params">-Control</span>/<span class="keyword">Max</span><span class="params">-Age</span></span><br><span class="line">（http1<span class="number">.0</span>）Pragma/Expires</span><br></pre></td></tr></table></figure><p>注意：<strong><code>Max-Age</code>不是一个头部，它是<code>Cache-Control</code>头部的值</strong></p><p>属于协商缓存控制的：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="variable">http1</span><span class="number">.1</span>）<span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span><span class="operator">/</span><span class="built_in">E</span><span class="operator">-</span><span class="variable">tag</span></span><br><span class="line">（<span class="variable">http1</span><span class="number">.0</span>）<span class="built_in">If</span><span class="operator">-</span><span class="variable">Modified</span><span class="operator">-</span><span class="variable">Since</span><span class="operator">/</span><span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span></span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同http时期的</p><p>再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META <span class="attribute">HTTP-EQUIV</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attribute">CONTENT</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐</p><h3 id="头部的区别">头部的区别</h3><p>首先明确，http的发展是从http1.0到http1.1</p><p>而在http1.1中，出了一些新内容，弥补了http1.0的不足。</p><p><strong>http1.0中的缓存控制：</strong></p><ul><li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li><li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li><li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li></ul><p><strong>http1.1中的缓存控制：</strong></p><ul><li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li><li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li><li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><p><strong>Max-Age相比Expires？</strong></p><p><code>Expires</code>使用的是服务器端的时间</p><p>但是有时候会有这样一种情况-客户端时间和服务端不同步</p><p>那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期</p><p>所以一般http1.1后不推荐使用<code>Expires</code></p><p>而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题</p><p>因此推荐使用<code>Max-Age</code>。</p><p>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p><p><strong>E-tag相比Last-Modified？</strong></p><p><code>Last-Modified</code>：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>而<code>E-tag</code>：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code></p><p>各大缓存头部的整体关系如下图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163035634.png" alt="image-20240617163035634"></p><h2 id="解析页面流程">解析页面流程</h2><p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染</p><h3 id="流程简述">流程简述</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 解析HTML，构建DOM树</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 解析CSS，生成CSS规则树</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 合并DOM树和CSS规则，生成render树</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 绘制render树（paint），绘制页面像素信息</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163118510.png" alt="image-20240617163118510"></p><h3 id="HTML解析，构建DOM">HTML解析，构建DOM</h3><p>整个渲染步骤中，HTML解析是第一步。</p><p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p><p>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。</p><p>解析HTML到构建出DOM当然过程可以简述如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → <span class="built_in">characters</span> → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;awesome-photo.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器的处理如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163136854.png" alt="image-20240617163136854"></p><p>列举其中的一些重点过程：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Conversion</span>转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure><p>最后的DOM树如下</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163154312.png" alt="image-20240617163154312"></p><h3 id="生成CSS规则">生成CSS规则</h3><p>同理，CSS规则树的生成也是类似。简述为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → <span class="built_in">characters</span> → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163213869.png" alt="image-20240617163213869"></p><h3 id="构建渲染树">构建渲染树</h3><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了</p><p>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应</p><p>因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等</p><p>整体来说可以看图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163239352.png" alt="image-20240617163239352"></p><h3 id="渲染">渲染</h3><p>有了render树，接下来就是开始渲染，基本流程如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163307907.png" alt="image-20240617163307907"></p><p>图中重要的四个步骤就是：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 计算CSS样式</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 构建渲染树</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure><p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）</p><p>这里Layout和Repaint的概念是有区别的：</p><ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。</p><p><strong>什么会引起回流？</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.页面渲染初始化</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="selector-class">.DOM</span>结构改变，比如删除了某个节点</span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="selector-class">.render</span>树变化，比如减少了<span class="attribute">padding</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.窗口<span class="attribute">resize</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （<span class="number">1</span>）offset(<span class="attribute">Top</span>/<span class="attribute">Left</span>/<span class="attribute">Width</span>/<span class="attribute">Height</span>)</span><br><span class="line">     (<span class="number">2</span>) scroll(<span class="attribute">Top</span>/<span class="attribute">Left</span>/<span class="attribute">Width</span>/<span class="attribute">Height</span>)</span><br><span class="line">     (<span class="number">3</span>) cilent(<span class="attribute">Top</span>/<span class="attribute">Left</span>/<span class="attribute">Width</span>/<span class="attribute">Height</span>)</span><br><span class="line">     (<span class="number">4</span>) <span class="attribute">width</span>,<span class="attribute">height</span></span><br><span class="line">     (<span class="number">5</span>) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure><p>回流一定伴随着重绘，重绘却可以单独出现</p><p>所以一般会有一些优化方案，如：</p><ul><li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li><li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><strong>注意：改变字体大小会引发回流</strong></p><p>再来看一个示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = <span class="string">&quot;2px&quot;</span>; <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">&quot;1px solid red&quot;</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">&quot;blue&quot;</span>; <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">&quot;#ccc&quot;</span>; <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">&quot;14px&quot;</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;abc!&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="简单层与复合层">简单层与复合层</h3><p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。</p><p>这里不展开，进简单介绍下：</p><ul><li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li><li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li><li>复合图层之间的绘制互不干扰，由GPU直接控制</li><li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul><p>更多参考：</p><p><a href="https://segmentfault.com/a/1190000012925872#articleHeader16">普通图层和复合图层</a></p><h3 id="Chrome中的调试">Chrome中的调试</h3><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163457951.png" alt="image-20240617163457951"></p><h3 id="资源外链的下载">资源外链的下载</h3><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p><p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><p><strong>遇到外链时的处理</strong></p><p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p><p><strong>遇到CSS样式资源</strong></p><p>CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建DOM树</li><li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><p><strong>遇到JS脚本资源</strong></p><p>JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p><p>简单的说（不展开）：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><p><strong>遇到img图片类资源</strong></p><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p><h3 id="loaded和domcontentloaded">loaded和domcontentloaded</h3><p>简单的对比：</p><ul><li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li><li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><h2 id="CSS的可视化格式模型">CSS的可视化格式模型</h2><p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong></p><p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong></p><p>先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li><li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p><p>关键字：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（<span class="built_in">Containing</span> <span class="built_in">Block</span>）</span><br><span class="line">控制框（<span class="variable">Controlling</span> <span class="built_in">Box</span>）</span><br><span class="line"><span class="variable">BFC</span>（<span class="built_in">Block</span> <span class="variable">Formatting</span> <span class="built_in">Context</span>）</span><br><span class="line"><span class="variable">IFC</span>（<span class="variable">Inline</span> <span class="variable">Formatting</span> <span class="built_in">Context</span>）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p><h3 id="包含块（Containing-Block）">包含块（Containing Block）</h3><p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。</p><p>元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</p><p>譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul><h3 id="控制框（Controlling-Box）">控制框（Controlling Box）</h3><p>块级元素和块框以及行内元素和行框的相关概念</p><p><strong>块框:</strong></p><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;DIV&gt;</span></span><br><span class="line"><span class="attribute">Some</span> text</span><br><span class="line"><span class="section">&lt;P&gt;</span><span class="attribute">More</span> text</span><br><span class="line"><span class="section">&lt;/DIV&gt;</span></span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p><p>换句话说:</p><p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p><p><strong>行内框：</strong></p><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>Some <span class="tag">&lt;<span class="name">EM</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="name">EM</span>&gt;</span> text<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some </code>，<code> text</code>，此时会专门为这些文本生成匿名行内框</p><p><strong>display属性的影响</strong></p><p><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的行内框</li><li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li><li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li></ul><h3 id="BFC（Block-Formatting-Context）">BFC（Block Formatting Context）</h3><p>FC（格式上下文）？</p><p>FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FC</span>像是一个大箱子，里面装有很多元素</span><br><span class="line"></span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响<span class="built_in">FC</span>内部的渲染）</span><br><span class="line"></span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure><p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC</p><p><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong></p><p><strong>BFC规则：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line"></span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line"></span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line"></span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure><p>总结几点BFC特点：</p><ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li><li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li><li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li><li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol><p>如何触发BFC？</p><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li><li><code>overflow</code>不为<code>visible</code></li></ol><p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC</p><p>更多请自行网上搜索</p><h3 id="IFC（Inline-Formatting-Context）">IFC（Inline Formatting Context）</h3><p>IFC即行内框产生的格式上下文</p><p><strong>IFC规则</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line"></span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line"></span><br><span class="line">水平方向上的 <span class="attribute">margin</span>，<span class="attribute">border</span> 和 <span class="attribute">padding</span> 在框之间得到保留</span><br><span class="line"></span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure><p><strong>行框</strong></p><p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p><p>行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定</p><p>行框的规则：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line"></span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line"></span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line"></span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure><p><strong>结合补充下IFC规则：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line"></span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line"></span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line"></span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `<span class="attribute">text-align</span>` 特性</span><br><span class="line"></span><br><span class="line">空的行内框应该被忽略</span><br><span class="line"></span><br><span class="line">即不包含文本，保留空白符，<span class="attribute">margin</span>/<span class="attribute">padding</span>/<span class="attribute">border</span>非<span class="number">0</span>的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul><p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）</p><p>但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解</p><h3 id="其它">其它</h3><p>当然还有有一些其它内容：</p><ul><li>譬如常规流，浮动，绝对定位等区别</li><li>譬如浮动元素不包含在常规流中</li><li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li><li>譬如<code>z-index</code>的分层显示机制等</li></ul><p>这里不一一展开，更多请参考：</p><p><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a></p><h2 id="JS引擎解析过程">JS引擎解析过程</h2><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）</p><h3 id="JS的解释阶段">JS的解释阶段</h3><p>首先得明确： <strong>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</strong></p><p>补充：</p><p><strong>编译型语言</strong>：<br>在编译型语言中，<strong>代码在执行前需要通过编译器转换为机器语言</strong>。这个转换过程被称为编译，它通常在代码运行前完成。一旦代码被编译，就可以直接在机器上运行，无需再次编译。编译型语言的优点是运行速度快，因为它直接运行机器代码。而缺点是跨平台性较差，不同的操作系统或硬件平台需要单独编译。C和C++是典型的编译型语言。</p><p><strong>解释型语言</strong>：<br>在解释型语言中，<strong>代码不是在运行前编译的，而是通过解释器在运行时逐行解释和执行</strong>。解释型语言的优点是跨平台性好，同一份代码可以在不同的平台上运行，只要这个平台上有对应的解释器。而缺点是运行速度相对较慢，因为需要逐行解释执行。Python和JavaScript是典型的解释型语言。</p><p><strong>Version1：</strong></p><p>引擎对JS的处理过程可以简述如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure><p><strong>Version2：</strong></p><p>JavaScript引擎的工作流程大致如下：</p><ol><li><strong>解析阶段</strong>：JS引擎首先会解析JavaScript代码，将其转化为一个叫做抽象语法树（AST）的数据结构。这个AST会包含所有的变量、函数、操作符以及它们之间的关系。</li><li><strong>编译阶段</strong>：然后，JS引擎会将AST编译为字节码或者直接编译为机器代码。这一步使得代码可以被计算机硬件执行。</li><li><strong>执行阶段</strong>：最后，JS引擎执行编译后的代码。</li></ol><p>值得一提的是，现代的JS引擎，比如V8（被Chrome和Node.js使用）或SpiderMonkey（被Firefox使用），使用了一种叫做即时编译（JIT）的技术，可以在JavaScript代码执行的同时进行编译，大大提高了代码的执行效率。</p><hr><p>最终计算机执行的就是机器码。</p><p>为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）</p><p>即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）</p><p>这样整个程序的运行速度能得到显著提升。</p><p>而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）</p><p>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行</strong></p><h3 id="JS的预处理阶段">JS的预处理阶段</h3><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等）</p><p>预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：</p><p><strong>分号补全</strong></p><p>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原因就是JS解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号</p><p>譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li><li>当有<code>&#125;</code>时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure><p>所以可以正常运行</p><p>当然了，这里有一个经典的例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">b</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="type">&#123;</span></span><br><span class="line">        a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code></p><p><strong>变量提升</strong></p><p>一般包括函数提升和变量提升</p><p>譬如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的</p><p>譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等</p><h3 id="JS的执行阶段">JS的执行阶段</h3><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a></p><p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p><p><strong>执行上下文简单解释</strong></p><ul><li>JS有<code>执行上下文</code>）</li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617164435479.png" alt="image-20240617164435479"></p><p>然后执行上下文与VO，作用域链，this的关系是：</p><p>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617164445984.png" alt="image-20240617164445984"></p><p><strong>VO与AO</strong></p><p>VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong></p><p>AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了</p><p>可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）</p><p><strong>作用域链</strong></p><p>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。</p><p>譬如流程简述：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line"></span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line"></span><br><span class="line">否则去它的父级作用域链中（<span class="emphasis">__parent__</span>）找</span><br><span class="line"></span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line"></span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617164504825.png" alt="image-20240617164504825"></p><p><strong>this指针</strong></p><p>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分</p><p>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong></p><p>因此:</p><ul><li>this是没有一个类似搜寻变量的过程</li><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    <span class="attr">baz</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.<span class="built_in">log</span>(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = bar.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入环境：global</span></span><br><span class="line">foo(); <span class="comment">// 200，严格模式中会报错，Cannot read property &#x27;baz&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入环境：global bar</span></span><br><span class="line">bar.foo(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>就要明白了上面this的介绍，上述例子很好理解</p><p>更多参考：</p><p><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html">深入理解JavaScript系列（13）：This? Yes,this!</a></p><h3 id="回收机制">回收机制</h3><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。</p><p>一般来说，垃圾处理器有自己的回收策略。</p><p>譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）</p><p>常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>譬如：（出自javascript高程）</p><blockquote><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</p></blockquote><blockquote><p>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p></blockquote><blockquote><p>而当变量离开环境时，则将其标记为“离开环境”。</p></blockquote><blockquote><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</p></blockquote><blockquote><p>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。</p></blockquote><blockquote><p>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</p></blockquote><blockquote><p>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>关于引用计数，简单点理解：</p><p><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数<code>+1</code>，减持时<code>-1</code>，下次垃圾回收器会回收次数为<code>0</code>的值的内存（当然了，容易出循环引用的bug）</strong></p><p><strong>GC的缺陷</strong></p><p>和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong></p><p>这是为了安全考虑。</p><p>而Javascript的GC在<code>100ms</code>甚至以上</p><p>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。</p><p>这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong></p><p><strong>GC优化策略</strong></p><p>这里介绍常用到的：<strong>分代回收（Generation GC）</strong></p><p>目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）</p><p>更多可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/33816534">V8 内存浅析</a></p><p>JavaScript可以用来做以下事情：</p><ol><li><strong>动态修改HTML和CSS</strong>：JavaScript可以动态地改变HTML的内容和CSS的样式，从而使网页内容更加丰富和生动。</li><li><strong>处理用户交互</strong>：JavaScript可以响应用户的操作，比如点击、滑动、键盘输入等，使得网页具有更好的交互性。</li><li><strong>创建动画和游戏</strong>：JavaScript可以用来制作动画、小游戏等，提高用户的使用体验。</li><li><strong>与服务器交互</strong>：JavaScript可以通过Ajax技术向服务器发送请求或接收数据，实现网页的异步更新。</li></ol><p>本文学习自：<a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p>]]></content>
    
    
    <summary type="html">在浏览器输入URL回车之后发生了什么？</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Kafka核心知识总结</title>
    <link href="https://penge666.github.io/posts/68ad5ab4.html"/>
    <id>https://penge666.github.io/posts/68ad5ab4.html</id>
    <published>2024-06-06T14:48:06.000Z</published>
    <updated>2024-06-06T14:49:11.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本简介">基本简介</h2><p>Apache Kafka是由LinkedIn采用Scala和Java开发的开源流处理软件平台，并捐赠给了Apache Software Foundation。</p><p>该项目旨在提供统一的、高吞吐量、低延迟的平台来处理实时数据流。</p><p>Kafka可以通过Kafka Connect连接到外部系统，并提供了Kafka Streams。</p><p><strong>「Kafka的特性」</strong></p><p>Kafka是一种分布式的，基于发布/订阅的消息系统，主要特性如下：</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">分布式</th><th style="text-align:left"><strong>「高性能」</strong></th><th style="text-align:left"><strong>「持久性和扩展性」</strong></th></tr></thead><tbody><tr><td style="text-align:left">描述</td><td style="text-align:left">多分区</td><td style="text-align:left">高吞吐量</td><td style="text-align:left">数据可持久化</td></tr><tr><td style="text-align:left">多副本</td><td style="text-align:left">低延迟</td><td style="text-align:left">容错性</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">多订阅者</td><td style="text-align:left">高并发</td><td style="text-align:left">支持水平在线扩展</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">基于ZooKeeper调度</td><td style="text-align:left">时间复杂度为O(1)</td><td style="text-align:left">消息自动平衡</td><td style="text-align:left"></td></tr></tbody></table><h2 id="版本号">版本号</h2><p><strong>「Kafka版本命名」</strong></p><p>我们在官网上下载Kafka时，会看到这样的版本：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606215953532.png" alt="image-20240606215953532"></p><p>前面的版本号是编译Kafka源代码的Scala编译器版本。</p><p><strong>Kafka服务器端的代码完全由Scala语言编写</strong>，Scala同时支持面向对象编程和函数式编程，用Scala写成的源代码编译之后也是普通的<code>.class</code>文件，因此我们说Scala是JVM系的语言。</p><p>真正的Kafka版本号实际上是<code>2.1.1</code>。</p><p>前面的2表示大版本号，即Major Version；中间的1表示小版本号或次版本号，即Minor Version；最后的1表示修订版本号，也就是Patch号。</p><p>Kafka社区在发布1.0.0版本后写过一篇文章，宣布Kafka版本命名规则正式从4位演进到3位，比如0.11.0.0版本就是4位版本号。</p><p>有个建议，不论用的是哪个版本，都请尽量保持服务器端版本和客户端版本一致，否则你将损失很多Kafka为你提供的性能优化收益。</p><p><strong>「版本演进」</strong></p><p>0.7版本：只提供了最基础的消息队列功能。</p><p>0.8版本：引入了副本机制，至此kafka成为了一个整整意义上完备的分布式可靠消息队列解决方案</p><p>0.9.0.0版本：增加了基础的安全认证/权限功能；使用Java重新了新版本消费者API；引入了Kafka Connect组件。</p><p>0.11.0.0版本：提供了幂等性Producer API以及事务API；对Kafka消息格式做了重构。</p><p>1.0和2.0版本：主要还是Kafka Streams的各种改进</p><h2 id="基本概念">基本概念</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606220052414.png" alt="image-20240606220052414"></p><p><strong>「主题」</strong></p><p>发布订阅的对象是主题（<code>Topic</code>），可以为每 个业务、每个应用甚至是每类数据都创建专属的主题</p><p><strong>「生产者和消费者」</strong></p><p>向主题发布消息的客户端应用程序称为生产者，生产者程序通常持续不断地 向一个或多个主题发送消息</p><p>订阅这些主题消息的客户端应用程序就被称为消费者，消费者也能够同时订阅多个主题的消息</p><p><strong>「Broker」</strong></p><p>集群由多个 Broker 组成，<strong><code>Broker</code> 负责接收和处理客户端发送过来的请求，以及对消息进行持久化</strong></p><p>虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将 不同的 <code>Broker</code> 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面 运行的所有 Broker 进程都挂掉了，其他机器上的 <code>Broker</code> 也依然能够对外提供服务</p><p><strong>「备份机制」</strong></p><p>备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝被称为副本</p><p>定义了两类副本：领导者副本和追随者副本</p><p>前者对外提供服务，这里的对外指的是与 客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互</p><p><strong>「分区」</strong></p><p>分区机制指的是将每个主题划分成多个分区，每个分区是一组有序的消息日志</p><p>生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中</p><p>每个分区下可以配置若干个副本，其中只能有 1 个领 导者副本和 N-1 个追随者副本</p><p>生产者向分区写入消息，每条消息在分区中的位置信息叫位移</p><p><strong>「消费者组」</strong></p><p>多个消费者实例共同组成一个组来 消费一组主题</p><p>这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它</p><p>如果所有实例都属于同一个 <code>Group</code>， 那么它实现的就是消息队列模型；</p><p>如果所有实例分别属于不 同的 <code>Group</code>，那么它实现的就是发布/订阅模型</p><p><strong>「Coordinator：协调者」</strong></p><p>所谓<strong>协调者</strong>，它专门为Consumer Group服务，负责为Group<strong>执行Rebalance以及提供位移管理和组成员管理</strong>等。</p><p>具体来讲，Consumer端应用程序在提交位移时，其实是向Coordinator所在的Broker提交位移，同样地，当Consumer应用启动时，也是向Coordinator所在的Broker发送各种请求，然后由Coordinator负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><p>所有Broker在启动时，都会创建和开启相应的Coordinator组件。</p><p>也就是说，<strong>「所有Broker都有各自的Coordinator组件」</strong>。</p><p>那么，Consumer Group如何确定为它服务的Coordinator在哪台Broker上呢？</p><p>【简单说，知道你哪个分区，找到该分区的leader】</p><p>【※】生活中的例子</p><p>在Kafka中，主题<code>__consumer_offsets</code>是一个特别的内部主题，它用于存储所有消费者组的消费进度，也就是offset。</p><p>举个例子，假设你正在看一本有很多章节的书，你可能会用一个书签来记住你读到哪一页，这样当你下次继续阅读时，你就知道从哪里开始。在这个例子中，书签就像是Kafka中的offset，它记录了消费者读取到消息队列的哪个位置。</p><p>然后假设你和你的朋友们一起在读这本书，每个人可能会在不同的时间阅读，所以每个人的书签位置可能会不同。你们可能需要一个地方来记录每个人的书签位置，这样每个人都可以知道自己应该从哪里开始阅读。在这个例子中，记录书签位置的地方就像是Kafka中的<code>__consumer_offsets</code>主题，它存储了每个消费者组的消费进度。</p><p>所以，<code>__consumer_offsets</code>主题在Kafka中扮演了非常重要的角色，它确保了即使消费者挂掉或者重新启动，也能从上次消费的位置继续消费，保证了消息的连续性。</p><hr><p>首先，Kafka会计算该Group的<code>group.id</code>参数的哈希值。</p><p>比如你有个Group的<code>group.id</code>设置成了<code>test-group</code>，那么它的hashCode值就应该是627841412。</p><p>其次，Kafka会计算<code>__consumer_offsets</code>的分区数，通常是50个分区，之后将刚才那个哈希值对分区数进行取模加求绝对值计算，即<code>abs(627841412 % 50) = 12</code>。【判断在哪个分区上，因为分区是轮询确定的】</p><p>此时，我们就知道了<code>__consumer_offsets</code>主题的分区12负责保存这个Group的数据。</p><p>有了分区号，我们只需要找出<code>__consumer_offsets</code>主题分区12的Leader副本在哪个Broker上就可以了，这个Broker，就是我们要找的Coordinator。</p><p><strong>「消费者位移：Consumer Offset」</strong></p><p>消费者消费进度，每个消费者都有自己的消费者位移。</p><p><strong>「重平衡：Rebalance」</strong></p><p>消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。</p><p>Rebalance是Kafka消费者端实现高可用的重要手段。</p><p><strong>「AR（Assigned Replicas）」</strong>：分区中的所有副本统称为AR。</p><p>所有消息会先发送到leader副本，然后follower副本才能从leader中拉取消息进行同步。</p><p>但是在同步期间，follower对于leader而言会有一定程度的滞后，这个时候follower和leader并非完全同步状态</p><p><strong>「OSR（Out Sync Replicas）」</strong>：follower副本与leader副本没有完全同步或滞后的副本集合</p><p><strong>「ISR（In Sync Replicas）：「AR中的一个子集，ISR中的副本都」是与leader保持完全同步的副本」</strong>，如果某个在ISR中的follower副本落后于leader副本太多，则会被从ISR中移除，否则如果完全同步，会从OSR中移至ISR集合。</p><p>在默认情况下，当leader副本发生故障时，只有在ISR集合中的follower副本才有资格被选举为新leader，而OSR中的副本没有机会（可以通过<code>unclean.leader.election.enable</code>进行配置）</p><p><strong>「ISR（In Sync Replicas）：**「AR中的一个子集，ISR中的副本都」**是与leader保持完全同步的副本」</strong>，如果某个在ISR中的follower副本落后于leader副本太多，则会被从ISR中移除，否则如果完全同步，会从OSR中移至ISR集合。</p><p>在默认情况下，当leader副本发生故障时，只有在ISR集合中的follower副本才有资格被选举为新leader，而OSR中的副本没有机会（可以通过<code>unclean.leader.election.enable</code>进行配置）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606220849989.png" alt="image-20240606220849989"></p><p><strong>「LEO（Log End Offset）」</strong>：标识当前日志文件中下一条待写入的消息的offset</p><p>上图中offset为9的位置即为当前日志文件的 LEO，LEO 的大小相当于当前日志分区中最后一条消息的offset值加1</p><p>分区 ISR 集合中的每个副本都会维护自身的 LEO ，而 ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息。</p><h2 id="系统架构">系统架构</h2><p><strong>「kafka设计思想」</strong></p><p>一个最基本的架构是生产者发布一个消息到Kafka的一个Topic ，该Topic的消息存放于的Broker中，消费者订阅这个Topic，然后从Broker中消费消息，下面这个图可以更直观的描述这个场景：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606220909898.png" alt="image-20240606220909898"></p><p><strong>「消息状态：」</strong> 在Kafka中，消息是否被消费的状态保存在Consumer中，Broker不会关心消息是否被消费或被谁消费，Consumer会记录一个offset值（指向partition中下一条将要被消费的消息位置），如果offset被错误设置可能导致同一条消息被多次消费或者消息丢失。</p><p><strong>「消息持久化：」</strong> Kafka会把消息持久化到本地文件系统中，并且具有极高的性能。</p><p><strong>「批量发送：」</strong> Kafka支持以消息集合为单位进行批量发送，以提高效率。</p><p><strong>「Push-and-Pull：」</strong> Kafka中的Producer和Consumer采用的是Push-and-Pull模式，即Producer向Broker Push消息，Consumer从Broker Pull消息。</p><p><strong>「分区机制（Partition）：」</strong> Kafka的Broker端支持消息分区，Producer可以决定把消息发到哪个Partition，在一个Partition中消息的顺序就是Producer发送消息的顺序，一个Topic中的Partition数是可配置的，Partition是Kafka高吞吐量的重要保证。</p><p><strong>「系统架构」</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606221119878.png" alt="image-20240606221119878"></p><p>通常情况下，一个kafka体系架构包括**「多个Producer」<strong>、</strong>「多个Consumer」<strong>、</strong>「多个broker」<strong>以及</strong>「一个Zookeeper集群」**。</p><p><strong>「Producer」</strong>：生产者，负责将消息发送到kafka中。</p><p><strong>「Consumer」</strong>：消费者，负责从kafka中拉取消息进行消费。</p><p><strong>「Broker」</strong>：Kafka服务节点，一个或多个Broker组成了一个Kafka集群</p><p><strong>「Zookeeper集群」</strong>：负责管理kafka集群元数据以及控制器选举等。</p><h2 id="生产者分区">生产者分区</h2><p><strong>「为什么分区？」</strong></p><p>Kafka的消息组织方式实际上是三级结构：<strong>主题-分区-消息。</strong></p><p>主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。</p><p>其实分区的作用就是提供负载均衡的能力，或者说对数据进行分区的主要原因，就是为了实现系统的高伸缩性（Scalability）。</p><p>不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理，并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。</p><p><strong>解释下</strong>：</p><p>高伸缩性（Scalability）可以理解为一个系统在处理更大负载时，有能力通过升级或增加资源来提升处理能力的特性。在Kafka中，分区就是实现高伸缩性的一种方式。</p><p>比如，我们可以把一个超市看作是一个系统。如果超市的客流量增加，那么超市就需要提高处理能力来满足更多顾客的需求。一种方式是增加收银员的数量，这就相当于在Kafka中增加分区。每个收银员可以同时为一个顾客结账，就像每个分区可以同时处理一部分数据。当我们增加收银员的数量时，超市就能同时处理更多的顾客，这就提高了系统的伸缩性。</p><p>同样地，如果一个主题的数据量非常大，超过了一个服务器的处理能力，那么可以将这个主题分为多个分区，然后分布在多个服务器上。这样，就可以利用多台服务器的处理能力来处理这个主题的数据，从而提高系统的伸缩性。</p><p>总的来说，通过分区，Kafka可以实现高伸缩性，满足大数据处理的需求。</p><p><strong>「都有哪些分区策略？」</strong></p><p><strong>「所谓分区策略是决定生产者将消息发送到哪个分区的算法。」</strong></p><p>Kafka为我们提供了默认的分区策略，同时它也支持你自定义分区策略。</p><p><strong>「自定义分区策略」</strong></p><p>如果要自定义分区策略，你需要显式地配置生产者端的参数p<code>artitioner.class</code>。</p><p>在编写生产者程序时，你可以编写一个具体的类实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口。</p><p>这个接口也很简单，只定义了两个方法：partition()和close()，通常你只需要实现最重要的partition方法。</p><p>我们来看看这个方法的方法签名：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span>(<span class="built_in">String</span> topic, <span class="built_in">Object</span> <span class="built_in">key</span>, <span class="type">byte</span>[] keyBytes, <span class="built_in">Object</span> value, <span class="type">byte</span>[] valueBytes, Cluster cluster);</span><br></pre></td></tr></table></figure><p>这里的topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息（比如当前Kafka集群共有多少主题、多少Broker等）。</p><p>Kafka给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。</p><p>只要你自己的实现类定义好了partition方法，同时设置<code>partitioner.class</code>参数为你自己实现类的Full Qualified Name，那么生产者程序就会按照你的代码逻辑对消息进行分区。</p><p><strong>「轮询策略」</strong></p><p>也称Round-robin策略，即顺序分配。</p><p>比如一个主题下有3个分区，那么第一条消息被发送到分区0，第二条被发送到分区1，第三条被发送到分区2，以此类推。当生产第4条消息时又会重新开始，即将其分配到分区0</p><p>这就是所谓的轮询策略。轮询策略是Kafka Java生产者API默认提供的分区策略。</p><p><strong>「轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们最常用的分区策略之一。」</strong></p><p><strong>「随机策略」</strong></p><p>也称Randomness策略。所谓随机就是我们随意地将消息放置到任意一个分区上。</p><p>如果要实现随机策略版的partition方法，很简单，只需要两行代码即可：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List partitions <span class="operator">=</span> cluster.partitionsForTopic(topic)<span class="comment">;</span></span><br><span class="line">return ThreadLocalRandom.current().nextInt(partitions.size())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。</p><p>本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以**「如果追求数据的均匀分布，还是使用轮询策略比较好」**。事实上，随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了。</p><p><strong>「按消息键保序策略」</strong></p><p>Kafka允许为每条消息定义消息键，简称为Key。</p><p>这个Key的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务ID等；也可以用来表征消息元数据。</p><p>特别是在Kafka不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进Key里面的。</p><p>一旦消息被定义了Key，那么你就可以保证同一个Key的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略</p><p>实现这个策略的partition方法同样简单，只需要下面两行代码即可：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List partitions = <span class="keyword">cluster</span>.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.<span class="keyword">abs</span>(key.hashCode()) % partitions.<span class="keyword">size</span>();</span><br></pre></td></tr></table></figure><p>前面提到的Kafka默认分区策略实际上同时实现了两种策略：如果指定了Key，那么默认实现按消息键保序策略；如果没有指定Key，则使用轮询策略。</p><p><strong>「其他分区策略」</strong></p><p>其实还有一种比较常见的，即所谓的基于地理位置的分区策略。</p><p>当然这种策略一般只针对那些大规模的Kafka集群，特别是跨城市、跨国家甚至是跨大洲的集群。</p><p>我们可以根据Broker所在的IP地址实现定制化的分区策略。比如下面这段代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List partitions = <span class="keyword">cluster</span>.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> partitions.stream().<span class="keyword">filter</span>(p -&gt; isSouth(p.leader().host())).map(PartitionInfo::<span class="keyword">partition</span>).findAny().<span class="keyword">get</span>();</span><br></pre></td></tr></table></figure><p>我们可以从所有分区中找出那些Leader副本在南方的所有分区，然后随机挑选一个进行消息发送。</p><h2 id="生产者压缩算法">生产者压缩算法</h2><p><strong>「Kafka是如何压缩消息的呢？」</strong></p><p>目前Kafka共有两大类消息格式，社区分别称之为V1版本和V2版本。</p><p>V2版本是Kafka 0.11.0.0中正式引入的。</p><p>不论是哪个版本，Kafka的消息层次都分为两层：消息集合以及消息。</p><p>一个消息集合中包含若干条日志项，而日志项才是真正封装消息的地方。</p><p>Kafka底层的消息日志由一系列消息集合日志项组成。</p><p>Kafka通常不会直接操作具体的一条条消息，它总是在消息集合这个层面上进行写入操作。</p><p><strong>「那么社区引入V2版本的目的是什么呢？」</strong></p><p>V2版本主要是针对V1版本的一些弊端做了修正，比如把消息的公共部分抽取出来放到外层消息集合里面，这样就不用每条消息都保存这些信息了。</p><p>举个例子：原来在V1版本中，每条消息都需要执行CRC校验，但有些情况下消息的CRC值是会发生变化的。</p><p>比如在Broker端可能会对消息时间戳字段进行更新，那么重新计算之后的CRC值也会相应更新；再比如Broker端在执行消息格式转换时（主要是为了兼容老版本客户端程序），也会带来CRC值的变化。</p><p>鉴于这些情况，再对每条消息都执行CRC校验就有点没必要了，不仅浪费空间还耽误CPU时间，因此在V2版本中，消息的CRC校验工作就被移到了消息集合这一层。</p><p>V2版本还有一个和压缩息息相关的改进，就是保存压缩消息的方法发生了变化。</p><p>之前V1版本中保存压缩消息的方法是把多条消息进行压缩然后保存到外层消息的消息体字段中；而V2版本的做法是对整个消息集合进行压缩，显然后者应该比前者有更好的压缩效果。</p><p><strong>「何时压缩？」</strong></p><p>在Kafka中，压缩可能发生在两个地方：生产者端和Broker端。</p><p>生产者程序中配置<code>compression.type</code>参数即表示启用指定类型的压缩算法。</p><p>比如下面这段程序代码展示了如何构建一个开启GZIP的Producer对象：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties <span class="built_in">props</span> = <span class="built_in">new</span> Properties(); </span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>); </span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>); </span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>); <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>); // 开启GZIP压缩 </span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;gzip&quot;</span>); </span><br><span class="line">Producer producer = <span class="built_in">new</span> KafkaProducer&lt;&gt;(<span class="built_in">props</span>);</span><br></pre></td></tr></table></figure><p>这里比较关键的代码行是<code>props.put(“compression.type”, “gzip”)</code>，它表明该Producer的压缩算法使用的是GZIP。</p><p>这样Producer启动后生产的每个消息集合都是经GZIP压缩过的，故而能很好地节省网络传输带宽以及Kafka Broker端的磁盘占用。</p><p>有两种例外情况就可能让Broker重新压缩消息：</p><p><strong>「情况一：Broker端指定了和Producer端不同的压缩算法。」</strong></p><p>一旦你在Broker端设置了不同的<code>compression.type</code>值，就一定要小心了，因为可能会发生预料之外的压缩/解压缩操作，通常表现为Broker端CPU使用率飙升。</p><p><strong>「情况二：Broker端发生了消息格式转换。」</strong></p><p>所谓的消息格式转换主要是为了兼容老版本的消费者程序。</p><p>在一个生产环境中，Kafka集群中同时保存多种版本的消息格式非常常见。</p><p>为了兼容老版本的格式，Broker端会对新版本消息执行向老版本格式的转换。</p><p>这个过程中会涉及消息的解压缩和重新压缩。</p><p>一般情况下这种消息格式转换对性能是有很大影响的，除了这里的压缩之外，它还让Kafka丧失了Zero Copy特性。</p><p><strong>「何时解压缩？」</strong></p><p>有压缩必有解压缩！通常来说解压缩发生在消费者程序中，也就是说Producer发送压缩消息到Broker后，Broker照单全收并原样保存起来。当Consumer程序请求这部分消息时，Broker依然原样发送出去，当消息到达Consumer端后，由Consumer自行解压缩还原成之前的消息。</p><p><strong>「基本过程：Producer端压缩、Broker端保持、Consumer端解压缩。」</strong></p><p>注意：除了在Consumer端解压缩，Broker端也会进行解压缩。</p><p>每个压缩过的消息集合在Broker端写入时都要发生解压缩操作，目的就是为了对消息执行各种验证。</p><p>我们必须承认这种解压缩对Broker端性能是有一定影响的，特别是对CPU的使用率而言。</p><p><strong>「各种压缩算法对比」</strong></p><p>在Kafka 2.1.0版本之前，Kafka支持3种压缩算法：GZIP、Snappy和LZ4。</p><p>从2.1.0开始，Kafka正式支持Zstandard算法（简写为zstd）。</p><p>它是Facebook开源的一个压缩算法，能够提供超高的压缩比。</p><p>在实际使用中，GZIP、Snappy、LZ4和zstd的表现各有千秋。</p><p>但对于Kafka而言，在吞吐量方面：LZ4 &gt; Snappy &gt; zstd和GZIP；而在压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy。</p><p>具体到物理资源，使用Snappy算法占用的网络带宽最多，zstd最少；</p><p>在CPU使用率方面，各个算法表现得差不多，只是在压缩时Snappy算法使用的CPU较多一些，而在解压缩时GZIP算法则可能使用更多的CPU。</p><p><strong>「最佳实践」</strong></p><blockquote><p>❝</p><p>何时启用压缩是比较合适的时机呢？</p><p>❞</p></blockquote><p>启用压缩的一个条件就是Producer程序运行机器上的CPU资源要很充足。</p><p>除了CPU资源充足这一条件，如果你的环境中带宽资源有限，那么建议你开启压缩。</p><h2 id="消费者组">消费者组</h2><p><strong>「Consumer Group是Kafka提供的可扩展且具有容错性的消费者机制」</strong>。</p><p>既然是一个组，那么组内必然可以有多个消费者或消费者实例，它们共享一个公共的ID，这个ID被称为Group ID。</p><p>组内的所有消费者协调在一起来消费订阅主题的所有分区。</p><blockquote><p>❝</p><p><strong>每个分区只能由同一个消费者组内的一个Consumer实例来消费。</strong></p><p>❞</p></blockquote><p><strong>「Consumer Group三个特性：」</strong></p><ol><li>Consumer Group下可以有一个或多个Consumer实例，这里的实例可以是一个单独的进程，也可以是同一进程下的线程。</li><li>Group ID是一个字符串，在一个Kafka集群中，它标识唯一的一个Consumer Group。</li><li>Consumer Group下所有实例订阅的主题的单个分区，只能分配给组内的某个Consumer实例消费，这个分区当然也可以被其他的Group消费。</li></ol><p>当Consumer Group订阅了多个主题后，组内的每个实例不要求一定要订阅主题的所有分区，它只会消费部分分区中的消息。</p><p>Consumer Group之间彼此独立，互不影响，它们能够订阅相同的一组主题而互不干涉。</p><p><strong>「Kafka仅仅使用Consumer Group这一种机制，却同时实现了传统消息引擎系统的两大模型」</strong>：</p><ul><li>如果所有实例都属于同一个Group，那么它实现的就是消息队列模型；</li><li>如果所有实例分别属于不同的Group，那么它实现的就是发布/订阅模型。</li></ul><p><strong>「一个Group下该有多少个Consumer实例呢？」</strong></p><p><strong>「理想情况下，Consumer实例的数量应该等于该Group订阅主题的分区总数。」</strong></p><p>假设一个Consumer Group订阅了3个主题，分别是A、B、C，它们的分区数依次是1、2、3，那么通常情况下，为该Group设置6个Consumer实例是比较理想的情形，因为它能最大限度地实现高伸缩性。</p><p><strong>「针对Consumer Group，Kafka是怎么管理位移的呢？」</strong></p><p><strong>「位移Offset」</strong></p><p>老版本的Consumer Group把位移保存在ZooKeeper中。</p><p>Apache ZooKeeper是一个分布式的协调服务框架，Kafka重度依赖它实现各种各样的协调管理。</p><p>将位移保存在ZooKeeper外部系统的做法，最显而易见的好处就是减少了Kafka Broker端的状态保存开销。</p><p>不过，慢慢地发现了一个问题，即ZooKeeper这类元框架其实并不适合进行频繁的写更新，而Consumer Group的位移更新却是一个非常频繁的操作。</p><p>这种大吞吐量的写操作会极大地拖慢ZooKeeper集群的性能。</p><p>于是，在新版本的Consumer Group中，Kafka社区重新设计了Consumer Group的位移管理方式，采用了将位移保存在Kafka内部主题的方法。</p><p>这个内部主题就是<code>__consumer_offsets</code>。</p><h2 id="消费者策略">消费者策略</h2><p><strong>「第一种是Round」</strong></p><p>默认，也叫轮循，说的是对于同一组消费者来说，使用轮训分配的方式，决定消费者消费的分区</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606221917493.png" alt="image-20240606221917493"></p><p><strong>「第二种叫做Range」</strong></p><p>对一个消费者组来说决定消费方式是以分区总数除以消费者总数来决定，一般如果不能整除，往往是从头开始将剩余的分区分配开</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606221943589.png" alt="image-20240606221943589"></p><p><strong>「第三种叫Sticky」</strong></p><p>是在0.11.x，新增的，它和前面两个不是很一样，它是在Range上的一种升华，且前面两个当同组内有新的消费者加入或者旧的消费者退出的时候，会从新开始决定消费者消费方式，但是Sticky，在同组中有新的新的消费者加入或者旧的消费者退出时，不会直接开始新的Range分配，而是保留现有消费者原来的消费策略，将退出的消费者所消费的分区平均分配给现有消费者，新增消费者同理，同其他现存消费者的消费策略中分离</p><h2 id="位移提交">位移提交</h2><p>假设一个分区中有10条消息，位移分别是0到9。</p><p>某个Consumer应用已消费了5条消息，这就说明该Consumer消费了位移为0到4的5条消息，此时Consumer的位移是5，指向了下一条消息的位移。</p><p>因为Consumer能够同时消费多个分区的数据，所以位移的提交实际上是在分区粒度上进行的，即**「Consumer需要为分配给它的每个分区提交各自的位移数据」**。</p><p><strong>「位移提交分为自动提交和手动提交；从Consumer端的角度来说，位移提交分为同步提交和异步提交」</strong>。</p><p>开启自动提交位移的方法：Consumer端有个参数<code>enable.auto.commit</code>，把它设置为true或者压根不设置它就可以了。</p><p>因为它的默认值就是true，即Java Consumer默认就是自动提交位移的。</p><p>如果启用了自动提交，Consumer端还有个参数：<code>auto.commit.interval.ms</code>。</p><p>它的默认值是5秒，表明Kafka每5秒会为你自动提交一次位移。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Properties <span class="built_in">props</span> = <span class="built_in">new</span> Properties();</span><br><span class="line">     <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">     <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">     <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">     <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;2000&quot;</span>);</span><br><span class="line">     <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">     <span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">     KafkaConsumer consumer = <span class="built_in">new</span> KafkaConsumer&lt;&gt;(<span class="built_in">props</span>);</span><br><span class="line">     consumer.subscribe(Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         ConsumerRecords records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">         <span class="keyword">for</span> (ConsumerRecord record : records)</span><br><span class="line">             System.out.<span class="built_in">printf</span>(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.<span class="built_in">key</span>(), record.value());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>上面的第3、第4行代码，就是开启自动提交位移的方法。</p><p>开启手动提交位移的方法就是设置<code>enable.auto.commit为false</code>。</p><p>还需要调用相应的API手动提交位移。最简单的API就是**「KafkaConsumer#commitSync()」**。</p><p>该方法会提交<code>KafkaConsumer#poll()</code>返回的最新位移。</p><p>从名字上来看，它是一个同步操作，即该方法会一直等待，直到位移被成功提交才会返回。</p><p>如果提交过程中出现异常，该方法会将异常信息抛出。</p><p>下面这段代码展示了commitSync()的使用方法：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ConsumerRecords <span class="keyword">records</span> =</span><br><span class="line">                        consumer.poll(<span class="built_in">Duration</span>.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            process(<span class="keyword">records</span>); <span class="comment">// 处理消息</span></span><br><span class="line">            try &#123;</span><br><span class="line">                        consumer.commitSync();</span><br><span class="line">            &#125; catch (CommitFailedException e) &#123;</span><br><span class="line">                        <span class="keyword">handle</span>(e); <span class="comment">// 处理提交失败异常</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦设置了<code>enable.auto.commit</code>为true，Kafka会保证在开始调用poll方法时，提交上次poll返回的所有消息。</p><p>从顺序上来说，poll方法的逻辑是先提交上一批消息的位移，再处理下一批消息，因此它能保证不出现消费丢失的情况。</p><p>但自动提交位移的一个问题在于，<strong>「它可能会出现重复消费」</strong>。</p><p>而手动提交位移，它的好处就在于更加灵活，你完全能够把控位移提交的时机和频率。</p><p>但是，它也有一个缺陷，就是在调用commitSync()时，Consumer程序会处于阻塞状态，直到远端的Broker返回提交结果，这个状态才会结束。</p><p>鉴于这个问题，Kafka社区为手动提交位移提供了另一个API方法：<strong>「KafkaConsumer#commitAsync()」</strong>。</p><p>从名字上来看它就不是同步的，而是一个异步操作。</p><p>调用commitAsync()之后，它会立即返回，不会阻塞，因此不会影响Consumer应用的TPS。</p><p>由于它是异步的，Kafka提供了回调函数（callback），供你实现提交之后的逻辑，比如记录日志或处理异常等。</p><p>下面这段代码展示了调用commitAsync()的方法：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ConsumerRecords <span class="keyword">records</span> = </span><br><span class="line"> consumer.poll(<span class="built_in">Duration</span>.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            process(<span class="keyword">records</span>); <span class="comment">// 处理消息</span></span><br><span class="line">            consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (exception != <span class="built_in">null</span>)</span><br><span class="line"> <span class="keyword">handle</span>(exception);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitAsync的问题在于，出现问题时它不会自动重试。</p><p>显然，如果是手动提交，我们需要将commitSync和commitAsync组合使用才能到达最理想的效果，原因有两个：</p><ol><li>我们可以利用commitSync的自动重试来规避那些瞬时错误，比如网络的瞬时抖动，Broker端GC等，因为这些问题都是短暂的，自动重试通常都会成功。</li><li>我们不希望程序总处于阻塞状态，影响TPS。</li></ol><p>我们来看一下下面这段代码，它展示的是如何将两个API方法结合使用进行手动提交。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        ConsumerRecords records = </span><br><span class="line">                                    consumer.poll(<span class="built_in">Duration</span>.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                        process(records); <span class="comment">// 处理消息</span></span><br><span class="line">                        commitAysnc(); <span class="comment">// 使用异步提交规避阻塞</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            handle(e); <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                        consumer.commitSync(); <span class="comment">// 最后一次提交使用同步阻塞式提交</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      consumer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个场景：你的poll方法返回的不是500条消息，而是5000条。</p><p>那么，你肯定不想把这5000条消息都处理完之后再提交位移，因为一旦中间出现差错，之前处理的全部都要重来一遍。</p><p>比如前面这个5000条消息的例子，你可能希望每处理完100条消息就提交一次位移，这样能够避免大批量的消息重新消费。</p><p>Kafka Consumer API为手动提交提供了这样的方法：commitSync(Map)和commitAsync(Map)。</p><p>它们的参数是一个Map对象，键就是TopicPartition，即消费的分区，而值是一个OffsetAndMetadata对象，保存的主要是位移数据。</p><blockquote><p>❝</p><p>如何每处理100条消息就提交一次位移呢？</p><p>❞</p></blockquote><p>在这里，我以commitAsync为例，展示一段代码，实际上，commitSync的调用方法和它是一模一样的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Map offsets = <span class="built_in">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords records = </span><br><span class="line"> consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord <span class="type">record</span>: records) &#123;</span><br><span class="line">                        process(<span class="type">record</span>);  // 处理消息</span><br><span class="line">                        offsets.put(<span class="built_in">new</span> TopicPartition(<span class="type">record</span>.topic(), <span class="type">record</span>.<span class="keyword">partition</span>()),</span><br><span class="line">                                   <span class="built_in">new</span> OffsetAndMetadata(<span class="type">record</span>.<span class="keyword">offset</span>() + <span class="number">1</span>)；</span><br><span class="line">                       <span class="keyword">if</span>（count % <span class="number">100</span> == <span class="number">0</span>）</span><br><span class="line">                                    consumer.commitAsync(offsets, <span class="keyword">null</span>); // 回调处理逻辑是<span class="keyword">null</span></span><br><span class="line">                        count++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序先是创建了一个Map对象，用于保存Consumer消费处理过程中要提交的分区位移，之后开始逐条处理消息，并构造要提交的位移值。</p><p>代码的最后部分是做位移的提交。设置了一个计数器，每累计100条消息就统一提交一次位移。</p><p>与调用无参的commitAsync不同，这里调用了带Map对象参数的commitAsync进行细粒度的位移提交。</p><p>这样，这段代码就能够实现每处理100条消息就提交一次位移，不用再受poll方法返回的消息总数的限制了。</p><h2 id="重平衡">重平衡</h2><p><strong>「（重平衡）Rebalance本质上是一种协议，规定了一个Consumer Group下的所有Consumer如何达成一致，来分配订阅Topic的每个分区」</strong>。</p><p>比如某个Group下有20个Consumer实例，它订阅了一个具有100个分区的Topic。</p><p>正常情况下，Kafka平均会为每个Consumer分配5个分区。这个分配的过程就叫Rebalance。</p><p><strong>「Rebalance的触发条件有3个。」</strong></p><ol><li>组成员数发生变更。比如有新的Consumer实例加入组或者离开组，或是有Consumer实例崩溃被踢出组。</li><li>订阅主题数发生变更。Consumer Group可以使用正则表达式的方式订阅主题，比如<code>consumer.subscribe(Pattern.compile(“t.*c”))</code>就表明该Group订阅所有以字母t开头、字母c结尾的主题，在Consumer Group的运行过程中，你新创建了一个满足这样条件的主题，那么该Group就会发生Rebalance。</li><li>订阅主题的分区数发生变更。Kafka当前只能允许增加一个主题的分区数，当分区数增加时，就会触发订阅该主题的所有Group开启Rebalance。</li></ol><p>Rebalance发生时，Group下所有的Consumer实例都会协调在一起共同参与。</p><p><strong>「分配策略」</strong></p><p>当前Kafka默认提供了3种分配策略，每种策略都有一定的优势和劣势，社区会不断地完善这些策略，保证提供最公平的分配策略，即每个Consumer实例都能够得到较为平均的分区数。</p><p>比如一个Group内有10个Consumer实例，要消费100个分区，理想的分配策略自然是每个实例平均得到10个分区。</p><p>这就叫公平的分配策略。</p><p>举个简单的例子来说明一下Consumer Group发生Rebalance的过程。</p><p>假设目前某个Consumer Group下有两个Consumer，比如A和B，当第三个成员C加入时，Kafka会触发Rebalance，并根据默认的分配策略重新为A、B和C分配分区</p><p>Rebalance之后的分配依然是公平的，即每个Consumer实例都获得了2个分区的消费权。</p><p>在Rebalance过程中，所有Consumer实例都会停止消费，等待Rebalance完成，这是Rebalance为人诟病的一个方面。</p><p>目前Rebalance的设计是所有Consumer实例共同参与，全部重新分配所有分区。</p><p><strong>「Coordinator会在什么情况下认为某个Consumer实例已挂从而要退组呢？」</strong></p><p>当Consumer Group完成Rebalance之后，每个Consumer实例都会定期地向Coordinator发送心跳请求，表明它还存活着。</p><p>如果某个Consumer实例不能及时地发送这些心跳请求，Coordinator就会认为该Consumer已经死了，从而将其从Group中移除，然后开启新一轮Rebalance。</p><p>Consumer端有个参数，叫<code>session.timeout.ms</code>。</p><p>该参数的默认值是10秒，即如果Coordinator在10秒之内没有收到Group下某Consumer实例的心跳，它就会认为这个Consumer实例已经挂了。</p><p>除了这个参数，Consumer还提供了一个允许你控制发送心跳请求频率的参数，就是<code>heartbeat.interval.ms</code>。</p><p>这个值设置得越小，Consumer实例发送心跳请求的频率就越高。</p><p>频繁地发送心跳请求会额外消耗带宽资源，但好处是能够更加快速地知晓当前是否开启Rebalance，因为，目前Coordinator通知各个Consumer实例开启Rebalance的方法，就是将<code>REBALANCE_NEEDED</code>标志封装进心跳请求的响应体中。</p><p>除了以上两个参数，Consumer端还有一个参数，用于控制Consumer实际消费能力对Rebalance的影响，即<code>max.poll.interval.ms</code>参数。</p><p>它限定了Consumer端应用程序两次调用poll方法的最大时间间隔。</p><p>它的默认值是5分钟，表示你的Consumer程序如果在5分钟之内无法消费完poll方法返回的消息，那么Consumer会主动发起离开组的请求，Coordinator也会开启新一轮Rebalance。</p><p><strong>「可避免Rebalance的配置」</strong></p><p>第一类Rebalance是因为未能及时发送心跳，导致Consumer被踢出Group而引发的</p><p>因此可以设置**「<a href="http://session.timeout.xn--msheartbeat-804s.interval.ms">session.timeout.ms和heartbeat.interval.ms</a>」**的值。</p><ul><li>设置<code>session.timeout.ms</code> = 6s。</li><li>设置<code>heartbeat.interval.ms</code> = 2s。</li><li>要保证Consumer实例在被判定为dead之前，能够发送至少3轮的心跳请求，即<code>session.timeout.ms &gt;= 3 * heartbeat.interval.ms</code>。</li></ul><p>将<code>session.timeout.ms</code>设置成6s主要是为了让Coordinator能够更快地定位已经挂掉的Consumer。</p><p><strong>「第二类Rebalance是Consumer消费时间过长导致的」</strong>。</p><p>你要为你的业务处理逻辑留下充足的时间，这样Consumer就不会因为处理这些消息的时间太长而引发Rebalance了。</p><h2 id="ConsumerOffsets">ConsumerOffsets</h2><p><strong>「Kafka将Consumer的位移数据作为一条条普通的Kafka消息，提交到__consumer_offsets中。」</strong></p><p><strong>「__consumer_offsets的主要作用是保存Kafka消费者的位移信息。」</strong></p><p>它要求这个提交过程不仅要实现高持久性，还要支持高频的写操作。</p><p><code>__consumer_offsets</code>主题就是普通的Kafka主题。你可以手动地创建它、修改它，甚至是删除它。</p><p>虽说<code>__consumer_offsets</code>主题是一个普通的Kafka主题，但**「它的消息格式却是Kafka自己定义的」**，用户不能修改，也就是说你不能随意地向这个主题写消息，因为一旦你写入的消息不满足Kafka规定的格式，那么Kafka内部无法成功解析，就会造成Broker的崩溃。</p><p>Kafka Consumer有API帮你提交位移，也就是向<code>__consumer_offsets</code>主题写消息，千万不要自己写个Producer随意向该主题发送消息。</p><p><code>__consumer_offsets</code>有3种消息格式：</p><ol><li>用于保存Consumer Group信息的消息。</li><li>用于删除Group过期位移甚至是删除Group的消息。</li><li>保存了位移值。</li></ol><p>第2种格式它有个专属的名字：tombstone消息，即墓碑消息，也称delete mark，它的主要特点是它的消息体是null，即空消息体。</p><p>一旦某个Consumer Group下的所有Consumer实例都停止了，而且它们的位移数据都已被删除时，Kafka会向<code>__consumer_offsets</code>主题的对应分区写入tombstone消息，表明要彻底删除这个Group的信息。</p><p><code>__consumer_offsets</code>是怎么被创建的？</p><p>通常来说，<strong>「当Kafka集群中的第一个Consumer程序启动时，Kafka会自动创建位移主题」</strong>。</p><p><strong>「默认该主题的分区数是50，副本数是3」</strong>。</p><p>目前Kafka Consumer提交位移的方式有两种：<strong>「自动提交位移和手动提交位移。」</strong></p><p>Consumer端有个参数叫<code>enable.auto.commit</code>，如果值是true，则Consumer在后台默默地为你定期提交位移，提交间隔由一个专属的参数<code>auto.commit.interval.ms</code>来控制。</p><p>自动提交位移有一个显著的优点，就是省事，你不用操心位移提交的事情，就能保证消息消费不会丢失。</p><p>但这一点同时也是缺点，丧失了很大的灵活性和可控性，你完全没法把控Consumer端的位移管理。</p><p>Kafka Consumer API为你提供了位移提交的方法，如<code>consumer.commitSync</code>等。</p><p>当调用这些方法时，Kafka会向<code>__consumer_offsets</code>主题写入相应的消息。</p><p>如果你选择的是自动提交位移，那么就可能存在一个问题：只要Consumer一直启动着，它就会无限期地向位移主题写入消息。</p><p><strong>「举个极端一点的例子。」</strong></p><p>假设Consumer当前消费到了某个主题的最新一条消息，位移是100，之后该主题没有任何新消息产生，故Consumer无消息可消费了，所以位移永远保持在100。</p><p>由于是自动提交位移，位移主题中会不停地写入位移=100的消息。</p><p>显然Kafka只需要保留这类消息中的最新一条就可以了，之前的消息都是可以删除的。</p><p>这就要求Kafka必须要有针对位移主题消息特点的消息删除策略，否则这种消息会越来越多，最终撑爆整个磁盘。</p><p><strong>「Compact策略」</strong></p><p>Kafka使用**「Compact策略」**来删除<code>__consumer_offsets</code>主题中的过期消息，避免该主题无限期膨胀。</p><p>比如对于同一个Key的两条消息M1和M2，如果M1的发送时间早于M2，那么M1就是过期消息。</p><p>Compact的过程就是扫描日志的所有消息，剔除那些过期的消息，然后把剩下的消息整理在一起。</p><p>我在这里贴一张来自官网的图片，来说明Compact过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606222941632.png" alt="image-20240606222941632"></p><p>图中位移为0、2和3的消息的Key都是K1，Compact之后，分区只需要保存位移为3的消息，因为它是最新发送的。</p><p><strong>「Kafka提供了专门的后台线程定期地巡检待Compact的主题，看看是否存在满足条件的可删除数据」</strong>。</p><p>这个后台线程叫Log Cleaner。</p><p>很多实际生产环境中都出现过位移主题无限膨胀占用过多磁盘空间的问题，如果你的环境中也有这个问题，建议你去检查一下Log Cleaner线程的状态，通常都是这个线程挂掉了导致的。</p><h2 id="副本机制">副本机制</h2><p>根据Kafka副本机制的定义，同一个分区下的所有副本保存有相同的消息序列，这些副本分散保存在不同的Broker上，从而能够对抗部分Broker宕机带来的数据不可用。</p><p>下面展示的是一个有3台Broker的Kafka集群上的副本分布情况。</p><p>从这张图中，我们可以看到，主题1分区0的3个副本分散在3台Broker上，其他主题分区的副本也都散落在不同的Broker上，从而实现数据冗余。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223053208.png" alt="image-20240606223053208"></p><p><strong>「副本角色」</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223111422.png" alt="image-20240606223111422"></p><p>在Kafka中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。</p><p>每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。</p><p>在Kafka中，追随者副本是不对外提供服务的。这就是说，任何一个追随者副本都不能响应消费者和生产者的读写请求。所有的请求都必须由领导者副本来处理，或者说，所有的读写请求都必须发往领导者副本所在的Broker，由该Broker负责处理。</p><p>追随者副本不处理客户端请求，它唯一的任务就是从领导者副本**「异步拉取」**消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。</p><p>当领导者副本挂掉了，或者说领导者副本所在的Broker宕机时，Kafka依托于ZooKeeper提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老Leader副本重启回来后，只能作为追随者副本加入到集群中。</p><p>对于客户端用户而言，Kafka的追随者副本没有任何作用，Kafka为什么要这样设计呢？</p><p>这种副本机制有两个方面的好处。</p><p>1.<strong>「方便实现Read-your-writes」</strong>。</p><p>所谓Read-your-writes，顾名思义就是，当你使用生产者API向Kafka成功写入消息后，马上使用消费者API去读取刚才生产的消息。</p><p>2.<strong>「方便实现单调读（Monotonic Reads）」</strong>。</p><p>假设当前有2个追随者副本F1和F2，它们异步地拉取领导者副本数据。倘若F1拉取了Leader的最新消息而F2还未及时拉取，那么，此时如果有一个消费者先从F1读取消息之后又从F2拉取消息，它可能会看到这样的现象：第一次消费时看到的最新消息在第二次消费时不见了，这就不是单调读一致性。</p><p>但是，如果所有的读请求都是由Leader来处理，那么Kafka就很容易实现单调读一致性。</p><h3 id="ISR机制">ISR机制</h3><p>In-sync Replicas，也就是所谓的ISR副本集合。</p><p>ISR中的副本都是与Leader同步的副本，相反，不在ISR中的追随者副本就被认为是与Leader不同步的。</p><blockquote><p>❝</p><p>什么副本能够进入到ISR中呢？</p><p>❞</p></blockquote><p>Leader副本天然就在ISR中。也就是说，<strong>「ISR不只是追随者副本集合，它必然包括Leader副本。甚至在某些情况下，ISR只有Leader这一个副本」</strong>。</p><p>另外，能够进入到ISR的追随者副本要满足一定的条件。</p><p><strong>「通过Broker端参数replica.lag.time.max.ms参数值」</strong>。</p><p>这个参数的含义是Follower副本能够落后Leader副本的最长时间间隔，当前默认值是10秒。</p><p>这就是说，只要一个Follower副本落后Leader副本的时间不连续超过10秒，那么Kafka就认为该Follower副本与Leader是同步的，即使此时Follower副本中保存的消息明显少于Leader副本中的消息。</p><p>Follower副本唯一的工作就是不断地从Leader副本拉取消息，然后写入到自己的提交日志中。</p><p>倘若该副本后面慢慢地追上了Leader的进度，那么它是能够重新被加回ISR的。</p><p>ISR是一个动态调整的集合，而非静态不变的。</p><h3 id="Unclean领导者选举">Unclean领导者选举</h3><p><strong>「Kafka把所有不在ISR中的存活副本都称为非同步副本」</strong>。</p><p>通常来说，非同步副本落后Leader太多，因此，如果选择这些副本作为新Leader，就可能出现数据的丢失。</p><p>毕竟，这些副本中保存的消息远远落后于老Leader中的消息。</p><p>在Kafka中，选举这种副本的过程称为Unclean领导者选举。</p><p><strong>「Broker端参数unclean.leader.election.enable控制是否允许Unclean领导者选举」</strong>。</p><p>开启Unclean领导者选举可能会造成数据丢失，但好处是，它使得分区Leader副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止Unclean领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。</p><h3 id="副本选举">副本选举</h3><p>对于kafka集群中对于任意的topic的分区以及副本leader的设定，都需要考虑到集群整体的负载能力的平衡性，会尽量分配每一个partition的副本leader在不同的broker中，这样会避免多个leader在同一个broker，导致集群中的broker负载不平衡</p><p>kafka引入了优先副本的概念，优先副本的意思在AR（分区中的所有副本）集合列表中的第一个副本，在理想状态下该副本就是该分区的leader副本</p><p>例如kafka集群由3台broker组成，创建了一个名为<code>topic-partitions</code>的topic，设置partition为3，副本数为3，partition0中AR列表为 <code>[1,2,0]</code>，那么分区0的优先副本为1</p><p>kafka使用多副本机制提高可靠性，但是只有leader副本对外提供读写服务，follow副本只是做消息同步。</p><p><strong>「如果一个分区的leader副本不可用，就意味着整个分区不可用，此时需要从follower副本中选举出新的leader副本提供服务」</strong>。</p><p><strong>「在创建主题的时候，该分区的主题和副本会尽可能的均匀发布到kafka的各个broker上」</strong>。</p><p>比如我们在包含3个broker节点的kafka集群上创建一个分区数为3，副本因子为3的主题<code>topic-partitions</code>时，leader副本会均匀的分布在3台broker节点上。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223147685.png" alt="image-20240606223147685"></p><p><strong>「针对同一个分区，在同一个broker节点上不可能出现它的多个副本」</strong>。</p><p>我们可以把leader副本所在的节点叫作分区的leader节点，把follower副本所在的节点叫作follower节点。</p><p>在上面的例子中，分区0的leader节点是broker1，分区1的leader节点是broker2，分区2的leader节点是broker0。</p><p>当分区leader节点发生故障时，其中的一个follower节点就会选举为新的leader节点。</p><p>当原来leader的节点恢复之后，它只能成为一个follower节点，此时就导致了集群负载不均衡。</p><p>比如分区1的leader节点broker2崩溃了，此时选举了在broker1上的分区1follower节点作为新的leader节点。</p><p>当broker2重新恢复时，此时的kafka集群状态如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223202013.png" alt="image-20240606223202013"></p><p>可以看到，此时broker1上负载更大，而broker2上没有负载。</p><p><strong>「为了解决上述负载不均衡的情况，kafka支持了优先副本选举，优先副本指的是一个分区所在的AR集合的第一个副本」</strong>。</p><p>比如上面的分区1，它的AR集合是<code>[2,0,1]</code>，表示分区1的优先副本就是在broker2上。</p><p>理想情况下，优先副本应该就是leader副本，kafka保证了优先副本的均衡分布，而这与broker节点宕机与否没有关系。</p><p><strong>「优先副本选举就是对分区leader副本进行选举的时候，尽可能让优先副本成为leader副本」</strong>，针对上述的情况，只要再触发一次优先副本选举就能保证分区负载均衡。</p><p>kafka支持自动优先副本选举功能，默认每5分钟触发一次优先副本选举操作。</p><p><strong>解释</strong>：</p><p>Kafka的副本选举是指在Kafka集群中，当一个分区的Leader副本发生故障后，从该分区的Follower副本中选举一个新的Leader副本的过程。</p><p>举个例子，假设你正在和一群朋友玩一个团队游戏，其中一个人（我们称他为&quot;Leader&quot;）是队长，负责制定策略和指挥大家。其他人（我们称他们为&quot;Follower&quot;）则是队员，他们跟随队长的指令行动。</p><p>突然，由于某种原因，队长不能再继续指挥大家（比如他需要暂时离开或者他的手机没电了）。这个时候，你们需要从剩下的队员中选出一个新的队长，这个过程就像Kafka的副本选举。</p><p>在Kafka中，如果当前的Leader副本发生了故障，那么Kafka会从ISR（In-Sync Replicas，与Leader保持同步的Follower副本集合）中选举一个新的Leader。这样可以确保数据的一致性，因为ISR中的副本都有最新的数据。</p><p>如果ISR中没有可用的副本，Kafka还可以进行&quot;Unclean Leader Election&quot;，也就是从OSR（Out-of-Sync Replicas，与Leader不完全同步的Follower副本集合）中选举新的Leader，但这可能会导致一些数据的丢失。</p><p>总的来说，Kafka的副本选举机制是为了保持系统的高可用性和数据的一致性。</p><h2 id="网络通信模型">网络通信模型</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223313048.png" alt="image-20240606223313048"></p><p>Broker 中有个<code>Acceptor(mainReactor)</code>监听新连接的到来，与新连接建连之后轮询选择一个<code>Processor(subReactor)</code>管理这个连接。</p><p>而<code>Processor</code>会监听其管理的连接，当事件到达之后，读取封装成<code>Request</code>，并将<code>Request</code>放入共享请求队列中。</p><p>然后IO线程池不断的从该队列中取出请求，执行真正的处理。处理完之后将响应发送到对应的<code>Processor</code>的响应队列中，然后由<code>Processor</code>将<code>Response</code>返还给客户端。</p><p>每个<code>listener</code>只有一个<code>Acceptor线程</code>，因为它只是作为新连接建连再分发，没有过多的逻辑，很轻量。</p><p><code>Processor</code> 在Kafka中称之为网络线程，默认网络线程池有3个线程，对应的参数是<code>num.network.threads</code>，并且可以根据实际的业务动态增减。</p><p>还有个 IO 线程池，即<code>KafkaRequestHandlerPool</code>，执行真正的处理，对应的参数是<code>num.io.threads</code>，默认值是 8。</p><p>IO线程处理完之后会将<code>Response</code>放入对应的<code>Processor</code>中，由<code>Processor</code>将响应返还给客户端。</p><p>可以看到网络线程和IO线程之间利用的经典的生产者 - 消费者模式，不论是用于处理Request的共享请求队列，还是IO处理完返回的Response。</p><h2 id="幂等性">幂等性</h2><p><strong>「幂等性Producer」</strong></p><p>在Kafka中，Producer默认不是幂等性的，但我们可以创建幂等性Producer。</p><p>它其实是0.11.0.0版本引入的新功能，在此之前，Kafka向分区发送数据时，可能会出现同一条消息被发送了多次，导致消息重复的情况。</p><p>在0.11之后，指定Producer幂等性的方法很简单，仅需要设置一个参数即可，即</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">props</span>.<span class="built_in">put</span>(“enable.idempotence”, ture)，</span><br><span class="line">或<span class="built_in">props</span>.<span class="built_in">put</span>(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， <span class="literal">true</span>)。</span><br></pre></td></tr></table></figure><p><code>enable.idempotence</code>被设置成true后，Producer自动升级成幂等性Producer，其他所有的代码逻辑都不需要改变。</p><p>Kafka自动帮你做消息的重复去重。</p><p>底层具体的原理很简单，就是经典的用空间去换时间的优化思路，即在Broker端多保存一些字段。</p><p><strong>当Producer发送了具有相同字段值的消息后，Broker能够自动知晓这些消息已经重复了，于是可以在后台默默地把它们丢弃掉。</strong></p><p><strong>「幂等性Producer的作用范围」</strong></p><p>首先，它只能保证单分区上的幂等性，即一个幂等性Producer能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。</p><p>其次，它只能实现单会话上的幂等性，不能实现跨会话的幂等性。</p><p>这里的会话，你可以理解为Producer进程的一次运行，当你重启了Producer进程之后，这种幂等性保证就丧失了。</p><h2 id="事务">事务</h2><p>Kafka自0.11版本开始也提供了对事务的支持，目前主要是在read committed隔离级别上做事情。</p><p>它能保证多条消息原子性地写入到目标分区，同时也能保证Consumer只能看到事务成功提交的消息。</p><p><strong>「事务型Producer」</strong></p><p>事务型Producer能够保证将消息原子性地写入到多个分区中。</p><p>这批消息要么全部写入成功，要么全部失败，另外，事务型Producer也不惧进程的重启。</p><p>Producer重启回来后，Kafka依然保证它们发送消息的精确一次处理。</p><p>设置事务型Producer的方法也很简单，满足两个要求即可：</p><ul><li>和幂等性Producer一样，开启<code>enable.idempotence = true</code>。</li><li>设置Producer端参数<code>transactional. id</code>，最好为其设置一个有意义的名字。</li></ul><p>此外，你还需要在Producer代码中做一些调整，如这段代码所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">producer<span class="selector-class">.initTransactions</span>();</span><br><span class="line">try &#123;</span><br><span class="line">            producer<span class="selector-class">.beginTransaction</span>();</span><br><span class="line">            producer<span class="selector-class">.send</span>(record1);</span><br><span class="line">            producer<span class="selector-class">.send</span>(record2);</span><br><span class="line">            producer<span class="selector-class">.commitTransaction</span>();</span><br><span class="line">&#125; catch (KafkaException e) &#123;</span><br><span class="line">            producer<span class="selector-class">.abortTransaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通Producer代码相比，事务型Producer的显著特点是调用了一些事务API，如initTransaction、beginTransaction、commitTransaction和abortTransaction，它们分别对应事务的初始化、事务开始、事务提交以及事务终止。</p><p>这段代码能够保证Record1和Record2被当作一个事务统一提交到Kafka，要么它们全部提交成功，要么全部写入失败。</p><p>实际上即使写入失败，Kafka也会把它们写入到底层的日志中，也就是说Consumer还是会看到这些消息。</p><p>有一个<code>isolation.level</code>参数，这个参数有两个取值：</p><ol><li><code>read_uncommitted</code>：这是默认值，表明Consumer能够读取到Kafka写入的任何消息，不论事务型Producer提交事务还是终止事务，其写入的消息都可以读取，如果你用了事务型Producer，那么对应的Consumer就不要使用这个值。</li><li><code>read_committed</code>：表明Consumer只会读取事务型Producer成功提交事务写入的消息，它也能看到非事务型Producer写入的所有消息。</li></ol><h2 id="拦截器">拦截器</h2><p><strong>「Kafka拦截器分为生产者拦截器和消费者拦截器」</strong>。</p><p>生产者拦截器允许你在发送消息前以及消息提交成功后植入你的拦截器逻辑；</p><p>而消费者拦截器支持在消费消息前以及提交位移后编写特定逻辑。</p><p>可以将一组拦截器串连成一个大的拦截器，Kafka会按照添加顺序依次执行拦截器逻辑。</p><p>当前Kafka拦截器的设置方法是通过参数配置完成的，生产者和消费者两端有一个相同的参数<code>interceptor.classes</code>，它指定的是一组类的列表，每个类就是特定逻辑的拦截器实现类。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="built_in">new</span> Properties(); </span><br><span class="line">List interceptors = <span class="built_in">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">interceptors.<span class="built_in">add</span>(<span class="string">&quot;com.yourcompany.kafkaproject.interceptors.AddTimestampInterceptor&quot;</span>);<span class="comment"> // 拦截器1 </span></span><br><span class="line">interceptors.<span class="built_in">add</span>(<span class="string">&quot;com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor&quot;</span>);<span class="comment"> // 拦截器2 </span></span><br><span class="line">props.<span class="built_in">put</span>(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors); </span><br><span class="line">…… </span><br></pre></td></tr></table></figure><blockquote><p>❝</p><p>怎么编写AddTimeStampInterceptor和UpdateCounterInterceptor类呢？</p><p>❞</p></blockquote><p>这两个类以及你自己编写的所有Producer端拦截器实现类都要继承<code>org.apache.kafka.clients.producer.ProducerInterceptor</code>接口。</p><p>该接口是Kafka提供的，里面有两个核心的方法。</p><ol><li>onSend：该方法会在消息发送之前被调用。</li><li>onAcknowledgement：该方法会在消息成功提交或发送失败之后被调用。onAcknowledgement的调用要早于callback的调用。值得注意的是，这个方法和onSend不是在同一个线程中被调用的，因此如果你在这两个方法中调用了某个共享可变对象，一定要保证线程安全。</li></ol><p>同理，指定消费者拦截器也是同样的方法，只是具体的实现类要实现<code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code>接口，这里面也有两个核心方法。</p><ol><li>onConsume：该方法在消息返回给Consumer程序之前调用。</li><li>onCommit：Consumer在提交位移之后调用该方法。通常你可以在该方法中做一些记账类的动作，比如打日志等。</li></ol><p>一定要注意的是，<strong>「指定拦截器类时要指定它们的全限定名」</strong>。</p><p>通俗点说就是要把完整包名也加上，不要只有一个类名在那里，并且还要保证你的Producer程序能够正确加载你的拦截器类。</p><h2 id="控制器">控制器</h2><p>【我的理解是从Broker中找到最快给zookeeper创文件的作为控制器，控制器帮助分区的缩减，领导者选举等】</p><p><strong>「控制器组件（Controller），它的主要作用是在Apache ZooKeeper的帮助下管理和协调整个Kafka集群」</strong>。</p><p>集群中任意一台Broker都能充当控制器的角色，但是，在运行过程中，只能有一个Broker成为控制器，行使其管理和协调的职责。</p><p>Kafka控制器大量使用ZooKeeper的Watch功能实现对集群的协调管理。</p><p><strong>「控制器是如何被选出来的」</strong></p><p>实际上，Broker在启动时，会尝试去ZooKeeper中创建<code>/controller</code>节点。</p><p>Kafka当前选举控制器的规则是：<strong>「第一个成功创建/controller节点的Broker会被指定为控制器」</strong>。</p><p><strong>「控制器是做什么的」</strong></p><p>控制器的职责大致可以分为5种：</p><p>1.<strong>「主题管理（创建、删除、增加分区）」</strong></p><p>控制器帮助我们完成对Kafka主题的创建、删除以及分区增加的操作。</p><p>2.<strong>「分区重分配」</strong></p><p>3.<strong>「Preferred领导者选举」</strong></p><p>Preferred领导者选举主要是Kafka为了避免部分Broker负载过重而提供的一种换Leader的方案。</p><p>4.<strong>「集群成员管理（新增Broker、Broker主动关闭、Broker宕机）」</strong></p><p>包括自动检测新增Broker、Broker主动关闭及被动宕机。</p><p>这种自动检测是依赖于Watch功能和ZooKeeper临时节点组合实现的。</p><p>比如，控制器组件会利用**「Watch机制」**检查ZooKeeper的<code>/brokers/ids</code>节点下的子节点数量变更。</p><p>目前，当有新Broker启动后，它会在<code>/brokers</code>下创建专属的znode节点。</p><p>一旦创建完毕，ZooKeeper会通过Watch机制将消息通知推送给控制器，这样，控制器就能自动地感知到这个变化，进而开启后续的新增Broker作业。</p><p>侦测Broker存活性则是依赖于刚刚提到的另一个机制：<strong>「临时节点」</strong>。</p><p>每个Broker启动后，会在<code>/brokers/ids</code>下创建一个临时znode。</p><p>当Broker宕机或主动关闭后，该Broker与ZooKeeper的会话结束，这个znode会被自动删除。</p><p>同理，ZooKeeper的Watch机制将这一变更推送给控制器，这样控制器就能知道有Broker关闭或宕机了，从而进行善后。</p><p>5.<strong>「数据服务」</strong></p><p>控制器上保存了最全的集群元数据信息，其他所有Broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。</p><p><strong>「控制器故障转移（Failover）」</strong></p><p><strong>「故障转移指的是，当运行中的控制器突然宕机或意外终止时，Kafka能够快速地感知到，并立即启用备用控制器来代替之前失败的控制器」</strong>。这个过程就被称为Failover，该过程是自动完成的，无需你手动干预。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223803292.png" alt="image-20240606223803292"></p><p>最开始时，Broker 0是控制器。当Broker 0宕机后，ZooKeeper通过Watch机制感知到并删除了<code>/controller</code>临时节点。</p><p>之后，所有存活的Broker开始竞选新的控制器身份。</p><p>Broker 3最终赢得了选举，成功地在ZooKeeper上重建了<code>/controller</code>节点。</p><p>之后，Broker 3会从ZooKeeper中读取集群元数据信息，并初始化到自己的缓存中。</p><p>至此，控制器的Failover完成，可以行使正常的工作职责了。</p><h2 id="日志存储">日志存储</h2><p>Kafka中的消息是以主题为基本单位进行归类的，每个主题在逻辑上相互独立。</p><p>每个主题又可以分为一个或多个分区，在不考虑副本的情况下，一个分区会对应一个日志。</p><p>但设计者考虑到随着时间推移，日志文件会不断扩大，因此为了防止Log过大，设计者引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment，便于后续的消息维护和清理工作。</p><p>下图描绘了主题、分区、副本、Log、LogSegment五者之间的关系。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223930968.png" alt="image-20240606223930968"></p><p><strong>「LogSegment」</strong></p><p>在Kafka中，每个Log对象又可以划分为多个LogSegment文件，每个LogSegment文件包括一个日志数据文件和两个索引文件（偏移量索引文件和消息时间戳索引文件）。</p><p>其中，每个LogSegment中的日志数据文件大小均相等（该日志数据文件的大小可以通过在Kafka Broker的<code>config/server.properties</code>配置文件的中的**「log.segment.bytes」**进行设置，默认为1G大小（1073741824字节），在顺序写入消息时如果超出该设定的阈值，将会创建一组新的日志数据和索引文件）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606223951739.png" alt="image-20240606223951739"></p><h2 id="常用参数">常用参数</h2><p><strong>「broker端配置」</strong></p><ul><li><a href="http://broker.id">broker.id</a></li></ul><p>每个 kafka broker 都有一个唯一的标识来表示，这个唯一的标识符即是 <code>broker.id</code>，它的默认值是 0。</p><p>这个值在 kafka 集群中必须是唯一的，这个值可以任意设定，</p><ul><li>port</li></ul><p>如果使用配置样本来启动 kafka，它会监听 9092 端口，修改 port 配置参数可以把它设置成任意的端口。</p><p>要注意，如果使用 1024 以下的端口，需要使用 root 权限启动 kakfa。</p><ul><li>zookeeper.connect</li></ul><p>用于保存 broker 元数据的 Zookeeper 地址是通过 <code>zookeeper.connect</code> 来指定的。</p><p>比如可以这么指定 <code>localhost:2181</code> 表示这个 Zookeeper 是运行在本地 2181 端口上的。</p><p>我们也可以通过 比如我们可以通过 <code>zk1:2181,zk2:2181,zk3:2181</code> 来指定 <code>zookeeper.connect</code> 的多个参数值。</p><p>该配置参数是用冒号分割的一组 <code>hostname:port/path</code> 列表，其含义如下</p><ul><li>hostname 是 Zookeeper 服务器的机器名或者 ip 地址。</li><li>port 是 Zookeeper 客户端的端口号</li><li>/path 是可选择的 Zookeeper 路径，Kafka 路径是使用了 <code>chroot</code> 环境，如果不指定默认使用跟路径。</li></ul><blockquote><p>❝</p><p>如果你有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的<code>zookeeper.connect</code>参数可以这样指定：<code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和<code>zk1:2181,zk2:2181,zk3:2181/kafka2</code></p><p>❞</p></blockquote><ul><li>log.dirs</li></ul><p>Kafka 把所有的消息都保存到磁盘上，存放这些日志片段的目录是通过 <code>log.dirs</code> 来制定的，它是用一组逗号来分割的本地系统路径，<code>log.dirs</code> 是没有默认值的，<strong>「你必须手动指定他的默认值」</strong>。</p><p>其实还有一个参数是 <code>log.dir</code>，这个配置是没有 <code>s</code> 的，默认情况下只用配置 <code>log.dirs</code> 就好了，比如你可以通过 <code>/home/kafka1,/home/kafka2,/home/kafka3</code> 这样来配置这个参数的值。</p><ul><li>auto.create.topics.enable</li></ul><p>默认情况下，kafka 会自动创建主题</p><p><code>auto.create.topics.enable</code>参数建议最好设置成 false，即不允许自动创建 Topic。</p><p><strong>「主题相关配置」</strong></p><ul><li>num.partitions</li></ul><p>num.partitions 参数指定了新创建的主题需要包含多少个分区，该参数的默认值是 1。</p><ul><li>default.replication.factor</li></ul><p>这个参数比较简单，它表示 kafka保存消息的副本数。</p><ul><li><a href="http://log.retention.ms">log.retention.ms</a></li></ul><p>Kafka 通常根据时间来决定数据可以保留多久。</p><p>默认使用<code>log.retention.hours</code>参数来配置时间，默认是 168 个小时，也就是一周。</p><p>除此之外，还有两个参数<code>log.retention.minutes</code> 和<code>log.retentiion.ms</code> 。</p><p>这三个参数作用是一样的，都是决定消息多久以后被删除，推荐使用<code>log.retention.ms</code>。</p><ul><li>message.max.bytes</li></ul><p>broker 通过设置 <code>message.max.bytes</code> 参数来限制单个消息的大小，默认是 1000 000， 也就是 1MB，如果生产者尝试发送的消息超过这个大小，不仅消息不会被接收，还会收到 broker 返回的错误消息。</p><ul><li><a href="http://retention.ms">retention.ms</a></li></ul><p>规定了该主题消息被保存的时常，默认是7天，即该主题只能保存7天的消息，一旦设置了这个值，它会覆盖掉 Broker 端的全局参数值。</p><h2 id="消息丢失问题">消息丢失问题</h2><p><strong>「生产者程序丢失数据」</strong></p><p>目前Kafka Producer是异步发送消息的，也就是说如果你调用的是<code>producer.send(msg)</code>这个API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。</p><p>如果用这个方式，可能会有哪些因素导致消息没有发送成功呢？</p><p>其实原因有很多，例如网络抖动，导致消息压根就没有发送到Broker端；或者消息本身不合格导致Broker拒绝接收（比如消息太大了，超过了Broker的承受能力）等。</p><p>实际上，解决此问题的方法非常简单：Producer永远要使用带有回调通知的发送API，也就是说不要使用<code>producer.send(msg)</code>，而要使用<code>producer.send(msg, callback)</code>。</p><p>它能准确地告诉你消息是否真的提交成功了。</p><p>一旦出现消息提交失败的情况，你就可以有针对性地进行处理。</p><p><strong>「消费者程序丢失数据」</strong></p><p>Consumer端丢失数据主要体现在Consumer端要消费的消息不见了。</p><p>下面这张图它清晰地展示了Consumer端的位移数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606224115640.png" alt="image-20240606224115640"></p><p>比如对于Consumer A而言，它当前的位移值就是9；Consumer B的位移值是11。</p><p>Consumer程序从Kafka获取到消息后开启了多个线程异步处理消息，而Consumer程序自动地向前更新位移。</p><p>假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于Consumer而言实际上是丢失了。</p><p>这里的关键在于Consumer自动提交位移。</p><p>这个问题的解决方案也很简单：</p><p><strong>「如果是多线程异步处理消费消息，Consumer程序不要开启自动提交位移，而是要应用程序手动提交位移」</strong>。</p><h2 id="最佳实践">最佳实践</h2><p>总结Kafka无消息丢失的配置：</p><ol><li>不要使用<code>producer.send(msg)</code>，而要使用<code>producer.send(msg, callback)</code>，一定要使用带有回调通知的send方法。</li><li>设置<code>acks = all</code>，acks是Producer的一个参数，代表了你对已提交消息的定义，如果设置成all，则表明所有副本Broker都要接收到消息，该消息才算是已提交。</li><li>设置retries为一个较大的值。这里的retries同样是Producer的参数，对应前面提到的Producer自动重试，当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了<code>retries &gt; 0</code>的Producer能够自动重试消息发送，避免消息丢失。</li><li>设置<code>unclean.leader.election.enable = false</code>，这是Broker端的参数，它控制的是哪些Broker有资格竞选分区的Leader，如果一个Broker落后原先的Leader太多，那么它一旦成为新的Leader，必然会造成消息的丢失，故一般都要将该参数设置成false，即不允许这种情况的发生。</li><li>设置<code>replication.factor &gt;= 3</code>，这也是Broker端的参数，将消息多保存几份，目前防止消息丢失的主要机制就是冗余。</li><li>设置<code>min.insync.replicas &gt; 1</code>，这依然是Broker端参数，控制的是消息至少要被写入到多少个副本才算是已提交，设置成大于1可以提升消息持久性，在实际环境中千万不要使用默认值1。</li><li>确保<code>replication.factor &gt; min.insync.replicas</code>，如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了，我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成，推荐设置成<code>replication.factor = min.insync.replicas + 1</code>。</li><li>确保消息消费完成再提交，Consumer端有个参数<code>enable.auto.commit</code>，最好把它设置成false，并采用手动提交位移的方式。</li></ol><h2 id="重复消费问题">重复消费问题</h2><p><strong>「消费重复的场景」</strong></p><p>在<code>enable.auto.commit</code> 默认值true情况下，出现重复消费的场景有以下几种：</p><blockquote><p>❝</p><p>consumer 在消费过程中，应用进程被强制kill掉或发生异常退出。</p><p>❞</p></blockquote><p>例如在一次poll 500条消息后，消费到200条时，进程被强制kill消费到offset未提交，或出现异常退出导致消费到offset未提交。</p><p>下次重启时，依然会重新拉取500消息，造成之前消费到200条消息重复消费了两次。</p><p>解决方案：在发生异常时正确处理未提交的offset</p><p><strong>「消费者消费时间过长」</strong></p><p><code>max.poll.interval.ms</code>参数定义了两次poll的最大间隔，它的默认值是 5 分钟，表示你的 Consumer 程序如果在 5 分钟之内无法消费完 poll 方法返回的消息，那么 Consumer 会主动发起离开组的请求，Coordinator 也会开启新一轮 Rebalance。</p><p>举例：单次拉取11条消息，每条消息耗时30s，11条消息耗时5分钟30秒，由于<code>max.poll.interval.ms</code> 默认值5分钟，所以消费者无法在5分钟内消费完，consumer会离开组，导致rebalance。</p><p>在消费完11条消息后，consumer会重新连接broker，再次rebalance，因为上次消费的offset未提交，再次拉取的消息是之前消费过的消息，造成重复消费。</p><p><strong>「解决方案：」</strong></p><p>1、提高消费能力，提高单条消息的处理速度；根据实际场景可讲<code>max.poll.interval.ms</code>值设置大一点，避免不必要的rebalance；可适当减小<code>max.poll.records</code>的值，默认值是500，可根据实际消息速率适当调小。</p><p>2、生成消息时，可加入唯一标识符如消息id，在消费端，保存最近的1000条消息id存入到redis或mysql中，消费的消息时通过前置去重。</p><h2 id="消息顺序问题">消息顺序问题</h2><p>我们都知道<code>kafka</code>的<code>topic</code>是无序的，但是一个<code>topic</code>包含多个<code>partition</code>，每个<code>partition</code>内部是有序的</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606224242118.png" alt="image-20240606224242118"></p><p><strong>「乱序场景1」</strong></p><p>因为一个topic可以有多个partition，kafka只能保证partition内部有序</p><p><strong>「解决方案」</strong></p><p>1、可以设置topic，有且只有一个partition</p><p>2、根据业务需要，需要顺序的 指定为同一个partition</p><p>3、根据业务需要，比如同一个订单，使用同一个key，可以保证分配到同一个partition上</p><p><strong>「乱序场景2」</strong></p><p>对于同一业务进入了同一个消费者组之后，用了多线程来处理消息，会导致消息的乱序</p><p><strong>「解决方案」</strong></p><p>消费者内部根据线程数量创建等量的内存队列，对于需要顺序的一系列业务数据，根据key或者业务数据，放到同一个内存队列中，然后线程从对应的内存队列中取出并操作</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606224303633.png" alt="image-20240606224303633"></p><p><strong>「通过设置相同key来保证消息有序性，会有一点缺陷：」</strong></p><p>例如消息发送设置了重试机制，并且异步发送，消息A和B设置相同的key，业务上A先发，B后发，由于网络或者其他原因A发送失败，B发送成功；A由于发送失败就会重试且重试成功，这时候消息顺序B在前A在后，与业务发送顺序不一致，如果需要解决这个问题，需要设置参数<code>max.in.flight.requests.per.connection=1</code>，其含义是限制客户端在单个连接上能够发送的未响应请求的个数，设置此值是1表示kafka broker在响应请求之前client不能再向同一个broker发送请求，这个参数默认值是5</p><blockquote><p>❝</p><p>官方文档说明，这个参数如果大于1，由于重试消息顺序可能重排</p></blockquote><h2 id="高性能原因">高性能原因</h2><p><strong>「顺序读写」</strong></p><p>kafka的消息是不断追加到文件中的，这个特性使<code>kafka</code>可以充分利用磁盘的顺序读写性能</p><p>顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写</p><p>Kafka 可以配置异步刷盘，不开启同步刷盘，异步刷盘不需要等写入磁盘后返回消息投递的 ACK，所以它提高了消息发送的吞吐量，降低了请求的延时</p><p><strong>「零拷贝」</strong></p><p>传统的 IO 流程，需要先把数据拷贝到内核缓冲区，再从内核缓冲拷贝到用户空间，应用程序处理完成以后，再拷贝回内核缓冲区</p><p>这个过程中发生了多次数据拷贝</p><p>为了减少不必要的拷贝，<code>Kafka</code> 依赖 Linux 内核提供的 <code>Sendfile</code> 系统调用</p><p>在 Sendfile 方法中，数据在内核缓冲区完成输入和输出，不需要拷贝到用户空间处理，这也就避免了重复的数据拷贝</p><p>在具体的操作中，Kafka 把所有的消息都存放在单独的文件里，在消息投递时直接通过 <code>Sendfile</code> 方法发送文件，减少了上下文切换，因此大大提高了性能</p><p><strong>「MMAP技术」</strong></p><p>除了 <code>Sendfile</code> 之外，还有一种零拷贝的实现技术，即 Memory Mapped Files</p><p>Kafka 使用 <code>Memory Mapped Files</code> 完成内存映射，<code>Memory Mapped Files</code> 对文件的操作不是 <code>write/read</code>，而是直接对内存地址的操作，如果是调用文件的 <code>read</code> 操作，则把数据先读取到内核空间中，然后再复制到用户空间，但 <code>MMAP</code>可以将文件直接映射到用户态的内存空间，省去了用户空间到内核空间复制的开销</p><p>Producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入</p><p>Customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。</p><p><strong>「批量发送读取」</strong></p><p>Kafka 的批量包括批量写入、批量发布等。它在消息投递时会将消息缓存起来，然后批量发送</p><p>同样，消费端在消费消息时，也不是一条一条处理的，而是批量进行拉取，提高了消息的处理速度</p><p><strong>「数据压缩」</strong></p><p>Kafka还支持对消息集合进行压缩，<code>Producer</code>可以通过<code>GZIP</code>或<code>Snappy</code>格式对消息集合进行压缩</p><p>压缩的好处就是减少传输的数据量，减轻对网络传输的压力</p><p>Producer压缩之后，在<code>Consumer</code>需进行解压，虽然增加了CPU的工作，但在对大数据处理上，瓶颈在网络上而不是CPU，所以这个成本很值得</p><p><strong>「分区机制」</strong></p><p>kafka中的topic中的内容可以被分为多partition存在，每个partition又分为多个段segment，所以每次操作都是针对一小部分做操作，很轻便，并且增加<code>并行操作</code>的能力</p><h2 id="常见面试题">常见面试题</h2><p><strong>「Kafka是Push还是Pull模式？」</strong></p><p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer。</p><p>在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。</p><p>push模式由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。</p><p>消息系统都致力于让consumer以最大的速率最快速的消费消息，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。</p><blockquote><p>❝</p><p>Kafka中的Producer和Consumer采用的是Push-and-Pull模式，即Producer向Broker Push消息，Consumer从Broker Pull消息。</p><p>❞</p></blockquote><p>Pull模式的一个好处是consumer可以自主决定是否批量的从broker拉取数据。</p><p>Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。</p><p>[<a href="https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&amp;mid=2247484980&amp;idx=1&amp;sn=6e0c7112dd72d0edc284009e7503b2ac&amp;scene=21#wechat_redirect">面试题：Kafka如何保证高可用？有图有真相</a>](<a href="https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&amp;mid=2247484980&amp;idx=1&amp;sn=6e0c7112dd72d0edc284009e7503b2ac&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&amp;mid=2247484980&amp;idx=1&amp;sn=6e0c7112dd72d0edc284009e7503b2ac&amp;scene=21#wechat_redirect</a>)</p><p><strong>「Kafk的使用场景」</strong></p><p>业界Kafka实际应用场景</p><blockquote><p>❝</p><p>异步通信</p><p>❞</p></blockquote><p>消息中间件在异步通信中用的最多，很多业务流程中，如果所有步骤都同步进行可能会导致核心流程耗时非常长，更重要的是所有步骤都同步进行一旦非核心步骤失败会导致核心流程整体失败，因此在很多业务流程中Kafka就充当了异步通信角色。</p><blockquote><p>❝</p><p>日志同步</p><p>❞</p></blockquote><p>大规模分布式系统中的机器非常多而且分散在不同机房中，分布式系统带来的一个明显问题就是业务日志的查看、追踪和分析等行为变得十分困难，对于集群规模在百台以上的系统，查询线上日志很恐怖。</p><p>为了应对这种场景统一日志系统应运而生，日志数据都是海量数据，通常为了不给系统带来额外负担一般会采用异步上报，这里Kafka以其高吞吐量在日志处理中得到了很好的应用。</p><blockquote><p>❝</p><p>实时计算</p><p>❞</p></blockquote><p>随着据量的增加，离线的计算会越来越慢，难以满足用户在某些场景下的实时性要求，因此很多解决方案中引入了实时计算。</p><p>很多时候，即使是海量数据，我们也希望即时去查看一些数据指标，实时流计算应运而生。</p><p>实时流计算有两个特点，一个是实时，随时可以看数据；另一个是流。</p><p>转载·自：<a href="https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&amp;mid=2247487063&amp;idx=1&amp;sn=d7c65359630a67695a079d62fce989c0&amp;chksm=fa5bda68cd2c537ed32003d5a98705e85c6b7a47afe0f837cebd27a5f33a8a11231d3eb9c1c5&amp;scene=27#wechat_redirect">Kafka核心知识总结！</a></p>]]></content>
    
    
    <summary type="html">Kafka核心知识总结!</summary>
    
    
    
    <category term="消息队列" scheme="https://penge666.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://penge666.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Kafka基本术语</title>
    <link href="https://penge666.github.io/posts/93a1f5a2.html"/>
    <id>https://penge666.github.io/posts/93a1f5a2.html</id>
    <published>2024-06-06T12:44:25.000Z</published>
    <updated>2024-06-06T14:49:11.709Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache Kafka是一款开源的消息引擎系统</strong>。</p><p>Kafka-Messaging-System</p><p>常见的有两种方法：</p><ul><li><strong>点对点模型</strong>：也叫消息队列模型。如果拿上面那个“民间版”的定义来说，那么系统A发送的消息只能被系统B接收，其他任何系统都不能读取A发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。</li><li><strong>发布/订阅模型</strong>：与上面不同的是，它有一个主题（Topic）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。生活中的报纸订阅就是一种典型的发布/订阅模型。</li></ul><p><strong>基本术语概念</strong></p><p>Kafka属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。在Kafka中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。</p><p>向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地向一个或多个主题发送消息，而订阅这些主题消息的客户端应用程序就被称为消费者（Consumer）。和生产者类似，消费者也能够同时订阅多个主题的消息。我们把生产者和消费者统称为客户端（Clients）。你可以同时运行多个生产者和消费者实例，这些实例会不断地向Kafka集群中的多个主题生产和消费消息。</p><p>有客户端自然也就有服务器端。Kafka的服务器端由被称为Broker的服务进程构成，即一个Kafka集群由多个Broker组成，Broker负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然多个Broker进程能够运行在同一台机器上，但更常见的做法是将不同的Broker分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有Broker进程都挂掉了，其他机器上的Broker也依然能够对外提供服务。这其实就是Kafka提供高可用的手段之一。</p><p>实现高可用的另一个手段就是备份机制（Replication）。备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在Kafka中被称为副本（Replica）。好吧，其实在整个分布式系统里好像都叫这个名字。副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。Kafka定义了两类副本：领导者副本（Leader Replica）和追随者副本（Follower Replica）。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。当然了，你可能知道在很多其他系统中追随者副本是可以对外提供服务的，比如MySQL的从库是可以处理读操作的，但是在Kafka中追随者副本不会对外提供服务。对了，一个有意思的事情是现在已经不提倡使用Master-Slave来指代这种主从关系了，毕竟Slave有奴隶的意思，在美国这种严禁种族歧视的国度，这种表述有点政治不正确了，所以目前大部分的系统都改成Leader-Follower了。</p><p>副本的工作机制也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p><p>虽然有了副本机制可以保证数据的持久化或消息不丢失，但没有解决伸缩性的问题。伸缩性即所谓的Scalability，是分布式系统中非常重要且必须要谨慎对待的问题。什么是伸缩性呢？我们拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台Broker机器都无法容纳了，此时应该怎么办呢？一个很自然的想法就是，能否把数据分割成多份保存在不同的Broker上？如果你就是这么想的，那么恭喜你，Kafka就是这么设计的。</p><p>这种机制就是所谓的分区（Partitioning）。如果你了解其他分布式系统，你可能听说过分片、分区域等提法，比如MongoDB和Elasticsearch中的Sharding、HBase中的Region，其实它们都是相同的原理，只是Partitioning是最标准的名称。</p><p>Kafka中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区0中，要么在分区1中。如你所见，Kafka的分区编号是从0开始的，如果Topic有100个分区，那么它们的分区号就是从0到99。</p><p>讲到这里，你可能有这样的疑问：刚才提到的副本如何与这里的分区联系在一起呢？实际上，副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有1个领导者副本和N-1个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。分区位移总是从0开始，假设一个生产者向一个空分区写入了10条消息，那么这10条消息的位移依次是0、1、2、……、9。</p><p>至此我们能够完整地串联起Kafka的三层消息架构：</p><ul><li>第一层是主题层，每个主题可以配置M个分区，而每个分区又可以配置N个副本。</li><li>第二层是分区层，每个分区的N个副本中只能有一个充当领导者角色，对外提供服务；其他N-1个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是消息层，分区中包含若干条消息，每条消息的位移从0开始，依次递增。</li><li>最后，客户端程序只能与分区的领导者副本进行交互。</li></ul><p>讲完了消息层次，我们来说说Kafka Broker是如何持久化数据的。总的来说，Kafka使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。因为只能追加写入，故避免了缓慢的随机I/O操作，改为性能较好的顺序I/O写操作，这也是实现Kafka高吞吐量特性的一个重要手段。不过如果你不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此Kafka必然要定期地删除消息以回收磁盘。怎么删除呢？简单来说就是通过日志段（Log Segment）机制。在Kafka底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>这里再重点说说消费者。在专栏的第一期中我提到过两种消息模型，即点对点模型（Peer to Peer，P2P）和发布订阅模型。这里面的点对点指的是同一条消息只能被下游的一个消费者消费，其他消费者则不能染指。在Kafka中实现这种P2P模型的方法就是引入了消费者组（Consumer Group）。所谓的消费者组，指的是多个消费者实例共同组成一个组来消费一组主题。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。为什么要引入消费者组呢？主要是为了提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）。我会在专栏的后面详细介绍消费者组机制，所以现在你只需要了解消费者组是做什么的即可。另外这里的消费者实例可以是运行消费者应用的进程，也可以是一个线程，它们都称为一个消费者实例（Consumer Instance）。</p><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助。假设组内某个实例挂掉了，Kafka能够自动检测到，然后把这个Failed实例之前负责的分区转移给其他活着的消费者。这个过程就是Kafka中大名鼎鼎的“重平衡”（Rebalance）。嗯，其实既是大名鼎鼎，也是臭名昭著，因为由重平衡引发的消费者问题比比皆是。事实上，目前很多重平衡的Bug社区都无力解决。</p><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（Consumer Offset）。注意，这和上面所说的位移完全不是一个概念。上面的“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。而消费者位移则不同，它可能是随时变化的，毕竟它是消费者消费进度的指示器嘛。另外每个消费者有着自己的消费者位移，因此一定要区分这两类位移的区别。我个人把消息在分区中的位移称为分区位移，而把消费者端的位移称为消费者位移。</p><p><strong>总结</strong></p><p>我来总结一下今天提到的所有名词术语：</p><ul><li>消息：Record。Kafka是消息引擎嘛，这里的消息就是指Kafka处理的主要对象。</li><li>主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li><li>分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。</li><li>消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li><li>副本：Replica。Kafka中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li><li>生产者：Producer。向主题发布新消息的应用程序。</li><li>消费者：Consumer。从主题订阅新消息的应用程序。</li><li>消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。</li><li>消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li><li>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance是Kafka消费者端实现高可用的重要手段。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606204014760.png" alt="image-20240606204014760"></p><p><strong>Kafka消息引擎系统的意义</strong></p><p>当引入了Kafka之后。上游订单服务不再直接与下游子服务进行交互。当新订单生成后它仅仅是向Kafka Broker发送一条订单消息即可。类似地，下游的各个子服务订阅Kafka中的对应主题，并实时从该主题的各自分区（Partition）中获取到订单消息进行处理，从而实现了上游订单服务与下游订单处理服务的解耦。这样当出现秒杀业务时，Kafka能够将瞬时增加的订单流量全部以消息形式保存在对应的主题中，既不影响上游服务的TPS，同时也给下游子服务留出了充足的时间去消费它们。</p><p><strong>Kafka只是消息引擎系统吗?</strong></p><ol><li>Kafka在设计之初就旨在提供三个方面的特性:提供一套API实现生产者和消费者;降低网络传输和磁盘存储开销;实现高伸缩性架构。</li><li>作为<strong>流处理平台</strong>，Kafka与其他主流大数据流式计算框架相比,优势有两点:更容易实现端到端的正确性;它自己对于流式计算的定位。</li><li>Apache Kafka是消息引擎系统,也是一个分布式流处理平台。除此之外，Kafka还能够被用作分布式存储系统。不过我觉得你姑且了解下就好了，我从没有见过在实际生产环境中，有人把Kafka当作持久化存储来用。</li></ol><p><strong>Kafka介绍</strong></p><ul><li>Apache Kafka，也称社区版Kafka。优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。</li><li>Confluent Kafka，Confluent公司提供的Kafka。优势在于集成了很多高级特性且由Kafka原班人马打造，质量上有保证；缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。</li><li>CDH/HDP Kafka，大数据云公司提供的Kafka，内嵌Apache Kafka。优势在于操作简单，节省运维成本；缺陷在于把控度低，演进速度较慢。</li></ul><p><strong>Kafka版本号</strong></p><ul><li>0.7版本:只提供了最基础的消息队列功能。</li><li>0.8版本:引入了副本机制，至此Kafka成为了一个真正意义上完备的分布式高可靠消息队列解决方案。</li><li>0.9.0.0版本:增加了基础的安全认证/权限功能;使用Java重写了新版本消费者API;引入了Kafka Connect组件。</li><li>0.10.0.0版本:引入了Kafka Streams，正式升级成分布式流处理平台。</li><li>0.11.0.0版本:提供了幂等性Producer API以及事务API;对Kafka消息格式做了重构。</li><li>1.0和2.0版本:主要还是Kafka Streams的各种改进。</li></ul><p><strong>Kafka客户端底层使用了Java的selector，selector在Linux上的实现机制是epoll，而在Windows平台上的实现机制是select。因此在这一点上将Kafka部署在Linux上是有优势的，因为能够获得更高效的I/O性能。</strong></p>]]></content>
    
    
    <summary type="html">Kafka概念介绍</summary>
    
    
    
    <category term="消息队列" scheme="https://penge666.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://penge666.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>etcd的读写请求</title>
    <link href="https://penge666.github.io/posts/5e31aad7.html"/>
    <id>https://penge666.github.io/posts/5e31aad7.html</id>
    <published>2024-06-06T08:41:45.000Z</published>
    <updated>2024-06-06T08:47:24.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础架构">基础架构</h2><p>基础架构</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164308547.png" alt="image-20240606164308547"></p><p>按照分层模型，etcd可分为Client层、API网络层、Raft算法层、逻辑层和存储层。这些层的功能如下：</p><ul><li><strong>Client层</strong>：Client层包括client v2和v3两个大版本API客户端库，提供了简洁易用的API，同时支持负载均衡、节点间故障自动转移，可极大降低业务使用etcd复杂度，提升开发效率、服务可用性。</li><li><strong>API网络层</strong>：API网络层主要包括client访问server和server节点之间的通信协议。一方面，client访问etcd server的API分为v2和v3两个大版本。v2 API使用HTTP/1.x协议，v3 API使用gRPC协议。同时v3通过etcd grpc-gateway组件也支持HTTP/1.x协议，便于各种语言的服务调用。另一方面，server之间通信协议，是指节点间通过Raft算法实现数据复制和Leader选举等功能时使用的HTTP协议。</li><li><strong>Raft算法层</strong>：Raft算法层实现了Leader选举、日志复制、ReadIndex等核心算法特性，用于保障etcd多个节点间的数据一致性、提升服务可用性等，是etcd的基石和亮点。</li><li><strong>功能逻辑层</strong>：etcd核心特性实现层，如典型的KVServer模块、MVCC模块、Auth鉴权模块、Lease租约模块、Compactor压缩模块等，其中MVCC模块主要由treeIndex模块和boltdb模块组成。</li><li><strong>存储层</strong>：存储层包含预写日志(WAL)模块、快照(Snapshot)模块、boltdb模块。其中WAL可保障etcd crash后数据不丢失，boltdb则保存了集群元数据和用户写入的数据。</li></ul><p>etcd是典型的<strong>读多写少存储</strong>。</p><h2 id="etcd读请求">etcd读请求</h2><p>读请求流程图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164336292.png" alt="image-20240606164336292"></p><h3 id="KVServer模块">KVServer模块</h3><p>client发送Range RPC请求到了server后，就开始进入我们架构图中的流程二，也就是KVServer模块了。</p><p>etcd提供了丰富的metrics、日志、请求行为检查等机制，可记录所有请求的执行耗时及错误码、来源IP等，也可控制请求是否允许通过，比如etcd Learner节点只允许指定接口和参数的访问，帮助大家定位问题、提高服务可观测性等，而这些特性是怎么非侵入式的实现呢？</p><p>答案就是拦截器。</p><h4 id="拦截器">拦截器</h4><p>etcd server定义了如下的Service KV和Range方法，启动的时候它会将实现KV各方法的对象注册到gRPC Server，并在其上注册对应的拦截器。下面的代码中的Range接口就是负责读取etcd key-value的的RPC接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service KV &#123;  </span><br><span class="line">  <span class="comment">// Range gets the keys in the range from the key-value store.  </span></span><br><span class="line">  <span class="function">rpc <span class="title">Range</span><span class="params">(RangeRequest)</span> <span class="title">returns</span> <span class="params">(RangeResponse)</span> </span>&#123;  </span><br><span class="line">      <span class="built_in">option</span> (google.api.http) = &#123;  </span><br><span class="line">        post: <span class="string">&quot;/v3/kv/range&quot;</span>  </span><br><span class="line">        body: <span class="string">&quot;*&quot;</span>  </span><br><span class="line">      &#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line">  ....</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>拦截器提供了在执行一个请求前后的hook能力，除了我们上面提到的debug日志、metrics统计、对etcd Learner节点请求接口和参数限制等能力，etcd还基于它实现了以下特性:</p><ul><li>要求执行一个操作前集群必须有Leader；</li><li>请求延时超过指定阈值的，打印包含来源IP的慢查询日志(3.5版本)。</li></ul><p>server收到client的Range RPC请求后，根据ServiceName和RPC Method将请求转发到对应的handler实现，handler首先会将上面描述的一系列拦截器串联成一个执行，在拦截器逻辑中，通过调用KVServer模块的Range接口获取数据。</p><h4 id="串行读与线性读">串行读与线性读</h4><p>进入KVServer模块后，我们就进入核心的读流程了，对应架构图中的流程三和四。我们知道etcd为了保证服务高可用，生产环境一般部署多个节点，那各个节点数据在任意时间点读出来都是一致的吗？什么情况下会读到旧数据呢？</p><p>这里为了帮助你更好的理解读流程，我先简单提下写流程。如下图所示，当client发起一个更新hello为world请求后，若Leader收到写请求，它会将此请求持久化到WAL日志，并广播给各个节点，若一半以上节点持久化成功，则该请求对应的日志条目被标识为已提交，etcdserver模块异步从Raft模块获取已提交的日志条目，应用到状态机(boltdb等)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164413824.png" alt="image-20240606164413824"></p><p>此时若client发起一个读取hello的请求，假设此请求直接从状态机中读取， 如果连接到的是C节点，若C节点磁盘I/O出现波动，可能导致它应用已提交的日志条目很慢，则会出现更新hello为world的写命令，在client读hello的时候还未被提交到状态机，因此就可能读取到旧数据，如上图查询hello流程所示。</p><p>从以上介绍我们可以看出，在多节点etcd集群中，各个节点的状态机数据一致性存在差异。而我们不同业务场景的读请求对数据是否最新的容忍度是不一样的，有的场景它可以容忍数据落后几秒甚至几分钟，有的场景要求必须读到反映集群共识的最新数据。</p><p>我们首先来看一个<strong>对数据敏感度较低的场景</strong>。</p><p>假如老板让你做一个旁路数据统计服务，希望你每分钟统计下etcd里的服务、配置信息等，这种场景其实对数据时效性要求并不高，读请求可直接从节点的状态机获取数据。即便数据落后一点，也不影响业务，毕竟这是一个定时统计的旁路服务而已。</p><p>这种直接读状态机数据返回、无需通过Raft协议与集群进行交互的模式，在etcd里叫做<strong>串行(<strong><strong>Serializable</strong></strong>)读</strong>，它具有低延时、高吞吐量的特点，适合对数据一致性要求不高的场景。</p><p>我们再看一个<strong>对数据敏感性高的场景</strong>。</p><p>当你发布服务，更新服务的镜像的时候，提交的时候显示更新成功，结果你一刷新页面，发现显示的镜像的还是旧的，再刷新又是新的，这就会导致混乱。再比如说一个转账场景，Alice给Bob转账成功，钱被正常扣出，一刷新页面发现钱又回来了，这也是令人不可接受的。</p><p>以上的业务场景就对数据准确性要求极高了，在etcd里面，提供了一种线性读模式来解决对数据一致性要求高的场景。</p><p><strong>什么是线性读呢?</strong></p><p>你可以理解一旦一个值更新成功，随后任何通过线性读的client都能及时访问到。虽然集群中有多个节点，但client通过线性读就如访问一个节点一样。etcd默认读模式是线性读，因为它需要经过Raft协议模块，反应的是集群共识，因此在延时和吞吐量上相比串行读略差一点，适用于对数据一致性要求高的场景。</p><p>如果你的etcd读请求显示指定了是串行读，就不会经过架构图流程中的流程三、四。默认是线性读，因此接下来我们看看读请求进入线性读模块，它是如何工作的。</p><p><strong>在etcd中，读操作主要有两种模式：串行读（Serialize）和线性读（Linearizable）。</strong></p><ol><li>串行读：这种读模式是在同一个节点上进行的，它不需要经过Raft协议模块的处理。串行读可以快速地读取数据，因为它不需要等待其他节点的确认，但是它可能无法读取到最新的数据。这种模式在对数据一致性要求不高，但对读取速度有较大需求的场景下比较适用。</li><li>线性读：这种读模式需要经过Raft协议模块的处理，它能反应集群的共识状态，也就是说，它可以保证读取到的数据是最新的。但是，因为需要经过Raft协议的处理，所以在延时和吞吐量上，线性读可能会比串行读略差一些。这种模式在对数据一致性要求高的场景下比较适用。</li></ol><p>举个例子，假设我们有一个在线购物网站，用户在浏览商品信息时，我们可以使用串行读来快速获取商品信息，因为这些信息一般不会频繁更新，即使偶尔读取到的是稍微旧一点的数据，也不会影响用户的使用体验。而在用户下单购买商品时，我们需要使用线性读来获取商品的库存信息，因为这个信息可能会被其他用户的购买行为实时改变，我们需要确保读取到的库存信息是最新的，以防止出现超卖的情况。</p><h4 id="线性读之ReadIndex">线性读之ReadIndex</h4><p>前面我们聊到串行读时提到，它之所以能读到旧数据，主要原因是Follower节点收到Leader节点同步的写请求后，应用日志条目到状态机是个异步过程，那么我们能否有一种机制在读取的时候，确保最新的数据已经应用到状态机中？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164512356.png" alt="image-20240606164512356"></p><p>其实这个机制就是叫ReadIndex，它是在etcd 3.1中引入的，我把简化后的原理图放在了上面。当收到一个线性读请求时，它首先会从Leader获取集群最新的已提交的日志索引(committed index)，如上图中的流程二所示。</p><p>Leader收到ReadIndex请求时，为防止脑裂等异常场景，会向Follower节点发送心跳确认，一半以上节点确认Leader身份后才能将已提交的索引(committed index)返回给节点C(上图中的流程三)。</p><p>C节点则会等待，直到状态机已应用索引(applied index)大于等于Leader的已提交索引时(committed Index)(上图中的流程四)，然后去通知读请求，数据已赶上Leader，你可以去状态机中访问数据了(上图中的流程五)。</p><p>以上就是线性读通过ReadIndex机制保证数据一致性原理， 当然还有其它机制也能实现线性读，如在早期etcd 3.0中读请求通过走一遍Raft协议保证一致性， 这种Raft log read机制依赖磁盘IO， 性能相比ReadIndex较差。</p><p>总体而言，KVServer模块收到线性读请求后，通过架构图中流程三向Raft模块发起ReadIndex请求，Raft模块将Leader最新的已提交日志索引封装在流程四的ReadState结构体，通过channel层层返回给线性读模块，线性读模块等待本节点状态机追赶上Leader进度，追赶完成后，就通知KVServer模块，进行架构图中流程五，与状态机中的MVCC模块进行进行交互了。</p><h2 id="etcd写请求">etcd写请求</h2><p>写请求流程图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164533960.png" alt="image-20240606164533960"></p><h3 id="Quota模块">Quota模块</h3><p>首先是流程一client端发起gRPC调用到etcd节点，和读请求不一样的是，写请求需要经过流程二db配额（Quota）模块，它有什么功能呢？</p><p>我们先从此模块的一个常见错误说起，你在使用etcd过程中是否遇到过”etcdserver: mvcc: database space exceeded”错误呢？</p><p>我相信只要你使用过etcd或者Kubernetes，大概率见过这个错误。它是指当前etcd db文件大小超过了配额，当出现此错误后，你的整个集群将不可写入，只读，对业务的影响非常大。</p><p>哪些情况会触发这个错误呢？</p><p>一方面默认db配额仅为2G，当你的业务数据、写入QPS、Kubernetes集群规模增大后，你的etcd db大小就可能会超过2G。</p><p>另一方面我们知道etcd v3是个MVCC数据库，保存了key的历史版本，当你未配置压缩策略的时候，随着数据不断写入，db大小会不断增大，导致超限。</p><p>最后你要特别注意的是，如果你使用的是etcd 3.2.10之前的旧版本，请注意备份可能会触发boltdb的一个Bug，它会导致db大小不断上涨，最终达到配额限制。</p><p>了解完触发Quota限制的原因后，我们再详细了解下Quota模块它是如何工作的。</p><p>当etcd server收到put/txn等写请求的时候，会首先检查下当前etcd db大小加上你请求的key-value大小之和是否超过了配额（quota-backend-bytes）。</p><p>如果超过了配额，它会产生一个告警（Alarm）请求，告警类型是NO SPACE，并通过Raft日志同步给其它节点，告知db无空间了，并将告警持久化存储到db中。</p><p>最终，无论是API层gRPC模块还是负责将Raft侧已提交的日志条目应用到状态机的Apply模块，都拒绝写入，集群只读。</p><p>那遇到这个错误时应该如何解决呢？</p><p>首先当然是调大配额。具体多大合适呢？etcd社区建议不超过8G。遇到过这个错误的你是否还记得，为什么当你把配额（quota-backend-bytes）调大后，集群依然拒绝写入呢?</p><p>原因就是我们前面提到的NO SPACE告警。Apply模块在执行每个命令的时候，都会去检查当前是否存在NO SPACE告警，如果有则拒绝写入。所以还需要你额外发送一个取消告警（etcdctl alarm disarm）的命令，以消除所有告警。</p><p>其次你需要检查etcd的压缩（compact）配置是否开启、配置是否合理。etcd保存了一个key所有变更历史版本，如果没有一个机制去回收旧的版本，那么内存和db大小就会一直膨胀，在etcd里面，压缩模块负责回收旧版本的工作。</p><p>压缩模块支持按多种方式回收旧版本，比如保留最近一段时间内的历史版本。不过你要注意，它仅仅是将旧版本占用的空间打个空闲（Free）标记，后续新的数据写入的时候可复用这块空间，而无需申请新的空间。</p><p>如果你需要回收空间，减少db大小，得使用碎片整理（defrag）， 它会遍历旧的db文件数据，写入到一个新的db文件。但是它对服务性能有较大影响，不建议你在生产集群频繁使用。</p><p>最后你需要注意配额（quota-backend-bytes）的行为，默认’0’就是使用etcd默认的2GB大小，你需要根据你的业务场景适当调优。如果你填的是个小于0的数，就会禁用配额功能，这可能会让你的db大小处于失控，导致性能下降，不建议你禁用配额。</p><h3 id="KVServer模块-2">KVServer模块</h3><p>通过流程二的配额检查后，请求就从API层转发到了流程三的KVServer模块的put方法，我们知道etcd是基于Raft算法实现节点间数据复制的，因此它需要将put写请求内容打包成一个提案消息，提交给Raft模块。不过KVServer模块在提交提案前，还有如下的一系列检查和限速。</p><h4 id="Preflight-Check">Preflight Check</h4><p>为了保证集群稳定性，避免雪崩，任何提交到Raft模块的请求，都会做一些简单的限速判断。如下面的流程图所示，首先，如果Raft模块已提交的日志索引（committed index）比已应用到状态机的日志索引（applied index）超过了5000，那么它就返回一个”etcdserver: too many requests”错误给client。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164603041.png" alt="image-20240606164603041"></p><p>然后它会尝试去获取请求中的鉴权信息，若使用了密码鉴权、请求中携带了token，如果token无效，则返回”auth: invalid auth token”错误给client。</p><p>其次它会检查你写入的包大小是否超过默认的1.5MB， 如果超过了会返回”etcdserver: request is too large”错误给给client。</p><h4 id="Propose">Propose</h4><p>最后通过一系列检查之后，会生成一个唯一的ID，将此请求关联到一个对应的消息通知channel，然后向Raft模块发起（Propose）一个提案（Proposal），提案内容为“大家好，请使用put方法执行一个key为hello，value为world的命令”，也就是整体架构图里的流程四。</p><p>向Raft模块发起提案后，KVServer模块会等待此put请求，等待写入结果通过消息通知channel返回或者超时。etcd默认超时时间是7秒（5秒磁盘IO延时+2*1秒竞选超时时间），如果一个请求超时未返回结果，则可能会出现你熟悉的etcdserver: request timed out错误。</p><h3 id="WAL模块">WAL模块</h3><p>Raft模块收到提案后，如果当前节点是Follower，它会转发给Leader，只有Leader才能处理写请求。Leader收到提案后，通过Raft模块输出待转发给Follower节点的消息和待持久化的日志条目，日志条目则封装了我们上面所说的put hello提案内容。</p><p>etcdserver从Raft模块获取到以上消息和日志条目后，作为Leader，它会将put提案消息广播给集群各个节点，同时需要把集群Leader任期号、投票信息、已提交索引、提案内容持久化到一个WAL（Write Ahead Log）日志文件中，用于保证集群的一致性、可恢复性，也就是我们图中的流程五模块。</p><p>WAL日志结构是怎样的呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164635657.png" alt="image-20240606164635657"></p><p>上图是WAL结构，它由多种类型的WAL记录顺序追加写入组成，每个记录由类型、数据、循环冗余校验码组成。不同类型的记录通过Type字段区分，Data为对应记录内容，CRC为循环校验码信息。</p><p>WAL记录类型目前支持5种，分别是文件元数据记录、日志条目记录、状态信息记录、CRC记录、快照记录：</p><ul><li>文件元数据记录包含节点ID、集群ID信息，它在WAL文件创建的时候写入；</li><li>日志条目记录包含Raft日志信息，如put提案内容；</li><li>状态信息记录，包含集群的任期号、节点投票信息等，一个日志文件中会有多条，以最后的记录为准；</li><li>CRC记录包含上一个WAL文件的最后的CRC（循环冗余校验码）信息， 在创建、切割WAL文件时，作为第一条记录写入到新的WAL文件， 用于校验数据文件的完整性、准确性等；</li><li>快照记录包含快照的任期号、日志索引信息，用于检查快照文件的准确性。</li></ul><p>WAL模块又是如何持久化一个put提案的日志条目类型记录呢?</p><p>首先我们来看看put写请求如何封装在Raft日志条目里面。下面是Raft日志条目的数据结构信息，它由以下字段组成：</p><ul><li>Term是Leader任期号，随着Leader选举增加；</li><li>Index是日志条目的索引，单调递增增加；</li><li>Type是日志类型，比如是普通的命令日志（EntryNormal）还是集群配置变更日志（EntryConfChange）；</li><li>Data保存我们上面描述的put提案内容。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">   Term             uint64    `protobuf:<span class="string">&quot;varint，2，opt，name=Term&quot;</span> json:<span class="string">&quot;Term&quot;</span>`</span><br><span class="line">   Index            uint64    `protobuf:<span class="string">&quot;varint，3，opt，name=Index&quot;</span> json:<span class="string">&quot;Index&quot;</span>`</span><br><span class="line">   Type             EntryType `protobuf:<span class="string">&quot;varint，1，opt，name=Type，enum=Raftpb.EntryType&quot;</span> json:<span class="string">&quot;Type&quot;</span>`</span><br><span class="line">   Data             []<span class="built_in">byte</span>    `protobuf:<span class="string">&quot;bytes，4，opt，name=Data&quot;</span> json:<span class="string">&quot;Data，omitempty&quot;</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解完Raft日志条目数据结构后，我们再看WAL模块如何持久化Raft日志条目。它首先先将Raft日志条目内容（含任期号、索引、提案内容）序列化后保存到WAL记录的Data字段， 然后计算Data的CRC值，设置Type为Entry Type， 以上信息就组成了一个完整的WAL记录。</p><p>最后计算WAL记录的长度，顺序先写入WAL长度（Len Field），然后写入记录内容，调用fsync持久化到磁盘，完成将日志条目保存到持久化存储中。</p><p>当一半以上节点持久化此日志条目后， Raft模块就会通过channel告知etcdserver模块，put提案已经被集群多数节点确认，提案状态为已提交，你可以执行此提案内容了。</p><p>于是进入流程六，etcdserver模块从channel取出提案内容，添加到先进先出（FIFO）调度队列，随后通过Apply模块按入队顺序，异步、依次执行提案内容。</p><h3 id="Apply模块">Apply模块</h3><p>执行put提案内容对应我们架构图中的流程七，其细节图如下。那么Apply模块是如何执行put请求的呢？若put请求提案在执行流程七的时候etcd突然crash了， 重启恢复的时候，etcd是如何找回异常提案，再次执行的呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606164651171.png" alt="image-20240606164651171"></p><p>核心就是我们上面介绍的WAL日志，因为提交给Apply模块执行的提案已获得多数节点确认、持久化，etcd重启时，会从WAL中解析出Raft日志条目内容，追加到Raft日志的存储中，并重放已提交的日志提案给Apply模块执行。</p><p>然而这又引发了另外一个问题，如何确保幂等性，防止提案重复执行导致数据混乱呢?</p><p>我们在上一节课里讲到，etcd是个MVCC数据库，每次更新都会生成新的版本号。如果没有幂等性保护，同样的命令，一部分节点执行一次，一部分节点遭遇异常故障后执行多次，则系统的各节点一致性状态无法得到保证，导致数据混乱，这是严重故障。</p><p>因此etcd必须要确保幂等性。怎么做呢？Apply模块从Raft模块获得的日志条目信息里，是否有唯一的字段能标识这个提案？</p><p>答案就是我们上面介绍Raft日志条目中的索引（index）字段。日志条目索引是全局单调递增的，每个日志条目索引对应一个提案， 如果一个命令执行后，我们在db里面也记录下当前已经执行过的日志条目索引，是不是就可以解决幂等性问题呢？</p><p>是的。但是这还不够安全，如果执行命令的请求更新成功了，更新index的请求却失败了，是不是一样会导致异常？</p><p>因此我们在实现上，还需要将两个操作作为原子性事务提交，才能实现幂等。</p><p>正如我们上面的讨论的这样，etcd通过引入一个consistent index的字段，来存储系统当前已经执行过的日志条目索引，实现幂等性。</p><p>Apply模块在执行提案内容前，首先会判断当前提案是否已经执行过了，如果执行了则直接返回，若未执行同时无db配额满告警，则进入到MVCC模块，开始与持久化存储模块打交道。</p><p><strong>总结</strong>：</p><p>首先我们介绍了Quota模块工作原理和我们熟悉的database space exceeded错误触发原因，写请求导致db大小增加、compact策略不合理、boltdb Bug等都会导致db大小超限。</p><p>其次介绍了WAL模块的存储结构，它由一条条记录顺序写入组成，每个记录含有Type、CRC、Data，每个提案被提交前都会被持久化到WAL文件中，以保证集群的一致性和可恢复性。</p><p>随后我们介绍了Apply模块基于consistent index和事务实现了幂等性，保证了节点在异常情况下不会重复执行重放的提案。</p>]]></content>
    
    
    <summary type="html">etcd的读写请求</summary>
    
    
    
    <category term="etcd" scheme="https://penge666.github.io/categories/etcd/"/>
    
    <category term="数据库" scheme="https://penge666.github.io/categories/etcd/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="etcd" scheme="https://penge666.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>etcd中的MVCC</title>
    <link href="https://penge666.github.io/posts/ebe68de0.html"/>
    <id>https://penge666.github.io/posts/ebe68de0.html</id>
    <published>2024-06-06T08:35:49.000Z</published>
    <updated>2024-06-06T08:39:03.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是MVCC">什么是MVCC</h2><p>首先和你聊聊什么是MVCC，从名字上理解，它是一个基于多版本技术实现的一种并发控制机制。那常见的并发机制有哪些？MVCC的优点在哪里呢？</p><p>提到并发控制机制你可能就没那么陌生了，比如数据库中的悲观锁，也就是通过锁机制确保同一时刻只能有一个事务对数据进行修改操作，常见的实现方案有读写锁、互斥锁、两阶段锁等。</p><p>悲观锁是一种事先预防机制，它悲观地认为多个并发事务可能会发生冲突，因此它要求事务必须先获得锁，才能进行修改数据操作。但是悲观锁粒度过大、高并发场景下大量事务会阻塞等，会导致服务性能较差。</p><p><strong>MVCC机制正是基于多版本技术实现的一种乐观锁机制</strong>，它乐观地认为数据不会发生冲突，但是当事务提交时，具备检测数据是否冲突的能力。</p><p>在MVCC数据库中，你更新一个key-value数据的时候，它并不会直接覆盖原数据，而是新增一个版本来存储新的数据，每个数据都有一个版本号。版本号它是一个逻辑时间，为了方便你深入理解版本号意义，在下面我给你画了一个etcd MVCC版本号时间序列图。</p><p>从图中你可以看到，随着时间增长，你每次修改操作，版本号都会递增。每修改一次，生成一条新的数据记录。<strong>当你指定版本号读取数据时，它实际上访问的是版本号生成那个时间点的快照数据</strong>。当你删除数据的时候，它实际也是新增一条带删除标识的数据记录。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163633150.png" alt="image-20240606163633150"></p><h2 id="MVCC特性初体验">MVCC特性初体验</h2><p>了解完什么是MVCC后，我先通过几个简单命令，带你初体验下MVCC特性，看看它是如何帮助你查询历史修改记录，以及找回不小心删除的key的。</p><p>启动一个空集群，更新两次key hello后，如何获取key hello的上一个版本值呢？ 删除key hello后，还能读到历史版本吗?</p><p>如下面的命令所示，第一次key hello更新完后，我们通过get命令获取下它的key-value详细信息。正如你所看到的，除了key、value信息，还有各类版本号，我后面会详细和你介绍它们的含义。这里我们重点关注mod_revision，它表示key最后一次修改时的etcd版本号。</p><p>当我们再次更新key hello为world2后，然后通过查询时指定key第一次更新后的版本号，你会发现我们查询到了第一次更新的值，甚至我们执行删除key hello后，依然可以获得到这个值。那么etcd是如何实现的呢?</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新key hello为world1</span></span><br><span class="line"><span class="variable">$ </span>etcdctl put hello world1</span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line"><span class="comment"># 通过指定输出模式为json,查看key hello更新后的详细信息</span></span><br><span class="line"><span class="variable">$ </span>etcdctl get hello -w=json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;kvs&quot;</span><span class="symbol">:</span>[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span><span class="symbol">:<span class="string">&quot;aGVsbG8=&quot;</span></span>,</span><br><span class="line">            <span class="string">&quot;create_revision&quot;</span><span class="symbol">:</span><span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;mod_revision&quot;</span><span class="symbol">:</span><span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;version&quot;</span><span class="symbol">:</span><span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span><span class="symbol">:<span class="string">&quot;d29ybGQx&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;count&quot;</span><span class="symbol">:</span><span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 再次修改key hello为world2</span></span><br><span class="line"><span class="variable">$ </span>etcdctl put hello world2</span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line"><span class="comment"># 确认修改成功,最新值为wolrd2</span></span><br><span class="line"><span class="variable">$ </span>etcdctl get hello</span><br><span class="line">hello</span><br><span class="line">world2</span><br><span class="line"><span class="comment"># 指定查询版本号,获得了hello上一次修改的值</span></span><br><span class="line"><span class="variable">$ </span>etcdctl get hello --rev=<span class="number">2</span></span><br><span class="line">hello</span><br><span class="line">world1</span><br><span class="line"><span class="comment"># 删除key hello</span></span><br><span class="line"><span class="variable">$ </span>etcdctl del  hello</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 删除后指定查询版本号3,获得了hello删除前的值</span></span><br><span class="line"><span class="variable">$ </span>etcdctl get hello --rev=<span class="number">3</span></span><br><span class="line">hello</span><br><span class="line">world2</span><br></pre></td></tr></table></figure><h2 id="整体架构">整体架构</h2><p>在详细和你介绍etcd如何实现MVCC特性前，我先和你从整体上介绍下MVCC模块。下图是MVCC模块的一个整体架构图，整个MVCC特性由treeIndex、Backend/boltdb组成。</p><p>当你执行MVCC特性初体验中的put命令后，请求经过gRPC KV Server、Raft模块流转，对应的日志条目被提交后，Apply模块开始执行此日志内容。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163649219.png" alt="image-20240606163649219"></p><p>Apply模块通过MVCC模块来执行put请求，持久化key-value数据。MVCC模块将请求请划分成两个类别，分别是读事务（ReadTxn）和写事务（WriteTxn）。读事务负责处理range请求，写事务负责put/delete操作。读写事务基于treeIndex、Backend/boltdb提供的能力，实现对key-value的增删改查功能。</p><p>treeIndex模块基于内存版B-tree实现了key索引管理，它保存了用户key与版本号（revision）的映射关系等信息。</p><p>Backend模块负责etcd的key-value持久化存储，主要由ReadTx、BatchTx、Buffer组成，ReadTx定义了抽象的读事务接口，BatchTx在ReadTx之上定义了抽象的写事务接口，Buffer是数据缓存区。</p><p>etcd设计上支持多种Backend实现，目前实现的Backend是boltdb。boltdb是一个基于B+ tree实现的、支持事务的key-value嵌入式数据库。</p><p>treeIndex与boltdb关系你可参考下图。当你发起一个get hello命令时，从treeIndex中获取key的版本号，然后再通过这个版本号，从boltdb获取value信息。boltdb的value是包含用户key-value、各种版本号、lease信息的结构体。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163705986.png" alt="image-20240606163705986"></p><p>接下来我和你重点聊聊treeIndex模块的原理与核心数据结构。</p><h2 id="treeIndex原理">treeIndex原理</h2><p>为什么需要treeIndex模块呢?</p><p>对于etcd v2来说，当你通过etcdctl发起一个put hello操作时，etcd v2直接更新内存树，这就导致历史版本直接被覆盖，无法支持保存key的历史版本。在etcd v3中引入treeIndex模块正是为了解决这个问题，支持保存key的历史版本，提供稳定的Watch机制和事务隔离等能力。</p><p>那etcd v3又是如何基于treeIndex模块，实现保存key的历史版本的呢?</p><p>在02节课里，我们提到过etcd在每次修改key时会生成一个全局递增的版本号（revision），然后通过数据结构B-tree保存用户key与版本号之间的关系，再以版本号作为boltdb key，以用户的key-value等信息作为boltdb value，保存到boltdb。</p><p>下面我就为你介绍下，etcd保存用户key与版本号映射关系的数据结构B-tree，为什么etcd使用它而不使用哈希表、平衡二叉树？</p><p>从etcd的功能特性上分析， 因etcd支持范围查询，因此保存索引的数据结构也必须支持范围查询才行。所以哈希表不适合，而B-tree支持范围查询。</p><p>从性能上分析，平横二叉树每个节点只能容纳一个数据、导致树的高度较高，而B-tree每个节点可以容纳多个数据，树的高度更低，更扁平，涉及的查找次数更少，具有优越的增、删、改、查性能。</p><p>Google的开源项目btree，使用Go语言实现了一个内存版的B-tree，对外提供了简单易用的接口。etcd正是基于btree库实现了一个名为treeIndex的索引模块，通过它来查询、保存用户key与版本号之间的关系。</p><p>下图是个最大度（degree &gt; 1，简称d）为5的B-tree，度是B-tree中的一个核心参数，它决定了你每个节点上的数据量多少、节点的“胖”、“瘦”程度。</p><p>从图中你可以看到，节点越胖，意味着一个节点可以存储更多数据，树的高度越低。在一个度为d的B-tree中，节点保存的最大key数为2d - 1，否则需要进行平衡、分裂操作。这里你要注意的是在etcd treeIndex模块中，创建的是最大度32的B-tree，也就是一个叶子节点最多可以保存63个key。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163722544.png" alt="image-20240606163722544"></p><p>从图中你可以看到，你通过put/txn命令写入的一系列key，treeIndex模块基于B-tree将其组织起来，节点之间基于用户key比较大小。当你查找一个key k95时，通过B-tree的特性，你仅需通过图中流程1和2两次快速比较，就可快速找到k95所在的节点。</p><p>在treeIndex中，每个节点的key是一个keyIndex结构，etcd就是通过它保存了用户的key与版本号的映射关系。</p><p>那么keyIndex结构包含哪些信息呢？下面是字段说明，你可以参考一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keyIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">   key         []<span class="type">byte</span> <span class="comment">//用户的key名称，比如我们案例中的&quot;hello&quot;</span></span><br><span class="line">   modified    revision <span class="comment">//最后一次修改key时的etcd版本号,比如我们案例中的刚写入hello为world1时的，版本号为2</span></span><br><span class="line">   generations []generation <span class="comment">//generation保存了一个key若干代版本号信息，每代中包含对key的多次修改的版本号列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keyIndex中包含用户的key、最后一次修改key时的etcd版本号、key的若干代（generation）版本号信息，每代中包含对key的多次修改的版本号列表。那我们要如何理解generations？为什么它是个数组呢?</p><p>generations表示一个key从创建到删除的过程，每代对应key的一个生命周期的开始与结束。当你第一次创建一个key时，会生成第0代，后续的修改操作都是在往第0代中追加修改版本号。当你把key删除后，它就会生成新的第1代，一个key不断经历创建、删除的过程，它就会生成多个代。</p><p>generation结构详细信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> generation <span class="keyword">struct</span> &#123;</span><br><span class="line">   ver     <span class="type">int64</span>    <span class="comment">//表示此key的修改次数</span></span><br><span class="line">   created revision <span class="comment">//表示generation结构创建时的版本号</span></span><br><span class="line">   revs    []revision <span class="comment">//每次修改key时的revision追加到此数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generation结构中包含此key的修改次数、generation创建时的版本号、对此key的修改版本号记录列表。</p><p>你需要注意的是版本号（revision）并不是一个简单的整数，而是一个结构体。revision结构及含义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> revision <span class="keyword">struct</span> &#123;</span><br><span class="line">   main <span class="type">int64</span>    <span class="comment">// 一个全局递增的主版本号，随put/txn/delete事务递增，一个事务内的key main版本号是一致的</span></span><br><span class="line">   sub <span class="type">int64</span>    <span class="comment">// 一个事务内的子版本号，从0开始随事务内put/delete操作递增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>revision包含main和sub两个字段，main是全局递增的版本号，它是个etcd逻辑时钟，随着put/txn/delete等事务递增。sub是一个事务内的子版本号，从0开始随事务内的put/delete操作递增。</p><p>比如启动一个空集群，全局版本号默认为1，执行下面的txn事务，它包含两次put、一次get操作，那么按照我们上面介绍的原理，全局版本号随读写事务自增，因此是main为2，sub随事务内的put/delete操作递增，因此key hello的revison为{2,0}，key world的revision为{2,1}。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl txn -i</span><br><span class="line">compares:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">success <span class="title">requests</span> (<span class="params"><span class="keyword">get</span>，put，del</span>):</span></span><br><span class="line"><span class="function">put hello 1</span></span><br><span class="line"><span class="function"><span class="keyword">get</span> hello</span></span><br><span class="line"><span class="function">put world 2</span></span><br></pre></td></tr></table></figure><p>介绍完treeIndex基本原理、核心数据结构后，我们再看看在MVCC特性初体验中的更新、查询、删除key案例里，treeIndex与boltdb是如何协作，完成以上key-value操作的?</p><h2 id="MVCC更新key原理">MVCC更新key原理</h2><p>当你通过etcdctl发起一个put hello操作时，如下面的put事务流程图流程一所示，在put写事务中，首先它需要从treeIndex模块中查询key的keyIndex索引信息，keyIndex中存储了key的创建版本号、修改的次数等信息，这些信息在事务中发挥着重要作用，因此会存储在boltdb的value中。</p><p>在我们的案例中，因为是第一次创建hello key，此时keyIndex索引为空。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163736154.png" alt="image-20240606163736154"></p><p>其次etcd会根据当前的全局版本号（空集群启动时默认为1）自增，生成put hello操作对应的版本号revision{2,0}，这就是boltdb的key。</p><p>boltdb的value是mvccpb.KeyValue结构体，它是由用户key、value、create_revision、mod_revision、version、lease组成。它们的含义分别如下：</p><ul><li>create_revision表示此key创建时的版本号。在我们的案例中，key hello是第一次创建，那么值就是2。当你再次修改key hello的时候，写事务会从treeIndex模块查询hello第一次创建的版本号，也就是keyIndex.generations[i].created字段，赋值给create_revision字段；</li><li>mod_revision表示key最后一次修改时的版本号，即put操作发生时的全局版本号加1；</li><li>version表示此key的修改次数。每次修改的时候，写事务会从treeIndex模块查询hello已经历过的修改次数，也就是keyIndex.generations[i].ver字段，将ver字段值加1后，赋值给version字段。</li></ul><p>填充好boltdb的KeyValue结构体后，这时就可以通过Backend的写事务batchTx接口将key{2,0},value为mvccpb.KeyValue保存到boltdb的缓存中，并同步更新buffer，如上图中的流程二所示。</p><p>此时存储到boltdb中的key、value数据如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163747347.png" alt="image-20240606163747347"></p><p>然后put事务需将本次修改的版本号与用户key的映射关系保存到treeIndex模块中，也就是上图中的流程三。</p><p>因为key hello是首次创建，treeIndex模块它会生成key hello对应的keyIndex对象，并填充相关数据结构。</p><p>keyIndex填充后的结果如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key hello的keyIndex:</span><br><span class="line"><span class="section">key:     &quot;hello&quot;</span></span><br><span class="line"><span class="section">modified: &lt;2,0&gt;</span></span><br><span class="line"><span class="section">generations:</span></span><br><span class="line"><span class="section">[&#123;ver:1,created:&lt;2,0&gt;,revisions: [&lt;2,0&gt;]&#125; ]</span></span><br></pre></td></tr></table></figure><p>我们来简易分析一下上面的结果。</p><ul><li>key为hello，modified为最后一次修改版本号&lt;2,0&gt;，key hello是首次创建的，因此新增一个generation代跟踪它的生命周期、修改记录；</li><li>generation的ver表示修改次数，首次创建为1，后续随着修改操作递增；</li><li>generation.created表示创建generation时的版本号为&lt;2,0&gt;；</li><li>revision数组保存对此key修改的版本号列表，每次修改都会将将相应的版本号追加到revisions数组中。</li></ul><p>通过以上流程，一个put操作终于完成。</p><p>但是此时数据还并未持久化，为了提升etcd的写吞吐量、性能，一般情况下（默认堆积的写事务数大于1万才在写事务结束时同步持久化），数据持久化由Backend的异步goroutine完成，它通过事务批量提交，定时将boltdb页缓存中的脏数据提交到持久化存储磁盘中，也就是下图中的黑色虚线框住的流程四。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163759638.png" alt="image-20240606163759638"></p><h2 id="MVCC查询key原理">MVCC查询key原理</h2><p>完成put hello为world1操作后，这时你通过etcdctl发起一个get hello操作，MVCC模块首先会创建一个读事务对象（TxnRead），在etcd 3.4中Backend实现了ConcurrentReadTx， 也就是并发读特性。</p><p>并发读特性的核心原理是创建读事务对象时，它会全量拷贝当前写事务未提交的buffer数据，并发的读写事务不再阻塞在一个buffer资源锁上，实现了全并发读。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163812068.png" alt="image-20240606163812068"></p><p>如上图所示，在读事务中，它首先需要根据key从treeIndex模块获取版本号，因我们未带版本号读，默认是读取最新的数据。treeIndex模块从B-tree中，根据key查找到keyIndex对象后，匹配有效的generation，返回generation的revisions数组中最后一个版本号{2,0}给读事务对象。</p><p>读事务对象根据此版本号为key，通过Backend的并发读事务（ConcurrentReadTx）接口，优先从buffer中查询，命中则直接返回，否则从boltdb中查询此key的value信息。</p><p>那指定版本号读取历史记录又是怎么实现的呢？</p><p>当你再次发起一个put hello为world2修改操作时，key hello对应的keyIndex的结果如下面所示，keyIndex.modified字段更新为&lt;3,0&gt;，generation的revision数组追加最新的版本号&lt;3,0&gt;，ver修改为2。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key hello的keyIndex:</span><br><span class="line"><span class="section">key:     &quot;hello&quot;</span></span><br><span class="line"><span class="section">modified: &lt;3,0&gt;</span></span><br><span class="line"><span class="section">generations:</span></span><br><span class="line"><span class="section">[&#123;ver:2,created:&lt;2,0&gt;,revisions: [&lt;2,0&gt;,&lt;3,0&gt;]&#125;]</span></span><br></pre></td></tr></table></figure><p>boltdb插入一个新的key revision{3,0}，此时存储到boltdb中的key-value数据如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163824235.png" alt="image-20240606163824235"></p><p>这时你再发起一个指定历史版本号为2的读请求时，实际是读版本号为2的时间点的快照数据。treeIndex模块会遍历generation内的历史版本号，返回小于等于2的最大历史版本号，在我们这个案例中，也就是revision{2,0}，以它作为boltdb的key，从boltdb中查询出value即可。</p><h2 id="MVCC删除key原理">MVCC删除key原理</h2><p>介绍完MVCC更新、查询key的原理后，我们接着往下看。当你执行etcdctl del hello命令时，etcd会立刻从treeIndex和boltdb中删除此数据吗？还是增加一个标记实现延迟删除（lazy delete）呢？</p><p>答案为etcd实现的是延期删除模式，原理与key更新类似。</p><p>与更新key不一样之处在于，一方面，生成的boltdb key版本号{4,0,t}追加了删除标识（tombstone,简写t），boltdb value变成只含用户key的KeyValue结构体。另一方面treeIndex模块也会给此key hello对应的keyIndex对象，追加一个空的generation对象，表示此索引对应的key被删除了。</p><p>当你再次查询hello的时候，treeIndex模块根据key hello查找到keyindex对象后，若发现其存在空的generation对象，并且查询的版本号大于等于被删除时的版本号，则会返回空。</p><p>etcdctl hello操作后的keyIndex的结果如下面所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key hello的keyIndex:</span><br><span class="line"><span class="section">key:     &quot;hello&quot;</span></span><br><span class="line"><span class="section">modified: &lt;4,0&gt;</span></span><br><span class="line"><span class="section">generations:</span></span><br><span class="line">[</span><br><span class="line"><span class="section">&#123;ver:3,created:&lt;2,0&gt;,revisions: [&lt;2,0&gt;,&lt;3,0&gt;,&lt;4,0&gt;(t)]&#125;，             </span></span><br><span class="line">&#123;empty&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>boltdb此时会插入一个新的key revision{4,0,t}，此时存储到boltdb中的key-value数据如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240606163836986.png" alt="image-20240606163836986"></p><p>那么key打上删除标记后有哪些用途呢？什么时候会真正删除它呢？</p><p>一方面删除key时会生成events，Watch模块根据key的删除标识，会生成对应的Delete事件。</p><p>另一方面，当你重启etcd，遍历boltdb中的key构建treeIndex内存树时，你需要知道哪些key是已经被删除的，并为对应的key索引生成tombstone标识。而真正删除treeIndex中的索引对象、boltdb中的key是通过压缩(compactor)组件异步完成。</p><p>正因为etcd的删除key操作是基于以上延期删除原理实现的，因此只要压缩组件未回收历史版本，我们就能从etcd中找回误删的数据。</p><h2 id="小结">小结</h2><p>最后我们来小结下今天的内容，我通过MVCC特性初体验中的更新、查询、删除key案例，为你分析了MVCC整体架构、核心模块，它由treeIndex、boltdb组成。</p><p>treeIndex模块基于Google开源的btree库实现，它的核心数据结构keyIndex，保存了用户key与版本号关系。每次修改key都会生成新的版本号，生成新的boltdb key-value。boltdb的key为版本号，value包含用户key-value、各种版本号、lease的mvccpb.KeyValue结构体。</p><p>当你未带版本号查询key时，etcd返回的是key最新版本数据。当你指定版本号读取数据时，etcd实际上返回的是版本号生成那个时间点的快照数据。</p><p>删除一个数据时，etcd并未真正删除它，而是基于lazy delete实现的异步删除。删除原理本质上与更新操作类似，只不过boltdb的key会打上删除标记，keyIndex索引中追加空的generation。真正删除key是通过etcd的压缩组件去异步实现的，在后面的课程里我会继续和你深入介绍。</p><p>基于以上原理特性的实现，etcd实现了保存key历史版本的功能，是高可靠Watch机制的基础。基于key-value中的各种版本号信息，etcd可提供各种级别的简易事务隔离能力。基于Backend/boltdb提供的MVCC机制，etcd可实现读写不冲突。</p>]]></content>
    
    
    <summary type="html">etcd中的MVCC</summary>
    
    
    
    <category term="数据库" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="etcd" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/etcd/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="etcd" scheme="https://penge666.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>Raft论文</title>
    <link href="https://penge666.github.io/posts/a5b7770b.html"/>
    <id>https://penge666.github.io/posts/a5b7770b.html</id>
    <published>2024-06-04T12:45:18.000Z</published>
    <updated>2024-06-04T13:00:39.328Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="https://github.com/maemual/raft-zh_cn">https://github.com/maemual/raft-zh_cn</a></p><p>raft经典论文.原汁原味理解raft</p><h1>寻找一种易于理解的一致性算法（扩展版）</h1><ul><li><a href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E7%A7%8D%E6%98%93%E4%BA%8E%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E6%89%A9%E5%B1%95%E7%89%88">寻找一种易于理解的一致性算法（扩展版）</a><ul><li><a href="#%E6%91%98%E8%A6%81">摘要</a></li><li><a href="#1-%E4%BB%8B%E7%BB%8D">1 介绍</a></li><li><a href="#2-%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA">2 复制状态机</a></li><li><a href="#3-paxos-%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98">3 Paxos 算法的问题</a></li><li><a href="#4-%E4%B8%BA%E4%BA%86%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1">4 为了可理解性的设计</a></li><li><a href="#5-raft-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95">5 Raft 一致性算法</a><ul><li><a href="#51-raft-%E5%9F%BA%E7%A1%80">5.1 Raft 基础</a></li><li><a href="#52-%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE">5.2 领导人选举</a></li><li><a href="#53-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6">5.3 日志复制</a></li><li><a href="#54-%E5%AE%89%E5%85%A8%E6%80%A7">5.4 安全性</a><ul><li><a href="#541-%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6">5.4.1 选举限制</a></li><li><a href="#542-%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E5%86%85%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE">5.4.2 提交之前任期内的日志条目</a></li><li><a href="#543-%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BA%E8%AF%81">5.4.3 安全性论证</a></li></ul></li><li><a href="#55-%E8%B7%9F%E9%9A%8F%E8%80%85%E5%92%8C%E5%80%99%E9%80%89%E4%BA%BA%E5%B4%A9%E6%BA%83">5.5 跟随者和候选人崩溃</a></li><li><a href="#56-%E6%97%B6%E9%97%B4%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7">5.6 时间和可用性</a></li></ul></li><li><a href="#6-%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96">6 集群成员变化</a></li><li><a href="#7-%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9">7 日志压缩</a></li><li><a href="#8-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92">8 客户端交互</a></li><li><a href="#9-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AF%84%E4%BC%B0">9 算法实现和评估</a><ul><li><a href="#91-%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7">9.1 可理解性</a></li><li><a href="#92-%E6%AD%A3%E7%A1%AE%E6%80%A7">9.2 正确性</a></li><li><a href="#93-%E6%80%A7%E8%83%BD">9.3 性能</a></li></ul></li><li><a href="#10-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C">10 相关工作</a></li><li><a href="#11-%E7%BB%93%E8%AE%BA">11 结论</a></li><li><a href="#12-%E6%84%9F%E8%B0%A2">12 感谢</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><h2 id="摘要">摘要</h2><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。一项用户研究的结果表明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</p><h2 id="1-介绍">1 介绍</h2><p>一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos 算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。</p><p>但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。因此工业界和学术界都对 Paxos 算法感到十分头疼。</p><p>努力研究过 Paxos 算法之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。与 Paxos 不同，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且比 Paxos 算法更容易学习。此外，我们希望该算法方便系统构建者的直觉的发展。重要的不仅仅是算法能够工作，更重要的是能够很清楚地知道它为什么能工作。</p><p>Raft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。</p><p>Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：</p><ul><li><strong>强领导人</strong>：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导人发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</li><li><strong>领导选举</strong>：Raft 算法使用一个随机计时器来选举领导人。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</li><li><strong>成员关系调整</strong>：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li></ul><p>我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全特性已经被正式定义和证明；它的效率和其他算法比起来也不相上下。</p><p>接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。</p><p>Q：<strong>共识和一致性</strong>的区别</p><p>A：</p><p>共识是分布式系统中多个节点之间对某个事情的看法。</p><p>一致性是多个副本对外呈现的状态。</p><p>因此，共识不一定一致。</p><h2 id="2-复制状态机">2 复制状态机</h2><p>一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604203908377.png" alt="image-20240604203908377"></p><blockquote><p>图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p></blockquote><p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p><p>一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p><p>实际系统中使用的一致性算法通常含有以下特性：</p><ul><li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。</li><li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。</li><li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li><li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li></ul><h2 id="3-Paxos-算法的问题">3 Paxos 算法的问题</h2><p>在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。</p><p>不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。</p><p>我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。</p><p>Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。</p><p>而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立地选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。</p><p>因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：</p><blockquote><p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。</p></blockquote><p>由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft 算法就是这次实验的结果。</p><h2 id="4-为了可理解性的设计">4 为了可理解性的设计</h2><p>设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。</p><p>在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？</p><p>我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：我们尽可能地将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和成员变更几个部分。</p><p>我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化来简化 Raft 中领导人选举算法。</p><h2 id="5-Raft-一致性算法">5 Raft 一致性算法</h2><p>Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。</p><p>Raft 通过选举一个杰出的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。</p><p>通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：</p><ul><li><strong>领导选举</strong>：当现存的领导人发生故障的时候, 一个新的领导人需要被选举出来（章节 5.2）</li><li><strong>日志复制</strong>：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。</li><li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到选举机制（5.2 节）上的一个额外限制。</li></ul><p>在展示一致性算法之后，这一章节会讨论一些可用性的问题和计时在系统中的作用。</p><p><strong>状态</strong>：</p><p>所有服务器上的持久性状态<br>(在响应 RPC 请求之前，已经更新到了稳定的存储设备)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空</td></tr><tr><td>log[]</td><td>日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）</td></tr></tbody></table><p>所有服务器上的易失性状态</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知已提交的最高的日志条目的索引（初始值为0，单调递增）</td></tr><tr><td>lastApplied</td><td>已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p>领导人（服务器）上的易失性状态<br>(选举后已经重新初始化)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1）</td></tr><tr><td>matchIndex[]</td><td>对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p><strong>追加条目（AppendEntries）RPC</strong>：</p><p>由领导人调用，用于日志条目的复制，同时也被当做心跳使用</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期</td></tr><tr><td>leaderId</td><td>领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人）</td></tr><tr><td>prevLogIndex</td><td>紧邻新日志条目之前的那个日志条目的索引</td></tr><tr><td>prevLogTerm</td><td>紧邻新日志条目之前的那个日志条目的任期</td></tr><tr><td>entries[]</td><td>需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个）</td></tr><tr><td>leaderCommit</td><td>领导人的已知已提交的最高的日志条目的索引</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期，对于领导人而言 它会更新自己的任期</td></tr><tr><td>success</td><td>如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true</td></tr></tbody></table><p>接收者的实现：</p><ol><li>返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）（5.1 节）</li><li>返回假 如果接收者日志中没有包含这样一个条目 即该条目的任期在 prevLogIndex 上能和 prevLogTerm 匹配上<br>（译者注：在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假）（5.3 节）</li><li>如果一个已经存在的条目和新条目（译者注：即刚刚接收到的日志条目）发生了冲突（因为索引相同，任期不同），那么就删除这个已经存在的条目以及它之后的所有条目 （5.3 节）</li><li>追加日志中尚未存在的任何新条目</li><li>如果领导人的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引（<code>leaderCommit &gt; commitIndex</code>），则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 领导人的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值</li></ol><p><strong>请求投票（RequestVote）RPC</strong>：</p><p>由候选人负责调用用来征集选票（5.2 节）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求选票的候选人的 ID</td></tr><tr><td>lastLogIndex</td><td>候选人的最后日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最后日志条目的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号，以便于候选人去更新自己的任期号</td></tr><tr><td>voteGranted</td><td>候选人赢得了此张选票时为真</td></tr></tbody></table><p>接收者实现：</p><ol><li>如果<code>term &lt; currentTerm</code>返回 false （5.2 节）</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）</li></ol><p><strong>所有服务器需遵守的规则</strong>：</p><p>所有服务器：</p><ul><li>如果<code>commitIndex &gt; lastApplied</code>，则 lastApplied 递增，并将<code>log[lastApplied]</code>应用到状态机中（5.3 节）</li><li>如果接收到的 RPC 请求或响应中，任期号<code>T &gt; currentTerm</code>，则令 <code>currentTerm = T</code>，并切换为跟随者状态（5.1 节）</li></ul><p>跟随者（5.2 节）：</p><ul><li>响应来自候选人和领导人的请求</li><li>如果在超过选举超时时间的情况之前没有收到<strong>当前领导人</strong>（即该领导人的任期需与这个跟随者的当前任期相同）的心跳/附加日志，或者是给某个候选人投了票，就自己变成候选人</li></ul><p>候选人（5.2 节）：</p><ul><li>在转变成候选人后就立即开始选举过程<ul><li>自增当前的任期号（currentTerm）</li><li>给自己投票</li><li>重置选举超时计时器</li><li>发送请求投票的 RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成领导人</li><li>如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者</li><li>如果选举过程超时，则再次发起一轮选举</li></ul><p>领导人：</p><ul><li>一旦成为领导人：发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以防止跟随者超时（5.2 节）</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</li><li>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（<code>lastLogIndex ≥ nextIndex</code>），则发送从 nextIndex 开始的所有日志条目：<ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，则 nextIndex 递减并重试</li></ul></li><li>假设存在 N 满足<code>N &gt; commitIndex</code>，使得大多数的 <code>matchIndex[i] ≥ N</code>以及<code>log[N].term == currentTerm</code> 成立，则令 <code>commitIndex = N</code>（5.3 和 5.4 节）</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604203937594.png" alt="image-20240604203937594"></p><blockquote><p>图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。</p></blockquote><table><thead><tr><th>特性</th><th>解释</th></tr></thead><tbody><tr><td>选举安全特性</td><td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td></tr><tr><td>领导人只附加原则</td><td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td></tr><tr><td>日志匹配原则</td><td>如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节）</td></tr><tr><td>领导人完全特性</td><td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td></tr><tr><td>状态机安全特性</td><td>如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节）</td></tr></tbody></table><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604203944709.png" alt="image-20240604203944709"></p><blockquote><p>图 3：Raft 在任何时候都保证以上的各个特性。</p></blockquote><h3 id="5-1-Raft-基础">5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；5 个服务器节点是一个典型的例子，这允许整个系统容忍 2 个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导人或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604203949708.png" alt="image-20240604203949708"></p><blockquote><p>图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604203954762.png" alt="image-20240604203954762"></p><blockquote><p>图 5：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</p></blockquote><p>Raft 把时间分割成任意长度的<strong>任期</strong>，如图 5。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导人。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导人。</p><p>不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，任期使得服务器可以检测一些过期的信息：比如过期的领导人。每个节点存储一个当前任期号，这一编号在整个时期内单调递增。每当服务器之间通信的时候都会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的任期号到较大的任期号值。如果一个候选人或者领导人发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</p><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节  5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。</p><h3 id="5-2-领导人选举">5.2 领导人选举</h3><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选人处接收到有效的 RPCs。领导人周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加条目（AppendEntries） RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导人,并且发起选举以选出新的领导人。</p><p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导人，© 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。</p><p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。</p><p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加条目（AppendEntries）RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。</p><p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p><p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。</p><p>领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。</p><h3 id="5-3-日志复制">5.3 日志复制</h3><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全地复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204000734.png" alt="image-20240604204000734"></p><blockquote><p>图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。</p></blockquote><p>日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。</p><p>领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交</strong>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p><p>我们设计了 Raft 的日志机制来维护不同服务器日志之间的高层次的一致性。这么做不仅简化了系统的行为也使其更具有可预测性，同时它也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些特性共同组成了图 3 中的<strong>日志匹配特性（Log Matching Property）</strong>：</p><ul><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。</li></ul><p>第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目前紧挨着的条目的索引位置和任期号包含在日志内。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查在日志扩展的时候保护了日志匹配特性。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。</p><p>在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同。跟随者可能会丢失一些在新的领导人中存在的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204006613.png" alt="image-20240604204006613"></p><blockquote><p>图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p></blockquote><p>在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。</p><p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 <strong>nextIndex</strong>，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</p><blockquote><p>如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。借助这些信息，领导人可以减小 nextIndex 一次性越过该冲突任期的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。</p></blockquote><p>通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。</p><p>日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。</p><h3 id="5-4-安全性">5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p><p>这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于<strong>领导人完整特性（Leader Completeness Property）</strong> 的简要证明，并且说明该特性是如何引导复制状态机做出正确行为的。</p><h4 id="5-4-1-选举限制">5.4.1 选举限制</h4><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导人。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证在选举的时候新的领导人拥有所有之前任期中已经提交的日志条目，而不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。</p><p>Raft 使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票（RequestVote） RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p><p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><h4 id="5-4-2-提交之前任期内的日志条目">5.4.2 提交之前任期内的日志条目</h4><p>如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204012637.png" alt="image-20240604204012637"></p><blockquote><p>图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 ©，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p></blockquote><p>为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。</p><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p><h4 id="5-4-3-安全性论证">5.4.3 安全性论证</h4><p>在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204018143.png" alt="image-20240604204018143"></p><blockquote><p>图 9：如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p></blockquote><ol><li>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li><li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。</li><li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</li><li>投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。</li><li>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</li><li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</li><li>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。</li><li>这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。</li><li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。</li></ol><p>通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p><h3 id="5-5-跟随者和候选人崩溃">5.5 跟随者和候选人崩溃</h3><p>到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单地通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。</p><h3 id="5-6-时间和可用性">5.6 时间和可用性</h3><p>Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p><blockquote><p>广播时间（broadcastTime）  &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt;  平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p><h2 id="6-集群成员变化">6 集群成员变化</h2><p>到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。</p><p>为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人在同一个任期里同时被选举成功。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性原子地转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204024635.png" alt="image-20240604204024635"></p><blockquote><p>图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p></blockquote><p>为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致（<em>joint consensus</em>)；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为领导人。</li><li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li></ul><p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用  C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。</p><p>一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，如果不经过另一个配置的允许都不能单独做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204030188.png" alt="image-20240604204030188"></p><blockquote><p>图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和  C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在  C-new 和 C-old 可以同时做出决定的时间点。</p></blockquote><p>在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新之前使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。</p><p>第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。</p><p>第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。</p><p>为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。确切地说，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。</p><h2 id="7-日志压缩">7 日志压缩</h2><p>Raft 的日志在正常操作中不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。</p><p>快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p><p>增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204036683.png" alt="image-20240604204036683"></p><blockquote><p>图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。</p></blockquote><p>图 12 展示了 Raft 中快照的基础思想。每个服务器独立地创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong>最后被包含索引</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong>最后被包含的任期</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</p><p>尽管通常服务器都是独立地创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。</p><p><strong>安装快照 RPC</strong>：</p><p>由领导人调用以将快照的分块发送给跟随者。领导人总是按顺序发送分块。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 ID，以便于跟随者重定向请求</td></tr><tr><td>lastIncludedIndex</td><td>快照中包含的最后日志条目的索引值</td></tr><tr><td>lastIncludedTerm</td><td>快照中包含的最后日志条目的任期号</td></tr><tr><td>offset</td><td>分块在快照中的字节偏移量</td></tr><tr><td>data[]</td><td>从偏移量开始的快照分块的原始字节</td></tr><tr><td>done</td><td>如果这是最后一个分块则为 true</td></tr></tbody></table><table><thead><tr><th>结果</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号（currentTerm），便于领导人更新自己</td></tr></tbody></table><p><strong>接收者实现</strong>：</p><ol><li>如果<code>term &lt; currentTerm</code>就立即回复</li><li>如果是第一个分块（offset 为 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done 是 false，则继续等待更多的数据</li><li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li><li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li><li>丢弃整个日志</li><li>使用快照重置状态机（并加载快照的集群配置）</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204049784.png" alt="image-20240604204049784"></p><blockquote><p>图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。</p></blockquote><p>在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种  RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。</p><p>这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。</p><p>我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</p><p>还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</p><p>第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</p><h2 id="8-客户端交互">8 客户端交互</h2><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><p>Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p><p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可能执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为响应客户端请求的领导人可能在他不知道的时候已经被新的领导人取代了。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道哪些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p><h2 id="9-算法实现和评估">9 算法实现和评估</h2><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p><p>这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p><h3 id="9-1-可理解性">9.1 可理解性</h3><p>为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者从第一部分的算法学习中获得的表现和经验的差异。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。</p><p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些  Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p><table><thead><tr><th>关心</th><th>缓和偏见采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr><td>相同的讲课质量</td><td>两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。</td><td>视频</td></tr><tr><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评价量规（rubric）</td></tr></tbody></table><blockquote><p>表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。</p></blockquote><p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。配置t-检验（又称student‘s t-test）表明，在 95% 的可信度下，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204056165.png" alt="image-20240604204056165"></p><blockquote><p>图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。</p></blockquote><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型预测，对小测验的选择会产生 12.5 分的差别。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft的得分低了6.3分; 虽然我们不知道为什么，这似乎在统计上是有意义的。</p><p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204101119.png" alt="image-20240604204101119"></p><blockquote><p>图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。</p></blockquote><p>关于 Raft 用户学习有一个更加详细的讨论。</p><h3 id="9-2-正确性">9.2 正确性</h3><p>在第 5 节，我们已经制定了正式的规范，和对一致性机制的安全性证明。这个正式规范使用 TLA+ 规范语言使图 2 中总结的信息非常清晰。它长约400行，并作为证明的主题。同时对于任何想实现 Raft 的人也是十分有用的。我们通过 TLA 证明系统非常机械的证明了日志完全特性。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性是完备的，并且是相当清晰的（大约 3500 个词）。</p><h3 id="9-3-性能">9.3 性能</h3><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604204108409.png" alt="image-20240604204108409"></p><blockquote><p>图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小选举超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。</p></blockquote><p>为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p><p>图 16 中上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p><p>图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。</p><h2 id="10-相关工作">10 相关工作</h2><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p><ul><li>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰。</li><li>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。</li><li>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>Paxos 可以应用的性能优化。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p><p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 种不同的消息类型，相对的，Raft 只有 4 种消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p><p>Raft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p><p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。</p><h2 id="11-结论">11 结论</h2><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p><p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p><h2 id="12-感谢">12 感谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利 CS 294-91 课程、斯坦福 CS 240 课程的学生。Scott Klemmer 帮我们设计了用户调查，Nelson Ray 建议我们进行统计学的分析。在用户调查时使用的关于 Paxos 的幻灯片很大一部分是从 Lorenzo Alvisi 的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 Ezra Hoch，他们找到了 Raft 中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括 Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，Arjun Gopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，Aleksandar Kracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，David Ramos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，Deian Stefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，Matei Zaharia 以及 24 位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 Eddie Kohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft 带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale 系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由 STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA 支持，在国家科学基金会的 0963859 号批准，并且获得了来自 Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。Diego Ongaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><h2 id="参考">参考</h2><p>略</p>]]></content>
    
    
    <summary type="html">原汁原味理解raft</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="论文阅读" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="论文阅读" scheme="https://penge666.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Nginx网络工作原理</title>
    <link href="https://penge666.github.io/posts/ef701d36.html"/>
    <id>https://penge666.github.io/posts/ef701d36.html</id>
    <published>2024-06-03T12:19:08.000Z</published>
    <updated>2024-06-03T13:32:35.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。</p><p>一个客户端和使用了 epoll 的服务端的交互过程如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202016660.png" alt="image-20240603202016660"></p><p>以下是其大概的代码示例（没耐心看的同学可以先）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//监听</span></span><br><span class="line"> lfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">bind</span>(lfd, ...)</span><br><span class="line"> <span class="built_in">listen</span>(lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建epoll对象，并把 listen socket的事件管理起来</span></span><br><span class="line"> efd = <span class="built_in">epoll_create</span>(...);</span><br><span class="line"> <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//事件循环</span></span><br><span class="line"> <span class="keyword">for</span> (;;)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">size_t</span> nready = <span class="built_in">epoll_wait</span>(efd, ep, ...);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; ++i)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(ep[i].data.fd == lfd)&#123;</span><br><span class="line">    <span class="comment">//lfd上发生事件表示都连接到达，accept接收它</span></span><br><span class="line">    fd = <span class="built_in">accept</span>(listenfd, ...);</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, fd, ...);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//其它socket发生的事件都是读写请求、或者关闭连接</span></span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单进程模型中，不管有多少的连接，是几万还是几十万，服务器都是通过 epoll 来监控这些连接 socket 上的可读和可写事件。当某个 socket 上有数据发生的时候，再以非阻塞的方式对 socket 进行读写操作。</p><p>事实上，Redis 5.0 及以前的版本中，它的网络部分去掉对 handler 的封装，去掉时间事件以后，代码基本和上述 demo 非常接近。而且因为 Redis 的业务特点只需要内存 IO，且 CPU 计算少，所以可以达到数万的 QPS。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202045785.png" alt="image-20240603202045785"></p><p>但是单进程的问题也是显而易见的，没有办法充分发挥多核的优势。所以目前业界绝大部分的后端服务还都是需要基于多进程的方式来进行开发的。到了多进程的时候，更复杂的问题多进程之间的配合和协作问题就产生了。比如</p><ul><li>哪个进程执行监听 listen ，以及 accept 接收新连接？</li><li>哪个进程负责发现用户连接上的读写事件？</li><li>当有用户请求到达的时候，如何均匀地将请求分散到不同的进程中？</li><li>需不需要单独搞一部分进程执行计算工作</li><li>…</li></ul><p>事实上，以上这些问题并没有标准答案。各大应用或者网络框架都有自己不同的实现方式。为此业界还专门总结出了两类网络设计模式 - Reactor 和 Proactor。不过今天我不想讨论这种抽象模式，而是想带大家看一个具体的 Case - Nginx 是如何在多进程下使用 epoll 的。</p><h2 id="一、-Nginx-Master-进程初始化">一、 Nginx Master 进程初始化</h2><p>在 Nginx 中，将进程分成了两类。一类是 Master 进程，一类是 Worker 进程。</p><p>在 Master 进程中，主要的任务是负责启动整个程序、读取配置文件、监听和处理各种信号，并对 Worker 进程进行统筹管理。</p><p>不过今天我们要查看的重点问题是看网络。在 Master 进程中，和网络相关的操作非常简单就是创建了 socket 并对其进行 bind 和 监听。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202124833.png" alt="image-20240603202124833"></p><p>具体细节我们来看 Main 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/nginx.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> ngx_cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">ngx_cycle_t</span>      *cycle, init_cycle;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.1 ngx_init_cycle 中开启监听</span></span><br><span class="line"> cycle = <span class="built_in">ngx_init_cycle</span>(&amp;init_cycle);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.2 启动主进程循环</span></span><br><span class="line"> <span class="built_in">ngx_master_process_cycle</span>(cycle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Nginx 中，ngx_cycle_t 是非常核心的一个结构体。这个结构体存储了很多东西，也贯穿了好多的函数。其中对端口的 bind 和 listen 就是在它执行时完成的。</p><p>ngx_master_process_cycle 是 Master 进程的主事件循环。它先是根据配置启动指定数量的 Worker 进程，然后就开始关注和处理重启、退出等信号。接下来我们分两个小节来更详细地看。</p><h3 id="1-1-Nginx-的服务端口监听">1.1 Nginx 的服务端口监听</h3><p>我们看下 ngx_init_cycle 中是如何执行 bind 和 listen 的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_cycle.c</span></span><br><span class="line"><span class="function"><span class="type">ngx_cycle_t</span> *<span class="title">ngx_init_cycle</span><span class="params">(<span class="type">ngx_cycle_t</span> *old_cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">ngx_open_listening_sockets</span>(cycle) != NGX_OK) &#123;</span><br><span class="line">  <span class="keyword">goto</span> failed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的监听还是在 ngx_open_listening_sockets 函数中，继续看它的源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line"><span class="function"><span class="type">ngx_int_t</span> <span class="title">ngx_open_listening_sockets</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//要监听的 socket 对象</span></span><br><span class="line"> ls = cycle-&gt;listening.elts;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取第i个socket</span></span><br><span class="line">  s = <span class="built_in">ngx_socket</span>(ls[i].sockaddr-&gt;sa_family, ls[i].type, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定</span></span><br><span class="line">  <span class="built_in">bind</span>(s, ls[i].sockaddr, ls[i].socklen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//监听</span></span><br><span class="line">  <span class="built_in">listen</span>(s, ls[i].backlog)</span><br><span class="line">  ls[i].listen = <span class="number">1</span>;</span><br><span class="line">  ls[i].fd = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，遍历要监听的 socket。如果是启用了 REUSEPORT 配置，那先把 socket 设置上 SO_REUSEPORT 选项。然后接下来就是大家都熟悉的 bind 和 listen。<strong>所以，bind 和 listen 是在 Master 进程中完成的。</strong></p><h3 id="1-2-Master-进程的主循环">1.2 Master 进程的主循环</h3><p>在 ngx_master_process_cycle 中主要完成两件事。</p><ul><li>启动 Worker 进程</li><li>将 Master 进程推入事件循环</li></ul><p>在创建 Worker 进程的时候，是通过 fork 系统调用让 Worker 进程完全复制自己的资源，包括 listen 状态的 socket 句柄</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202234404.png" alt="image-20240603202234404"></p><p>我们接下来看详细的代码。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line">void <span class="built_in">ngx_master_process_cycle</span>(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="built_in">ngx_start_worker_processes</span>(cycle, ccf-&gt;worker_processes,</span><br><span class="line">          NGX_PROCESS_RESPAWN);</span><br><span class="line"> <span class="comment">//进入主循环,等待接收各种信号</span></span><br><span class="line"> for ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//ngx_quit</span></span><br><span class="line">  <span class="comment">//ngx_reconfigure</span></span><br><span class="line">  <span class="comment">//ngx_restart</span></span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主进程在配置中读取到了 Worker 进程的数量 ccf-&gt;worker_processes。通过 ngx_start_worker_processes 来启动指定数量的 Worker。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/os/unix/ngx_process_cycle.c</span></span><br><span class="line">static void <span class="built_in">ngx_start_worker_processes</span>(...)</span><br><span class="line">&#123;</span><br><span class="line"> for (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="built_in">ngx_spawn_process</span>(cycle, ngx_worker_process_cycle,</span><br><span class="line">        (void *) (intptr_t) <span class="selector-tag">i</span>, &quot;worker process&quot;, type);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中值得注意的是，在调用 ngx_spawn_process 时的几个参数</p><ul><li>cycle：nginx 的核心数据结构</li><li>cngx_worker_process_cycle：worker 进程的入口函数</li><li>ci: 当前 worker 的序号</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process.c</span></span><br><span class="line"><span class="function"><span class="type">ngx_pid_t</span> <span class="title">ngx_spawn_process</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, ngx_spawn_proc_pt proc,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">//出错了</span></span><br><span class="line">   ... </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子进程创建成功</span></span><br><span class="line">   ngx_parent = ngx_pid;</span><br><span class="line">   ngx_pid = <span class="built_in">ngx_getpid</span>();</span><br><span class="line">   <span class="built_in">proc</span>(cycle, data);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ngx_spawn_process 中调用 fork 来创建进程，创建成功后 Worker 进程就将进入 ngx_worker_process_cycle 来进行处理了。</p><p>总结：在网络上，master 进程其实只是 listen 了一下。listen 过后的 socket 存到 cycle-&gt;listening 这里了。剩下的网络操作都是在 Worker 中完成的。</p><h2 id="二、Worker-进程处理">二、Worker 进程处理</h2><p>在上面小节中看到，Master 进程关于网络其实做的事情不多，只是 bind 和 listen 了一下。epoll 相关的函数调用一个也没见着，更别说 accept 接收连接，以及 read 、 write 函数处理了。那这些细节一定都是在 Worker 进程中完成的。</p><p>事实的确如此，epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202329716.png" alt="image-20240603202329716"></p><p>在 Worker 进程中，创建了一个 epoll 内核对象，通过 epoll_ctl 将其想监听的事件注册上去，然后调用 epoll_wait 进入事件循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ngx_worker_process_cycle</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//2.2 Worker进程初始化编译进来的各个模块</span></span><br><span class="line"> <span class="built_in">ngx_worker_process_init</span>(cycle, worker);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//进入事件循环</span></span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//2.3 进入 epollwait</span></span><br><span class="line">  <span class="built_in">ngx_process_events_and_timers</span>(cycle);</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-Nginx-的-网络相关-module">2.1 Nginx 的 网络相关 module</h3><p>撇开 Worker 的工作流程不提，咱们先来了解一个背景知识 - Nginx module。</p><p>Nginx 采用的是<strong>一种模块化的架构</strong>，<strong>它的模块包括核心模块、标准HTTP模块、可选HTTP模块、邮件服务模块和第三方模块等几大类</strong>。每一个模块都以一个 module 的形式存在，都对应一个 ngx_module_s 结构体。通过这种方式来实现软件可拔插，是一种非常优秀的软件架构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202401129.png" alt="image-20240603202401129"></p><p>每个 module 根据自己的需求来实现各种 init_xxx, exit_xxx 方法来供 Nginx 在合适的时机调用。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_module.h</span></span><br><span class="line">struct ngx_module_s &#123;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> ngx_uint_t            version;</span><br><span class="line"></span><br><span class="line"> void                 *ctx;</span><br><span class="line"> ngx_command_t        *commands;</span><br><span class="line"> ngx_uint_t            type;</span><br><span class="line"></span><br><span class="line"> ngx_int_t           (*init_master)(ngx_log_t *log);</span><br><span class="line"> ngx_int_t           (*init_module)(ngx_cycle_t *cycle);</span><br><span class="line"> ngx_int_t           (*init_process)(ngx_cycle_t *cycle);</span><br><span class="line"> ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);</span><br><span class="line"> void                (*exit_thread)(ngx_cycle_t *cycle);</span><br><span class="line"> void                (*exit_process)(ngx_cycle_t *cycle);</span><br><span class="line"> void                (*exit_master)(ngx_cycle_t *cycle);</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中和网络相关的 module 有 ngx_events_module 、ngx_event_core_module 和具体的网络底层模块 ngx_epoll_module、ngx_kqueue_module等。</p><p>对于 ngx_epoll_module 来说，它在其上下文 ngx_epoll_module_ctx 中定义了各种 actions 方法（添加事件、删除事件、添加连接等）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/ngx_event.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">ngx_str_t</span>              *name;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span>                 *(*create_conf)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">char</span>                 *(*init_conf)(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">void</span> *conf);</span><br><span class="line"></span><br><span class="line"> <span class="type">ngx_event_actions_t</span>     actions;</span><br><span class="line">&#125; <span class="type">ngx_event_module_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;</span><br><span class="line"> &amp;epoll_name,</span><br><span class="line"> ngx_epoll_create_conf,               <span class="comment">/* create configuration */</span></span><br><span class="line"> ngx_epoll_init_conf,                 <span class="comment">/* init configuration */</span></span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* add an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* delete an event */</span></span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* enable an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* disable an event */</span></span><br><span class="line">  ngx_epoll_add_connection,        <span class="comment">/* add an connection */</span></span><br><span class="line">  ngx_epoll_del_connection,        <span class="comment">/* delete an connection */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_EVENTFD)</span></span><br><span class="line">  ngx_epoll_notify,                <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="literal">NULL</span>,                            <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ngx_epoll_process_events,        <span class="comment">/* process the events */</span></span><br><span class="line">  ngx_epoll_init,                  <span class="comment">/* init the events */</span></span><br><span class="line">  ngx_epoll_done,                  <span class="comment">/* done the events */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中有一个 init 方法是 ngx_epoll_init，在这个 init 中会进行 epoll 对象的创建，以及 ngx_event_actions 方法的设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_epoll_init</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">ngx_msec_t</span> timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//创建一个 epoll 句柄</span></span><br><span class="line"> ep = <span class="built_in">epoll_create</span>(cycle-&gt;connection_n / <span class="number">2</span>);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ngx_event_actions = ngx_epoll_module_ctx.actions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Worker-进程初始化各个模块">2.2 Worker 进程初始化各个模块</h3><p>Worker 进程初始化的时候，在 ngx_worker_process_init 中读取配置信息进行一些设置，然后调用所有模块的 init_process 方法。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202452066.png" alt="image-20240603202452066"></p><p>来看详细代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_worker_process_init</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">ngx_int_t</span> worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取配置</span></span><br><span class="line"> ccf = (<span class="type">ngx_core_conf_t</span> *) <span class="built_in">ngx_get_conf</span>(cycle-&gt;conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置优先级</span></span><br><span class="line"> <span class="built_in">setpriority</span>(PRIO_PROCESS, <span class="number">0</span>, ccf-&gt;priority)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置文件描述符限制</span></span><br><span class="line"> <span class="built_in">setrlimit</span>(RLIMIT_NOFILE, &amp;rlmt)</span><br><span class="line"> <span class="built_in">setrlimit</span>(RLIMIT_CORE, &amp;rlmt)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//group 和 uid 设置</span></span><br><span class="line"> <span class="built_in">initgroups</span>(ccf-&gt;username, ccf-&gt;group)</span><br><span class="line"> <span class="built_in">setuid</span>(ccf-&gt;user)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CPU亲和性</span></span><br><span class="line"> cpu_affinity = <span class="built_in">ngx_get_cpu_affinity</span>(worker)</span><br><span class="line"> <span class="keyword">if</span> (cpu_affinity) &#123;</span><br><span class="line">  <span class="built_in">ngx_setaffinity</span>(cpu_affinity, cycle-&gt;log);</span><br><span class="line"> &#125;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用各个模块的init_process进行模块初始化</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; cycle-&gt;modules[i]; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cycle-&gt;modules[i]-&gt;init_process) &#123;</span><br><span class="line">   <span class="keyword">if</span> (cycle-&gt;modules[i]-&gt;<span class="built_in">init_process</span>(cycle) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="comment">/* fatal */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>[✳]  ~ <a href="https://www.cnblogs.com/wenqiang/p/6049978.html">linux进程、线程与cpu的亲和性（affinity）</a></li></ul><p>前面我们说过 ngx_event_core_module ，它的 init_process 方法是 ngx_event_process_init。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="type">ngx_module_t</span>  ngx_event_core_module = &#123;</span><br><span class="line"> ...</span><br><span class="line"> ngx_event_process_init,                <span class="comment">/* init process */</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 ngx_event_core_module 的 ngx_event_process_init 中，我们将看到 <strong>Worker 进程使用 epoll_create 来创建 epoll 对象，使用epoll_ctl 来监听 listen socket 上的连接请求。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202522699.png" alt="image-20240603202522699"></p><p>来详细看 ngx_event_process_init 的代码。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line">static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//调用模块的init，创建 epoll 对象</span></span><br><span class="line"> <span class="function"><span class="title">for</span> (m = 0; cycle-&gt;</span>modules[m]; m++) &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (cycle-&gt;</span><span class="function"><span class="title">modules</span>[m]-&gt;</span>type != NGX_EVENT_MODULE) &#123;</span><br><span class="line">   continue;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">module</span>-&gt;</span>actions.init(cycle, ngx_timer_resolution)</span><br><span class="line">  break;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取自己监听的sokcet，将它们都添加到 epoll 中</span></span><br><span class="line"> ngx_event_t         *rev</span><br><span class="line"> <span class="function"><span class="title">ls</span> = cycle-&gt;</span>listening.elts;</span><br><span class="line"> <span class="function"><span class="title">for</span> (i = 0; i &lt; cycle-&gt;</span>listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取一个 ngx_connection_t</span></span><br><span class="line">  <span class="function"><span class="title">c</span> = ngx_get_connection(ls[i].fd, cycle-&gt;</span><span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置回调函数为 ngx_event_accept</span></span><br><span class="line">  <span class="function"><span class="title">rev</span>-&gt;</span>handler = ngx_event_accept </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</span><br><span class="line">   return NGX_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ngx_add_event 注册的 READ 事件的处理函数。ngx_add_event 就是一个抽象，对于 epoll 来说就是对 epoll_ctl 的封装而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_add_event        ngx_event_actions.add</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ngx_int_t</span> <span class="title">ngx_epoll_add_event</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(ep, op, c-&gt;fd, &amp;ee) == <span class="number">-1</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO: epoll_create 还没解决呢。</p><h3 id="2-3-进入-epollwait">2.3 进入 epollwait</h3><p>在 ngx_worker_process_init 中， epoll_create 和 epoll_ctl 都已经完成了。接下来就是进入事件循环，执行 epoll_wait 来处理。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202554722.png" alt="image-20240603202554722"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_process_events_and_timers</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 防accept惊群锁</span></span><br><span class="line"> <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">  <span class="comment">//尝试获取锁，获取失败直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ngx_trylock_accept_mutex</span>(cycle) == NGX_ERROR) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取锁成功，则设置 NGX_POST_EVENTS 标记。</span></span><br><span class="line">  <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">   flags |= NGX_POST_EVENTS;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//处理各种事件</span></span><br><span class="line"> (<span class="type">void</span>) <span class="built_in">ngx_process_events</span>(cycle, timer, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 ngx_process_events_and_timers 开头处，判断是否使用 accpet_mutext 锁。这是一个防止惊群的解决办法。如果使用的话，先调用 ngx_trylock_accept_mutex 获取锁，获取失败则直接返回，过段时间再来尝试。获取成功是则设置 NGX_POST_EVENTS 的标志位。</p><p>接下来调用 ngx_process_events 来处理各种网络和 timer 事件。对于 epoll 来说，这个函数就是对 epoll_wait 的封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_process_events   ngx_event_actions.process_events</span></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ngx_int_t</span> <span class="title">ngx_epoll_process_events</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> events = <span class="built_in">epoll_wait</span>(ep, event_list, (<span class="type">int</span>) nevents, timer);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">ngx_post_event</span>(rev, queue);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//调用回调函数</span></span><br><span class="line">   rev-&gt;<span class="built_in">handler</span>(rev);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在 ngx_epoll_process_events 是调用 epoll_wait 等待各种事件的发生。如果没有 NGX_POST_EVENTS 标志，则直接回调 rev-&gt;handler 进行处理。使用了 accept_mutex 锁的话，先把这个事件保存起来，等后面合适的时机再去 accpet。</p><p>简单对本节内容汇总一下。在 Master 进程中只是做了 socket 的 bind 和 listen。而在 Worker 进程中所做的事情比较多，创建了 epoll，使用 epoll_ctl 将 listen 状态的 socket 的事件监控起来。最后调用 epoll_wait 进入了事件循环，开始处理各种网络和 timer 事件。本节流程总结如图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202632527.png" alt="image-20240603202632527"></p><h2 id="三、用户连接来啦！">三、用户连接来啦！</h2><p>现在假设用户的连接请求已经到了，这时候 epoll_wait 返回后会执行其对应的 handler 函数 ngx_add_event。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202651350.png" alt="image-20240603202651350"></p><p>在该回调函数中被执行到的时候，表示 listen 状态的 socket 上面有连接到了。所以这个函数主要做了三件事。</p><ul><li>1.调用 accept 获取用户连接</li><li>2.获取 connection 对象，其回调函数为 ngx_http_init_connection</li><li>3.将新连接 socket 通过 epoll_ctl 添加到 epoll 中进行管理</li></ul><p>我们来看 ngx_event_accept 详细代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event_accept.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ngx_event_accept</span><span class="params">(<span class="type">ngx_event_t</span> *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//接收建立好的连接</span></span><br><span class="line">  s = <span class="built_in">accept</span>(lc-&gt;fd, &amp;sa.sockaddr, &amp;socklen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s &#123;</span><br><span class="line">   <span class="comment">//3.1 获取 connection</span></span><br><span class="line">   c = <span class="built_in">ngx_get_connection</span>(s, ev-&gt;log);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.2 添加新连接</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">ngx_add_conn</span>(c) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="built_in">ngx_close_accepted_connection</span>(c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line"> &#125; <span class="keyword">while</span> (ev-&gt;available);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>listen socket 上的读事件发生的时候，就意味着有用户连接就绪了。所以可以直接通过 accept 将其取出来。取出连接以后，再获取一个空闲的 connection对象，通过 ngx_add_conn 将其添加到 epoll 中进行管理。</p><h3 id="3-1-获取-connection">3.1 获取 connection</h3><p>我们说一下 ngx_get_connection，这个函数本身倒是没有啥可说的。就是从 ngx_cycle 的 free_connections 中获取一个 connection 出来。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line">ngx_connection_t *ngx_get_connection(ngx_socket_t s, ngx_log_t *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="title">c</span> = ngx_cycle-&gt;</span>free_connections;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span>read = rev;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span>write = wev;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span>fd = s;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"> return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得说的是 free_connections 中的连接，对于 HTTP 服务来说，会经过 ngx_http_init_connection 的初始化处理。它会设置该连接读写事件的回调函数 c-&gt;read-&gt;handler 和 c-&gt;write-&gt;handler。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/http/ngx_http_request.c</span></span><br><span class="line">void ngx_http_init_connection(ngx_connection_t *c)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="function"><span class="title">rev</span> = c-&gt;</span>read;</span><br><span class="line"> <span class="function"><span class="title">rev</span>-&gt;</span>handler = ngx_http_wait_request_handler;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">write</span>-&gt;</span>handler = ngx_http_empty_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-添加新连接">3.2 添加新连接</h3><p>我们再来看 ngx_add_conn，对于 epoll module 来说，它就是 ngx_epoll_add_connection 这个函数。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line">#define ngx_add_conn         ngx_event_actions.add_conn</span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line">static ngx_int_t</span><br><span class="line">ngx_epoll_add_connection(ngx_connection_t *c)</span><br><span class="line">&#123;</span><br><span class="line"> struct epoll_event  ee;</span><br><span class="line"> ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;</span><br><span class="line"> <span class="function"><span class="title">ee</span>.<span class="keyword">data</span>.ptr = (void *) ((uintptr_t) c | c-&gt;</span><span class="function"><span class="title">read</span>-&gt;</span>instance);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">epoll_ctl</span>(ep, EPOLL_CTL_ADD, c-&gt;</span>fd, &amp;ee)</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">read</span>-&gt;</span>active = <span class="number">1</span>;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">write</span>-&gt;</span>active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这只是 epoll_ctl 的一个封装而已。这里再补充说一下，如果这个客户端连接 socket 上有数据到达的时候，就会进入到上面 3.1 节中注册的 ngx_http_wait_request_handler 函数进行处理。后面就是 HTTP 的处理逻辑了。</p><h2 id="四、总结">四、总结</h2><p>Nginx 的 Master 中做的网络相关动作不多，仅仅只是创建了 socket、然后 bind 并 listen 了一下。接着就是用自己 fork 出来多个 Worker 进程来。由于每个进程都一样，所以每个 Worker 都有 Master 创建出来的 listen 状态的 socket 句柄。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202746092.png" alt="image-20240603202746092"></p><p>Worker 进程处理的网络相关工作就比较多了。epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的，也包括用户连接上的数据 read、处理 和 write。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202802393.png" alt="image-20240603202802393"></p><ul><li>1.先是使用 epoll_create 创建一个 epoll 对象出来</li><li>2.设置回调为 ngx_event_accept</li><li>3.通过 epoll_ctl 将所有 listen 状态的 socket 的事件都管理起来</li><li>4.执行 epoll_wait 等待 listen socket 上的连接到来</li><li>5.新连接到来是 epoll_wait 返回，进入 ngx_event_accept 回调</li><li>6.ngx_event_accept 回调中将新连接也添加到 epoll 中进行管理（其回调为ngx_http_init_connection）</li><li>7.继续进入 epoll_wait 等待事件</li><li>8.用户数据请求到达时进入 http 回调函数进行处理</li></ul><p>讲到这里，你可以觉得咱们已经讨论完了。实际上有一个点我们还没有考虑到。我们上面讨论的流程是一个 Worker 在工作的情况。那么在多 Worker 的情况下，Nginx 的全貌咱们还没展开说过。通过上文我们可以看到以下几个细节：</p><ul><li>1.每个 Worker 都会有一个属于自己的 epoll 对象</li><li>2.每个 Worker 会关注所有的 listen 状态上的新连接事件</li><li>3.对于用户连接，只有一个 Worker 会处理，其它 Worker 不会持有该用户连接的 socket。</li></ul><p>根据这三条结论，我们再画一个 Nginx 的全貌图。</p><p>【easy say:就是刚开始master进程创建socket与端口绑定，然后通过fork子进程的方式，让这些子进程也可以监听这些最为原始的socket，然后时间发生的时候，操作系统的内核会发生惊群效应，从这些子进程中选择·一个进程事件处理】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240603202820951.png" alt="image-20240603202820951"></p>]]></content>
    
    
    <summary type="html">Nginx网络工作原理</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper原理篇</title>
    <link href="https://penge666.github.io/posts/586aed37.html"/>
    <id>https://penge666.github.io/posts/586aed37.html</id>
    <published>2024-06-02T12:40:07.000Z</published>
    <updated>2024-06-02T12:57:39.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="28-彻底掌握二阶段提交三阶段提交算法原理">28 彻底掌握二阶段提交三阶段提交算法原理</h2><p>在本节课的开篇中，我们已经提到过 ZooKeeper 在分布式系统环境中主要解决的是分布式一致性问题。而为什么会发生数据不一致的问题呢？是因为当网络集群处理来自客户端的请求时，其中的事务性会导致服务器上数据状态的变更。</p><p>为了保证数据变更请求在整个分布式环境下正确地执行，不会发生异常中断，从而导致请求在某一台服务器执行失败而在集群中其他服务器上执行成功，在整个分布式系统处理数据变更请求的过程中，引入了分布式事务的概念。</p><h3 id="分布式事务">分布式事务</h3><p>对于事务操作我们并不陌生，最为熟悉的就是数据库事务操作。当多个线程对数据库中的同一个信息进行修改的时候，为保证数据的原子性、一致性、隔离性、持久性，需要进行本地事务性操作。而在分布式的网络环境下，也会面临多个客户端的数据请求服务。在处理数据变更的时候，需要保证在分布式环境下的数据的正确完整，因此在分布式环境下也引入了分布式事务。</p><h3 id="二阶段提交">二阶段提交</h3><p>二阶段提交（Two-phase Commit）简称 2PC ，它是一种实现分布式事务的算法。二阶段提交算法可以保证分布在不同网络节点上的程序或服务按照事务性的方式进行调用。</p><h4 id="底层实现">底层实现</h4><p>正如算法的名字一样，二阶段提交的底层实现主要分成两个阶段，分别是<strong>询问阶段</strong>和<strong>提交阶段</strong>。具体过程如下图所示：</p><p>整个集群服务器被分成一台协调服务器，集群中的其他服务器是被协调的服务器。在二阶段算法的询问阶段，分布式集群服务在接收到来自客户端的请求的时候，首先会通过协调者服务器，针对本次请求能否正常执行向集群中参与处理的服务器发起询问请求。集群服务器在接收到请求的时候，会在本地机器上执行会话操作，并记录执行的相关日志信息，最后将结果返回给协调服务器。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602194748445.png" alt="image-20240602194748445"></p><p>【简单来说，先搞懂这是分布式事务，本质还是事务，只不过在分布式环境中。就是先问你事务能不能执行，能执行就执行】</p><p>在协调服务器接收到来自集群中其他服务器的反馈信息后，会对信息进行统计。如果集群中的全部机器都能正确执行客户端发送的会话请求，那么协调者服务器就会再次向这些服务器发送提交命令。在集群服务器接收到协调服务器的提交指令后，会根据之前处理该条会话操作的日志记录在本地提交操作，并最终完成数据的修改。</p><p>虽然二阶段提交可以有效地保证客户端会话在分布式集群中的事务性，但是<strong>该算法自身也有很多问题</strong>，主要可以归纳为以下几点：效率问题、单点故障、异常中断。</p><h4 id="性能问题">性能问题</h4><p>首先，我们先来介绍一下性能问题。如我们上面介绍的二阶段算法，在数据提交的过程中，所有参与处理的服务器都处于阻塞状态，如果其他线程想访问临界区的资源，需要等待该条会话请求在本地执行完成后释放临界区资源。因此，采用二阶段提交算法也会降低程序并发执行的效率。</p><h4 id="单点问题">单点问题</h4><p>此外，还会发生单点问题。单点问题也叫作单点服务器故障问题，它指的是当作为分布式集群系统的调度服务器发生故障时，整个集群因为缺少协调者而无法进行二阶段提交算法。单点问题也是二阶段提交最大的缺点，因此使用二阶段提交算法的时候通常都会进行一些改良，以满足对系统稳定性的要求。</p><h4 id="异常中断">异常中断</h4><p>异常中断问题指的是当统计集群中的服务器可以进行事务操作时，协调服务器会向这些处理事务操作的服务器发送 commit 提交请求。如果在这个过程中，其中的一台或几台服务器发生网络故障，无法接收到来自协调服务器的提交请求，导致这些服务器无法完成最终的数据变更，就会造成整个分布式集群出现数据不一致的情况。</p><p>由于以上种种问题，在实际操作中，我更推荐使用另一种分布式事务的算法——三阶段提交算法。</p><h3 id="三阶段提交">三阶段提交</h3><p>三阶段提交（Three-phase commit）简称 3PC ， 其实是在二阶段算法的基础上进行了优化和改进。如下图所示，在整个三阶段提交的过程中，相比二阶段提交，<strong>增加了预提交阶段</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602194807863.png" alt="image-20240602194807863"></p><p>【简单来说，就是问你事务能不能执行，执行的结果如何，🆗的就提交吧！】</p><h4 id="底层实现-2">底层实现</h4><p><strong>预提交阶段</strong></p><p>为了保证事务性操作的稳定性，同时避免二阶段提交中因为网络原因造成数据不一致等问题，完成提交准备阶段后，集群中的服务器已经为请求操作做好了准备，协调服务器会向参与的服务器发送预提交请求。集群服务器在接收到预提交请求后，在本地执行事务操作，并将执行结果存储到本地事务日志中，并对该条事务日志进行锁定处理。</p><p><strong>提交阶段</strong></p><p>在处理完预提交阶段后，集群服务器会返回执行结果到协调服务器，最终，协调服务器会根据返回的结果来判断是否继续执行操作。如果所有参与者服务器返回的都是可以执行事务操作，协调者服务器就会再次发送提交请求到参与者服务器。参与者服务器在接收到来自协调者服务器的提交请求后，在本地正式提交该条事务操作，并在完成事务操作后关闭该条会话处理线程、释放系统资源。当参与者服务器执行完相关的操作时，会再次向协调服务器发送执行结果信息。</p><p>协调者服务器在接收到返回的状态信息后会进行处理，如果全部参与者服务器都正确执行，并返回 yes 等状态信息，整个事务性会话请求在服务端的操作就结束了。如果在接收到的信息中，有参与者服务器没有正确执行，则协调者服务器会再次向参与者服务器发送 rollback 回滚事务操作请求，整个集群就退回到之前的状态，这样就避免了数据不一致的问题。</p><h3 id="总结">总结</h3><p>本节课我们主要学习了分布式系统下的分布式事务问题。由于分布式系统架构的特点，组成整个系统的网络服务可能分布在不同的网络节点或服务器上，因此在调用这些网络服务的过程中，会面临网络异常中断等不确定的问题，最终导致集群中出现数据不一致的情况。</p><p>为了保证数据的有一致性，我们引入了二阶段提交和三阶段提交算法。这两种算法都会将整个事务处理过程分成<strong>准备、执行、确认</strong>提交这几个阶段。不同的是，二阶段提交会因为网络原因造成数据不一致的问题，而三阶段提交通过增加预加载阶段将执行的事务数据保存到本地，当整个网络中的参与者服务器都能进行事务操作后，协调服务器会发送最终提交请求给参与者服务器，并最终完成事务操作的数据的修改。</p><h2 id="29-ZAB-协议算法：崩溃恢复和消息广播">29 ZAB 协议算法：崩溃恢复和消息广播</h2><p>之前谈到当 Leader 节点发生崩溃的时候，在 ZooKeeper 集群中会重新选举出新的 Leader 节点服务器，以保证 ZooKeeper 集群的可用性。那么从 Leader 节点发生崩溃到重新恢复中间经历了哪些过程，又是采用什么算法恢复集群服务的？</p><h3 id="ZAB-协议算法">ZAB 协议算法</h3><p>ZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。</p><p><strong>ZAB 协议算法</strong>（Zookeeper Atomic Broadcast ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是<strong>崩溃恢复</strong>和<strong>原子广播协议</strong>。</p><p>在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用<strong>主从模式</strong>的系统架构方式来保证 ZooKeeper 集群系统的一致性。整个实现过程如下图所示，当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602195634863.png" alt="image-20240602195634863"></p><p>以 ZooKeeper 集群为例，这个操作过程可以概括为：当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。</p><h4 id="崩溃恢复">崩溃恢复</h4><p>【简单来说，就是主节点泵了选一个出来继续当头】</p><p>在介绍完 ZAB 协议在架构层面的实现逻辑后，我们不难看出整个 ZooKeeper 集群处理客户端会话的核心点<strong>在一台 Leader 服务器上</strong>。所有的业务处理和数据同步操作都要靠 Leader 服务器完成。结合我们在“ 28 | 彻底掌握二阶段提交/三阶段提交算法原理” 中学习到的二阶段提交知识，会发现就目前介绍的 ZooKeeper 架构方式而言，<strong>极易产生单点问题</strong>，即当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。</p><p>崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。</p><p><strong>投票过程如下</strong>：当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。</p><p><strong>举个生活的例子：</strong></p><p>举个例子，假设我们有一个小镇，镇长突然离职了，我们需要选出一个新的镇长来。每个居民（对应于Follow服务器）都可以提名一个候选人，然后将这个提名给其他居民看。每个居民在收到其他居民的提名后，会将自己的提名和新的提名进行比较，如果认为新的提名更合适，那么就会采用新的提名作为自己的提名。</p><p>这个过程就像是一轮轮的投票，每一轮投票结束后，如果还没有超过半数的居民提名同一个人，那么就需要进行新一轮的投票。最终，当超过半数的居民提名同一个人时，这个人就被选为新的镇长。</p><h4 id="选票结构">选票结构</h4><p>介绍完整个选举 Leader 节点的过程后，我们来看一下整个投票阶段中的投票信息具有怎样的结构。以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602195729126.png" alt="image-20240602195729126"></p><ul><li><strong>ogicClock</strong>：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。</li><li><strong>state</strong>：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。</li><li><strong>self_id</strong>：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。</li><li><strong>self_zxid</strong>： 当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</li><li><strong>vote_id</strong>：投票要被推举的服务器的唯一 ID 。</li><li><strong>vote_zxid</strong>：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</li></ul><p>当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。</p><h4 id="选票筛选">选票筛选</h4><p>接下来我们再来看一下，当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。Follow 服务器进行选票对比的过程，如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602195829997.png" alt="image-20240602195829997"></p><p>首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。接下来再对比 vote_zxid 被选举的服务器 ID 信息，若接收到的外部投票信息中的 vote_zxid 字段较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid ，并广播出去。要是对比的结果相同，则继续对比 vote_myid 被选举服务器上所保存的最大事务 ID ，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 。 经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。</p><p><strong>举例说明</strong></p><p>ZooKeeper集群的选举过程可以比作一个民主投票过程。</p><p>假设我们在一个小镇上，需要选出新的镇长。每个居民（对应于ZooKeeper的服务器）都会在一张选票上写下他心目中理想的候选人，并写下他们的理由（这可以看作是服务器的vote_zxid和vote_myid）。</p><p>然后，每个人都会拿着自己的选票和其他人的票进行比较。首先，他们会看选票的轮次（logicClock），如果轮次是一样的，那么就说明这两张票是在同一轮投票中产生的，可以进行下一步比较。如果轮次不同，那么就会跳过这张票。</p><p>接下来，他们会看票上的理由（vote_zxid），如果别人的理由更有说服力（即vote_zxid更大），那么他就会改变自己的心意，将自己的票改为别人的候选人和理由，并将这个改变告诉其他人。如果理由相同，那么他们会继续看候选人（vote_myid），如果别人的候选人更优秀（即vote_myid更大），那么他也会改变自己的票。</p><p>通过这样的比较和替换，每个人都可能产生新的投票信息。然后，在下一轮投票中，他们会将自己的新票发送给其他人。最终，当超过半数的人选出了同一个人，这个人就会被选为新的镇长。</p><p>在ZooKeeper集群中，这个过程确保了即使在Leader服务器崩溃后，整个集群也能通过投票选出新的Leader服务器，保证系统的正常运行。</p><h4 id="消息广播">消息广播</h4><p><strong>在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步</strong>。ZooKeeper 集群采用消息广播的方式发送通知。</p><p>ZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与我们在“ 28 | 彻底掌握二阶段提交/三阶段提交算法原理” 的二阶段提交过程非常相似，如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602200426527.png" alt="image-20240602200426527"></p><p>当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。</p><p>这里请大家注意 ，与我们“ 28 | 彻底掌握二阶段提交/三阶段提交算法原理” 中提到的二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一般的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。</p><h3 id="总结-2">总结</h3><p>本节课我们主要介绍了 ZooKeeper 中的 ZAB 协议算法。 ZAB 协议算法能够保证 ZooKeeper 集群服务在处理事务性请求后的数据一致性 ，当集群中的 Leader 服务器发生崩溃的时候，ZAB 协议算法可以在 ZooKeeper 集群中重新选举 Leader 并进行数据的同步恢复。其中值得注意的是消息广播的底层实现过程虽然与二阶段提交非常相似，但是与二阶段提交相比，<strong>并没有事务丢弃的过程</strong>。在 ZooKeeper 集群的消息广播中，只要满足整个集群中超过半数的 Follow 服务器可以执行本次事务操作，Leader 就可以向集群中发送提交事务操作，最终完成数据的变更。</p><h2 id="30-ZAB-与-Paxos-算法的联系与区别">30 ZAB 与 Paxos 算法的联系与区别</h2><p>在掌握 ZAB 协议的情况下，我们再进一步学习另一种算法： Paxos 算法。我们会通过研究 Paxos 算法的实现原理，来分析它与 ZAB 协议有什么不同，及它们各自的优缺点。</p><h3 id="Paxos-算法">Paxos 算法</h3><p>在分布式一致性问题的解决方案中，Paxos 算法可以说是<strong>目前最为优秀</strong>的。很多方案，包括我们学习的 ZooKeeper 的 ZAB 协议算法都是在其基础上改进和演变过来的。</p><p>Paxos 算法是基于消息传递的分布式一致性算法，很多大型的网络技术公司和开源框架都采用 Paxos 算法作为其各自的底层解决方案，比如 Chubby 、 Megastore 以及 MySQL Group Replication 。 Paxos 算法运行在服务器发生宕机故障的时候，能够保证数据的完整性，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复，保证服务的高可用性。</p><h3 id="底层实现-3">底层实现</h3><p>介绍完 Paxos 算法能够解决哪些问题后，接下来我们继续学习 Paxos 算法的底层实现过程。保证分布式系统下数据的一致性操作，本质是协调运行在不同的网络服务器上的线程服务，使这些服务就某一个特定的数据执行一致性的变更操作。在整个 Paxos 算法的实现过程中，将参与算法的集群中的全部服务器，分成三种角色：提议者（Proposer）、决策者（Acceptor）、决策学习者（Learner）。</p><h4 id="三种角色">三种角色</h4><p>先来看看三种角色的具体分工。</p><ul><li><strong>提议者（Proposer）</strong>：提出提案（Proposal）。Proposal 信息包括提案编号（Proposal ID）和提议的值（Value）。</li><li><strong>决策者（Acceptor）</strong>：参与决策，回应 Proposers 的提案。收到 Proposal 后可以接受提案，若 Proposal 获得超过半数 Acceptors 的许可，则称该 Proposal 被批准。</li><li><strong>决策学习者</strong>：不参与决策，从 Proposers/Acceptors 学习最新达成一致的提案（Value）。</li></ul><p>经过我们之前对 ZooKeeper 的学习，相信对 Paxos 算法的集群角色划分并不陌生。而与 ZAB 协议算法<strong>不同的是</strong>，<strong>在 Paxos 算法中，当处理来自客户端的事务性会话请求的过程时，首先会触发一个或多个服务器进程，就本次会话的处理发起提案。当该提案通过网络发送到集群中的其他角色服务器后，这些服务器会就该会话在本地的执行情况反馈给发起提案的服务器。发起提案的服务器会在接收到这些反馈信息后进行统计，当集群中超过半数的服务器认可该条事务性的客户端会话操作后，认为该客户端会话可以在本地执行操作</strong>。</p><p>上面介绍的 Paxos 算法针对事务性会话的处理投票过程与 ZAB 协议十分相似，但不同的是，对于采用 ZAB 协议的 ZooKeeper 集群中发起投票的机器，所采用的是在集群中运行的一台 Leader 角色服务器。而 Paxos 算法则采用多副本的处理方式，即存在多个副本，每个副本分别包含提案者、决策者以及学习者。下图演示了三种角色的服务器之间的关系。</p><p><strong>举例说明</strong></p><p>将Paxos算法中的参与者比作一个议会的三个角色可能会更好理解：</p><ol><li><strong>提议者（Proposer）</strong>：就像是议会的议员，他们有权提出新的法案（Proposal）。每个法案都有一个唯一的编号（Proposal ID）和一个具体的内容（Value）。</li><li><strong>决策者（Acceptor）</strong>：就像是参议院的成员，他们的职责是对提出的法案进行投票。他们可以选择赞成或反对法案，如果一个法案得到了超过半数的赞成票，那么这个法案就被认为是通过了。</li><li><strong>决策学习者（Learner）</strong>：就像是公众，他们不参与决策，但是可以从议员和参议员那里了解最新通过的法案（Value）。</li></ol><p>当处理来自客户端的请求时，Paxos算法会触发一个或多个服务器进程，这些服务器就像是提出新法案的议员。他们会将法案发送给其他的服务器，其他的服务器就像是参议院的成员，他们会根据自己的情况对法案进行投票，并将投票结果反馈给发起法案的服务器。发起法案的服务器收到反馈后，会进行统计，如果超过半数的服务器赞成这个法案，那么就认为这个请求可以在本地执行。</p><h4 id="事务处理过程">事务处理过程</h4><p>介绍完 Paxos 算法中的服务器角色和投票的处理过程后，接下来我们再来看一下 Paxos 针对一次提案是如何处理的。如下图所示，整个提案的处理过程可以分为三个阶段，分别是提案准备阶段、事务处理阶段、数据同步阶段。我们分别介绍一下这三个阶段的底层处理逻辑。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602201705558.png" alt="image-20240602201705558"></p><ul><li><strong>提案准备阶段</strong>：该阶段是整个 Paxos 算法的最初阶段，所有接收到的来自客户端的事务性会话在执行之前，整个集群中的 Proposer 角色服务器或者节点，需要将会话发送给 Acceptor 决策者服务器。在 Acceptor 服务器接收到该条询问信息后，需要返回 Promise ，承诺可以执行操作信息给 Proposer 角色服务器。</li><li><strong>事务处理阶段</strong>：在经过提案准备阶段，确认该条事务性的会话操作可以在集群中正常执行后，Proposer 提案服务器会再次向 Acceptor 决策者服务器发送 propose 提交请求。Acceptor 决策者服务器在接收到该 propose 请求后，在本地执行该条事务性的会话操作。</li><li><strong>数据同步阶段</strong>：在完成了事务处理阶段的操作后，整个集群中对该条事务性会话的数据变更已经在 Acceptor 决策者服务器上执行完成，当整个集群中有超过半数的 Acceptor 决策者服务器都成功执行后，Paxos 算法将针对本次执行结果形成一个决议，并发送给 Learner 服务器。当 Learner 服务器接收到该条决议信息后，会同步 Acceptor 决策者服务器上的数据信息，最终完成该条事务性会话在整个集群中的处理。</li></ul><p><strong>举例说明</strong></p><p>Paxos算法的处理流程就像一个公司的决策过程。</p><p>首先是<strong>提案准备阶段</strong>，这就像是公司的某个部门（Proposer角色服务器）有一个新的项目想法，他们会将这个想法提交给公司的领导团队（Acceptor决策者服务器）。领导团队在接收到这个想法后，会评估这个项目是否值得进行，并给出他们的承诺（Promise），也就是是否同意进行这个项目。</p><p>接下来是<strong>事务处理阶段</strong>，这个阶段就像是公司开始执行这个项目。部门会再次向领导团队发送项目的详细计划（propose提交请求），领导团队在接收到这个计划后，会开始在本地执行这个项目，也就是开始分配资源，调配人员等。</p><p>最后是<strong>数据同步阶段</strong>，这就像是项目执行完成后，公司开始进行项目的总结和反馈。当超过半数的领导团队成员都同意这个项目的执行结果后，公司会形成一个最终的决议，并将这个决议发送给其他的部门（Learner服务器）。其他的部门在接收到这个决议后，会同步领导团队的决策，也就是根据这个项目的结果进行相应的调整和改进。</p><p>这就是Paxos算法的整个处理流程。通过这个流程，Paxos算法能够在分布式环境中实现数据的一致性，保证系统的正常运行。</p><h3 id="Paxos-PK-ZAB">Paxos PK ZAB</h3><p>经过上面的介绍我们对 Paxos 算法所能解决的问题，以及底层的实现原理都有了一个详细的了解。现在结合我们之前学习的 ZooKeeper 相关知识，来看看 Paxos 算法与 ZAB 算法的相同及不同之处。</p><p><strong>相同之处是</strong>，在执行事务行会话的处理中，两种算法最开始都需要一台服务器或者线程针对该会话，在集群中发起提案或是投票。只有当集群中的过半数服务器对该提案投票通过后，才能执行接下来的处理。</p><p>而 Paxos 算法与 ZAB 协议<strong>不同的是</strong>，Paxos 算法的发起者可以是一个或多个。当集群中的 Acceptor 服务器中的大多数可以执行会话请求后，提议者服务器只负责发送提交指令，事务的执行实际发生在 Acceptor 服务器。这与 ZooKeeper 服务器上事务的执行发生在 Leader 服务器上不同。Paxos 算法在数据同步阶段，是多台 Acceptor 服务器作为数据源同步给集群中的多台 Learner 服务器，而 ZooKeeper 则是单台 Leader 服务器作为数据源同步给集群中的其他角色服务器。</p><p><strong>举例说明</strong></p><p>Paxos算法和ZAB协议都是用于处理分布式系统中数据一致性问题的算法，它们有一些相同之处，也有一些不同之处。</p><p>相同之处在于，两种算法在处理事务性会话时，都需要有一个服务器或线程在集群中发起提案或投票，只有当集群中的过半数服务器对这个提案投票通过，才能执行接下来的操作。这就像是一个公司在做重大决策时，需要有一个部门提出建议，然后全公司进行投票，<strong>只有当半数以上的员工同意这个建议时，才会执行这个决策。</strong></p><p>不同之处在于，Paxos算法的发起者可以是一个或者多个，这就像是公司中的多个部门都可以提出建议。而在ZAB协议中，只有一个Leader服务器可以发起提案，这就像是公司中只有CEO可以提出建议。另外，Paxos算法中，事务的执行实际发生在Acceptor（决策者）服务器，这就像是公司的各个部门根据CEO的决策进行执行。而在ZooKeeper中，事务的执行实际上发生在Leader服务器，这就像是CEO直接负责执行决策。</p><p>此外，在数据同步阶段，Paxos算法是由多台Acceptor服务器同步数据给集群中的Learner服务器，就像是公司的各个部门都会将执行结果报告给所有员工。而在ZooKeeper中，只有Leader服务器会同步数据给其他服务器，这就像是只有CEO会将执行结果公布给全公司。</p><p>通过这些例子，我们可以更好地理解Paxos算法和ZAB协议的相同之处和不同之处。</p><h3 id="总结-3">总结</h3><p>本节课我们主要介绍了 Paxos 算法，该算法在解决分布式一致性问题上被广泛采用。Paxos 算法将集群中的服务器或网络节点分为提议者（Proposer）、决策者（Acceptor）、决策学习者（Learner），在处理事务性会话请求的时候，会针对该会话操作在集群中通过提议者（Proposer）服务器发起询问操作，之后由决策者（Acceptor）服务器决定是否执行。在集群中多数服务器都正确执行会话操作后，决策学习者（Learner）会同步（Acceptor）服务器上的数据，并完成最终的操作。</p><h2 id="31-ZooKeeper-中二阶段提交算法的实现分析">31 ZooKeeper 中二阶段提交算法的实现分析</h2><p>我们一直围绕在分布式系统环境下，如何解决一致性问题来进行讨论，并分别介绍了在分布式环境中比较常见的二阶段提交、三阶段提交算法，之后又对比介绍了 ZooKeeper 所采用的 ZAB 协议算法和 Paxos 算法的优缺点。</p><p>在学习 ZAB 协议和 Paxos 算法的过程中，我们曾提到在处理来自客户端的事务性请求时，为了保证整个集群的数据一致性，其各自的底层实现与二阶段算法都有相似之处。但我们知道，二阶段提交算法自身有一些缺点，比如容易发生单点故障，比如在并发性能上有一些瓶颈，那么今天就深入 ZooKeeper 的底层，来看一下 ZooKeeper 是如何克服这些问题，并实现自己特有的二阶段提交算法的。希望通过本节课的学习，帮助你进一步提高解决分布式一致性问题的能力。</p><h3 id="提交请求">提交请求</h3><p>前面我们学到，二阶段提交的本质是协调和处理 ZooKeeper 集群中的服务器，使它们在处理事务性会话请求的过程中能保证数据一致性。如果把执行在 ZooKeeper 集群中各个服务器上的事务会话处理操作分别看作不同的函数，那么整个一致性的处理逻辑就相当于包裹这些函数的事务。而在单机环境中处理事务的逻辑是，包含在事务中的所有函数要么全部成功执行，要么全部都不执行。</p><p>其中，事务性会话，简单来说，就是一系列的操作，这些操作被视为一个整体，要么全部成功，要么全部失败。这就像是一个链条，只有当所有的环节都成功，链条才能完整，只要有一个环节失败，整个链条就会断开。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602203300990.png" alt="image-20240602203300990"></p><p>不同的是，在分布式环境中，处理事务请求的各个函数是分布在不同的网络服务器上的线程，无法像在单机环境下一样，做到当事务中的某一个环节发生异常的时候，回滚包裹在整个事务中的操作。因此，分布式环境中处理事务操作的时候，一般的算法不会要求全部集群中的机器都成功执行操作，如果有其中一个函数执行异常，那么整个事务就会把所有函数的执行结果回滚到执行前的状态，也就是无论是正确执行的函数，还是执行异常的函数，各自所做的对数据和程序状态的变更都将被删除。</p><h3 id="执行请求">执行请求</h3><p>看完提交请求的处理过程后，我们再来看一下在执行请求时 ZooKeeper 的底层实现过程。</p><p>ZooKeeper 集群中的 Leader 服务器对该条事务性会话操作是否能够在 Follow 服务器上执行，向集群中的 Follow 服务器发起 Proposal 请求。</p><p>这里请你注意，与我们之前介绍的二阶段提交不同的是，在 ZooKeeper 的实现中并没有中断提交的逻辑。集群中的 Follow 服务器在接收到上述 Proposal 请求后，只有两种处理情况：</p><p>第一种情况：ZooKeeper 集群中的 Follow 服务器能够正确执行操作，并向 ZooKeeper 集群中的 Leader 反馈执行结果。</p><p>第二种情况：无法正确执行该条 Proposal 操作，直接抛弃该条请求。</p><p>ZooKeeper 集群的这种执行逻辑，最终导致无须等 待所有服务器都执行完成并反馈，集群中的 Leader 服务器只需要接收到集群中过半数的 Follow 服务器成功执行的反馈信息， ZooKeeper 集群中的 Leader 服务器最终会统计 Follow 服务器反馈的信息，当超过半数以上服务器可以正确执行操作后，整个 ZooKeeper 集群就可以进入执行事务提交操作。</p><h3 id="底层实现-4">底层实现</h3><p>介绍完 ZooKeeper 实现二阶段提交算法的原理后，接下来我们深入代码层面看看 ZooKeeper 是如何设计架构的。</p><p>从源码层面来讲，ZooKeeper 在实现整个二阶段提交算法的过程中，可以分为 Leader 服务器端的发起 Proposal 操作和 Follow 服务器端的执行反馈操作。</p><p>我们先来看看，在 ZooKeeper 集群中的 Leader 是如何向其他 Follow 服务器发送 Proposal 请求的呢？</p><p>如下面的代码所示， ZooKeeper 通过 SendAckRequestProcessor 类发送 Proposal 来提交请求。这个类首先继承了 RequestProcessor 类，但是它不是处理来自客户端的请求信息，而是用来处理向 Follow 服务器发送的 Proposal 请求信息。它在内部通过 processRequest 函数来判断，责任链中传递请求操作是否是数据同步操作：如果判断是 OpCode.sync 操作（也就是数据同步操作），就通过 learner.writePacket 方法把 Proposal 请求向集群中的所有 Follow 服务器进行发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendAckRequestProcessor</span> <span class="keyword">implements</span> <span class="title class_">RequestProcessor</span>, Flushable &#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(Request si)</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(si.type != OpCode.sync)&#123; </span><br><span class="line"></span><br><span class="line">        <span class="type">QuorumPacket</span> <span class="variable">qp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuorumPacket</span>(Leader.ACK, si.getHdr().getZxid(), <span class="literal">null</span>, </span><br><span class="line"></span><br><span class="line">            <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line">            learner.writePacket(qp, <span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line"></span><br><span class="line">            LOG.warn(<span class="string">&quot;Closing connection to leader, exception during packet send&quot;</span>, e); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!learner.sock.isClosed()) &#123; </span><br><span class="line"></span><br><span class="line">                    learner.sock.close(); </span><br><span class="line"></span><br><span class="line">                &#125; </span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// Nothing to do, we are shutting things down, so an exception here is irrelevant </span></span><br><span class="line"></span><br><span class="line">                LOG.debug(<span class="string">&quot;Ignoring error closing the connection&quot;</span>, e1); </span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在介绍完 ZooKeeper 集群中的 Leader 服务器发送 Proposal 的底层实现过程后，接下来我们再来学习一下 Follow 服务端在接收到 Leader 服务器发送的 Proposal 后的整个处理逻辑。</p><p>如下面的代码所示，这在 Follow 服务器端是通过 ProposalRequestProcessor 来完成处理的。ProposalRequestProcessor 构造函数中首先初始化了 Leader 服务器、下一个请求处理器，以及负责反馈执行结果给 Leader 服务器的 AckRequestProcessor 处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProposalRequestProcessor</span><span class="params">(LeaderZooKeeperServer zks, </span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        RequestProcessor nextProcessor)</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.zks = zks; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextProcessor = nextProcessor; </span><br><span class="line"></span><br><span class="line">    <span class="type">AckRequestProcessor</span> <span class="variable">ackProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AckRequestProcessor</span>(zks.getLeader()); </span><br><span class="line"></span><br><span class="line">    syncProcessor = <span class="keyword">new</span> <span class="title class_">SyncRequestProcessor</span>(zks, ackProcessor); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来，我们进入到 AckRequestProcessor 函数的内部，来看一下 Follow 服务器是如何反馈处理结果给 Leader 服务器的。</p><p>如下面的代码所示， AckRequestProcessor 类同样也继承了 RequestProcessor，从中可以看出在 ZooKeeper 中处理 Leader 服务器的 Proposal 时，是将该 Proposal 请求当作网络中的一条会话请求来处理的。整个处理的逻辑实现也是按照处理链模式设计实现的，在 AckRequestProcessor 类的内部通过 processRequest 函数，来向集群中的 Leader 服务器发送 ack 反馈信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AckRequestProcessor</span> <span class="keyword">implements</span> <span class="title">RequestProcessor</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_ invoke__">processRequest</span>(Request request) &#123; </span><br><span class="line"></span><br><span class="line">    QuorumPeer <span class="built_in">self</span> = leader.<span class="built_in">self</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span> != <span class="literal">null</span>) </span><br><span class="line">        leader.<span class="title function_ invoke__">processAck</span>(<span class="built_in">self</span>.<span class="title function_ invoke__">getId</span>(), request.zxid, <span class="literal">null</span>); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        LOG.<span class="title function_ invoke__">error</span>(<span class="string">&quot;Null QuorumPeer&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125;&#125; </span><br></pre></td></tr></table></figure><h3 id="总结-4">总结</h3><p>本节课我们主要介绍了，二阶段提交算法在 ZooKeeper 中的应用，并深入底层分析了 ZooKeeper 实现二阶段提交的具体过程。虽然二阶段提交自身有一些问题，不过还是一个比较好的解决分布式环境下一致性问题的算法，因此 ZooKeeper 在实现的过程中也借鉴了它，并通过自身的崩溃恢复机制来解决二阶段提交算法中的单点故障等问题。</p><h2 id="32-ZooKeeper-数据存储底层实现解析">32 ZooKeeper 数据存储底层实现解析</h2><h3 id="文件系统布局">文件系统布局</h3><p>无论是 ZooKeeper 服务在运行时候产生的数据日志，还是在集群中进行数据同步的时候所用到的数据快照，都可以被看作一种文件系统。而文件系统的两个功能就是对文件的存储和对不同文件格式的解析。ZooKeeper 中的数据存储，可以分为两种类型：数据日志文件和快照文件，接下来我们就分别介绍这两种文件的结构信息和底层实现。</p><h3 id="数据日志">数据日志</h3><p>在 ZooKeeper 服务运行的过程中，数据日志是用来记录 ZooKeeper 服务运行状态的数据文件。通过这个文件我们不但能统计 ZooKeeper 服务的运行情况，更可以在 ZooKeeper 服务发生异常的情况下，根据日志文件记录的内容来进行分析，定位问题产生的原因并找到解决异常错误的方法。</p><p>如何找到日志文件呢？在 ZooKeeper 的 zoo.cfg 配置文件中的 dataLogDir 属性字段，所指定的文件地址就是当前 ZooKeeper 服务的日志文件的存储地址。</p><p>在了解了 ZooKeeper 服务在运行的过程中所产生的日志文件的存放位置，以及日志文件的格式结构后，接下来我们就深入到 ZooKeeper 服务的底层，来看一下它是如何实现日志的搜集以及存储的。</p><h4 id="搜集日志">搜集日志</h4><p>我们先来看一下 ，ZooKeeper 是如何搜集程序的运行信息的。在统计操作情况的日志信息中，ZooKeeper 通过第三方开源日志服务框架 SLF4J 来实现的。</p><p>SLF4J 是一个<strong>采用门面设计模式（Facade）</strong> 的日志框架。如下图所示，门面模式也叫作外观模式，采用这种设计模式的主要作用是，对外隐藏系统内部的复杂性，并向外部调用的客户端或程序提供统一的接口。门面模式通常以接口的方式实现，可以被程序中的方法引用。</p><p>在下图中，我们用门面模式创建了一个绘制几何图形的小功能。首先，定义了一个 Shape 接口类，并分别创建了三个类 Circle、Square、Rectangle ，以继承 Shape 接口。其次，我们再来创建一个画笔类 ShapeMaker ，在该类中我定义了 shape 形状字段以及绘画函数 drawCircle等。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602203726254.png" alt="image-20240602203726254"></p><p>之后，当我们在本地项目中需要调用实现的会话功能时，直接调用 ShapeMaker 类，并传入我们要绘制的图形信息，就可以实现图形的绘制功能了。它使用起来非常简单，不必关心其底层是如何实现绘制操作的，只要将我们需要绘制的图形信息传入到接口函数中即可。</p><p>而在 ZooKeeper 中使用 SLF4J 日志框架也同样简单，如下面的代码所示，首先在类中通过工厂函数创建日志工具类 LOG，然后在需要搜集的操作流程处引入日志搜集函数 <a href="http://LOG.info">LOG.info</a> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.<span class="built_in">getLogger</span>(Learner.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">LOG.<span class="built_in">info</span>(<span class="string">&quot;Revalidating client: 0x&quot;</span> + Long.<span class="built_in">toHexString</span>(clientId));</span><br><span class="line"></span><br><span class="line">LOG.<span class="built_in">warn</span>(<span class="string">&quot;Couldn&#x27;t find the leader with id = &quot;</span></span><br><span class="line"></span><br><span class="line">        + current.<span class="built_in">getId</span>());</span><br></pre></td></tr></table></figure><h4 id="存储日志">存储日志</h4><p>接下来我们看一下搜集完的日志是什么样子的。在开头我们已经说过，系统日志的存放位置，在 zoo.cfg 文件中。假设我们的日志路径为dataDir=/var/lib/zookeeper，打开系统命令行，进入到该文件夹，就会看到如下图所示的样子，所有系统日志文件都放在了该文件夹下。</p><h3 id="快照文件">快照文件</h3><p>除了上面介绍的记录系统操作日志的文件外，ZooKeeper 中另一种十分重要的文件数据是快照日志文件。快照日志文件主要用来存储 ZooKeeper 服务中的事务性操作日志，并通过数据快照文件实现集群之间服务器的数据同步功能。</p><h4 id="快照创建">快照创建</h4><p>接下来我们来介绍，在 ZooKeeper 的底层实现中，一个快照文件是如何创建的。</p><p>如下面的代码所示，在 ZooKeeper 的源码中定义了一个 SnapShot 接口类，在该接口中描述了 ZooKeeper 服务的相关属性和方法。其中 serialize 函数是用来将内存中的快照文件转存到本地磁盘中时的序列化操作。而 deserialize 的作用正好与其相反，是把快照文件从本地磁盘中加载到内存中时的反序列化操作。无论是序列化还是反序列化，整个快照所操作的数据对象是 ZooKeeper 数据模型，也就是由 Znode 组成的结构树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SnapShot</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">deserialize</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions)</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">               File name, <span class="type">boolean</span> fsync)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    File <span class="title function_">findMostRecentSnapshot</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快照存储">快照存储</h4><p>创建完 ZooKeeper 服务的数据快照文件后，接下来就要对数据文件进行持久化的存储操作了。其实在整个 ZooKeeper 中，随着服务的不同阶段变化，数据快照存放文件的位置也随之变化。存储位置的变化，主要是内存和本地磁盘之间的转变。当 ZooKeeper 集群处理来自客户端的事务性的会话请求的时候，会首先在服务器内存中针对本次会话生成数据快照。当整个集群可以执行该条事务会话请求后，提交该请求操作，就会将数据快照持久化到本地磁盘中，如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602203745904.png" alt="image-20240602203745904"></p><p>存储到本地磁盘中的数据快照文件，是经过 ZooKeeper 序列化后的二进制格式文件，通常我们无法直接查看，但如果想要查看，也可以通过 ZooKeeper 自带的 SnapshotFormatter 类来实现。如下图所示，在 SnapshotFormatter 类的内部用来查看快照文件的几种函数分别是： printDetails 函数，用来打印日志中的数据节点和 Session 会话信息；printZnodeDetails 函数，用来查看日志文件中节点的详细信息，包括节点 id 编码、state 状态信息、version 节点版本信息等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotFormatter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(DataTree dataTree, Map&lt;Long, Integer&gt; sessions)</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printZnodeDetails</span><span class="params">(DataTree dataTree)</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printZnode</span><span class="params">(DataTree dataTree, String name)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSessionDetails</span><span class="params">(DataTree dataTree, Map&lt;Long, Integer&gt; sessions)</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printStat</span><span class="params">(StatPersisted stat)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHex</span><span class="params">(String prefix, <span class="type">long</span> value)</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 ZooKeeper 提供了 SnapshotFormatter 类，但其实现的查询功能比较单一，我们可以通过本节课的学习，按照自己的业务需求，编写自己的快照文件查看器。</p><p>到目前位置，我们对 ZooKeeper 服务相关的数据文件都做了讲解。无论是数据日志文件，还是数据快照文件，最终都会存储在本地磁盘中。而从文件的生成方式来看，两种日志文件的不同是：数据日志文件实施性更高，相对的产生的日志文件也不断变化，只要 ZooKeeper 服务一直运行，就会产生新的操作日志数据；而数据快照并非实时产生，它是当集群中数据发生变化后，先在内存中生成数据快照文件，经过序列化后再存储到本地磁盘中。</p><h3 id="总结-5">总结</h3><p>本节课我们讲解了在 ZooKeeper 服务运行过程中所产生的两种主要数据文件：数据日志文件和数据快照文件的结构信息和底层实现，以便加强你对它们的理解。</p>]]></content>
    
    
    <summary type="html">Zookeeper原理篇</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础笔记</title>
    <link href="https://penge666.github.io/posts/b79fdeab.html"/>
    <id>https://penge666.github.io/posts/b79fdeab.html</id>
    <published>2024-06-02T08:07:40.000Z</published>
    <updated>2024-06-02T09:44:59.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB-基础">MongoDB 基础</h2><h3 id="MongoDB-是什么？">MongoDB 是什么？</h3><p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 <strong>C++</strong> 编写的。MongoDB 提供了 面向文档 的存储方式，操作起来比较简单和容易，支持“无模式”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong> 。</p><p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。</p><p>适用于<strong>OLTP</strong>。</p><h3 id="MongoDB-的存储结构是什么？">MongoDB 的存储结构是什么？</h3><p>MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：</p><ul><li>文档（Document） ：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。</li><li>集合（Collection） ：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。</li><li>数据库（Database） ：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。</li></ul><p>也就是说，MongoDB 将数据记录存储为文档 （更具体来说是BSON 文档），这些文档在集合中聚集在一起，数据库中存储一个或多个文档集合。</p><p>SQL 与 MongoDB 常见术语对比 ：</p><table><thead><tr><th>SQL</th><th>MongoDB</th></tr></thead><tbody><tr><td>表（Table）</td><td>集合（Collection）</td></tr><tr><td>行（Row）</td><td>文档（Document）</td></tr><tr><td>列（Col）</td><td>字段（Field）</td></tr><tr><td>主键（Primary Key）</td><td>对象 ID（Objectid）</td></tr><tr><td>索引（Index）</td><td>索引（Index）</td></tr><tr><td>嵌套表（Embeded Table）</td><td>嵌入式文档（Embeded Document）</td></tr><tr><td>数组（Array）</td><td>数组（Array）</td></tr></tbody></table><h3 id="文档">文档</h3><p>MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。字段的值可能包括其他文档、数组和文档数组。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163330369.png" alt="image-20240602163330369"></p><p>文档的键是字符串。除了少数例外情况，键可以使用任意 UTF-8 字符。</p><ul><li>键不能含有 <code>\0</code>(空字符）。这个字符用来表示键的结尾。</li><li><code>.</code> 和 <code>$</code> 有特别的意义，只有在特定环境下才能使用。</li><li>以下划线<code>_</code>开头的键是保留的(不是严格要求的)。</li></ul><p>BSON [bee·sahn] 是 Binary JSON的简称，是 JSON 文档的二进制表示，支持将文档和数组嵌入到其他文档和数组中，还包含允许表示不属于 JSON 规范的数据类型的扩展。有关 BSON 规范的内容，可以参考 <a href="http://bsonspec.org">bsonspec.org</a>，另见BSON 类型。</p><p>根据维基百科对 BJSON 的介绍，BJSON 的遍历速度优于 JSON，这也是 MongoDB 选择 BSON 的主要原因，但 BJSON 需要更多的存储空间。</p><blockquote><p>与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163349917.png" alt="image-20240602163349917"></p><h3 id="集合">集合</h3><p>MongoDB 集合存在于数据库中，没有固定的结构，也就是 无模式 的，这意味着可以往集合插入不同格式和类型的数据。不过，通常情况相爱插入集合中的数据都会有一定的关联性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163406051.png" alt="image-20240602163406051"></p><p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p><p>集合名可以是满足下列条件的任意 UTF-8 字符串：</p><ul><li>集合名不能是空字符串<code>&quot;&quot;</code>。</li><li>集合名不能含有 <code>\0</code> （空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。例如 <code>system.users</code> 这个集合保存着数据库的用户信息，<code>system.namespaces</code> 集合保存着所有数据库集合的信息。</li><li>集合名必须以下划线或者字母符号开始，并且不能包含 <code>$</code>。</li></ul><h3 id="数据库">数据库</h3><p>数据库用于存储所有集合，而集合又用于存储所有文档。一个 MongoDB 中可以创建多个数据库，每一个数据库都有自己的集合和权限。</p><p>MongoDB 预留了几个特殊的数据库。</p><ul><li>admin : admin 数据库主要是保存 root 用户和角色。例如，system.users 表存储用户，system.roles 表存储角色。一般不建议用户直接操作这个数据库。将一个用户添加到这个数据库，且使它拥有 admin 库上的名为 dbAdminAnyDatabase 的角色权限，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如关闭服务器。</li><li>local : local 数据库是不会被复制到其他分片的，因此可以用来存储本地单台服务器的任意 collection。一般不建议用户直接使用 local 库存储任何数据，也不建议进行 CRUD 操作，因为数据无法被正常备份与恢复。</li><li>config : 当 MongoDB 使用分片设置时，config 数据库可用来保存分片的相关信息。</li><li>test : 默认创建的测试库，连接 mongod 服务时，如果不指定连接的具体数据库，默认就会连接到 test 数据库。</li></ul><p>数据库名可以是满足以下条件的任意 UTF-8 字符串：</p><ul><li>不能是空字符串<code>&quot;&quot;</code>。</li><li>不得含有<code>' '</code>（空格)、<code>.</code>、<code>$</code>、<code>/</code>、<code>\</code>和 <code>\0</code> (空字符)。</li><li>应全部小写。</li><li>最多 64 字节。</li></ul><p>数据库名最终会变成文件系统里的文件，这也就是有如此多限制的原因。</p><h3 id="MongoDB-有什么特点？">MongoDB 有什么特点？</h3><ul><li><strong>数据记录被存储为文档</strong> ：MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</li><li><strong>模式自由</strong> ：集合的概念类似 MySQL 里的表，但它不需要定义任何模式，能够用更少的数据对象表现复杂的领域模型对象。</li><li><strong>支持多种查询方式</strong> ：MongoDB 查询 API 支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li><li><strong>支持 ACID 事务</strong> ：NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。与关系型数据库一样，MongoDB 事务同样具有 ACID 特性。MongoDB 单文档原生支持原子性，也具备事务的特性。MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了分布式事务，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</li><li><strong>高效的二进制存储</strong> ：存储在集合中的文档，是以键值对的形式存在的。键用于唯一标识一个文档，一般是 ObjectId 类型，值是以 BSON 形式存在的。BSON = Binary JSON， 是在 JSON 基础上加了一些类型及元数据描述的格式。</li><li><strong>自带数据压缩功能</strong> ：存储同样的数据所需的资源更少。</li><li><strong>支持 mapreduce</strong> ：通过分治的方式完成复杂的聚合任务。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 聚合管道。聚合管道提供比 map-reduce 更好的性能和可用性。</li><li><strong>支持多种类型的索引</strong> ：MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li><li><strong>支持 failover</strong> ：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li><li><strong>支持分片集群</strong> ：MongoDB 支持集群自动切分数据，让集群存储更多的数据，具备更强的性能。在数据插入和更新时，能够自动路由和存储。</li><li><strong>支持存储大文件</strong> ：MongoDB 的单文档存储空间要求不超过 16MB。对于超过 16MB 的大文件，MongoDB 提供了 GridFS 来进行存储，通过 GridFS，可以将大型数据进行分块处理，然后将这些切分后的小文档保存在数据库中。</li></ul><h3 id="MongoDB-适合什么应用场景？">MongoDB 适合什么应用场景？</h3><p>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。</p><p>选用 MongoDB 应该充分考虑 MongoDB 的优势，结合实际项目的需求来决定：</p><ul><li>随着项目的发展，使用类 JSON 格式（BSON）保存数据是否满足项目需求？MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</li><li>是否需要大数据量的存储？是否需要快速水平扩展？MongoDB 支持分片集群，可以很方便地添加更多的节点（实例），让集群存储更多的数据，具备更强的性能。</li><li>是否需要更多类型索引来满足更多应用场景？MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li><li>…</li></ul><h2 id="MongoDB-存储引擎">MongoDB 存储引擎</h2><h3 id="MongoDB-支持哪些存储引擎？">MongoDB 支持哪些存储引擎？</h3><p>存储引擎（Storage Engine）是数据库的核心组件，负责管理数据在内存和磁盘中的存储方式。</p><p>与 MySQL 一样，MongoDB 采用的也是 插件式的存储引擎架构 ，支持不同类型的存储引擎，不同的存储引擎解决不同场景的问题。在创建数据库或集合时，可以指定存储引擎。</p><blockquote><p>插件式的存储引擎架构可以实现 Server 层和存储引擎层的解耦，可以支持多种存储引擎，如MySQL既可以支持B-Tree结构的InnoDB存储引擎，还可以支持LSM结构的RocksDB存储引擎。</p></blockquote><p>在存储引擎刚出来的时候，默认是使用 MMAPV1 存储引擎，MongoDB4.x 版本不再支持 MMAPv1 存储引擎。</p><p>现在主要有下面这两种存储引擎：</p><ul><li>WiredTiger 存储引擎 ：自 MongoDB 3.2 以后，默认的存储引擎为 WiredTiger 存储引擎 。非常适合大多数工作负载，建议用于新部署。WiredTiger 提供文档级并发模型、检查点和数据压缩（后文会介绍到）等功能。</li><li>In-Memory 存储引擎 ：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是将它们保留在内存中以获得更可预测的数据延迟。</li></ul><p>此外，MongoDB 3.0 提供了 可插拔的存储引擎 API ，允许第三方为 MongoDB 开发存储引擎，这点和 MySQL 也比较类似。</p><h3 id="WiredTiger-基于-LSM-Tree-还是-B-Tree？">WiredTiger 基于 LSM Tree 还是 B+ Tree？</h3><p>目前绝大部分流行的数据库存储引擎都是基于 B/B+ Tree 或者 LSM(Log Structured Merge) Tree 来实现的。对于 NoSQL 数据库来说，绝大部分（比如 HBase、Cassandra、RocksDB）都是基于 LSM 树，MongoDB 不太一样。</p><p>上面也说了，自 MongoDB 3.2 以后，默认的存储引擎为WiredTiger 存储引擎。在 WiredTiger 引擎官网上，我们发现 WiredTiger 使用的是 B+ 树作为其存储结构：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WiredTiger maintains a table<span class="comment">&#x27;s data in memory using a data structure called a B-Tree ( B+ Tree to be specific), referring to the nodes of a B-Tree as pages. Internal pages carry only keys. The leaf pages store both keys and values.</span></span><br></pre></td></tr></table></figure><p>此外，WiredTiger 还支持 LSM(Log Structured Merge) 树作为存储结构，MongoDB 在使用WiredTiger 作为存储引擎时，默认使用的是 B+ 树。</p><p>如果想要了解 MongoDB 使用 B 树的原因，可以看看这篇文章：为什么 MongoDB 使用 B 树？。</p><blockquote><p>为什么这么设计（Why’s THE Design）是一系列关于计算机领域中程序设计决策的文章，我们在这个系列的每一篇文章中都会提出一个具体的问题并从不同的角度讨论这种设计的优缺点、对具体实现造成的影响。如果你有想要了解的问题，可以在文章下面留言。</p></blockquote><p>我们在这一系列前面的文章曾经分析过 为什么 MySQL 使用 B+ 树，有读者在文章下面留言，希望能出一个为什么 MongoDB 使用 B 树的对比文章，这是一个比较好的问题，MySQL 和 MongoDB 两种不同类型的数据库使用了相似却不同的数据结构，为什么 MySQL 选择使用 B+ 树而 MongoDB 使用 B 树呢？</p><p><strong>概述</strong></p><p>MongoDB 是一个通用的、面向文档的分布式数据库[^1]，这是官方对 MongoDB 介绍。区别于传统的关系型数据库 MySQL、Oracle 和 SQL Server，MongoDB 最重要的一个特点就是**『面向文档』**，由于数据存储方式的不同，对外提供的接口不再是被大家熟知的 SQL，所以被划分成了 NoSQL，NoSQL 是相对 SQL 而言的，很多我们耳熟能详的存储系统都被划分成了 NoSQL，例如：Redis、DynamoDB[^2] 和 Elasticsearch 等。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163456995.png" alt="image-20240602163456995"></p><p>NoSQL 经常被理解成没有 SQL（Non-SQL）或者非关系型（Non-Relational）[^3]，不过也有人将其理解成不只是 SQL（Not Only SQL）[^4]，深挖这个词的含义和起源可能没有太多意义，这种二次解读很多时候都是为营销服务的，我们只需要知道 MongoDB 对数据的存储方式与传统的关系型数据库完全不同。</p><p>MongoDB 的架构与 MySQL 非常类似，它们底层都使用了可插拔的存储引擎以满足用户的不同需求，用户可以根据数据特征选择不同的存储引擎，最新版本的 MongoDB 使用了 WiredTiger 作为默认的存储引擎[^5]。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163510771.png" alt="image-20240602163510771"></p><p>作为 MongoDB 默认的存储引擎，WiredTiger 使用 B 树作为索引底层的数据结构，但是除了 B 树之外，它还支持 LSM 树作为可选的底层存储结构，LSM 树的全称是 Log-structured merge-tree，你可以在 MongoDB 中使用如下所示的命令创建一个基于 LSM 树的集合（Collection）[^6]:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_ invoke__">createCollection</span>(    <span class="string">&quot;posts&quot;</span>,    &#123; <span class="attr">storageEngine</span>: &#123; <span class="attr">wiredTiger</span>: &#123;<span class="attr">configString</span>: <span class="string">&quot;type=lsm&quot;</span>&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们在这篇文章中不仅会介绍 MongoDB 的默认存储引擎 WiredTiger 为什么选择使用 B 树而不是 B+ 树，还会对 B 树和 LSM 树之间的性能和应用场景进行比较，帮助各位读者更全面地理解今天的问题。</p><p><strong>设计</strong></p><p>既然要比较两个不同数据结构与 B 树的差别，那么在这里我们将分两个小节分别介绍 B+ 树和 LSM 树为什么没有成为 WiredTiger 默认的数据结构：</p><ul><li>作为非关系型的数据库，MongoDB 对于遍历数据的需求没有关系型数据库那么强，它追求的是读写单个记录的性能；</li><li>大多数 OLTP 的数据库面对的都是读多写少的场景，B 树与 LSM 树在该场景下有更大的优势；</li></ul><p>上述的两个场景都是 MongoDB 需要面对和解决的，所以我们会在这两个常见场景下对不同的数据结构进行比较。</p><p><strong>非关系型</strong></p><p>我们在上面其实已经多次提到了 MongoDB 是非关系型的文档数据库，它完全抛弃了关系型数据库那一套体系之后，在设计和实现上就非常自由，它不再需要遵循 SQL 和关系型数据库的体系，可以更自由对特定场景进行优化，而在 MongoDB 假设的场景中遍历数据并不是常见的需求。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163545596.png" alt="image-20240602163545596"></p><p>MySQL 中使用 B+ 树是因为 B+ 树只有叶节点会存储数据，将树中的每一个叶节点通过指针连接起来就能实现顺序遍历，而遍历数据在关系型数据库中非常常见，所以这么选择是完全没有问题的[^7]。</p><p>MongoDB 和 MySQL 在多个不同数据结构之间选择的最终目的就是减少查询需要的随机 IO 次数，MySQL 认为遍历数据的查询是常见的，所以它选择 B+ 树作为底层数据结构，而舍弃了通过<strong>非叶节点存储数据</strong>这一特性，但是 MongoDB 面对的问题就不太一样了：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602163600570.png" alt="image-20240602163600570"></p><p>虽然遍历数据的查询是相对常见的，但是【关键】<strong>MongoDB 认为查询单个数据记录远比遍历数据更加常见，由于 B 树的非叶结点也可以存储数据</strong>，所以<strong>查询一条数据所需要的平均随机 IO 次数会比 B+ 树少</strong>，使用 B 树的 MongoDB 在类似场景中的查询速度就会比 MySQL 快。这里并不是说 MongoDB 并不能对数据进行遍历，我们在 MongoDB 中也可以使用范围来查询一批满足对应条件的记录，只是需要的时间会比 MySQL 长一些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM comments WHERE created_at &gt; <span class="string">&#x27;2019-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>很多人看到遍历数据的查询想到的可能都是如上所示的范围查询，然而在关系型数据库中更常见的其实是如下所示的 SQL —— 查询外键或者某字段等于某一个值的全部记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM comments WHERE post_id = 1</span><br></pre></td></tr></table></figure><p>上述查询其实并不是范围查询，它没有使用 <code>&gt;</code>、<code>&lt;</code> 等表达式，但是它却会在 <code>comments</code> 表中查询一系列的记录，如果 <code>comments</code> 表上有索引 <code>post_id</code>，那么这个查询可能就会在索引中遍历相应索引，找到满足条件的 <code>comment</code>，这种查询也会受益于 MySQL B+ 树相互连接的叶节点，因为它能减少磁盘的随机 IO 次数。</p><p>MongoDB 作为非关系型的数据库，它从集合的设计上就使用了完全不同的方法，如果我们仍然使用传统的关系型数据库的表设计思路来思考 MongoDB 中集合的设计，写出类似如上所示的查询会带来相对比较差的性能：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comments.<span class="built_in">find</span>( &#123; post_id: 1 &#125; )</span><br></pre></td></tr></table></figure><p>因为 B 树的所有节点都能存储数据，各个连续的节点之间没有很好的办法通过指针相连，所以上述查询在 B 树中性能会比 B+ 树差很多，但是这并不是一个 MongoDB 中推荐的设计方法，更合适的做法其实是使用嵌入文档，将 <code>post</code> 和属于它的所有 <code>comments</code> 都存储到一起：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为什么 MongoDB 使用 B 树&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;draven&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你这写的不行&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一楼说的对&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用上述方式对数据进行存储时就不会遇到 <code>db.comments.find( &#123; post_id: 1 &#125; )</code> 这样的查询了，我们只需要将 <code>post</code> 取出来就会获得相关的全部评论，这种区别于传统关系型数据库的设计方式是需要所有使用 MongoDB 的开发者重新思考的，这也是很多人使用 MongoDB 后却发现性能不如 MySQL 的最大原因 —— 使用的姿势不对。</p><p><strong>进一步说明：</strong></p><p>在传统的关系型数据库中，你可能会将帖子（post）和评论（comments）存储在两个不同的表中，并通过post_id将他们关联起来。当你想要获取一个帖子和它的所有评论时，你就需要执行一个类似于<code>db.comments.find( &#123; post_id: 1 &#125; )</code>的查询。然而，因为MongoDB使用的是B树，这种查询在性能上可能不如使用B+树的关系型数据库。</p><p>在MongoDB中，一种更好的设计方式是使用嵌入式文档（embedded documents）。你可以将一个帖子和它的所有评论都存储在一起，像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;为什么 MongoDB 使用 B 树&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;draven&quot;</span>,</span><br><span class="line">    <span class="string">&quot;comments&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你这写的不行&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: <span class="string">&quot;一楼说的对&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，你只需要取出帖子就能同时获取所有的评论，而不需要像在关系型数据库中那样进行额外的查询。这样就大大提高了查询效率，因此这是一种更推荐的设计方法。</p><hr><p>有些读者到这里可能会有疑问了，既然 MongoDB 认为查询单个数据记录远比遍历数据的查询更加常见，那为什么不使用哈希作为底层的数据结构呢？</p><p>回答：如果我们使用哈希，那么对于所有单条记录查询的复杂度都会是 <code>O(1)</code>，但是遍历数据的复杂度就是 <code>O(n)</code>；如果使用 B+ 树，那么单条记录查询的复杂度是 <code>O(log n)</code>，遍历数据的复杂度就是 <code>O(log n) + X</code>，这两种不同的数据结构一种提供了最好的单记录查询性能，一种提供了最好的遍历数据的性能，但是这都不能满足 MongoDB 面对的场景 —— 单记录查询非常常见，但是对于遍历数据也需要有相对较好的性能支持，哈希这种性能表现较为极端的数据结构往往只能在简单、极端的场景下使用。</p><h3 id="读多写少">读多写少</h3><p>LSM 树是一个基于磁盘的数据结构，它设计的主要目的是为长期需要高频率写入操作的文件提供低成本的索引机制[^8]。无论是 B 树还是 B+ 树，向这些数据结构组成的索引文件中写入记录都需要执行的磁盘随机写，LSM 树的优化逻辑就是牺牲部分的读性能，将随机写转换成顺序写以优化数据的写入。</p><p>我们在这篇文章不会详细介绍为什么 LSM 树有着较好的写入性能，我们只是来分析为什么 WiredTiger 使用 B 树作为默认的数据结构。WiredTiger 对 LSM 树和 B 树的性能进行了读写吞吐量的基准测试[^9]，通过基准测试得到了如下图所示的结果，从图中的结果我们能发现：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602164301739.png" alt="image-20240602164301739"></p><ol><li><p>在不限制写入的情况下；</p></li><li><ol><li>LSM 树的写入性能是 B 树的 1.5 ~ 2 倍；</li><li>LSM 树的读取性能是 B 树的 1/6 ~ 1/3；</li></ol></li><li><p>在限制写入的情况下；</p></li><li><ol><li>LSM 树的写入性能与 B 树的性能基本持平；</li><li>LSM 树的读取性能是 B 树的 1/4 ~ 1/2；</li></ol></li></ol><p>在限制写入的情况下，每秒会写入 30,000 条数据，从这里的分析结果来看，无论那种情况下 B 树的读取性能是远好于 LSM 树的。对于大多数的 OLTP 系统来说，系统的查询会是写的很多倍，所以 LSM 树在写入方面的优异表现也没有办法让它成为 MongoDB 默认的数据格式。</p><p><strong>解释</strong>：在&quot;无限制写&quot;的情况下，数据可以随时写入，没有任何限制。这种方式下，如果有大量的写入请求，那么写入性能会成为系统的瓶颈。在这种情况下，LSM树的写入性能通常会优于B树。</p><p>而&quot;限制写&quot;是指对数据写入进行一定的限制，这可能是通过限制写入速度或者限制同时写入的数据量等方式来实现的。在这种情况下，因为写入被限制，所以读取性能会变得更重要。在这种情况下，B树的读取性能通常会优于LSM树。</p><p><strong>总结</strong></p><p>应用场景永远都是系统设计时首先需要考虑的问题，作为 NoSQL 的 MongoDB，其目标场景就与更早的数据库就有着比较大的差异，我们来简单总结一下 MongoDB 最终选择使用 B 树的两个原因：</p><ul><li>MySQL 使用 B+ 树是因为数据的遍历在关系型数据库中非常常见，它经常需要处理各个表之间的关系并通过范围查询一些数据；但是 MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式，所以选择了查询单个文档性能较好的 B 树，这个选择对遍历数据的查询也可以保证可以接受的时延；</li><li>LSM 树是一种专门用来优化写入的数据结构，它将随机写变成了顺序写显著地提高了写入性能，但是却牺牲了读的效率，这与大多数场景需要的特点是不匹配的，所以 MongoDB 最终还是选择读取性能更好的 B 树作为默认的数据结构；</li></ul><h2 id="MongoDB-聚合">MongoDB 聚合</h2><h3 id="MongoDB-聚合有什么用？">MongoDB 聚合有什么用？</h3><p>实际项目中，我们经常需要将多个文档甚至是多个集合汇总到一起计算分析（比如求和、取最大值）并返回计算后的结果，这个过程被称为 <strong>聚合操作</strong> 。</p><p>根据官方文档介绍，我们可以使用聚合操作来：</p><ul><li>将来自多个文档的值组合在一起。</li><li>对集合中的数据进行的一系列运算。</li><li>分析数据随时间的变化。</li></ul><h3 id="MongoDB-提供了哪几种执行聚合的方法？">MongoDB 提供了哪几种执行聚合的方法？</h3><p>MongoDB 提供了两种执行聚合的方法：</p><ul><li><strong>聚合管道（Aggregation Pipeline）</strong> ：执行聚合操作的首选方法。</li><li><strong>单一目的聚合方法（Single purpose aggregation methods）</strong> ：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li></ul><p>绝大部分文章中还提到了 <strong>map-reduce 这种聚合方法</strong>。不过，从 <strong>MongoDB 5.0</strong> 开始，map-reduce 已经不被官方推荐使用了，替代方案是 聚合管道。聚合管道提供比 map-reduce 更好的性能和可用性。</p><p>MongoDB 聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。</p><p>每个管道的工作流程是：</p><ol><li>接受一系列原始数据文档</li><li>对这些文档进行一系列运算</li><li>结果文档输出给下一个阶段</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602165207382.png" alt="image-20240602165207382"></p><p>常用阶段操作符 ：</p><table><thead><tr><th>操作符</th><th>简述</th></tr></thead><tbody><tr><td>$match</td><td>匹配操作符，用于对文档集合进行筛选</td></tr><tr><td>$project</td><td>投射操作符，用于重构每一个文档的字段，可以提取字段，重命名字段，甚至可以对原有字段进行操作后新增字段</td></tr><tr><td>$sort</td><td>排序操作符，用于根据一个或多个字段对文档进行排序</td></tr><tr><td>$limit</td><td>限制操作符，用于限制返回文档的数量</td></tr><tr><td>$skip</td><td>跳过操作符，用于跳过指定数量的文档</td></tr><tr><td>$count</td><td>统计操作符，用于统计文档的数量</td></tr><tr><td>$group</td><td>分组操作符，用于对文档集合进行分组</td></tr><tr><td>$unwind</td><td>拆分操作符，用于将数组中的每一个值拆分为单独的文档</td></tr><tr><td>$lookup</td><td>连接操作符，用于连接同一个数据库中另一个集合，并获取指定的文档，类似于 populate</td></tr></tbody></table><p>更多操作符介绍详见官方文档：<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/">https://docs.mongodb.com/manual/reference/operator/aggregation/</a></p><p>阶段操作符用于 <code>db.collection.aggregate</code> 方法里面，数组参数中的第一层。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate( [ &#123; 阶段操作符：表述 &#125;, &#123; 阶段操作符：表述 &#125;, ... ] )</span><br></pre></td></tr></table></figure><p>下面是 MongoDB 官方文档中的一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.orders.<span class="title function_ invoke__">aggregate</span>([</span><br><span class="line">   # 第一阶段：<span class="variable">$match</span>阶段按status字段过滤文档，并将status等于<span class="string">&quot;A&quot;</span>的文档传递到下一阶段。</span><br><span class="line">    &#123; <span class="variable">$match</span>: &#123; <span class="attr">status</span>: <span class="string">&quot;A&quot;</span> &#125; &#125;,</span><br><span class="line">  # 第二阶段：<span class="variable">$group</span>阶段按cust_id字段将文档分组，以计算每个cust_id唯一值的金额总和。</span><br><span class="line">    &#123; <span class="variable">$group</span>: &#123; <span class="attr">_id</span>: <span class="string">&quot;<span class="subst">$cust_id</span>&quot;</span>, <span class="attr">total</span>: &#123; <span class="variable">$sum</span>: <span class="string">&quot;<span class="subst">$amount</span>&quot;</span> &#125; &#125; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="MongoDB-事务">MongoDB 事务</h2><ul><li><a href="https://mongoing.com/archives/82187">技术干货| MongoDB 事务原理</a></li><li><a href="https://developer.aliyun.com/article/782494">MongoDB 一致性模型设计与实现</a></li><li><a href="https://www.mongodb.com/docs/upcoming/core/transactions/">MongoDB 官方文档对事务的介绍</a></li></ul><p>我们在介绍 NoSQL 数据的时候也说过，NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。</p><p>与关系型数据库一样，MongoDB 事务同样具有 ACID 特性：</p><ul><li>原子性（<code>Atomicity</code>） ：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>隔离性（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。WiredTiger 存储引擎支持读未提交（ read-uncommitted ）、读已提交（ read-committed ）和快照（ snapshot ）隔离，MongoDB 启动时默认选快照隔离。在不同隔离级别下，一个事务的生命周期内，可能出现脏读、不可重复读、幻读等现象。</li><li>持久性（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p>MongoDB 单文档原生支持原子性，也具备事务的特性。当谈论 MongoDB 事务的时候，通常指的是 多文档 。MongoDB 4.0 加入了对多文档 ACID 事务的支持，但只支持复制集部署模式下的 ACID 事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了 分布式事务 ，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</p><p>根据官方文档介绍：</p><blockquote><p>从 MongoDB 4.2 开始，分布式事务和多文档事务在 MongoDB 中是一个意思。分布式事务是指分片集群和副本集上的多文档事务。从 MongoDB 4.2 开始，多文档事务（无论是在分片集群还是副本集上）也称为分布式事务。</p></blockquote><p>在大多数情况下，多文档事务比单文档写入会产生更大的性能成本。对于大部分场景来说， 非规范化数据模型（嵌入式文档和数组） 依然是最佳选择。也就是说，适当地对数据进行建模可以最大限度地减少对多文档事务的需求。</p><p>注意 ：</p><ul><li>从MongoDB 4.2开始，多文档事务支持副本集和分片集群，其中：主节点使用WiredTiger存储引擎，同时从节点使用WiredTiger存储引擎或In-Memory存储引擎。在MongoDB 4.0中，只有使用WiredTiger存储引擎的副本集支持事务。</li><li>在MongoDB 4.2及更早版本中，你无法在事务中创建集合。从 MongoDB 4.4 开始，您可以在事务中创建集合和索引。有关详细信息，请参阅 在事务中创建集合和索引。</li></ul><h2 id="MongoDB-数据压缩">MongoDB 数据压缩</h2><p>借助 WiredTiger 存储引擎（ MongoDB 3.2 后的默认存储引擎），MongoDB 支持对所有集合和索引进行压缩。压缩以额外的 CPU 为代价最大限度地减少存储使用。</p><p>默认情况下，WiredTiger 使用 Snappy 压缩算法（谷歌开源，旨在实现非常高的速度和合理的压缩，压缩比 3 ～ 5 倍）对所有集合使用块压缩，对所有索引使用前缀压缩。</p><p>除了 Snappy 之外，对于集合还有下面这些压缩算法：</p><ul><li>zlib：高度压缩算法，压缩比 5 ～ 7 倍</li><li>Zstandard（简称 zstd）：Facebook 开源的一种快速无损压缩算法，针对 zlib 级别的实时压缩场景和更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li></ul><p>WiredTiger 日志也会被压缩，默认使用的也是 Snappy 压缩算法。如果日志记录小于或等于 128 字节，WiredTiger 不会压缩该记录。</p><h2 id="MongoDB-索引">MongoDB 索引</h2><h3 id="MongoDB-索引有什么用">MongoDB 索引有什么用?</h3><p>和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 <strong>集合扫描</strong> ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。</p><p>虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。</p><h3 id="MongoDB-支持哪些类型的索引？">MongoDB 支持哪些类型的索引？</h3><p><strong>MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</strong></p><ul><li><strong>单字段索引</strong>： 建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB 可以头/尾开始遍历。</li><li><strong>复合索引</strong>： 建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li><li><strong>多键索引</strong> ：MongoDB 的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li><li><strong>哈希索引</strong> ：按数据的哈希值索引，用在哈希分片集群上。</li><li><strong>文本索引</strong>： 支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li><li><strong>地理位置索引</strong>： 基于经纬度的索引，适合 2D 和 3D 的位置查询。</li><li><strong>唯一索引</strong> ：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li><li><strong>TTL 索引</strong> ：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。</li><li>…</li></ul><h3 id="复合索引中字段的顺序有影响吗？">复合索引中字段的顺序有影响吗？</h3><p>复合索引中字段的顺序非常重要，例如下图中的复合索引由<code>&#123;userid:1, score:-1&#125;</code>组成，则该复合索引首先按照<code>userid</code>升序排序；然后再每个<code>userid</code>的值内，再按照<code>score</code>降序排序。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602170041591.png" alt="image-20240602170041591"></p><p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。</p><p>走复合索引的排序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;userid&quot;</span>: <span class="number">1</span>, <span class="string">&quot;score&quot;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;userid&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;score&quot;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>不走复合索引的排序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;userid&quot;</span>: <span class="number">1</span>, <span class="string">&quot;score&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;userid&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;score&quot;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;score&quot;</span>: <span class="number">1</span>, <span class="string">&quot;userid&quot;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;score&quot;</span>: <span class="number">1</span>, <span class="string">&quot;userid&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;score&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;userid&quot;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;score&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;userid&quot;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>我们可以通过 explain 进行分析：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.s2</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="string">&quot;score&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;userid&quot;</span>: <span class="number">1</span>&#125;)<span class="selector-class">.explain</span>()</span><br></pre></td></tr></table></figure><h3 id="复合索引遵循左前缀原则吗？">复合索引遵循左前缀原则吗？</h3><p>MongoDB 的复合索引遵循左前缀原则 ：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 <code>&#123;a: 1, b: 1, c: 1, ..., z: 1&#125;</code> 这样的索引，那么实际上也等于有了 <code>&#123;a: 1&#125;</code>、<code>&#123;a: 1, b: 1&#125;</code>、<code>&#123;a: 1, b: 1, c: 1&#125;</code> 等一系列索引，但是不会有 <code>&#123;b: 1&#125;</code> 这样的非左前缀的索引。</p><h3 id="什么是-TTL-索引？">什么是 TTL 索引？</h3><p>TTL 索引提供了一个过期机制，<strong>允许为每一个文档设置一个过期时间</strong> <code>expireAfterSeconds</code> ，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p><p>数据过期对于某些类型的信息很有用，比如<strong>机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</strong></p><p><strong>TTL 索引运行原理</strong>：</p><ul><li>MongoDB 会开启一个后台线程读取该 TTL 索引的值来判断文档是否过期，但不会保证已过期的数据会立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li><li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除是由主库删除后产生的 oplog 来做同步。</li></ul><p><strong>TTL 索引限制</strong> ：</p><ul><li>TTL 索引是单字段索引。复合索引不支持 TTL。</li><li><code>_id</code>字段不支持 TTL 索引。</li><li>无法在上限集合(Capped Collection)上创建 TTL 索引，因为 MongoDB 无法从上限集合中删除文档。</li><li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li></ul><h3 id="什么是覆盖索引查询？">什么是覆盖索引查询？</h3><p>根据官方文档介绍，覆盖查询是以下的查询：</p><ul><li>所有的查询字段是索引的一部分。</li><li>结果中返回的所有字段都在同一索引中。</li><li>查询中没有字段等于<code>null</code>。</li></ul><p>由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。因为索引存在于内存中，从索引中获取数据比通过扫描文档读取数据要快得多。</p><p>举个例子：我们有如下 <code>users</code> 集合:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;_id&quot;</span>: ObjectId(<span class="string">&quot;53402597d852426020000002&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">   <span class="string">&quot;contact&quot;</span>: <span class="string">&quot;987654321&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="string">&quot;dob&quot;</span>: <span class="string">&quot;01-01-1991&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom Benzamin&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;tombenzamin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>users</code> 集合中创建联合索引，字段为 <code>gender</code> 和 <code>user_name</code> :</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">db</span>.users.ensureIndex(&#123;gender:<span class="number">1</span>,user_name:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>现在，该索引会覆盖以下查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.<span class="title function_ invoke__">find</span>(&#123;<span class="attr">gender</span>:<span class="string">&quot;M&quot;</span>&#125;,&#123;<span class="attr">user_name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><p>为了让指定的索引覆盖查询，必须显式地指定 <code>_id: 0</code> 来从结果中排除 <code>_id</code> 字段，因为索引不包括 <code>_id</code> 字段。</p><h2 id="MongoDB-高可用">MongoDB 高可用</h2><h3 id="复制集群">复制集群</h3><h4 id="什么是复制集群？">什么是复制集群？</h4><p>MongoDB 的复制集群又称为<strong>副本集群</strong>，<strong>是一组维护相同数据集合的 mongod 进程</strong>。</p><p><strong>客户端连接到整个 Mongodb 复制集群，主节点机负责整个复制集群的写，从节点可以进行读操作，但默认还是主节点负责整个复制集群的读</strong>。主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p><p>通常来说，<strong>一个复制集群包含 1 个主节点（Primary），多个从节点（Secondary）以及零个或 1 个仲裁节点（Arbiter）。</strong></p><ul><li>主节点 ：整个集群的写操作入口，接收所有的写操作，并将集合所有的变化记录到操作日志中，即 oplog。主节点挂掉之后会自动选出新的主节点。</li><li>从节点 ：从主节点同步数据，在主节点挂掉之后选举新节点。不过，从节点可以配置成 0 优先级，阻止它在选举中成为主节点。</li><li>仲裁节点 ：这个是为了节约资源或者多机房容灾用，只负责主节点选举时投票不存数据，保证能有节点获得多数赞成票。</li></ul><p>下图是一个典型的三成员副本集群：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602170958257.png" alt="image-20240602170958257"></p><p>主节点与备节点之间是通过 oplog（操作日志） 来同步数据的。oplog 是 local 库下的一个特殊的 上限集合(Capped Collection) ，用来保存写操作所产生的增量日志，类似于 MySQL 中 的 Binlog。</p><blockquote><p>上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I/O 速度非常快，如果不建立索引，性能更好。</p></blockquote><p><strong>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</strong></p><p>副本集最多有一个主节点。如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p><h4 id="为什么要用复制集群？">为什么要用复制集群？</h4><ul><li>实现 failover ：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li><li>实现读写分离 ：我们可以设置从节点上可以读取数据，主节点负责写入数据，这样的话就实现了读写分离，减轻了主节点读写压力过大的问题。MongoDB 4.0 之前版本如果主库压力不大,不建议读写分离，因为写会阻塞读，除非业务对响应时间不是非常关注以及读取历史数据接受一定时间延迟。</li></ul><h3 id="分片集群">分片集群</h3><h4 id="什么是分片集群？">什么是分片集群？</h4><p>分片集群是 MongoDB 的分布式版本，相较副本集，分片集群数据被均衡的分布在不同分片中， 不仅大幅提升了整个集群的数据容量上限，也将读写的压力分散到不同分片，以解决副本集性能瓶颈的难题。</p><p>MongoDB 的分片集群由如下三个部分组成</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602171729227.png" alt="image-20240602171729227"></p><ul><li>Config Servers：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</li><li>Mongos：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</li><li>Shard：每个分片是整体数据的一部分子集，从MongoDB3.6版本开始，每个Shard必须部署为副本集（replica set）架构</li></ul><p><strong>解释：</strong></p><p>首先，分片集群主要由三个部分组成：Config Servers，Mongos和Shard。</p><ol><li>Config Servers：它们是配置服务器，负责存储集群的元数据和配置信息。比如说，你的数据库里有哪些数据，这些数据该如何分布在不同的Shard上，这些信息都是由Config Servers来保存的。可以把它们看作是一本详尽的目录，帮助我们知道去哪里查找或者存储数据。</li><li>Mongos：它是路由服务，它的主要职能就是把客户端的请求转发到对应的Shard上。比如说，<strong>你想要查询某个数据，这个请求首先会被发送到Mongos，Mongos会查阅Config Servers的信息，找到这个数据存储在哪个Shard上，然后把请求转发到那个Shard</strong>。Mongos本身不存储数据，它只是起到一个信息中转站的作用。</li><li>Shard：它们是真正存储数据的地方。每个Shard存储数据库的一部分数据。这样，当数据量非常大的时候，我们可以把数据分布在多个Shard上，这样不仅可以提高数据的读写速度，还能有效地利用多台服务器的存储空间。</li></ol><p>举个例子，假设你正在管理一个图书馆，那么Config Servers就像是图书馆的图书目录，记录了每本书在哪个书架上；Mongos就像是图书馆的管理员，当读者想要找一本书的时候，管理员会查阅目录，然后告诉读者这本书在哪个书架上；而Shard就像是图书馆的书架，真正存储了这些书。</p><h4 id="为什么要用分片集群？">为什么要用分片集群？</h4><p>随着系统数据量以及吞吐量的增长，常见的解决办法有两种：垂直扩展和水平扩展。</p><p>垂直扩展通过增加单个服务器的能力来实现，比如磁盘空间、内存容量、CPU 数量等；水平扩展则通过将数据存储到多个服务器上来实现，根据需要添加额外的服务器以增加容量。</p><p>类似于 Redis Cluster，MongoDB 也可以通过分片实现 水平扩展 。水平扩展这种方式更灵活，可以满足更大数据量的存储需求，支持更高吞吐量。并且，水平扩展所需的整体成本更低，仅仅需要相对较低配置的单机服务器即可，代价是增加了部署的基础设施和维护的复杂性。</p><p>也就是说当你遇到如下问题时，可以使用分片集群解决：</p><ul><li>存储容量受单机限制，即磁盘资源遭遇瓶颈。</li><li>读写能力受单机限制，可能是 CPU、内存或者网卡等资源遭遇瓶颈，导致读写能力无法扩展。</li></ul><p><strong>举例：</strong></p><p>垂直扩展和水平扩展是处理大数据的两种常见解决方案。我来通俗易懂地解释一下这两种扩展方式。</p><ol><li>垂直扩展：这就好比是把一台车加装更大的引擎、更宽敞的储物空间，或者更舒适的座椅来提高它的性能。在计算机世界里，垂直扩展就是通过提升单台服务器的硬件性能来处理更多的数据，比如增加更大的硬盘、更多的内存、或者更强大的CPU。这种方式的优点是操作相对简单，只需要购买更好的硬件就行，但缺点是硬件的提升总是有上限的，比如CPU的速度或者硬盘的大小总是有个上限。</li><li>水平扩展：这就像是买更多的车来承载更多的人。在计算机世界里，水平扩展就是通过增加更多的服务器来共同处理数据。比如一个大型的网站，可以将用户的请求分发到多台服务器上处理，这样就可以处理更多的用户请求。水平扩展的优点是理论上可以无限扩展，只要有足够的资源，就可以一直添加服务器。但是，这种方式需要有合理的数据分片和负载均衡策略，否则可能会导致数据不一致或者某些服务器过载。</li></ol><p>举个例子，假设我们开一家快餐店。如果我们要提高服务能力，垂直扩展就好比是购买更快的炉子、更大的冰箱、更多的食材，这样我们可以更快地做出更多的食物。而水平扩展就好比是开更多的分店，每家分店都可以为客户提供服务，这样我们就可以服务更多的客户。</p><h4 id="什么是分片键？">什么是分片键？</h4><p>分片键（Shard Key） 是数据分区的前提， 从而实现数据分发到不同服务器上，减轻服务器的负担。也就是说，分片键决定了集合内的文档如何在集群的多个分片间的分布状况。</p><p>分片键就是文档里面的一个字段，但是这个字段不是普通的字段，有一定的要求：</p><ul><li>它必须在所有文档中都出现。</li><li>它必须是集合的一个索引，可以是单索引或复合索引的前缀索引，不能是多索引、文本索引或地理空间位置索引。</li><li>MongoDB 4.2 之前的版本，文档的分片键字段值不可变。MongoDB 4.2 版本开始，除非分片键字段是不可变的 <code>_id</code> 字段，否则您可以更新文档的分片键值。MongoDB 5.0 版本开始，实现了实时重新分片（live resharding），可以实现分片键的完全重新选择。</li><li>它的大小不能超过 512 字节。</li></ul><p><strong>解释</strong>：</p><p>分片键在MongoDB中起到了非常重要的作用。它是决定数据如何在分布式数据库系统中进行分布的关键。<strong>简单来说，就好比是一本厚厚的字典，我们是按照字母顺序来决定每个单词在哪一页的，那么这个“字母顺序”就相当于是分片键。</strong></p><p>以一个学生管理系统为例，如果我们把学生的学号设置为分片键，那么系统在存储学生信息的时候，就会根据学号的大小将数据分布到不同的服务器上。<strong>比如学号1-1000的学生信息存储在服务器A，学号1001-2000的学生信息存储在服务器B</strong>，以此类推。这样做的好处是，当我们想要查找某个学生的信息时，系统可以直接去对应的服务器上查找，大大提高了查询效率。</p><p>但是，分片键需要满足一些条件：</p><ol><li>它必须在所有文档中都出现。这是因为分片键是用来决定数据如何分布的，如果有的文档没有这个字段，那系统就无法决定把这个文档存储到哪里。</li><li>它必须是集合的一个索引，可以是单索引或复合索引的前缀索引。</li><li>分片键的大小不能超过512字节。</li></ol><p>这就是分片键的基本概念，希望对你有所帮助。</p><h4 id="如何选择分片键？">如何选择分片键？</h4><p>选择合适的片键对 sharding 效率影响很大，主要基于如下四个因素（摘自分片集群使用注意事项 - - 腾讯云文档）：</p><ul><li>取值基数 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。例如：选择年龄做一个基数，范围最多只有100个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li><li>取值分布 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li><li>查询带分片 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li><li>避免单调递增或递减 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li></ul><p>综上，在选择片键时要考虑以上4个条件，尽可能满足更多的条件，才能降低 MoveChuncks 对性能的影响，从而获得最优的性能体验。</p><h4 id="分片策略有哪些？">分片策略有哪些？</h4><p>MongoDB 支持两种分片算法来满足不同的查询需求（摘自MongoDB 分片集群介绍 - 阿里云文档）：</p><p>1、<strong>基于范围的分片</strong> ：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172751440.png" alt="image-20240602172751440"></p><p>MongoDB 按照分片键（Shard Key）的值的范围将数据拆分为不同的块（Chunk），每个块包含了一段范围内的数据。当分片键的基数大、频率低且值非单调变更时，范围分片更高效。</p><ul><li>优点：Mongos 可以快速定位请求需要的数据，并将请求转发到相应的 Shard 节点中。</li><li>缺点：可能导致数据在 Shard 节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li><li>适用场景：分片键的值不是单调递增或单调递减、分片键的值基数大且重复的频率低、需要范围查询等业务场景。</li></ul><p>2、<strong>基于 Hash 值的分片</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172837739.png" alt="image-20240602172837739"></p><p>MongoDB 计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块（Chunk）。</p><ul><li>优点：可以将数据更加均衡地分布在各 Shard 节点中，具备写分散性。</li><li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的 Shard 节点。</li><li>适用场景：分片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li></ul><p>除了上述两种分片策略，您还可以配置 复合片键 ，例如由一个低基数的键和一个单调递增的键组成。</p><h4 id="分片数据如何存储？">分片数据如何存储？</h4><p>Chunk（块） 是 MongoDB 分片集群的一个核心概念，其本质上就是由一组 Document 组成的逻辑数据单元。每个 Chunk 包含一定范围片键的数据，互不相交且并集为全部数据，即离散数学中划分的概念。</p><p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上一级这个 Chunk 包含哪些数据。</p><p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 Chunk 分裂。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172927951.png" alt="image-20240602172927951"></p><p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 均衡器(Balancer) 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 再平衡（Rebalance）。默认情况下，数据库和集合的 Rebalance 是开启的。</p><p>如下图所示，随着数据插入，导致 Chunk 分裂，让 AB 两个分片有 3 个 Chunk，C 分片只有一个，这个时候就会把 B 分配的迁移一个到 C 分片实现集群数据均衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172941546.png" alt="image-20240602172941546"></p><blockquote><p>Balancer 是 MongoDB 的一个运行在 Config Server 的 Primary 节点上(自 MongoDB 3.4 版本起)的后台进程，它监控每个分片上 Chunk 数量，并在某个分片上 Chunk 数量达到阈值进行迁移。</p></blockquote><p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p><p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p><p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p><p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p><h4 id="Chunk-迁移原理是什么？">Chunk 迁移原理是什么？</h4><p><strong>一、chunk简介</strong></p><p><strong>1.1 chunk是什么</strong></p><p>MongoDB在Sharding模式下（对于Sharding不了解的可以参考shard介绍），通过Mongos向开启了shard分片的集合写入文档，这些文档会根据其shardKey分散到MongoDB的不同shard上。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602174141898.png" alt="image-20240602174141898"></p><p>如上图，假设集合的shardKey x（以范围分片为例，哈希分片类似），写入该集合的文档根据其x的取值范围，会被分散到chunk1到chunk4中，每个chunk只包含特定范围的数据（比如chunk2就只包含x的取值在[-75, 25)范围内的文档），同一chunk的文档只会存储在一个shard上，一个shard可能包含多个chunk，chunk具体存储在哪个shard，由记录在config server中的路由信息决定。</p><p><strong>1.2 chunk分裂</strong></p><p>默认情况下，一个chunk的最大值默认为64MB（可调整），进行数据插入、更新、删除时，如果此时mongos感知到了目标chunk的大小超过上限，则会触发chunk分裂。chunk分裂动作为逻辑上的概念，它会对需要分裂的chunk进行分段，指定split point标记切割的位置</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602174158563.png" alt="image-20240602174158563"></p><p><strong>解释：</strong></p><p>例如，假设我们的分片键是学号，一个Chunk中存储了学号1-1000的学生信息，但是这个Chunk已经满了。这时，如果我们要插入更多的学生信息，系统就会选择一个分裂点，例如500，然后将学号501-1000的学生信息移动到新的Chunk，原来的Chunk就只存储学号1-500的学生信息了。</p><p>这样，我们就可以继续向数据库插入新的数据，而不需要担心存储空间不足的问题。同时，通过合理的分裂点选择，我们也可以保证数据在Chunk之间的均衡分布，提高查询效率。</p><p><strong>1.3 chunk的迁移</strong></p><p>MongoDB默认情况下会开启一个balancer模块用于定期检测各个shard上的chunk数量分布，当检测到各个shard上的chunk数量存在分布不均匀的情况时，就会触发chunk迁移。如下图，三个shard的chunk数量分别为3、3、1，此时balancer认为chunk数量分布不均，于是会将shard B上的chunk迁移一个到shard C上，这样三个shard的chunk数量分布最终就会变为3、2、2，分布更为均匀。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602174214629.png" alt="image-20240602174214629"></p><p>上文提到的balancer通过特定规则来筛选出来需要进行迁移的chunk，这些规则具体是什么呢？当前，mongoDB会对以下三种类型的chunk进行迁移（优先级由高到底）：</p><ul><li>chunk属于正在进行排水（即draining，一般出现在shard删除，move primary等情况下，表示该chunk需要尽快被删除）的shard</li><li>chunk是否违反了zones的约束（zones的定义见此）</li><li>如果不属于以上两种情况，则通过计算各个shard之间的chunks数量进行负载均衡，原则上balancer会让各个shard在满足zones约束的条件下尽可能均衡</li></ul><p>选定了需要迁移的chunk后，balancer会选择当前shards中chunks数最少的一个作为迁移的目标。</p><p><strong>chunk迁移原理</strong></p><p>chunk迁移操作通过moveChunk命令发起，moveChunk命令即可以被balancer自动调用（balancer每隔10s扫描哪些chunk需要被迁移），也支持用户主动发起。迁移chunk的整个过程实际上就是一次两个shard进行数据交换的过程，发送chunk的一方称为发送方（donorShard），接收chunk的一方称为接收方（recipientShard）。发送方和接收方通过一系列精心设计的步骤来实现chunk的迁移。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602174250750.png" alt="image-20240602174250750"></p><p>完成一次chunk迁移需要进行以下7个步骤：1）发送方发起迁移: configsvr向发送方请求进行指定chunk的迁移任务（同一时刻只能执行一个chunk迁移）。如果此时发现已有一个相同的chunk的迁移任务，跳过此次迁移，否则会新发起一个迁移任务。</p><p>2）接收方发起chunk拷贝: 发送方进行迁移参数的校验，校验通过后，向接收方发送recvChunkStart命令，接收方进行一些传送文档数据的初始化工作后，会不断重复地向发送方发送migrateClone命令批量拉取chunk中的文档并将拉取的文档进行批量插入，即进行文档的全量拷贝。</p><p>3）接收方拉取增量修改: 文档全量拷贝完成后，接收方通过不断重复发送transferMods命令拉取chunk的增量修改（包括插入、更新、删除），并将其应用到自身。</p><p>4）发送方等待接收方chunk拷贝完成: 发送方不断向接收方发送recvChunkStatus命令查询文档增量同步是否完成或超时，当增量同步完成时，表示此时接受方已进入“steady”状态，可以进行接下来的流程。</p><p>5）发送方进入临界区: 一旦当接收方的文档数据同步完成，发送方就会进入临界区(critical section)，此时发送方接下来的操作不可被打断，并且所有发送方的写操作将被挂起，直到发送方退出临界区。</p><p>6）接收方执行commit: 发送方进入临界区后，接下来会同步地调用recvChunkCommit命令给接收方，接收方再一次进行chunk文档的增量同步，同步完成后，向接收方返回同步完成的结果，接收方退出临界区。</p><p>7）configsvr执行commit: 接收方收到同步完成的结果后，向configsvr发送configsvrCommitChunkMigration命令，表示迁移完成。（configsvrCommitChunkMigration命令返回前，发送方的读操作会被挂起）</p><p>以上便为MongoDB进行chunk迁移的基本步骤，在下一节我们将会从源码层面对迁移流程的每一阶段代码做详细解读。</p><p>想看源码的点击下面网址详细查看！</p><p>转载自：<a href="https://mp.weixin.qq.com/s/JCbkayq07H34RMs8sUmKEA">万字详解，吃透 MongoDB！</a></p>]]></content>
    
    
    <summary type="html">万字详解，吃透 MongoDB！</summary>
    
    
    
    <category term="数据库" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
