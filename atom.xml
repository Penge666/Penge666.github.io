<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-08-06T15:45:14.397Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Glibc-ptmalloc</title>
    <link href="https://penge666.github.io/posts/3707fe10.html"/>
    <id>https://penge666.github.io/posts/3707fe10.html</id>
    <published>2024-08-06T15:25:18.000Z</published>
    <updated>2024-08-06T15:45:14.397Z</updated>
    
    <content type="html"><![CDATA[<p>在Unix和类Unix系统中，glibc（GNU C Library）扮演着至关重要的角色。它作为系统调用和库函数的桥梁，使得程序员能够方便地利用底层系统资源。<code>ptmalloc</code> 是 <code>malloc</code> 在 GNU C Library（glibc）中的一个具体实现。</p><p><strong>32</strong> <strong>位模式下进程内存经典布局</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806233656259.png" alt="image-20240806233656259"></p><p>着重关注两个区：<strong>heap</strong>（堆区） <strong>memory mapping</strong>（内存映射区）</p><ul><li><p>brk函数其实就是在heap分配空间，在ptmalloc的设计中有start_brk和brk两个标志，他们两个的差值标记着堆区的大小。一开始这两个值是相同的，但是随着ptmalloc去调用brk函数，brk标记不断向高地址区域偏移，标记着heap堆区被分配出去了。</p></li><li><p>mmap函数则是在memory mapping区域分配空间，memory mapping区域除了我们常知道的映射动态库对象或者文件，其空间还可以被mmap映射至物理内存。</p></li></ul><h2 id="分配区">分配区</h2><p>在 Doug Lea 实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在 SMP 多线程环境下，对主分配区的锁的争用很激烈，严重影响了 malloc 的分配效率。<strong>于是 Wolfram Gloger 在 Doug Lea 的基础上改进使得Glibc 的 malloc 可以支持多线程，增加了非主分配区（non main arena）支持，主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</strong>【有点分段锁的味道】</p><p>每个进程只有一个主分配区，但可能存在多个非主分配区，ptmalloc 根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。**主分配区可以访问进程的 heap 区域和 mmap 映射区域，也就是说主分配区可以使用 sbrk 和 mmap向操作系统申请虚拟内存。而非主分配区只能访问进程的 mmap 映射区域，非主分配区每次使用 mmap()向操作系统“发”HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统默认为 64MB）大小的虚拟内存，**当用户向非主分配区请求分配内存时再切割成小块“零售”出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap()函数向操作系统申请虚拟内存。</p><p>主分配区可以访问 heap 区域，如果用户不调用 brk()或是 sbrk()函数，分配程序就可以保证分配到连续的虚拟地址空间，因为每个进程只有一个主分配区使用 sbrk()分配 heap 区域的虚拟内存。内核对 brk 的实现可以看着是 mmap 的一个精简版，相对高效一些。如果主分配区的内存是通过 mmap()向系统分配的，当 free 该内存时，主分配区会直接调用 munmap()将该内存归还给系统。</p><p>**当某一线程需要调用 malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。**在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。申请小块内存时会产生很多内存碎片，ptmalloc 在整理时也需要对分配区做加锁操作。每个加锁操作大概需要 5～10 个 cpu 指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致 malloc 性能下降。一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc在多线程竞争情况下性能远远落后于 tcmalloc。最新版的 ptmalloc 对锁进行了优化，加入了PER_THREAD 和 ATOMIC_FASTBINS 优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。</p><p><strong>代码角度理解</strong></p><p><strong>主分配区（Main Arena）</strong></p><p>主分配区是唯一的，它与进程的主线程相关联。主分配区使用进程的堆（heap）来分配内存，并且在进程启动时创建，始终存在。以下是主分配区的一些关键代码实现细节：</p><ol><li><p><strong><code>malloc_state</code> 结构体</strong>：</p><ul><li><p>这是主分配区的核心数据结构，包含了所有用于管理内存的字段，例如 <code>bins</code> 数组、<code>top</code> 指针（指向当前未分配的内存区域）、<code>last_remainder</code> 指针（指向最后一个分割的内存块）等。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    <span class="type">binmap_t</span> binmap;          <span class="comment">// 用于快速查找非空 bin 的位图</span></span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *last_remainder; <span class="comment">// 指向最后一个分割的内存块</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><p>主分配区通常是一个全局变量，例如在 <code>glibc</code> 中，主分配区可以通过 <code>main_arena</code> 变量访问。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> malloc_state main_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化</strong>：</p><ul><li><p>主分配区在进程启动时初始化，通常在 <code>ptmalloc</code> 的初始化函数中完成。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ptmalloc_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化主分配区</span></span><br><span class="line">    <span class="built_in">init_arena</span>(&amp;main_arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>从分配区（Thread Arena）</strong></p><p>从分配区是为每个线程独立创建的分配区，它允许线程独立地管理内存，从而减少锁竞争，提高并发性能。以下是从分配区的一些关键代码实现细节：</p><ol><li><p><strong>线程局部存储（Thread Local Storage, TLS）</strong>：</p><ul><li><p>每个线程可以通过线程局部存储（TLS）来访问自己的分配区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread malloc_state *thread_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>创建从分配区</strong>：</p><ul><li><p>当一个线程第一次调用 <code>malloc</code> 时，如果还没有分配区，<code>ptmalloc</code> 会为该线程创建一个新的从分配区。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> malloc_state *<span class="title">arena_get</span><span class="params">(mstate *ar_ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *a;</span><br><span class="line">    <span class="comment">// 尝试获取现有的分配区或创建新的分配区</span></span><br><span class="line">    a = <span class="built_in">get_free_list</span>(); <span class="comment">// 从空闲列表中获取分配区</span></span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        a = _int_new_arena(size); <span class="comment">// 创建新的分配区</span></span><br><span class="line">    &#125;</span><br><span class="line">    *ar_ptr = a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配和释放</strong>：</p><ul><li><p>当线程请求内存时，<code>ptmalloc</code> 会从相应的分配区中查找合适的内存块。如果找到合适的内存块，则将其从 <code>bins</code> 中移除并返回给调用者。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line">    <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="built_in">arena_get</span>(&amp;ar_ptr, size);</span><br><span class="line">    <span class="comment">// 从分配区中查找合适的内存块</span></span><br><span class="line">    victim = _int_malloc(ar_ptr, size);</span><br><span class="line">    <span class="keyword">if</span> (!victim) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些代码片段，可以看到主分配区和从分配区的基本结构和操作。</p><h2 id="关键数据结构">关键数据结构</h2><p>在 <code>ptmalloc</code> 内存分配器中，<code>unsorted bin</code>、<code>Fast Bins</code>、<code>top chunk</code>、<code>bins</code> 和 <code>mmaped chunk</code> 是用于管理内存块的关键数据结构。它们之间的关系和作用如下：</p><ol><li><code>unsorted bin</code></li></ol><p><code>unsorted bin</code> 是一个双向链表，用于临时存储最近释放的内存块。这些内存块在下次分配请求时会被重新整理并放入相应的 <code>bins</code> 中。</p><ol start="2"><li><code>Fast Bins</code></li></ol><p><code>Fast Bins</code> 是一个单链表数组，用于存储较小的空闲内存块（通常小于64或128字节）。<code>Fast Bins</code> 中的内存块不会被合并，这样可以快速地进行分配和释放。</p><ol start="3"><li><code>top chunk</code></li></ol><p><code>top chunk</code> 是分配区中未分配的内存区域。当 <code>bins</code> 中没有合适的内存块时，<code>ptmalloc</code> 会从 <code>top chunk</code> 中分割出所需的内存块。</p><ol start="4"><li><code>bins</code></li></ol><p><code>bins</code> 是一个双向链表数组，用于存储具有相同大小的空闲内存块。<code>bins</code> 分为 <code>small bins</code> 和 <code>large bins</code>，分别用于存储较小的和较大的内存块。</p><ol start="5"><li><code>mmaped chunk</code></li></ol><p><code>mmaped chunk</code> 是通过 <code>mmap</code> 系统调用分配的内存块。当请求的内存大小超过某个阈值时，<code>ptmalloc</code> 会使用 <code>mmap</code> 来分配内存，而不是从堆中分配。</p><p><strong>代码解读</strong></p><p>以下是一个简化的代码示例，展示了这些数据结构之间的关系和作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> prev_size;  <span class="comment">// 前一个内存块的大小</span></span><br><span class="line">    <span class="type">size_t</span> size;       <span class="comment">// 当前内存块的大小</span></span><br><span class="line">    malloc_chunk *fd;  <span class="comment">// 指向链表中下一个内存块</span></span><br><span class="line">    malloc_chunk *bk;  <span class="comment">// 指向链表中前一个内存块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *fastbinsY[NFASTBINS]; <span class="comment">// Fast Bins 数组</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *ar_ptr = <span class="built_in">get_arena</span>(); <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="type">size_t</span> nb = <span class="built_in">request2size</span>(size);     <span class="comment">// 将请求的大小转换为实际分配的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 Fast Bins 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt;= <span class="built_in">get_max_fast</span>()) &#123;</span><br><span class="line">        idx = <span class="built_in">fastbin_index</span>(nb);</span><br><span class="line">        fb = &amp;fastbinsY[idx];</span><br><span class="line">        victim = *fb;</span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 unsorted bin 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unsorted_chunks</span>(ar_ptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        victim = <span class="built_in">unsorted_chunks</span>(ar_ptr);</span><br><span class="line">        <span class="built_in">unsorted_chunks</span>(ar_ptr) = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (victim-&gt;size == nb) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 bins 中分配内存</span></span><br><span class="line">    idx = <span class="built_in">bin_index</span>(nb);</span><br><span class="line">    bin = <span class="built_in">bin_at</span>(ar_ptr, idx);</span><br><span class="line">    victim = <span class="built_in">first</span>(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin) &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(victim, bk, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 top chunk 中分配内存</span></span><br><span class="line">    victim = ar_ptr-&gt;top;</span><br><span class="line">    size = <span class="built_in">chunksize</span>(victim);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">        ar_ptr-&gt;top = remainder;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 mmap 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &amp; MMAP_THRESHOLD) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, nb, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>获取分配区</strong>：<ul><li><code>get_arena()</code> 函数获取当前线程的分配区。</li></ul></li><li><strong>Fast Bins</strong>：<ul><li>如果请求的大小小于 <code>get_max_fast()</code> 返回的值，尝试从 <code>Fast Bins</code> 中分配内存。</li><li><code>fastbin_index(nb)</code> 计算 <code>Fast Bins</code> 的索引，<code>fastbinsY[idx]</code> 获取相应的 <code>Fast Bin</code>。</li><li>如果找到合适的内存块，将其从 <code>Fast Bin</code> 中移除并返回。</li></ul></li><li><strong>unsorted bin</strong>：<ul><li>如果 <code>unsorted bin</code> 不为空，尝试从中分配内存。</li><li>如果找到合适大小的内存块，直接返回。</li></ul></li><li><strong>bins</strong>：<ul><li>计算请求大小的 <code>bin</code> 索引，尝试从相应的 <code>bin</code> 中分配内存。</li><li>如果找到合适的内存块，将其从 <code>bin</code> 中移除并返回。</li></ul></li><li><strong>top chunk</strong>：<ul><li>如果 <code>top chunk</code> 的大小足够，从 <code>top chunk</code> 中分割出所需的内存块，并更新 <code>top chunk</code> 的指针。</li></ul></li><li><strong>mmaped chunk</strong>：<ul><li>如果请求的大小超过某个阈值，使用 <code>mmap</code> 系统调用分配内存。</li></ul></li></ol><h2 id="分配释放策略">分配释放策略</h2><p><strong>ptmalloc 的分配策略</strong></p><ul><li>获取分配区锁，加锁成功则使用该分配区分配内存，否则就遍历分配区的环形链表。如果链表中没有空闲的，就开辟一个新的分配区，把其加入线程私有实例并且加入到环形链表。</li><li>将用户请求的字节向上对齐到bins中的最近字节。</li><li>如果小于64B就在fast bin中分配内存，如果大于再去判断是否小于512B，如果小于就去small bin中分配大小，如果大于就说明此时分配的是大内存。</li><li>首先会将fast bin中的chunk进行合并，然后链接至unsorted bin，再将其链接到相应的bin中。</li><li>然后去large bins中进行寻找，如果够用结束，不够下一步。</li><li>这个时候就需要判断top chunk是否够用，不够用下一步。</li><li>有两种选择，判断分配的字节大小是否大于等于mmap分配阈值，如果小于根据分配区去选择brk还是mmap去增加top chunk的大小；如果大于就直接调用mmap去映射。</li></ul><p><strong>ptmalloc 的释放策略</strong></p><ul><li>获取分配区的锁</li><li>判断free参数是否位nullptr，如果为nullptr则什么都不做</li><li>如果释放空间为mmaped chunk，直接使用munmap释放</li><li>如果size &lt; 64B且不和top chunk相邻，放入fast bin</li><li>判断前一个块是否空闲，空闲则合并</li><li>判断下一个是否空闲，空闲则合并放入unsorted bin，然后放入相应的bin中</li><li>判读合并后是否大于64kb，如果大于fast bin中chunk进行合并，放入unsorted bin，然后下一步。</li><li>判读top chunk是否大于128kb，如果大于就会归还给操作系统。注意：如果为非主分配区，就只会归还一部部分。</li></ul><p>学习自：glibc内存管理ptmalloc源代码分析</p>]]></content>
    
    
    <summary type="html">ptmalloc内存池</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议学习</title>
    <link href="https://penge666.github.io/posts/61c8c4f5.html"/>
    <id>https://penge666.github.io/posts/61c8c4f5.html</id>
    <published>2024-07-22T09:01:48.000Z</published>
    <updated>2024-07-22T09:34:54.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、QUIC-简介"><strong>1、QUIC 简介</strong></h3><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171232702.png" alt="image-20240722171232702"></p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h3 id="2、QUIC-实现原理"><strong>2、QUIC 实现原理</strong></h3><h4 id="2-1、数据格式"><strong>2.1、数据格式</strong></h4><p>一个 QUIC 数据包的格式如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171314750.png" alt="image-20240722171314750"></p><p>由 header 和 data 两部分组成。</p><p>header 是明文的，包含 4 个字段：Flags、Connection ID、QUIC Version、Packet Number；</p><p>data 是加密的，可以包含 1 个或多个 frame，每个 frame 又分为 type 和 payload，其中 payload 就是应用数据；</p><p>数据帧有很多类型：Stream、ACK、Padding、Window_Update、Blocked 等，这里重点介绍下用于传输应用数据的 Stream 帧。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171320083.png" alt="image-20240722171320083"></p><p><strong>Frame Type：</strong> 帧类型，占用 1 个字节</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171324906.png" alt="image-20240722171324906"></p><p>（1）Bit7：必须设置为 1，表示 Stream 帧</p><p>（2）Bit6：如果设置为 1，表示发送端在这个 stream 上已经结束发送数据，流将处于半关闭状态</p><p>（3）Bit5：如果设置为 1，表示 Stream 头中包含 Data length 字段</p><p>（4）Bit432：表示 offset 的长度。000 表示 0 字节，001 表示 2 字节，010 表示 3 字节，以此类推</p><p>（5）Bit10：表示 Stream ID 的长度。00 表示 1 字节，01 表示 2 字节，10 表示 3 字节，11 表示 4 字节</p><p><strong>Stream ID：</strong> 流 ID，用于标识数据包所属的流。后面的流量控制和多路复用会涉及到</p><p>**Offset：**偏移量，表示该数据包在整个数据中的偏移量，用于数据排序。</p><p><strong>Data Length：</strong> 数据长度，占用 2 个字节，表示实际应用数据的长度</p><p><strong>Data：</strong> 实际的应用数据</p><h4 id="2-2、建立连接"><strong>2.2、建立连接</strong></h4><p>先分析下 HTTPS 的握手过程，包含 TCP 握手和 TLS 握手，TCP 握手：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171428707.png" alt="image-20240722171428707"></p><p>从图中可以看出，TCP 握手需要 2 个 RTT。</p><p>TLS 握手：密钥协商（1.3 版本）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171450629.png" alt="image-20240722171450629"></p><p>从图中可以看出，TLS 握手需要 1 个 RTT，也就是 1 次 RTT 就把通信密钥协商好了，这是怎么做到的？</p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）服务器：生成随机数 b，计算 B=b*G%P，将 B 发送给客户端，也就是 Server Hello 消息</p><p>（3）客户端：使用 ECDH 算法生成通信密钥 KEY = a * B = a * b * G%P</p><p>（4）服务器：使用 ECDH 算法生成通信密钥 KEY = b * A = b * a * G%P</p><p>所以，这里的关键就是 ECDH 算法，a 和 b 是客户端和服务器的私钥，是不公开的，而其他参数是公开的。ECDH 算法有个非常重要的特征：即使知道 A、G、P，通过 A = a*G%P 公式也是无法推到出 a 的，保证了私钥的安全性。</p><p>综上所述，HTTPS 建立连接需要 3 个 RTT，由于 QUIC 的握手是基于 TLS1.3 实现的，所以首次建立连接时也是需要 1 次 RTT，那 QUIC 是如何做到 0-RTT 握手的呢？</p><h5 id="2-2-1、0-RTT-握手"><strong>2.2.1、0-RTT 握手</strong></h5><p>其实原理很简单：客户端缓存了 ServerConfig（B=b*G%P），下次建连直接使用缓存数据计算通信密钥：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171543971.png" alt="image-20240722171543971"></p><p>（1）客户端：生成随机数 c，选择公开的大数 G 和 P，计算 A=c*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算通信密钥 KEY = c <em>B =  c * b</em>G%P，加密发送应用数据</p><p>（3）服务器：根据 Client Hello 消息计算通信密钥 KEY = b * A = b * c*G%P</p><p>也就是说，客户端不需要经过握手就可以发送应用数据，这就是 0-RTT 握手。再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数（A1=a * G%P，A2=c * G%P，…），一旦服务器的随机数 b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。</p><p>为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性</p><h5 id="2-2-2、前向安全"><strong>2.2.2、前向安全</strong></h5><p>前向安全：是指用来产生会话密钥的长期密钥泄露出去，不会泄漏以前的通讯内容。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171728670.png" alt="image-20240722171728670"></p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算初始密钥 initKey = a<em>B = a</em>b*G%P，加密发送应用数据 1</p><p>（3）服务器：根据 Client Hello 消息计算初始密钥 initKey = b<em>A = b</em>a*G%P</p><p>（4）服务器：生成随机数 c，计算 C=c*G%P，使用 initKey 加密 C，发送给客户端，也就是 Server Hello 消息</p><p>（5）客户端：使用 initKey 解码获取 C，计算会话密钥 sessionKey = a<em>C = a</em>c*G%P，加密发送应用数据 2</p><p>（6）服务器：计算会话密钥 sessionKey = c<em>A = c</em>a*G%P，解密获取应用数据 2</p><p>客户端缓存的 ServerConfig 是服务器静态配置的，是可以长期使用的。客户端通过 ServerConfig 实现 0-RTT 握手，使用会话密钥 sessionKey 保证通信数据的前向安全。</p><p><strong>详细解释：</strong></p><p>为了让前向安全的过程更加通俗易懂，我们可以将它与一个简单的比喻结合起来。这种机制可以确保即使某个时刻的密钥泄露，也不会影响之前的通信安全。我们可以将这个过程想象成两个朋友（客户端和服务器）在通信时进行的秘密交换：</p><ol><li><p><strong>客户端生成随机数a，选择公开的大数G和P，计算A=a*G%P，并将A和G发送给服务器，这相当于Client Hello消息</strong>：</p><p>想象两个朋友A（客户端）和B（服务器）想要交换秘密信息。A生成了一个随机数a，并选择了一个共同使用的公开的“大数”G和P。A计算了一个值A=a*G%P，并将这个值A和大数G发送给B。这就像A告诉B：“这是我的公开信息。”</p></li><li><p><strong>客户端使用缓存的ServerConfig计算初始密钥initKey=aB=ab*G%P，并加密发送应用数据1</strong>：</p><p>A使用之前存储的服务器配置信息（ServerConfig）计算一个初始密钥initKey=a*B，其中B是服务器的公开信息。然后，A使用这个初始密钥来加密一些信息，并将其发送给B。</p></li><li><p><strong>服务器根据Client Hello消息计算初始密钥initKey=bA=ba*G%P</strong>：</p><p>B收到A的公开信息后，也生成了一个随机数b。B使用这个随机数和A发送的公开信息计算了同样的初始密钥initKey=b*A。这样，A和B现在都有了一个相同的初始密钥。</p></li><li><p><strong>服务器生成随机数c，计算C=c*G%P，使用initKey加密C，发送给客户端，即Server Hello消息</strong>：</p><p>B生成另一个随机数c，并计算一个新的值C=c*G%P。B使用之前计算的初始密钥initKey加密这个新值C，然后将加密后的C发送给A。这就像B告诉A：“这是我生成的新秘密信息，但你需要用我们的初始密钥来解密它。”</p></li><li><p><strong>客户端使用initKey解码获取C，计算会话密钥sessionKey=aC=ac*G%P，并加密发送应用数据2</strong>：</p><p>A使用初始密钥解密B发送的C，然后计算一个新的会话密钥sessionKey=a*C。A使用这个会话密钥来加密新的信息，并将其发送给B。</p></li><li><p><strong>服务器计算会话密钥sessionKey=cA=ca*G%P，解密获取应用数据2</strong>：</p><p>B也使用C和A发送的公开信息计算同样的会话密钥sessionKey=c*A。然后，B使用这个会话密钥来解密A发送的加密信息。</p></li></ol><p>通过这个过程，客户端和服务器能够在不暴露各自秘密的情况下生成相同的会话密钥，从而确保通信的前向安全。这意味着即使未来某个密钥被泄露，也不会影响之前的通信内容的安全性。</p><h4 id="2-3、可靠传输"><strong>2.3、可靠传输</strong></h4><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171841278.png" alt="image-20240722171841278"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN = 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN=4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN=2）和重传的数据包（PKN=4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171905289.png" alt="image-20240722171905289"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h4 id="2-4、流量控制"><strong>2.4、流量控制</strong></h4><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171922763.png" alt="image-20240722171922763"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171935952.png" alt="image-20240722171935952"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171947478.png" alt="image-20240722171947478"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 = 60</p><h4 id="2-5、拥塞控制"><strong>2.5、拥塞控制</strong></h4><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd = min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h5 id="2-5-1、慢启动"><strong>2.5.1、慢启动</strong></h5><p>初始拥塞窗口大小 cwnd=1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS = 1500（MTU）- 20（IP 首部）- 8（UDP 首部） = 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets <span class="operator">=</span> <span class="number">2000</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;= ssthresh</strong> 时，使用拥塞避免算法</li></ul><h5 id="2-5-2、拥塞避免"><strong>2.5.2、拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1/cwnd</p><p>假设现在的 cwnd=8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h5 id="2-5-3、拥塞发生"><strong>2.5.3、拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = 1</li></ul><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd = cwnd / 2</li><li>ssthresh = cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h5 id="2-5-4、快速恢复"><strong>2.5.4、快速恢复</strong></h5><p>快速恢复算法：cwnd = ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><h5 id="2-5-5、常见算法"><strong>2.5.5、常见算法</strong></h5><ul><li>New Reno：基于丢包检测</li><li>CUBIC：基于丢包检测</li><li>BBR：基于网络带宽</li></ul><p>和 TCP 不同的是，QUIC 是在用户空间实现的拥塞控制，可以非常灵活的设置，甚至可以为每一个请求都设置一种拥塞控制算法。</p><h4 id="2-6、多路复用"><strong>2.6、多路复用</strong></h4><p>多路复用是 HTTP/2 的主要特性之一。</p><p>概念：单条 TCP 连接上可以同时发送多个 HTTP 请求，解决了 HTTP1.1 中单个连接 1 次只能发送 1 个请求的性能瓶颈。<strong>HTTP/2 能实现多路复用的根本原因是采用了二进制帧格式的数据结构</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172100507.png" alt="image-20240722172100507"></p><ul><li>Length：表示 Payload 的长度</li><li>Type：表示帧类型</li><li>Flags：帧标识</li><li>Stream ID：数据帧所属的流</li><li>Payload：应用数据，长度由 Length 字段指定</li></ul><p>一个请求就对应一条流，通过 Stream ID 就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID 分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172118432.png" alt="image-20240722172118432"></p><p>虽然在 HTTP 应用层，可以同时发送多个请求，但是在 TCP 传输层，仍然只有 1 个滑动窗口来发送这些数据包，考虑下面的情形：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172132726.png" alt="image-20240722172132726"></p><p>客户端发送的 5 个数据包（56789）服务器都收到了，并且回应了 5 个 ACK，但是第 5 个数据包的 ACK 丢失了，导致客户端的发送窗口无法向前移动，也就无法发送新的数据，这就是 TCP 层的队头阻塞问题。</p><p>HTTP/2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞。那 QUIC 是如何解决 TCP 层的队头阻塞问题的呢？其实很简单，HTTP/2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口**，那如果给每个请求流都分配一个独立的滑动窗口**，是不是就可以解决这个问题了？</p><p>QUIC 就是这么做的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172143472.png" alt="image-20240722172143472"></p><p>A 请求流上的丢包不会影响 B 请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然 QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC 声明的无队头阻塞的多路复用。</p><h4 id="2-7、连接迁移"><strong>2.7、连接迁移</strong></h4><p>连接迁移：<strong>当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信</strong>，对于 TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源 IP、源端口、目的 IP、目的端口，只要其中 1 个发生变化，就需要重新建立连接。但 QUIC 的连接是基于 64 位的 Connection ID，网络切换并不会影响 Connection ID 的变化，连接在逻辑上仍然是通的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172203987.png" alt="image-20240722172203987"></p><p>假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为 IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID 字段可以判断这 4 个包是来自于同一个客户端。QUIC 能实现连接迁移的根本原因是底层使用 UDP 协议就是面向无连接的。</p><p>补充：<strong>Connection ID</strong>：每个QUIC连接都有一个唯一的Connection ID。当客户端和服务器建立连接时，它们交换并存储彼此的Connection ID！</p><h3 id="3、QUIC-小结"><strong>3、QUIC 小结</strong></h3><p>本文尽量用通俗易懂的语言介绍了 QUIC 协议实现原理，目的是让大家对 QUIC 有一个基本的了解，当然，这只是 QUIC 协议的冰山一角，更详细具体的内部实现还需要深入研究标准文档和源码，如果文中有描述不对的地方，欢迎批评指正，多多交流</p><p>本文学习自:<a href="https://zhuanlan.zhihu.com/p/405387352">QUIC 协议详解</a></p>]]></content>
    
    
    <summary type="html">QUIC 协议详解</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Glibc-ptmalloc</title>
    <link href="https://penge666.github.io/posts/3707fe10.html"/>
    <id>https://penge666.github.io/posts/3707fe10.html</id>
    <published>2024-07-19T15:25:18.000Z</published>
    <updated>2024-08-06T15:47:19.276Z</updated>
    
    <content type="html"><![CDATA[<p>在Unix和类Unix系统中，glibc（GNU C Library）扮演着至关重要的角色。它作为系统调用和库函数的桥梁，使得程序员能够方便地利用底层系统资源。<code>ptmalloc</code> 是 <code>malloc</code> 在 GNU C Library（glibc）中的一个具体实现。</p><p><strong>32</strong> <strong>位模式下进程内存经典布局</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806233656259.png" alt="image-20240806233656259"></p><p>着重关注两个区：<strong>heap</strong>（堆区） <strong>memory mapping</strong>（内存映射区）</p><ul><li><p>brk函数其实就是在heap分配空间，在ptmalloc的设计中有start_brk和brk两个标志，他们两个的差值标记着堆区的大小。一开始这两个值是相同的，但是随着ptmalloc去调用brk函数，brk标记不断向高地址区域偏移，标记着heap堆区被分配出去了。</p></li><li><p>mmap函数则是在memory mapping区域分配空间，memory mapping区域除了我们常知道的映射动态库对象或者文件，其空间还可以被mmap映射至物理内存。</p></li></ul><h2 id="分配区">分配区</h2><p>在 Doug Lea 实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在 SMP 多线程环境下，对主分配区的锁的争用很激烈，严重影响了 malloc 的分配效率。<strong>于是 Wolfram Gloger 在 Doug Lea 的基础上改进使得Glibc 的 malloc 可以支持多线程，增加了非主分配区（non main arena）支持，主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</strong>【有点分段锁的味道】</p><p>每个进程只有一个主分配区，但可能存在多个非主分配区，ptmalloc 根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。**主分配区可以访问进程的 heap 区域和 mmap 映射区域，也就是说主分配区可以使用 sbrk 和 mmap向操作系统申请虚拟内存。而非主分配区只能访问进程的 mmap 映射区域，非主分配区每次使用 mmap()向操作系统“发”HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统默认为 64MB）大小的虚拟内存，**当用户向非主分配区请求分配内存时再切割成小块“零售”出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap()函数向操作系统申请虚拟内存。</p><p>主分配区可以访问 heap 区域，如果用户不调用 brk()或是 sbrk()函数，分配程序就可以保证分配到连续的虚拟地址空间，因为每个进程只有一个主分配区使用 sbrk()分配 heap 区域的虚拟内存。内核对 brk 的实现可以看着是 mmap 的一个精简版，相对高效一些。如果主分配区的内存是通过 mmap()向系统分配的，当 free 该内存时，主分配区会直接调用 munmap()将该内存归还给系统。</p><p>**当某一线程需要调用 malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。**在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。申请小块内存时会产生很多内存碎片，ptmalloc 在整理时也需要对分配区做加锁操作。每个加锁操作大概需要 5～10 个 cpu 指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致 malloc 性能下降。一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc在多线程竞争情况下性能远远落后于 tcmalloc。最新版的 ptmalloc 对锁进行了优化，加入了PER_THREAD 和 ATOMIC_FASTBINS 优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。</p><p><strong>代码角度理解</strong></p><p><strong>主分配区（Main Arena）</strong></p><p>主分配区是唯一的，它与进程的主线程相关联。主分配区使用进程的堆（heap）来分配内存，并且在进程启动时创建，始终存在。以下是主分配区的一些关键代码实现细节：</p><ol><li><p><strong><code>malloc_state</code> 结构体</strong>：</p><ul><li><p>这是主分配区的核心数据结构，包含了所有用于管理内存的字段，例如 <code>bins</code> 数组、<code>top</code> 指针（指向当前未分配的内存区域）、<code>last_remainder</code> 指针（指向最后一个分割的内存块）等。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    <span class="type">binmap_t</span> binmap;          <span class="comment">// 用于快速查找非空 bin 的位图</span></span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *last_remainder; <span class="comment">// 指向最后一个分割的内存块</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><p>主分配区通常是一个全局变量，例如在 <code>glibc</code> 中，主分配区可以通过 <code>main_arena</code> 变量访问。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> malloc_state main_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化</strong>：</p><ul><li><p>主分配区在进程启动时初始化，通常在 <code>ptmalloc</code> 的初始化函数中完成。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ptmalloc_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化主分配区</span></span><br><span class="line">    <span class="built_in">init_arena</span>(&amp;main_arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>从分配区（Thread Arena）</strong></p><p>从分配区是为每个线程独立创建的分配区，它允许线程独立地管理内存，从而减少锁竞争，提高并发性能。以下是从分配区的一些关键代码实现细节：</p><ol><li><p><strong>线程局部存储（Thread Local Storage, TLS）</strong>：</p><ul><li><p>每个线程可以通过线程局部存储（TLS）来访问自己的分配区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread malloc_state *thread_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>创建从分配区</strong>：</p><ul><li><p>当一个线程第一次调用 <code>malloc</code> 时，如果还没有分配区，<code>ptmalloc</code> 会为该线程创建一个新的从分配区。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> malloc_state *<span class="title">arena_get</span><span class="params">(mstate *ar_ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *a;</span><br><span class="line">    <span class="comment">// 尝试获取现有的分配区或创建新的分配区</span></span><br><span class="line">    a = <span class="built_in">get_free_list</span>(); <span class="comment">// 从空闲列表中获取分配区</span></span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        a = _int_new_arena(size); <span class="comment">// 创建新的分配区</span></span><br><span class="line">    &#125;</span><br><span class="line">    *ar_ptr = a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配和释放</strong>：</p><ul><li><p>当线程请求内存时，<code>ptmalloc</code> 会从相应的分配区中查找合适的内存块。如果找到合适的内存块，则将其从 <code>bins</code> 中移除并返回给调用者。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line">    <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="built_in">arena_get</span>(&amp;ar_ptr, size);</span><br><span class="line">    <span class="comment">// 从分配区中查找合适的内存块</span></span><br><span class="line">    victim = _int_malloc(ar_ptr, size);</span><br><span class="line">    <span class="keyword">if</span> (!victim) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些代码片段，可以看到主分配区和从分配区的基本结构和操作。</p><h2 id="关键数据结构">关键数据结构</h2><p>在 <code>ptmalloc</code> 内存分配器中，<code>unsorted bin</code>、<code>Fast Bins</code>、<code>top chunk</code>、<code>bins</code> 和 <code>mmaped chunk</code> 是用于管理内存块的关键数据结构。它们之间的关系和作用如下：</p><ol><li><code>unsorted bin</code></li></ol><p><code>unsorted bin</code> 是一个双向链表，用于临时存储最近释放的内存块。这些内存块在下次分配请求时会被重新整理并放入相应的 <code>bins</code> 中。</p><ol start="2"><li><code>Fast Bins</code></li></ol><p><code>Fast Bins</code> 是一个单链表数组，用于存储较小的空闲内存块（通常小于64或128字节）。<code>Fast Bins</code> 中的内存块不会被合并，这样可以快速地进行分配和释放。</p><ol start="3"><li><code>top chunk</code></li></ol><p><code>top chunk</code> 是分配区中未分配的内存区域。当 <code>bins</code> 中没有合适的内存块时，<code>ptmalloc</code> 会从 <code>top chunk</code> 中分割出所需的内存块。</p><ol start="4"><li><code>bins</code></li></ol><p><code>bins</code> 是一个双向链表数组，用于存储具有相同大小的空闲内存块。<code>bins</code> 分为 <code>small bins</code> 和 <code>large bins</code>，分别用于存储较小的和较大的内存块。</p><ol start="5"><li><code>mmaped chunk</code></li></ol><p><code>mmaped chunk</code> 是通过 <code>mmap</code> 系统调用分配的内存块。当请求的内存大小超过某个阈值时，<code>ptmalloc</code> 会使用 <code>mmap</code> 来分配内存，而不是从堆中分配。</p><p><strong>代码解读</strong></p><p>以下是一个简化的代码示例，展示了这些数据结构之间的关系和作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> prev_size;  <span class="comment">// 前一个内存块的大小</span></span><br><span class="line">    <span class="type">size_t</span> size;       <span class="comment">// 当前内存块的大小</span></span><br><span class="line">    malloc_chunk *fd;  <span class="comment">// 指向链表中下一个内存块</span></span><br><span class="line">    malloc_chunk *bk;  <span class="comment">// 指向链表中前一个内存块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *fastbinsY[NFASTBINS]; <span class="comment">// Fast Bins 数组</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *ar_ptr = <span class="built_in">get_arena</span>(); <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="type">size_t</span> nb = <span class="built_in">request2size</span>(size);     <span class="comment">// 将请求的大小转换为实际分配的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 Fast Bins 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt;= <span class="built_in">get_max_fast</span>()) &#123;</span><br><span class="line">        idx = <span class="built_in">fastbin_index</span>(nb);</span><br><span class="line">        fb = &amp;fastbinsY[idx];</span><br><span class="line">        victim = *fb;</span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 unsorted bin 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unsorted_chunks</span>(ar_ptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        victim = <span class="built_in">unsorted_chunks</span>(ar_ptr);</span><br><span class="line">        <span class="built_in">unsorted_chunks</span>(ar_ptr) = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (victim-&gt;size == nb) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 bins 中分配内存</span></span><br><span class="line">    idx = <span class="built_in">bin_index</span>(nb);</span><br><span class="line">    bin = <span class="built_in">bin_at</span>(ar_ptr, idx);</span><br><span class="line">    victim = <span class="built_in">first</span>(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin) &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(victim, bk, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 top chunk 中分配内存</span></span><br><span class="line">    victim = ar_ptr-&gt;top;</span><br><span class="line">    size = <span class="built_in">chunksize</span>(victim);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">        ar_ptr-&gt;top = remainder;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 mmap 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &amp; MMAP_THRESHOLD) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, nb, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>获取分配区</strong>：<ul><li><code>get_arena()</code> 函数获取当前线程的分配区。</li></ul></li><li><strong>Fast Bins</strong>：<ul><li>如果请求的大小小于 <code>get_max_fast()</code> 返回的值，尝试从 <code>Fast Bins</code> 中分配内存。</li><li><code>fastbin_index(nb)</code> 计算 <code>Fast Bins</code> 的索引，<code>fastbinsY[idx]</code> 获取相应的 <code>Fast Bin</code>。</li><li>如果找到合适的内存块，将其从 <code>Fast Bin</code> 中移除并返回。</li></ul></li><li><strong>unsorted bin</strong>：<ul><li>如果 <code>unsorted bin</code> 不为空，尝试从中分配内存。</li><li>如果找到合适大小的内存块，直接返回。</li></ul></li><li><strong>bins</strong>：<ul><li>计算请求大小的 <code>bin</code> 索引，尝试从相应的 <code>bin</code> 中分配内存。</li><li>如果找到合适的内存块，将其从 <code>bin</code> 中移除并返回。</li></ul></li><li><strong>top chunk</strong>：<ul><li>如果 <code>top chunk</code> 的大小足够，从 <code>top chunk</code> 中分割出所需的内存块，并更新 <code>top chunk</code> 的指针。</li></ul></li><li><strong>mmaped chunk</strong>：<ul><li>如果请求的大小超过某个阈值，使用 <code>mmap</code> 系统调用分配内存。</li></ul></li></ol><h2 id="分配释放策略">分配释放策略</h2><p><strong>ptmalloc 的分配策略</strong></p><ul><li>获取分配区锁，加锁成功则使用该分配区分配内存，否则就遍历分配区的环形链表。如果链表中没有空闲的，就开辟一个新的分配区，把其加入线程私有实例并且加入到环形链表。</li><li>将用户请求的字节向上对齐到bins中的最近字节。</li><li>如果小于64B就在fast bin中分配内存，如果大于再去判断是否小于512B，如果小于就去small bin中分配大小，如果大于就说明此时分配的是大内存。</li><li>首先会将fast bin中的chunk进行合并，然后链接至unsorted bin，再将其链接到相应的bin中。</li><li>然后去large bins中进行寻找，如果够用结束，不够下一步。</li><li>这个时候就需要判断top chunk是否够用，不够用下一步。</li><li>有两种选择，判断分配的字节大小是否大于等于mmap分配阈值，如果小于根据分配区去选择brk还是mmap去增加top chunk的大小；如果大于就直接调用mmap去映射。</li></ul><p><strong>ptmalloc 的释放策略</strong></p><ul><li>获取分配区的锁</li><li>判断free参数是否位nullptr，如果为nullptr则什么都不做</li><li>如果释放空间为mmaped chunk，直接使用munmap释放</li><li>如果size &lt; 64B且不和top chunk相邻，放入fast bin</li><li>判断前一个块是否空闲，空闲则合并</li><li>判断下一个是否空闲，空闲则合并放入unsorted bin，然后放入相应的bin中</li><li>判读合并后是否大于64kb，如果大于fast bin中chunk进行合并，放入unsorted bin，然后下一步。</li><li>判读top chunk是否大于128kb，如果大于就会归还给操作系统。注意：如果为非主分配区，就只会归还一部部分。</li></ul><p>学习自：glibc内存管理ptmalloc源代码分析</p><ul><li><a href="http://manistein.club/post/program/c/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ptmalloc%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6/">深入理解ptmalloc的运作机制</a></li></ul>]]></content>
    
    
    <summary type="html">ptmalloc内存池</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-多级反馈队列</title>
    <link href="https://penge666.github.io/posts/40ab952d.html"/>
    <id>https://penge666.github.io/posts/40ab952d.html</id>
    <published>2024-07-18T14:04:26.000Z</published>
    <updated>2024-08-06T14:22:29.359Z</updated>
    
    <content type="html"><![CDATA[<p>进程调度有一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。</p><blockquote><p><strong>提示：从历史中学习</strong></p><p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。</p></blockquote><h2 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h2><p>MLFQ 中有许多独立的<code>队列</code>（queue），每个队列有不同的<code>优先级</code>（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是<strong>优先执行较高优先级</strong>的工作（即在<strong>较高级队列</strong>中的工作）。对于同一个队列中的任务，采用<code>轮转调度</code>。</p><p><code>MLFQ</code>中工作优先级并不是固定的，而是会根据进程的行为<code>动态调整优先级</code>。例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是<strong>交互型进程</strong>的可能行为，MLFQ 因此会让它保持<strong>高优先级</strong>。相反，如果一个工作<strong>长时间地占用</strong> CPU，MLFQ 会<strong>降低其优先级</strong>。</p><p>MLFQ 的两条基本规则:</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</li><li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B 。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806222225344.png" alt="image-20240806222225344"></p><h2 id="尝试-1：如何改变优先级"><a href="#尝试-1：如何改变优先级" class="headerlink" title="尝试 1：如何改变优先级"></a>尝试 1：如何改变优先级</h2><p>我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有<strong>运行时间很短</strong>、<strong>频繁放弃 CPU</strong> 的<code>交互型工作</code>，也有需要<strong>很多 CPU 时间</strong>、<strong>响应时间却不重要</strong>的长时间<code>计算密集型工作</code>。下面是我们第一次尝试优先级调整算法。</p><ul><li><strong>规则 3</strong> ：工作进入系统时，放在最高优先级（最上层队列）。</li><li><strong>规则 4a</strong>：工作用完整个时间片后，降低其优先级（移入下一个队列）。</li><li><strong>规则 4b</strong>：如果工作在其时间片以内主动释放 CPU，则优先级不变。</li></ul><h3 id="实例-1：单个长工作"><a href="#实例-1：单个长工作" class="headerlink" title="实例 1：单个长工作"></a>实例 1：单个长工作</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221138198.png" alt="image-20240806221138198"></p><p>从这个例子可以看出，该工作首先进入最高优先级（Q2）。执行一个 10ms 的时间片后，调度程序将工作的优先级减 1，因此进入 Q1。在 Q1 执行一个时间片后，最终降低优先级进入系统的最低优先级（Q0），并一直留在那里。</p><h3 id="实例-2：加入一个短工作"><a href="#实例-2：加入一个短工作" class="headerlink" title="实例 2：加入一个短工作"></a>实例 2：加入一个短工作</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221310794.png" alt="image-20240806221310794"></p><p>B 在 T=100 时到达</p><p>如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，<strong>MLFQ 近似于 SJF</strong>(最短任务优先)。</p><h3 id="实例-3：如果有-I-O-呢"><a href="#实例-3：如果有-I-O-呢" class="headerlink" title="实例 3：如果有 I/O 呢"></a>实例 3：如果有 I/O 呢</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221321021.png" alt="image-20240806221321021"></p><p>交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O 操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交互型工作快速运行</p><h3 id="当前-MLFQ-的一些问题"><a href="#当前-MLFQ-的一些问题" class="headerlink" title="当前 MLFQ 的一些问题"></a>当前 MLFQ 的一些问题</h3><ol><li>饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。</li><li>愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。</li><li>一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间需要作为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。因为优先级一旦下降就无法提升</li></ol><h2 id="尝试-2：提升优先级"><a href="#尝试-2：提升优先级" class="headerlink" title="尝试 2：提升优先级"></a>尝试 2：提升优先级</h2><p>为解决[1]饥饿问题</p><ul><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221329792.png" alt="image-20240806221329792"></p><ol><li><strong>左边没有优先级提升</strong>，长工作在两个短工作到达后被饿死。</li><li><strong>右边每 50ms 就有一次优先级提升</strong>（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 50ms 就被提升到最高优先级，从而定期获得执行。</li></ol><p>添加时间段 S 导致了明显的问题：S 的值应该如何设置？德高望重的系统研究员 John Ousterhout 曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。</p><h2 id="尝试-3：更好的计时方式"><a href="#尝试-3：更好的计时方式" class="headerlink" title="尝试 3：更好的计时方式"></a>尝试 3：更好的计时方式</h2><p>为解决[2]愚弄调度程序问题</p><p>起因是规则 4a 和 4b 不合理，调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。</p><p>重写规则 4：</p><ul><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221337806.png" alt="image-20240806221337806"></p><p>没有<strong>规则 4</strong>的保护时，进程可以在每个时间片结束前发起一次 I/O 操作，从而垄断 CPU 时间。有了这样的保护后，不论进程的 I/O 行为如何，都会慢慢地降低优先级，因而无法获得超过公平的 CPU 时间比例。同时由于<strong>规则 5</strong>的存在，原来的交互性进程还是可以在之后提升优先级。</p><h2 id="MLFQ-调优及其他问题"><a href="#MLFQ-调优及其他问题" class="headerlink" title="MLFQ 调优及其他问题"></a>MLFQ 调优及其他问题</h2><p>关于 MLFQ 调度算法还有一些问题。其中一个大问题是<strong>如何配置</strong>一个调度程序，例如：</p><ol><li>配置多少队列？</li><li>每一层队列的时间片配置多大？</li><li>为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</li></ol><p>这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221345717.png" alt="image-20240806221345717"></p><p>例如，大多数的 MLFQ 变体都支持不同队列可变的时间片长度。<strong>高优先级队列通常只有较短的时间片</strong>（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，<strong>低优先级队列</strong>中更多的是 CPU 密集型工作，配置<strong>更长的时间片</strong>会取得更好的效果。图 8.7 展示了一个例子，两个长工作在高优先级队列执行 10ms，中间队列执行 20ms，最后在最低优先级队列执行 40ms。</p><p><code>Solaris</code> 的 MLFQ 实现（<code>时分调度类 TS</code>）很容易配置。它提供了<code>一组表</code>来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级。管理员可以通过这些表，让调度程序的行为方式不同。该表默认有 60 层队列，时间片长度从 20ms（最高优先级），到几百 ms（最低优先级），每一秒左右提升一次进程的优先级。</p><p>其他一些 MLFQ 调度程序没用表，甚至没用本章中讲到的规则，有些采用数学公式来调整优先级。例如，<code>FreeBSD</code> 调度程序（4.3 版本），会基于当前进程使用了多少 CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升，但与这里描述方式不同。阅读 Epema 的论文，他漂亮地概括了这种使用量衰减（decay-usage）算法及其特征</p><p>最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的<code>建议</code>（advice），比如通过命令行工具 <code>nice</code>，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看 man 手册。</p><blockquote><p><strong>提示：尽可能多地使用建议</strong></p><p>操作系统很少知道什么策略对系统中的单个进程和每个进程算是好的，因此提供接口并允许用户或管理员给操作系统一些提示（hint）常常很有用。我们通常称之为建议（advice），因为操作系统不一定要关注它，但是可能会将建议考虑在内，以便做出更好的决定。这种用户建议的方式在操作系统中的各个领域经常十分有用，包括调度程序（通过 nice）、内存管理（madvise），以及文件系统（通知预取和缓存[P+95]）</p></blockquote><h2 id="MLFQ：小结"><a href="#MLFQ：小结" class="headerlink" title="MLFQ：小结"></a>MLFQ：小结</h2><p>本章介绍了一种调度方式，名为<code>多级反馈队列</code>（MLFQ）。</p><p>本章包含了一组优化的 MLFQ 规则。为了方便查阅，我们重新列在这里。</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</li><li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</li><li><strong>规则 3</strong>：工作进入系统时，放在最高优先级（最上层队列）。</li><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul><p>MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ 可以同时满足各种工作的需求：<strong>对于短时间运行的交互型工作，获得类似于 SJF/STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前</strong>。因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括<code>类 BSD UNIX 系统</code>、<code>Solaris</code>以及 <code>Windows NT</code> 和其后的 <code>Window 系列操作系统</code>。</p><p>最后，关于抢占式问题总结：</p><ol><li><strong>先来先服务（First-Come, First-Served, FCFS）</strong>：<ul><li>通常是非抢占式的。进程一旦获得CPU，就会一直运行直到完成或阻塞。</li></ul></li><li><strong>短作业优先（Shortest Job First, SJF）</strong>：<ul><li>可以是抢占式的，也可以是非抢占式的。抢占式的SJF称为最短剩余时间优先（Shortest Remaining Time First, SRTF），它会在新到达的进程比当前运行进程的剩余时间更短时抢占CPU。</li></ul></li><li><strong>时间片轮转（Round Robin, RR）</strong>：<ul><li>是抢占式的。每个进程被分配一个固定的时间片，当时间片用完时，当前进程被抢占，CPU分配给队列中的下一个进程。</li></ul></li><li><strong>多级反馈队列（Multilevel Feedback Queue, MFQ）</strong>：<ul><li>是抢占式的。进程可以在不同优先级的队列之间移动，高优先级的队列中的进程可以抢占低优先级队列中的进程。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">OS-多级反馈队列MLFQ</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT6.081-Lab1&amp;&amp;2</title>
    <link href="https://penge666.github.io/posts/c952f7a6.html"/>
    <id>https://penge666.github.io/posts/c952f7a6.html</id>
    <published>2024-07-16T12:08:55.000Z</published>
    <updated>2024-08-06T14:52:22.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前阅读过Linux0.11的源码，但是还是觉得远远还不够，随后入坑了这门mit6.s081. 享受lab带来的快乐~</p><h3 id="环境配置">环境配置</h3><p>网页：<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">https://pdos.csail.mit.edu/6.828/2021/tools.html</a></p><p>先说环境，笔者直接在VMWare上的Ubuntu22.04上实验的，废话少说，开干~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure><p>直接克隆即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ <span class="built_in">ls</span></span><br><span class="line">conf            gradelib.py  LICENSE   mkfs    user</span><br><span class="line">grade-lab-util  kernel       Makefile  README</span><br><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ git checkout util</span><br><span class="line">Already on <span class="string">&#x27;util&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/util&#x27;</span>.</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  make clean</span><br><span class="line"><span class="built_in">rm</span> -f *.tex *.dvi *.idx *.aux *.<span class="built_in">log</span> *.ind *.ilg \</span><br><span class="line">*/*.o */*.d */*.asm */*.sym \</span><br><span class="line">user/initcode user/initcode.out kernel/kernel fs.img \</span><br><span class="line">mkfs/mkfs .gdbinit \</span><br><span class="line">        user/usys.S \</span><br><span class="line">user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_alarmtest  user/_call user/_bttest \</span><br><span class="line">ph barrier</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  make      </span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/kalloc.o kernel/kalloc.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/string.o kernel/string.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/main.o kernel/main.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/vm.o kernel/vm.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/proc.o kernel/proc.c</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/swtch.o kernel/swtch.S</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/trampoline.o kernel/trampoline.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/trap.o kernel/trap.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/syscall.o kernel/syscall.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sysproc.o kernel/sysproc.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/bio.o kernel/bio.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/fs.o kernel/fs.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/log.o kernel/log.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sleeplock.o kernel/sleeplock.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/file.o kernel/file.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/pipe.o kernel/pipe.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/exec.o kernel/exec.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sysfile.o kernel/sysfile.c</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/kernelvec.o kernel/kernelvec.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/plic.o kernel/plic.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/virtio_disk.o kernel/virtio_disk.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/start.o kernel/start.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/console.o kernel/console.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/printf.o kernel/printf.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/uart.o kernel/uart.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/spinlock.o kernel/spinlock.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -march=rv64g -nostdinc -I. -Ikernel -c user/initcode.S -o user/initcode.o</span><br><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -N -e start -Ttext 0 -o user/initcode.out user/initcode.o</span><br><span class="line">riscv64-linux-gnu-objcopy -S -O binary user/initcode.out user/initcode</span><br><span class="line">riscv64-linux-gnu-objdump -S user/initcode.o &gt; user/initcode.asm</span><br><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -T kernel/kernel.ld -o kernel/kernel kernel/entry.o kernel/kalloc.o kernel/string.o kernel/main.o kernel/vm.o kernel/proc.o kernel/swtch.o kernel/trampoline.o kernel/trap.o kernel/syscall.o kernel/sysproc.o kernel/bio.o kernel/fs.o kernel/log.o kernel/sleeplock.o kernel/file.o kernel/pipe.o kernel/exec.o kernel/sysfile.o kernel/kernelvec.o kernel/plic.o kernel/virtio_disk.o kernel/start.o kernel/console.o kernel/printf.o kernel/uart.o kernel/spinlock.o</span><br><span class="line">riscv64-linux-gnu-objdump -S kernel/kernel &gt; kernel/kernel.asm</span><br><span class="line">riscv64-linux-gnu-objdump -t kernel/kernel | sed <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27;</span> &gt; kernel/kernel.sym</span><br></pre></td></tr></table></figure><p>离谱的操作</p><p><code>ctrl + p </code>可以查看当前进程</p><p><code>ctrl-a  x</code>可以退出sh（是按住ctrl还有a，松开手，再按下x，然后回车）</p><p>※ Note：退出 <code>ctrl + a 放开后，再按下x</code></p><h3 id="调试">调试</h3><p>这个方式有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch kernel/kernel</span><br><span class="line">（gdb）<span class="built_in">set</span> architecture riscv:rv64</span><br><span class="line">(gdb)target remote localhost:25000</span><br></pre></td></tr></table></figure><p>因此使用<code>riscv-unknown-elf-gdb</code>这条命令~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805213407210.png" alt="image-20240805213407210"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ sudo vim .gdbinit</span><br></pre></td></tr></table></figure><p>将画红框的内容加入到<code>.gdbinit</code>隐藏文件。</p><blockquote><p><strong>调试的话</strong></p></blockquote><p>一个终端开启调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  sudo make qemu-gdb</span><br><span class="line"> *** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br></pre></td></tr></table></figure><p>一个终端远程连接即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  riscv64-unknown-elf-gdb kernel/kernel</span><br><span class="line">GNU gdb (GDB) 13.1</span><br><span class="line">(gdb) target remote localhost:25000</span><br><span class="line">Remote debugging using localhost:25000</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) b main</span><br><span class="line">Note: breakpoint 1 also <span class="built_in">set</span> at pc 0x8000032e.</span><br><span class="line">Breakpoint 2 at 0x8000032e: file kernel/main.c, line 13.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at kernel/main.c:1</span><br></pre></td></tr></table></figure><p>然后就可用快乐的调试了~</p><p>Note：由于这个实验是多线程的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> CPUS</span><br><span class="line">CPUS := 1</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LAB)</span>,fs)</span><br><span class="line">CPUS := 1</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>为了调试方便，就先将这个设置成1了。</p><ul><li><a href="https://blog.csdn.net/yihuajack/article/details/116571913">xv6 2020版使用gdb调试debug的方法</a></li><li><a href="https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/">优雅的调试—在vscode上完美调试xv6（完结</a></li><li><a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">MIT 6.S081 xv6调试不完全指北</a></li><li><a href="https://github.com/monifeng/6.s081/blob/main/MIT6.s081%20gdb%E8%B0%83%E8%AF%95.md">mit6.s081 GDB调试</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># b <span class="comment">//设置断点（breakpoint）</span></span></span><br><span class="line"><span class="meta"># c <span class="comment">//继续运行（Continue）--到断点处就会停止</span></span></span><br><span class="line"><span class="meta"># n <span class="comment">//单步调试 </span></span></span><br><span class="line"><span class="meta"># p <span class="comment">//打印变量内容</span></span></span><br><span class="line"><span class="meta"># si <span class="comment">//断点定位</span></span></span><br><span class="line"><span class="meta"># display/i $pc <span class="comment">//每次停止时，都可以显示下一条指令的反汇编</span></span></span><br><span class="line"><span class="meta"># layout asm <span class="comment">//可以显示当前的汇编指令</span></span></span><br><span class="line"><span class="meta"># display /3i $pc <span class="comment">//如果您希望在单步执行程序时自动显示下3条指令,可以使用display命令</span></span></span><br><span class="line"><span class="meta"># p *path@6 <span class="comment">//这里是打印path指向的内容，打印长度为6（如果不写@6那么只能打印一个char）</span></span></span><br></pre></td></tr></table></figure><p><strong>闲话</strong>：闲着看看项目行数</p><p>统计当前目录下的所有文件行数： wc -l *</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  <span class="built_in">wc</span> -l *</span><br><span class="line"></span><br><span class="line">      4 answers-traps.txt</span><br><span class="line"><span class="built_in">wc</span>: conf: Is a directory</span><br><span class="line">      0 conf</span><br><span class="line">   3418 fs.img</span><br><span class="line">     70 grade-lab-traps</span><br><span class="line">    611 gradelib.py</span><br><span class="line"><span class="built_in">wc</span>: kernel: Is a directory</span><br><span class="line">      0 kernel</span><br><span class="line">     24 LICENSE</span><br><span class="line">    410 Makefile</span><br><span class="line"><span class="built_in">wc</span>: mkfs: Is a directory</span><br><span class="line">      0 mkfs</span><br><span class="line"><span class="built_in">wc</span>: __pycache__: Is a directory</span><br><span class="line">      0 __pycache__</span><br><span class="line">     47 README</span><br><span class="line"><span class="built_in">wc</span>: user: Is a directory</span><br><span class="line">      0 user</span><br><span class="line">     62 xv6.out</span><br><span class="line">   4646 total</span><br></pre></td></tr></table></figure><p>当前目录以及子目录的所有文件行数： find  . * | xargs wc -l</p><h2 id="Lab1">Lab1</h2><p>lab1就是简单的linux下编程，了解命令的含义编程即可。</p><h3 id="Boot-xv6-easy">Boot xv6 (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><p>这个就不截图了，能跑起了就好啦~</p><h3 id="sleep-easy">sleep (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><blockquote><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p></blockquote><p>简单来讲就是实现一个睡眠的程序，需要自己写在 <code>user/sleep.c</code> 里，一定要读一读实验手册里的hints，非常有用并且涉及到一些细节问题！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;args wrong!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> num = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">sleep</span>(num);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><ul><li>考虑输入为空或其他</li><li>将字符串转换为int类型</li><li>头文件的引用</li></ul><h3 id="pingpong-easy">pingpong (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><p>这个也不是很难</p><p><strong>实验要求</strong></p><blockquote><p>Write a program that uses UNIX system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p></blockquote><p>大义就是：用两个管道接收父子进程的数据，父进程发送一个byte，然后子进程接收后打印，然后子进程发送父进程一个byte，最后父进程打印输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> q[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(p),<span class="built_in">pipe</span>(q);</span><br><span class="line">    <span class="comment">// child </span></span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buff_child[<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// === child  first stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(p[WRITE]);</span><br><span class="line">        <span class="built_in">read</span>(p[READ],buff_child,<span class="number">6</span>);</span><br><span class="line">        <span class="type">int</span> child_pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,child_pid);</span><br><span class="line">        <span class="built_in">close</span>(p[READ]);</span><br><span class="line">        <span class="comment">// === second stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(q[READ]);</span><br><span class="line">        <span class="built_in">write</span>(q[WRITE], <span class="string">&quot;father\n&quot;</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="built_in">close</span>(q[WRITE]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> buff_fa[<span class="number">6</span>];</span><br><span class="line">        <span class="comment">// ===fa  first stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(p[READ]);</span><br><span class="line">        <span class="built_in">write</span>(p[WRITE], <span class="string">&quot;child\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">close</span>(p[WRITE]);</span><br><span class="line">        <span class="comment">// === second stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(q[WRITE]);</span><br><span class="line">        <span class="built_in">read</span>(q[READ],buff_fa,<span class="number">7</span>);</span><br><span class="line">        <span class="type">int</span> fa_pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,fa_pid);</span><br><span class="line">        <span class="built_in">close</span>(q[READ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="primes-moderate-hard">primes (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">hard</a>)</h3><p><strong>实验要求</strong></p><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p></blockquote><p>用管道编写一个筛选质数的筛选器，可以参考超链接和下图：</p><p>目标是使用pipe和fork来设置管道。第一个进程将数字2到35输入到管道中。对于每个素数，您将安排创建一个进程，该进程通过一个管道从左边的邻居读取数据，并通过另一个管道向右边的邻居写入数据。由于 xv6的文件描述符和进程数量有限，因此第一个进程可以停留在35个。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805214744151.png" alt="image-20240805214744151"></p><p><strong>思路</strong></p><p>因为稍微有一点复杂，建议理一理思路后再动手。</p><p>每次将符合要求的全部传入管道中，第一个传的一定是素数，直接打印，然后将其他符合要求的再次传入管道并传给子进程。我自己的方法是递归处理，并没有完全利用到多进程的性能，如果有改进的办法，可以提出来讨论一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL (int*)0</span></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个管道</span></span><br><span class="line">    <span class="type">int</span> pipe_fa[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(pipe_fa);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> main_pid=fork();</span><br><span class="line">    <span class="comment">// 子线程</span></span><br><span class="line">    <span class="keyword">if</span>(main_pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[WRITE]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 定义子线程</span></span><br><span class="line">            <span class="type">int</span> pipe_child[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">pipe</span>(pipe_child); </span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num;</span><br><span class="line">            <span class="type">int</span> res_read = <span class="built_in">read</span>(pipe_fa[READ],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            <span class="keyword">if</span>(res_read==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            ans[cnt++]=num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,num);</span><br><span class="line">            <span class="comment">// printf(&quot;debug:answer generate%d\n&quot;,num);</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> res_read_ = <span class="built_in">read</span>(pipe_fa[READ],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                <span class="comment">// printf(&quot;debug:read num:%d res_read_:%d\n&quot;,num,res_read_);</span></span><br><span class="line">                <span class="keyword">if</span>(res_read_==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num%ans[cnt<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="built_in">write</span>(pipe_child[WRITE],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(pipe_child[WRITE]);</span><br><span class="line">            <span class="comment">// printf(&quot;debug:finish %d\n&quot;,num);</span></span><br><span class="line">            <span class="comment">// 循环迭代</span></span><br><span class="line">            <span class="type">int</span> pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 子线程</span></span><br><span class="line">                pipe_fa[READ] = <span class="built_in">dup</span>(pipe_child[READ]);</span><br><span class="line">                <span class="built_in">close</span>(pipe_child[READ]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 父线程</span></span><br><span class="line">                <span class="built_in">close</span>(pipe_child[READ]);</span><br><span class="line">                <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[READ]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">write</span>(pipe_fa[WRITE],&amp;i,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[WRITE]);</span><br><span class="line">        <span class="comment">// printf(&quot;debug:main input[2~35]\n&quot;);</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);       <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;cnt;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;,ans[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805214107322.png" alt="image-20240805214107322"></p><h2 id="Lab2">Lab2</h2><h3 id="System-call-tracing-moderate">System call tracing (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)</h3><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>在这个作业中，您将添加一个系统调用跟踪特性，它可以帮助您调试以后的实验室。您将创建一个新的跟踪系统调用来控制跟踪。它应该采用一个参数，一个整数“掩码”，其位指定哪个系统调用跟踪。例如，为了跟踪 fork 系统调用，程序调用 trace (1 &lt; &lt; SYS _ fork) ，其中 SYS _ fork 是 kernel/syscall.h 中的系统调用号。如果在掩码中设置了系统调用的编号，则必须修改 xv6内核，以便在每个系统调用即将返回时输出一行。这一行应该包含进程 id、系统调用的名称和返回值; 您不需要打印系统调用参数。跟踪系统调用应该能够跟踪调用它的进程及其随后分支的任何子进程，但不应影响其他进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ trace 2147483647 grep hello README</span><br><span class="line">4: syscall trace -&gt; 0</span><br><span class="line">4: syscall <span class="built_in">exec</span> -&gt; 3</span><br><span class="line">4: syscall open -&gt; 3</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">4: syscall close -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408</span><br><span class="line">408: syscall fork -&gt; 409</span><br><span class="line">409: syscall fork -&gt; 410</span><br><span class="line">410: syscall fork -&gt; 411</span><br><span class="line">409: syscall fork -&gt; 412</span><br><span class="line">410: syscall fork -&gt; 413</span><br><span class="line">409: syscall fork -&gt; 414</span><br><span class="line">411: syscall fork -&gt; 415</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先聊下添加系统调用的步骤：</p><p>添加系统调用主要有以下几步：</p><ul><li>在user/user.h中添加系统调用函数的定义。</li><li>在user/usys.pl中添加入口，这个文件将会在make后生成user/usys.S文件，在该汇编文件中，每个函数就只有三行，将系统调用号通过li(load imm)存入a7寄存器，之后使用ecall进入内核态，最后返回。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exit</span><br></pre></td></tr></table></figure><ul><li><p>在kernel/syscall.h中定义系统调用号。</p></li><li><p>在kernel/syscall.c的syscalls函数指针数组中添加对应的函数。在syscall函数中，先读取trapframe-&gt;a7获取系统调用号，之后根据该系统调用号查找syscalls数组中的对应的处理函数并调用。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805235021773.png" alt="image-20240805235021773"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">initlock</span>(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)<span class="built_in">PGROUNDUP</span>((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    <span class="built_in">kfree</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kfree</code> 函数的主要功能是将一个内存页标记为空闲，并将其添加到空闲内存链表中。它首先检查传入的地址是否有效，然后填充内存页以捕获悬空引用，最后将内存页添加到空闲链表中，并确保操作是线程安全的。这样可以确保内存页在后续的内存分配中可以被重新使用。</p><p>整个详细流程可见：</p><ul><li><p><a href="https://juejin.cn/user/2392979529797981/posts">[mit6.s081] 笔记 Lab2: System calls | 系统调用</a></p></li><li><p><a href="https://blog.csdn.net/ahundredmile/article/details/125512247">6.S081 Lab00 xv6启动过程（从代码出发，了解操作系统启动过程）</a></p></li><li><p><a href="https://leenjewel.github.io/blog/2015/11/11/%5B%28xue-xi-xv6%29%5D-nei-he-gai-lan/">【学习Xv6】 内核概览</a></p></li><li><p><a href="https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#25-lab-2-system-calls">MIT 6.S081 Lecture Notes</a></p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805234706950.png" alt="image-20240805234706950"></p>]]></content>
    
    
    <summary type="html">XV6-热身环节</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>32位的int和32位的float，谁能表示的数多</title>
    <link href="https://penge666.github.io/posts/7b5b2d72.html"/>
    <id>https://penge666.github.io/posts/7b5b2d72.html</id>
    <published>2024-07-15T11:58:22.000Z</published>
    <updated>2024-08-06T14:59:44.768Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://www.cnblogs.com/any91/p/14784786.html">同样是占32个坑，凭啥你float就比int的范围更大？</a></h1><p>原文出处：<a href="https://zhuanlan.zhihu.com/p/84453627?from_voters_page=true">https://zhuanlan.zhihu.com/p/84453627?from_voters_page=true</a></p><p>ok，这里先说明一下，假设是在32位的机器上，int是32位。而float使用的是IEEE 754标准的单精度浮点数格式也是占用32位。</p><p>这时候float和int都是占用32位，占用同样的空间，但float范围是更大的，那我们为啥还要int呢？为啥不节省空间，只用float？我们来一探究竟！他们在计算机的大脑里是如何记忆的？</p><p><strong>ok，这里先说明一下，假设是在32位的机器上，int是32位。而float使用的是IEEE 754标准的单精度浮点数格式也是占用32位。</strong></p><p>这时候float和int都是占用32位，占用同样的空间，但float范围是更大的，那我们为啥还要int呢？为啥不节省空间，只用float？我们来一探究竟！他们在计算机的大脑里是如何记忆的？</p><h2 id="1、int对32个坑是如何使用的？">1、int对32个坑是如何使用的？</h2><p>int类型的使用方法，大多学过计算机的，应该都是非常清楚的。二进制存储即可。</p><p><strong>例1：请写出165(10进制)使用32位int型存储在计算机中的形式。</strong></p><p>10进制转换为2进制，我个人喜欢先转为16进制，再写成2进制。</p><p>如下： 16510⇒10×16+5×1⇒A516⇒10100101</p><p>那么165在32位int型中是这样存储的（中间的0，我省略了）：</p><p><img src="https://pic4.zhimg.com/80/v2-d275288a53e69f37d8d1a1e4842da7cb_720w.webp" alt="img"></p><p>165在计算机中的int存储</p><p>非常简单明了，好理解。把10进制转换2进制，直接存进去就ok，前面空位补0。</p><p><strong>例2：请写出-165(10进制)使用32位int型存储在计算机中的形式。</strong></p><p>这是一个负数，按照惯例int型首位为符号位。0表示在正数，1表示负数。</p><p>如下： −16510⇒−(10×16+5×1)⇒100⋅⋅⋅10100101</p><p>但在计算机中，负数存储的是补码，不是原码。</p><p>他们之间按照如下转换：</p><p><strong>原码：1000 0000 1010 0101</strong></p><p><strong>反码：1111 1111 0101 1010</strong> （除了符号位，其它取反）</p><p><strong>补码：1111 1111 0101 1011</strong> （在反码的基础上加1即可）</p><p>那么-165在32位int型中是这样存储的（中间的1，我省略了）：</p><p><img src="https://pic2.zhimg.com/80/v2-d08661c3d813990cdcff8a7e728be789_720w.webp" alt="img"></p><p>-165在计算机中的int存储</p><p>比正数复杂了一点，但是还是可以很容易算出来的。</p><p>问题来了？为啥负数要用补码？这不是挑事吗？原码不好吗？</p><p><img src="https://pic4.zhimg.com/80/v2-6972d84f8d2fb7e050c16bf77b3743f7_720w.webp" alt="img"></p><p>原因之一在于，我们计算： 165+(−165)=0 ，在计算机中存储的是二进制，</p><p>如果使用原码进行计算，需要单独把符号位拿出来，再做减法运算，而把符号位区分出来是需要额外的硬件电路支撑的，这很不方便。</p><p>如果使用补码，如下所示（这里按照16位进行举例）：</p><p>0000 0000 1010 0101 + 1111 1111 0101 1011=0000 0000 0000 0000；</p><p>使用补码参与运算后，无需再管符号位，可以让符号位直接参与运算。这就是使用补码的最大的好处。到这里大家有没有发现，int型的这种存储方案是没有考虑小数的，所以这是整型的。关于int型的存储，不再赘述，整体来说还是清晰明了的一种方案。</p><hr><h2 id="2、float对32个坑是如何使用的？">2、float对32个坑是如何使用的？</h2><p>同样也是占用32个坑，float型的范围比int就大很多，而且还能表示小数，那么它到底是如何利用这32个坑的呢？</p><p><strong>例3：请写出165.25(10进制)使用float型存储在计算机中的形式。</strong></p><p>同样我们还是先转换为2进制：165.2510⇒ <strong>1010 0101 . 0100</strong></p><p>那么如何把上面的二进制小数存到32个坑里呢？</p><p>在填坑之前，我们先要规范二进制小数的表示形式，就和我们的科学计数法一样的道理。</p><p>（就像 123.6 要写成 1.236×102 这个样子，把所有的小数换成统一的格式）</p><p>IEEE754标准做了这样的规定：当尾数(小数)不为0时，<strong>尾数域的最高有效位为1</strong>，这称为浮点数的规格化。</p><p>例如： 10100101.0100⇒1.01001010100×27</p><p>规格化后的二进制小数，有了统一的规格，可以发现这样规格化之后，我们只需要存储一个尾数（即小数部分，整数部分恒为1）和指数部分。</p><p>IEEE754标准把float型的32个坑做了如下划分：</p><p><img src="https://pic3.zhimg.com/80/v2-ab70e3260e17f51f27b53bb45cca0a7a_720w.webp" alt="img"></p><p>其中包含了1位符号位S，8位阶码E和23位尾数M。</p><p>1.01001010100×27 ，要存储这个二进制小数；</p><p>首先符号位S，<strong>0</strong>表示正数，<strong>1</strong>表示负数。<strong>S=0</strong>；</p><p>再写出尾数M，即：<strong>M=0100 1010 1000 0000 0000 000</strong>；</p><p>然后算出阶码E，这里指数为：<strong>e=7=0000 0111</strong>，根据标准要求，E=e+127；</p><p>即：<strong>E=7+127=134=1000 0110</strong>；</p><p>那么把这三个数都填进坑里，就ok啦。</p><p><img src="https://pic2.zhimg.com/80/v2-5a112a8353f2050f65eae389780a5579_720w.webp" alt="img"></p><p>165.25在计算机中的float储存</p><p>这个计算过程稍微复杂点，但也还可以手算出来。</p><p><img src="https://pic3.zhimg.com/80/v2-34f77d9cdabf5cf49b28d2c78a3a812a_720w.webp" alt="img"></p><p>但是问题又来了：</p><p>1、浮点数的表示范围有多大？</p><p>2、为什么要用指数加上127，才是阶码E，而不是直接用指数存进去？</p><p>3、这个过程可以看出float有效位是尾数M加1也就是24位，阶码E只是我们规范科学计数法记录指数的，但int有效位是32位，float实际有效位比int少，那么在相互转换的过程中会出现什么问题？</p><p>我依次解释这3个问题：</p><p><strong>1、浮点数的表示范围有多大？</strong></p><p><img src="https://pic4.zhimg.com/80/v2-c357fa1691ded5da725e94d29bfad20f_720w.webp" alt="img"></p><p>float型定义的正无穷大</p><p><img src="https://pic2.zhimg.com/80/v2-6a52c35f1cb54f1d56993818a127b95d_720w.webp" alt="img"></p><p>float型定义的负无穷大</p><p>可以得出当<strong>E= 1111 1111</strong>时，指数为255-127=128，但这并不是表示这个数是： 1×2128 ，在IEEE754把这种情况定义为无穷大，此时尾数必须全部为0，不能有其他值，否则就认为无效数字。</p><p>那么除了无穷大这个特殊的、人为定义的情况，float型能表示的最大的正整数是多少？最小的负整数是多少？当<strong>E= 1111 1111</strong>时，是IEEE754定义的特殊值即为无穷大，那么除此之外的最大值就是：<strong>E= 1111 1110</strong>，M也取最大值，即得到如下结果：</p><p><img src="https://pic4.zhimg.com/80/v2-5954a5358cec9a68e62eed2b8f98f433_720w.webp" alt="img"></p><p>float型能存储的最大正整数</p><p>此时阶码E为254，指数即为e=254-127=127。这个数即为：</p><p>1.11111111111111111111111×2127 ；</p><p>对于尾数我们可以换一个写法：</p><p><strong>1.1111 1111 1111 1111 1111 111=10-0.0000 0000 0000 0000 0000 001</strong></p><p>这样尾数可以写成： 2−2−23 ；</p><p>那么float能够表示的最大正整数就是： (2−2−23)×2127 ，即为 2128−2104 。</p><p>那么float能够表示的最小负整数就是： 2104−2128 。</p><p><strong>2、为什么要用指数加上127，才是阶码E，而不是直接用指数存进去？</strong></p><p>这就很容易说明了，我们举个例子：</p><p><strong>例4：请写出0.75(10进制)使用float型存储在计算机中的形式。</strong></p><p>写成二进制：0.7510=0.11 。再写成规划化的计数法： 1.1×2−1 ；</p><p>发现问题了没有？这次的指数是个负数啦，而我们希望存储到机器里的阶码永远都是正值，因为我们不希望再浪费一个坑去保存阶码的正负号，于是乎，干脆把指数加上127，而指数能取到的最小值就是-127，这样就可以保证阶码<strong>E</strong>永远都是正数啦，我们就不用再考虑指数正负号的问题了。</p><p><strong>E=-1+127=126=0111 1110；</strong></p><p><strong>M=1000 0000 0000 0000 0000 000；</strong></p><p><img src="https://pic3.zhimg.com/80/v2-c6bb9c6bfd42cf2bfc7b805214ce8bfe_720w.webp" alt="img"></p><p>0.75在计算机中的float储存</p><p><strong>3、这个过程可以看出float有效位是尾数M加1也就是24位，阶码E只是我们用于规范科学计数法记录指数的，但int有效位是32位，float实际有效位比int少，那么在相互转换的过程中会出现什么问题？</strong></p><p>通过问题1知道，float型的表示范围是比int大很多的，但有效位确实只有24位。既然float范围大，那么所有的int型都是可以转换为float型的，这是不会产生溢出报错的。但因为int型有效位是32位，是比float型的24位大的，是有可能发生舍入的，即当一个int型数字，转成float型后，可能就不再是原本数字了，损失了一定的精度。</p><p>例如2进制int型正数：<strong>0111 1111 1111 1111 1111 1111 1111 1111</strong>；</p><p>写成科学计数法即为： 1.11111111111111111111111111111111×230</p><p>小数点后面有30个1，但是我们知道float种尾数M只有23个坑。</p><p>则转化为float型后，阶码<strong>E=30+127=157=1001 1101</strong></p><p><img src="https://pic2.zhimg.com/80/v2-b77b9dbf319006623f273cfc1542c485_720w.webp" alt="img"></p><p>可以发现，我们对原int型中存储的数字只保留了小数点后23个1，而后面7个，直接忽视了，这就是发生了舍入。</p>]]></content>
    
    
    <summary type="html">32位的int和32位的float，谁能表示的数多</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈分段,分页的理解</title>
    <link href="https://penge666.github.io/posts/40df8a20.html"/>
    <id>https://penge666.github.io/posts/40df8a20.html</id>
    <published>2024-07-14T12:19:31.000Z</published>
    <updated>2024-08-06T13:51:34.119Z</updated>
    
    <content type="html"><![CDATA[<p>一道很经典的OS面试题~</p><p>我们知道<strong>操作系统本质就是虚拟化</strong>：</p><ol><li><strong>CPU虚拟化</strong>：操作系统允许多个程序共享CPU资源，通过时间分片（time-slicing）或多任务处理（multitasking）技术，使得每个程序都认为自己独占CPU。</li><li><strong>内存虚拟化</strong>：操作系统通过虚拟内存管理技术（如分页和分段），为每个程序提供一个连续的地址空间，即使物理内存是分散的。这样，程序可以使用比实际物理内存更大的地址空间。</li><li><strong>存储虚拟化</strong>：操作系统通过文件系统接口，将物理存储设备（如硬盘或SSD）抽象为文件和目录，使得用户和应用程序可以方便地存储和检索数据，而不需要关心底层的物理存储细节。</li><li><strong>I/O设备虚拟化</strong>：操作系统通过设备驱动程序，将物理I/O设备（如键盘、鼠标、显示器、网络接口等）抽象为统一的接口，使得应用程序可以方便地与这些设备交互。</li><li><strong>网络虚拟化</strong>：现代操作系统还支持网络虚拟化技术，如虚拟网络接口和网络命名空间，使得多个网络配置可以在同一物理网络上共存，而不会相互干扰。</li></ol><p>接下来聊聊内存虚拟化。</p><h2 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h2><p>​    在早期的计算机中，要运行一个程序，会把这些程序全都装入内存，程序都是直接运行在内存上的，也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。那当程序同时运行多个程序时，操作系统是如何为这些程序分配内存的呢？下面通过实例来说明当时的内存分配方法：</p><p>   某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806202253933.png" alt="image-20240806202253933"></p><p><strong>问题1：进程地址空间不隔离</strong>。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。</p><p><strong>问题2：内存使用效率低</strong>。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p><p><strong>问题3：程序运行的地址不确定</strong>。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。</p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>　　为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。<strong>按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</strong></p><p>​      当创建一个进程时，操作系统会为该进程分配一个4GB大小的虚拟进程地址空间。之所以是4GB，是因为在32位的操作系统中，一个指针长度是4字节，而4字节指针的寻址能力是从0x00000000~0xFFFFFFFF，最大值0xFFFFFFFF表示的即为4GB大小的容量。与虚拟地址空间相对的，还有一个物理地址空间，这个地址空间对应的是真实的物理内存。如果你的计算机上安装了512M大小的内存，那么这个物理地址空间表示的范围是0x00000000~0x1FFFFFFF。当操作系统做虚拟地址到物理地址映射时，只能映射到这一范围，操作系统也只会映射到这一范围。当进程创建时，每个进程都会有一个自己的4GB虚拟地址空间。要注意的是这个4GB的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的地址隔离。那是不是这4GB的虚拟地址空间应用程序可以随意使用呢？很遗憾，在Windows系统下，这个虚拟地址空间被分成了4部分：NULL指针区、用户区、64KB禁入区、内核区。应用程序能使用的只是用户区而已，大约2GB左右(最大可以调整到3GB)。内核区为2GB，内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享，但应用程序是不能直接访问的。</p><p>​     <strong>人们之所以要创建一个虚拟地址空间，目的是为了解决进程地址空间隔离的问题。但程序要想执行，必须运行在真实的内存上，所以，必须在虚拟地址与物理地址间建立一种映射关系。这样，通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值。人们想到了一种分段(Sagmentation)的方法，它的思想是在虚拟地址空间和物理地址空间之间做一一映射。比如说虚拟地址空间中某个10M大小的空间映射到物理地址空间中某个10M大小的空间。这种思想理解起来并不难，操作系统保证不同进程的地址空间被映射到物理地址空间中不同的区域上，这样每个进程最终访问到的</strong></p><p>​      物理地址空间都是彼此分开的。通过这种方式，就实现了进程间的地址隔离。还是以实例说明，假设有两个进程A和B，进程A所需内存大小为10M，其虚拟地址空间分布在0x00000000到0x00A00000，进程B所需内存为100M，其虚拟地址空间分布为0x00000000到0x06400000。那么按照分段的映射方法，进程A在物理内存上映射区域为0x00100000到0x00B00000，，进程B在物理内存上映射区域为0x00C00000到0x07000000。于是进程A和进程B分别被映射到了不同的内存区间，彼此互不重叠，实现了地址隔离。从应用程序的角度看来，进程A的地址空间就是分布在0x00000000到0x00A00000，在做开发时，开发人员只需访问这段区间上的地址即可。应用程序并不关心进程A究竟被映射到物理内存的那块区域上了，所以程序的运行地址也就是相当于说是确定的了。 图二显示的是分段方式的内存映射方法。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806202355700.png" alt="image-20240806202355700"></p><p>　　这种分段的映射方法虽然解决了上述中的问题一和问题三，但并没能解决问题二，即内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序，这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。实际上，程序的运行有局部性特点，在某个时间段内，程序只是访问程序的一小部分数据，也就是说，程序的大部分数据在一个时间段内都不会被用到。基于这种情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页(Paging)。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>   分页的基本方法是，将地址空间分成许多的页。每页的大小由CPU决定，然后由操作系统选择页的大小。目前Inter系列的CPU支持4KB或4MB的页大小，而PC上目前都选择使用4KB。按这种选择，4GB虚拟地址空间共可以分成1048576个页，512M的物理内存可以分为131072个页。显然虚拟空间的页数要比物理空间的页数多得多。</p><p>​      在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分<strong>页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</strong></p><p>​     下面通过介绍一个<strong>可执行文件的装载过程来说明分页机制的实现方法</strong>。一个可执行文件(PE文件)其实就是一些编译链接好的数据和指令的集合，它也会被分成很多页，在PE文件执行的过程中，它往内存中装载的单位就是页。当一个PE文件被执行时，操作系统会先为该程序创建一个4GB的进程虚拟地址空间。前面介绍过，虚拟地址空间只是一个中间层而已，它的功能是利用一种映射机制将虚拟地址空间映射到物理地址空间，所以，创建4GB虚拟地址空间其实并不是要真的创建空间，只是要创建那种映射机制所需要的数据结构而已，这种数据结构就是页目和页表。</p><p>​      当创建完虚拟地址空间所需要的数据结构后，进程开始读取PE文件的第一页。在PE文件的第一页包含了PE文件头和段表等信息，进程根据文件头和段表等信息，将PE文件中所有的段一一映射到虚拟地址空间中相应的页(PE文件中的段的长度都是页长的整数倍)。这时PE文件的真正指令和数据还没有被装入内存中，操作系统只是根据PE文件的头部等信息建立了PE文件和进程虚拟地址空间中页的映射关系而已。当CPU要访问程序中用到的某个虚拟地址时，当CPU发现该地址并没有相相关联的物理地址时，CPU认为该虚拟地址所在的页面是个空页面，CPU会认为这是个页错误(Page Fault)，CPU也就知道了操作系统还未给该PE页面分配内存，CPU会将控制权交还给操作系统。操作系统于是为该PE页面在物理空间中分配一个页面，然后再将这个物理页面与虚拟空间中的虚拟页面映射起来，然后将控制权再还给进程，进程从刚才发生页错误的位置重新开始执行。由于此时已为PE文件的那个页面分配了内存，所以就不会发生页错误了。随着程序的执行，页错误会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。</p><p>​       分页方法的核心思想就是当可执行文件执行到第x页时，就为第x页分配一个内存页y，然后再将这个内存页添加到进程虚拟地址空间的映射表中,这个映射表就相当于一个y=f(x)函数。应用程序通过这个映射表就可以访问到x页关联的y页了。</p><p>补充：<a href="https://www.zhihu.com/question/50796850/answer/522734117">怎样通俗的理解操作系统中内存管理分页和分段？</a></p>]]></content>
    
    
    <summary type="html">OS-分段/分页</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL学习笔记</title>
    <link href="https://penge666.github.io/posts/26565af3.html"/>
    <id>https://penge666.github.io/posts/26565af3.html</id>
    <published>2024-07-13T09:05:35.000Z</published>
    <updated>2024-07-13T13:34:22.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>为什么叫allocator空间配置器，而不叫内存配置器？<br>因为空间不一定是内存，也可能是磁盘或其他辅助存储介质。可以写一个allocator，直接向硬盘取空间。</p><p>不过，实际上，我们最常用的就是用于配置内存。</p><h2 id="空间配置器的标准接口">空间配置器的标准接口</h2><p>allocator标准接口：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line">    一个嵌套的（nested）<span class="keyword">class</span> template。<span class="keyword">class</span> rebind&lt;U&gt; 拥有唯一成员other, 那是一个typedef, 代表allocator&lt;U&gt;.</span><br><span class="line">allocator::allocator()</span><br><span class="line">    <span class="keyword">default</span> <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&amp;)</span><br><span class="line">    copy <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">template</span>&lt;<span class="title">class</span> <span class="title">U</span>&gt; <span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line">    泛化的copy <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">allocator</span>:</span>:~allocator()</span><br><span class="line">    <span class="keyword">default</span> <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">pointer</span> <span class="title">allocator</span>:</span>:address(reference x) <span class="keyword">const</span></span><br><span class="line">    返回某个对象的地址. 算式a.address(x)等同于&amp;x</span><br><span class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></span><br><span class="line">    返回某个<span class="keyword">const</span>对象的地址. 算式a.address(x)等同于&amp;x</span><br><span class="line">pointer allocator::allocate(size_type n, <span class="keyword">const</span> void* = <span class="number">0</span>)</span><br><span class="line">    配置空间, 足以存储n个T对象. 第二参数是个提示. 实现上可能会利用它来增进区域性(locality), 或完全忽略之</span><br><span class="line">void allocator::deallocate(pointer p, size_type n)</span><br><span class="line">    归还先前配置的空间</span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span></span><br><span class="line">    返回可成功配置的最大量</span><br><span class="line">void allocator::construct(pointer p, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">    等同于 new ((<span class="keyword">const</span> void*)p) T(x)</span><br><span class="line">void allocator::destroy(pointer p)</span><br><span class="line">    等同于p-&gt;~T()</span><br></pre></td></tr></table></figure><h2 id="两种空间配置器">两种空间配置器</h2><p><a href="http://www.rrsd.com/software_development/stl/stl/index.html">SGI STL</a>有2个种空间配置器：<br>1）std::allocator，符合STL标准，但很少使用，也不建议使用。因为只是把::operator new和::operator delete做了一层薄薄封装，效率差。<br>2）std::alloc，SGI特殊空间配置器，将配置器分为两级，兼顾了效率与内存碎片问题，效率高。推荐使用。</p><p>下面主要讲的也是std::alloc。</p><h3 id="空间配置器的职责">空间配置器的职责</h3><p>通常，我们习惯用new、delete对C++ 内存配置进行申请、释放操作。比如，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;...&#125;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure><p>其中，new操作内含2阶段操作：<br>1）调用::operator new配置内存。<br>2）调用Foo::Foo()构造对象。</p><p>delete操作也内含2阶操作：<br>1）调用Foo::~Foo()析构对象；<br>2）调用::operator delete释放内存；</p><p>而STL的allocator（空间配置器）把这两阶段操作分开了。其中，内存配置（申请）由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由全局::construct()负责，对象析构由全局::destroy()负责。</p><h2 id="配置器allocator文件说明">配置器allocator文件说明</h2><p>STL标准规定，配置器定义于<code>&lt;memory&gt;</code>，而SGI <code>&lt;memory&gt;</code>内含3个与配置器相关的文件：<br>1）&lt;stl_construct.h&gt; 定义了全局函数construct(), destroy(), 负责对象的构造和析构。隶属于STL标准规范。<br>2）&lt;stl_alloc.h&gt; 定义了一、二级配置器，彼此合作。配置器名为alloc。<br>3）&lt;stl_uninitialized.h&gt; 定义一些全局函数，用来填充（fill）或复制（copy）大块内存数据。都属于STL标准规范：</p><ul><li>un_initialized_copy()</li><li>un_initialized_fill()</li><li>un_initialized_fill_n()<br>3个函数不属于配置器范畴，但与对象初值设置有关。对于容器的大规模元素初值设置很有帮助。这些函数对于效率都有面面俱到的考虑，最差情况下会调用construct()。最佳情况则会使用C标准函数memmove()直接进行内存数据的移动。</li></ul><h2 id="构造和析构工具：construct-destroy">构造和析构工具：construct, destroy</h2><p>全局函数<strong>construct(), destroy()在已配置内存的基础上，用于对象的构造和析构</strong>。<br>因此，construct()需要原生内存（native memory）地址和要构造对象类型，可能包含初值（列表）用于构造对象作为参数。<br>destroy有两种形式：1）析构单个对象，提供对象指针即可；2）析构迭代器区间所有对象，提供迭代器区间[first, last)。</p><p>注意：如果是原始类型区间，如char* [start, end)，则不需要析构，因为没有构建对象。</p><p>可以得到construct和destroy的模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stl_construct.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _Construct(T1* p) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="type">void</span>*) p) <span class="built_in">T</span>(); <span class="comment">// placement new; 调用T::T()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value); <span class="comment">// placement new; 调用T1::T1(value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第一个版本, 接受一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">       pointer-&gt;~<span class="built_in">T</span>(); <span class="comment">// 调用dtor ~T()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第二个版本, 接受两个迭代器. 次函数设法找出元素的数值型别,</span></span><br><span class="line"><span class="comment">// 进而利用__type_traits&lt;&gt;求取最适当措施</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">       __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型别(value type)是否有trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) &#123;</span><br><span class="line">       <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor  trivial_destructor;</span><br><span class="line">       __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型别(value type)有non-trivial destructor, 则派送(dispatch)到这里</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last,  __false_type) &#123;</span><br><span class="line">       <span class="keyword">for</span> (; first &lt; last; ++first)</span><br><span class="line">              <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型别(value type)有trivial destructor, 则派送(dispatch)到这里</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last,  __true_type) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy() 第二版针对迭代器为char*和wchar_t*的特化版</span></span><br><span class="line"><span class="comment">// 原生指针区间不需要析构, 因为没有对象, 类似地，还有int*, long*, float*, double*，这里省略</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>代码中一组__destroy()是辅助实现destroy()的，编译器会在编译期根据萃取出参数的类型（value type）。接着萃取出trivial_destructor特性，判断是否支持trivial_destructor（平凡的析构函数，说明没有申请动态内存），如果支持（特性为__true_type），就不需要专门调用析构函数；如果不支持（特性为__false_type），就需要针对迭代器区间每个元素，逐个调用析构函数。<br>如果迭代器区间包含元素较多，这能节省不少时间。</p><h2 id="空间配置与释放，std-alloc">空间配置与释放，std::alloc</h2><p><strong>std::alloc 负责内存的配置和释放</strong>。对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责，SGI对此设计哲学：</p><ul><li>向system heap要求空间。</li><li>考虑多线程（multi-threads）状态。</li><li>考虑内存不足时的应变措施。</li><li>考虑过多“小型区块”可能造成的内存碎片（fragment）问题。</li></ul><p>本文为控制问题复杂度，以下讨论及源码，皆排除多线程。</p><p>C++的内存配置基本操作::operator new()，内存释放基本操作 ::operator delete()。这2全局函数相当于C的malloc()和free()。SGI正是以malloc()和free()完成内存的配置与释放的，但SGI STL的std::alloc不能使用operator new/delete，因为new/delete会直接构造/析构对象，而这不符合std::alloc职责。</p><p><strong>std::alloc设计基本思想</strong><br>为避免小型区块可能造成的内存碎片问题，SGI STL设计了双层级配置器：<br>1）第一级配置器，直接使用malloc(), free()；<br>2）第二级配置器，视情况采用不同策略：<br>当配置区块 &gt; 128bytes时，视为“足够大”，便调用第一级配置器；<br>当配置区块 &lt;= 128bytes时，视为“过小”，交给memory pool（内存池）来管理，不再求助于第一级配置器。</p><p>设计可以只开放第一级配置器，可以同时开启。取决于__USE_MALLOC是否被定义（SGI STL并未定义__USE_MALLOC）。</p><p>SGI STL的两级配置器：__malloc_alloc_template是第一级配置器，__default_alloc_template是第二级配置器。alloc不接受任何template型别参数。并且，SGI还在此基础上，用simple_alloc包装了一个接口，对用户屏蔽内部细节，使之符合STL规格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stl_alloc.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部4个成员函数都是单纯的转发调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123; <span class="comment">// simple_alloc包装第一级配置器和第二级配置器, 用户传入模板参数给Alloc即可</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">// 配置n个单位T类型对象的原始空间</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T*)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     <span class="comment">// 配置1个单位T类型对象的原始空间</span></span><br><span class="line">              <span class="keyword">return</span> (T*)Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p, <span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">// 释放n个单位T类型对象的原始空间</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p)</span> </span>&#123; <span class="comment">// 释放1个单位T类型对象的原始空间</span></span><br><span class="line">              Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了转发调用，simple_alloc包装配置器还将接口的配置单位，由byte转换成了元素的大小（sizeof(T)）。SGI STL容器全部使用这个simple_alloc接口。<br>例如，vector的专属空间配置器data_allocator，就是simple_alloc&lt;value_type, Alloc&gt;，当然Alloc取决于我们传入vector的配置器类型（一级或二级），缺省是std::alloc。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">// 使用缺省alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">       <span class="comment">// 专属空间配置器, 每次配置一个元素大小</span></span><br><span class="line">       <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (...)</span><br><span class="line">                     data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一级配置器：-malloc-alloc-template">第一级配置器：__malloc_alloc_template</h2><ol><li>allocate() 直接使用malloc(), deallocate() 直接使用free()；</li><li>模拟C++的set_new_handler()以处理内存不足的状况。</li></ol><p>set_new_handler只有针对placement new申请内存时，才有效；用malloc申请时，无效。需要借助malloc返回值为空，进行申请内存失败判断。</p><p><strong>如何选择使用哪个配置器？</strong><br>定义或取消宏__USE_MALLOC，就能决定alloc的实际类型（一级配置器 or 二级配置器）。SGI STL并未定义__USE_MALLOC，因此SGI默认使用的二级配置器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc single_client_alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt; single_client_alloc;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="一级配置器实现">一级配置器实现</h3><p>用malloc(), free(), realloc()等C函数执行实际的内存配置、释放、重新配置，并模拟实现类似于C++ new-handler异常处理机制。不能直接使用new-handler机制，因为并没有用::operator new配置内存，而是用的malloc。</p><p><strong>C++ new handler机制是什么？</strong><br>指你可以要求系统在内存配置需求无法被满足时，调用一个你指定的函数，来进行异常处理。i.e. 一旦::operator new无法完成任务，在抛出std::bad_alloc异常前，会先调用由客户端指定的处理例程。 (见<a href="https://www.cnblogs.com/fortunely/p/15682123.html">《Effective C++》条款49</a>）</p><p><strong>谁负责注册、设计“内存不足处理例程”？</strong><br>设计“内存不足处理例程”是客户端的责任，注册“内存不足处理例程”也是客户端的责任。也就是，客户负责调用set_malloc_handler()注册内存不足处理例程，并定义传入实参（内存不足如何处理）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stl_alloc.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一级配置器</span></span><br><span class="line"><span class="comment">// 用于异常处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __THROW_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span> defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)</span></span><br><span class="line"><span class="meta">#    <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __THROW_BAD_ALLOC fprintf(stderr, <span class="string">&quot;out of memory\n&quot;</span>); exit(1)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span> <span class="comment">/* Standard conforming out-of-memory handling */</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __THROW_BAD_ALLOC throw std::bad_alloc()</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc-based allocator 通常比default alloc速度慢</span></span><br><span class="line"><span class="comment">// 一般而言是thread-safe, 并且对空间的运用比较高效(efficient)</span></span><br><span class="line"><span class="comment">// 以下是第一级配置</span></span><br><span class="line"><span class="comment">// 注意， 无&quot;template型别参数&quot;. 至于&quot;非型别参数&quot;inst, 则完全没派上用场</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// 以下都是函数指针, 所代表的函数将用来处理内存不足的情况</span></span><br><span class="line">       <span class="comment">// oom: out of memory.</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;            <span class="comment">// 模拟C++ placement new, 不断尝试配置内存, 调用客户注册的处理例程或抛出异常</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*, <span class="type">size_t</span>)</span></span>;    <span class="comment">// 模拟C++ placement new, 不断尝试重新配置内存, 调用客户注册的处理例程或抛出异常</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>; <span class="comment">// 保存客户注册的 内存不足处理例程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">              <span class="type">void</span> *result = <span class="built_in">malloc</span>(n); <span class="comment">// 第一级配置器直接使用malloc()</span></span><br><span class="line">              <span class="comment">// 以下无法满足需求时, 改用oom_malloc()</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> <span class="comment">/*n*/</span>)</span> </span>&#123;</span><br><span class="line">              <span class="built_in">free</span>(p); <span class="comment">// 第一级配置器直接使用free()</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">              <span class="type">void</span> *result = <span class="built_in">realloc</span>(p, new_sz); <span class="comment">// 第一级配置器直接使用realloc()</span></span><br><span class="line">              <span class="comment">// 以下无法满足需求时, 改用oom_realloc()</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下仿真C++的set_new_handler(). 换句话说， 你可以通过它指定自己的out-of-memory handler</span></span><br><span class="line">       <span class="comment">// 注册 内存不足处理例程</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(*set_malloc_handler(<span class="type">void</span>(*f)()))</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="built_in">void</span>(*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">              __malloc_alloc_oom_handler = f;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"><span class="comment">// 初值0, 有待客户端设定</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span></span><br><span class="line"><span class="function"><span class="title">void</span><span class="params">(*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">void</span>(*my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (; ;) &#123; <span class="comment">// 循环尝试配置内存</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)(); <span class="comment">// 调用客户注册的处理例程, 企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);     <span class="comment">// 再次尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span>* p, <span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">void</span>(*my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (; ;) &#123; <span class="comment">// 循环不断尝试释放、配置 ...</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; <span class="comment">// 如果客户没有设置my_malloc_handler, 就抛出异常</span></span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)();    <span class="comment">// 调用客户注册的处理例程, 企图释放内存</span></span><br><span class="line">        result = <span class="built_in">reallocate</span>(p, n); <span class="comment">// 尝试重新配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意, 以下直接将参数inst指定为0</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure><h2 id="第二级配置器：-default-alloc-template">第二级配置器：__default_alloc_template</h2><p>与第一级配置器区别：为避免太多小额区块造成内存碎片，多了一些机制。</p><p>SGI第二级配置做法：如果区块够大，&gt; 128bytes，移交给第一级配置器处理；当区块 &lt; 128bytes，则以内存池（memory pool）管理。<br>这种方法称为<strong>次配置（sub-allocation）</strong>：每次配置一大块内存，并维护对应自由链表（free-list）。下次再有相同大小内存需求时，就直接从free-lists中取出。如果客户端归还小额区块，就由配置器回收到free-lists中。<br>简而言之，二级配置器负责内存配置、回收，会根据区块大小，选择自行配置，还是移交给一级配置器处理。</p><p>因此，可以知道二级配置器多了自由链表和内存池两个机制，专门为处理 &lt;= 128bytes的内存申请而生。</p><h3 id="自由链表-free-lists">自由链表 free-lists</h3><p>二级配置器的核心之一就是free-lists（自由链表），每个free-list代表一类空闲区块，大小从8，16，24，…，到128 （bytes），共16个。16个free-list的头结点，用一个数组free_list[16]表示，下文称之为槽位。每个槽位指向的区块是一个链表，而该区块就是链表的第一个空闲块。</p><p>free-list的精髓就是联合体obj：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free-lists节点结构</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">    <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>一般情况下，我们用next* 和 data的struct来描述链表节点，而obj用obj*的union，这是为什么？</strong><br>因为这样可以节省维护链表的指针空间。一个区块，在分配给客户端之前，首部大小为obj那部分可以看作一个指针free_list_link，用来串成链表；而分配给客户端之后，这部分无需当做指针，可以被客户按需使用；待客户归还区块时，首部大小为obj那部分又会被当做指针，用来串成链表，加入free list。<br>free_list_link所指向的内存区块大小，由链表头结点，即槽位所在free_list[]中的索引决定。而归还时，调用者会记录区块大小。因此，obj不需要额外存储区块大小。</p><p><strong>为什么free-list区块最小尺寸是8byte，而不是4byte？</strong><br>因为64位系统上，指针尺寸8byte；32位系统上，指针尺寸4byte。为了兼容32位、64位系统，取较大值8。</p><p>下图是以96byte区块为例，描述free-lists结构：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212536617.png" alt="image-20240713212536617"></p><h3 id="default-alloc-template-的数据结构">__default_alloc_template 的数据结构</h3><p>SGI STL中，__default_alloc_template 的数据结构签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二级配置器的部分实现内容</span></span><br><span class="line"><span class="keyword">enum</span> &#123; __ALIGN = <span class="number">8</span> &#125;; <span class="comment">// 小型区块上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123; __MAX_BYTES = <span class="number">128</span> &#125;; <span class="comment">// 小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123; __NFREELTISTS = __MAX_BYTES / __ALIGN &#125;; <span class="comment">// free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是第二级配置器</span></span><br><span class="line"><span class="comment">// 注意, 无&quot;template型别参数&quot;, 且第二参数完全没派上用场</span></span><br><span class="line"><span class="comment">// 第一参数用于多线程环境. 本书不讨论多线程环境</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// ROUND_UP() 将bytes上调至8的倍数</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// free-lists节点结构</span></span><br><span class="line">       <span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">              <span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">              <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// 16个free-lists</span></span><br><span class="line">       <span class="type">static</span> obj* <span class="keyword">volatile</span> free_list[__NFREELTISTS];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下函数根据区块大小, 决定使用第n号free-lists. n从1起算</span></span><br><span class="line">       <span class="comment">// 根据要申请的内存空间大小(bytes), 找到free list中不小于bytes的区块, 返回其位于free_list[]的编号</span></span><br><span class="line">       <span class="comment">// e.g. 1) bytes = 96, return = (96 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line">       <span class="comment">// 2) bytes = 95, return = (95 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line">       <span class="comment">// 3) bytes = 97, return = (97 + 8 - 1) / 8 - 1 = 12</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">       <span class="comment">// 配置一大块空间, 可容纳nobjs个大小为&quot;size&quot;的区块</span></span><br><span class="line">       <span class="comment">// 如果配置nobjs个区块有所不便, nobjs可能会降低</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Chunk allocation state</span></span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* start_free; <span class="comment">// 内存池起始位置. 只在chunk_alloc()中变化</span></span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* end_free;   <span class="comment">// 内存池结束位置. 只在chunk_alloc()中变化</span></span><br><span class="line">       <span class="type">static</span> <span class="type">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后*/</span> &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>  <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p , <span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后*/</span> &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">reallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于free-lists，有两个重要操作：<br>1）ROUND_UP() 将参数bytes上调至8的倍数，确保所有操作都是8byte对齐；<br>2）FREELIST_INDEX() 根据参数bytes，在free_list[]中找到合适的槽位：确保区块大小 &gt;= bytes。</p><h3 id="ROUND-UP-向上调对齐">ROUND_UP() 向上调对齐</h3><p>ROUND_UP()实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ROUND_UP() 将bytes上调至8的倍数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (((bytes)+__ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FREELIST-INDEX-找合适槽位">FREELIST_INDEX() 找合适槽位</h3><p>FREELIST_INDEX()实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下函数根据区块大小, 决定使用第n号free-lists. </span></span><br><span class="line"><span class="comment">// 根据要申请的内存空间大小(bytes), 找到free list中不小于bytes的区块, 返回其位于free_list[]的编号</span></span><br><span class="line"><span class="comment">// e.g. 1) bytes = 96, return = (96 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line"><span class="comment">// 2) bytes = 95, return = (95 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line"><span class="comment">// 3) bytes = 97, return = (97 + 8 - 1) / 8 - 1 = 12</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (((bytes)+__ALIGN - <span class="number">1</span>) / __ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocate-空间配置">allocate() 空间配置</h3><p>作为一个配置器，最核心的功能莫过于分配内存、回收内存。allocate()负责分配内存，deallocate()负责回收内存。</p><p>利用allocate()申请n bytes内存流程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212756541.png" alt="image-20240713212756541"></p><p>有3个关键点：<br>1）申请内存空间n &gt; 128bytes时，交给一级配置器处理。而一级配置器的__malloc_alloc_template&lt;&gt;::allocate()在前面已讲过，这里不再遨述。<br>2）n &lt;= 128bytes，在free_list[]数组会找一个适当的区块链表free list，并且该free list有可用空间时，需要将free list链表的第一个空闲数据块交给客户，而自身的指针也同样需要更新。<br>3）在2）的基础上，free list并没有可用空间时，就会调用refill()重新填充该free list。这部分放到下面的refill()函数部分讲解，而内部涉及到memory pool（内存池）的部分，放到下面memory pool部分专门讲解。</p><p><strong>什么时候表示free list有空闲区块？</strong><br>free_list[i]（i=0,1,…15）的free_list_link所指向的下一个链表节点如果非空（非0），代表有空闲区块。而二级指针my_free_list指向free_list[i]（某个槽位）。</p><p>针对情形2），当free list由空闲区块时，拔出第一个空闲区块给客户</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212745601.png" alt="image-20240713212745601"></p><p>二级配置器的allocate()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n must be &gt; 0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">       obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">       obj* result;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// &gt;128, 调用第一级配置器</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123;</span><br><span class="line">              <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n)); <span class="comment">// malloc_alloc即一级配置器 __malloc_alloc_template&lt;0&gt;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">       my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">       result = *my_free_list;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 没找到可用的free list, 准备重新填充free list</span></span><br><span class="line">              <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n)); <span class="comment">/* 后面详述 */</span></span><br><span class="line">              <span class="keyword">return</span> r;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调整free list</span></span><br><span class="line">       *my_free_list = result-&gt;free_list_link;</span><br><span class="line">       <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deallocate-空间释放">deallocate() 空间释放</h3><p>空间释放与空间配置的逆过程，由deallocate()处理，负责回收分配出去的内存空间。总的原则是谁配置的空间，由谁来负责回收。</p><p>不过，与allocate()分配空间不同，deallocate()只有2个关键点，因为不存在内存空间不够的情况。<br>2个关键点：<br>1）回收的空间 n &gt; 128byte时，交给第一级配置器处理；<br>2）n &lt;= 128bytes时，找到适当的free list，然后调整free list，将回收空间加入其中。</p><p>二级配置器回收空间流程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212729258.png" alt="image-20240713212729258"></p><p>二级配置器回收空间结构变化示意图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713213107576.png" alt="image-20240713213107576"></p><p>二级配置器deallocate()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 不可以是0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>  <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p , <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">       obj* q = (obj*)p;</span><br><span class="line">       obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// &gt; 128调用第一级配置器</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123;</span><br><span class="line">              malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找对应free list</span></span><br><span class="line">       my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">       <span class="comment">// 调整free list, 回收区块</span></span><br><span class="line">       q-&gt;free_list_link = *my_free_list;</span><br><span class="line">       *my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当 归还空间大小 &lt;= 128时，deallocate并没有将空间归还给系统，而是交给了free list，方便下次申请。这样可以有效避免内存碎片问题。</p><h3 id="refill-重新填充free-list">refill() 重新填充free list</h3><p>在allocate()中，当发现合适的free list中并没有可用的空闲块时，就会调用refill()为free list重新填充空闲空间。新空间由chunk_alloc()完成，默认取自内存池。</p><p>refill() 默认向chunk_alloc()申请nobjs=20个大小为n（假定n已经调整为8倍数）的（连续）内存空间，当然实际成功申请到多少个，需要根据实际情况决定，可通过nobjs传出值判断。可以肯定的是，如果有返回值（没有出现异常终止程序），那么至少会有一个大小为n的对象。<br>refill()会得到一个连续空间，而把第一个大小n的对象返回给客户；至于剩余的空间，在按尺寸n找到合适的free list后，将剩余空间按链表形式加入free list。</p><p>refill() 重新填充free list流程：<br><img src="https://img2022.cnblogs.com/blog/741401/202205/741401-20220504190104782-1277915042.png" alt="img"></p><p>refill()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个大小为n的对象, 并且有时候会为适当的free list增加节点</span></span><br><span class="line"><span class="comment">// 假设n已经适当上调至8的倍数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">       <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用chunk_alloc(), 尝试取得nobjs个区块作为free list的新节点</span></span><br><span class="line">       <span class="comment">// 注意参数nobjs是pass by reference</span></span><br><span class="line">       <span class="type">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n, nobjs); <span class="comment">// 下节详述</span></span><br><span class="line">       obj* <span class="keyword">volatile</span> *my_free_list; <span class="comment">// 2级指针, 指向free list链表头结点, 也位于free_list[]槽位上</span></span><br><span class="line">       obj* result;</span><br><span class="line">       obj *current_obj, *next_obj;</span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果只获得一个区块, 这个区块就分配给调用者, free list无新节点</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 否则准备调整free list, 纳入新节点</span></span><br><span class="line">       my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下在chunk空间内建立free list</span></span><br><span class="line">       result = (obj*)chunk; <span class="comment">// 首部这一块准备返回给客户端</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下引导free list指向新配置的空间(取自内存池)</span></span><br><span class="line">       *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下在chunk剩余空间(除去返回给客户的首部)上, 将free list的各节点串起来</span></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">1</span>; ; ++i) &#123; <span class="comment">// 从1开始, 因为第0个将返回给客户端</span></span><br><span class="line">              current_obj = next_obj;</span><br><span class="line">              next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br><span class="line">              <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">                     current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                     current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memory-pool-内存池">memory pool 内存池</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713213157224.png" alt="image-20240713213157224"></p><p>chunk_alloc()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设size已经适当上调至8的倍数</span></span><br><span class="line"><span class="comment">// 注意参数nobjs是pass by reference</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>  &amp;nobjs) &#123;</span><br><span class="line">       <span class="type">char</span>* result;</span><br><span class="line">       <span class="type">size_t</span> total_bytes = size * nobjs;         <span class="comment">// 要申请的内存总量</span></span><br><span class="line">       <span class="type">size_t</span> bytes_left = end_free - start_free; <span class="comment">// 内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">              <span class="comment">// 内存池剩余空间完全满足需求量, 从内存池直接分配所需量 start_free ~ start_free + total_bytes</span></span><br><span class="line">              result = start_free;</span><br><span class="line">              start_free += total_bytes; <span class="comment">// 从内存池取出内存后, 移动内存池起始位置</span></span><br><span class="line">              <span class="keyword">return</span> (result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">              <span class="comment">// 内存池剩余空间不能完全满足需求量, 但足够供应一个(含)以上的区块</span></span><br><span class="line">              nobjs = bytes_left / size;  <span class="comment">// 先分配能满足的块数</span></span><br><span class="line">              total_bytes = size * nobjs; <span class="comment">// 从内存池实际能分配的总量</span></span><br><span class="line">              result = start_free;</span><br><span class="line">              start_free += total_bytes;</span><br><span class="line">              <span class="keyword">return</span> (result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 内存池剩余空间连一个区块的大小都无法提供, 就需要向OS重新申请(malloc)内存</span></span><br><span class="line">              <span class="comment">// 默认申请 2倍所需量, heap_size 用来调整申请的内存量.</span></span><br><span class="line">              <span class="comment">// 注意: 为内存池申请空间, 分配空间时, 需要确保对齐(8byte对齐)</span></span><br><span class="line">              <span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>); <span class="comment">// &gt;&gt; 4 &lt;=&gt; /16</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 先试着让内存池的残余零头还有利用价值, 因为不够申请的一个区块大小(size),</span></span><br><span class="line">              <span class="comment">// 因此内存池剩余空间肯定 &lt; 128bytes, 可以加入某个区块</span></span><br><span class="line">              <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="comment">// 内存池还有一些零头, 先分配给恰当的free list, 以备其他客户向free list申请空间</span></span><br><span class="line">                     <span class="comment">// 首先寻找适当的free list</span></span><br><span class="line">                     obj* <span class="keyword">volatile</span> *my_free_list = free_list +  <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 将内存池残余空间插入到free list槽位对应链表</span></span><br><span class="line">                     <span class="comment">// 调整free list, 将内存池中的残余空间编入</span></span><br><span class="line">                     ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">                     *my_free_list = (obj*)start_free;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 向OS heap申请新空间, 用来补充内存池. 此时内存池已经为空, 残余空间已经交给free list.</span></span><br><span class="line">              start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123; <span class="comment">// OS heap空间不足, malloc()失败后异常处理</span></span><br><span class="line">                     <span class="type">int</span> i;</span><br><span class="line">                     obj* <span class="keyword">volatile</span> * my_free_list, *p;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 试着检查我们手上拥有的东西, 这不会造成伤害. 我们不打算尝试配置较小的区块,</span></span><br><span class="line">                     <span class="comment">// 因为那在多进程(multi-process)机器上容易导致灾难</span></span><br><span class="line">                     <span class="comment">// 以下搜寻适当的free list</span></span><br><span class="line">                     <span class="comment">// 所谓适当是指&quot;尚有未用区块, 且区块够大&quot;之free list</span></span><br><span class="line">                     <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                           my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">                           p = *my_free_list;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (<span class="number">0</span> != p) &#123; <span class="comment">// free list内尚有未用区块</span></span><br><span class="line">                                  <span class="comment">// 调整free list以释放出未用区块</span></span><br><span class="line">                                  *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                                  start_free = (<span class="type">char</span>*)p;</span><br><span class="line">                                  end_free = start_free + i;</span><br><span class="line">                                         </span><br><span class="line">                                  <span class="comment">// 此时内存池已经有足够大区块. 递归调用自己, 为了修正nobjs</span></span><br><span class="line">                                  <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">                                  <span class="comment">// 注意, 内存池任何残余零头终将被编入适当的free-list中备用</span></span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     end_free = <span class="number">0</span>; <span class="comment">// 如果出现意外(到处都没内存可用)</span></span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 调用第一级配置器, 看看out-of-memory机制是否能尽点力</span></span><br><span class="line">                     start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">                     <span class="comment">// 这会导致抛出异常(exception), 或内存不足的情况获得改善</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              heap_size += bytes_to_get;            <span class="comment">// 向OS成功申请到内存, 就扩大heap size</span></span><br><span class="line">              end_free = start_free + bytes_to_get; <span class="comment">// 更新内存池end_free边界</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 此时内存池有足够空间, 递归调用自己, 为了修正nobjs</span></span><br><span class="line">              <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713213309191.png" alt="image-20240713213309191"></p><p>本文转载自：<a href="https://www.cnblogs.com/fortunely/p/16219743.html">https://www.cnblogs.com/fortunely/p/16219743.html</a></p>]]></content>
    
    
    <summary type="html">STL空间配置器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>互斥锁、读写锁、自旋锁</title>
    <link href="https://penge666.github.io/posts/39f9f1ca.html"/>
    <id>https://penge666.github.io/posts/39f9f1ca.html</id>
    <published>2024-07-02T04:00:20.000Z</published>
    <updated>2024-07-08T08:16:06.244Z</updated>
    
    <content type="html"><![CDATA[<p>鹰击长空鲸霸海，不试怎知龙与邱！</p><h2 id="1-前言">1.前言</h2><p>本文介绍锁与临界资源与原子操作的的使用场景。</p><h2 id="2-临界资源">2.临界资源</h2><h3 id="2-1-什么是临界资源">2.1 什么是临界资源</h3><p>临界资源就是被多个线程/进程共享，但在某一时刻只能被一个线程/进程所使用的资源。   下文以一个经典案例(多线程同时进行i++)介绍三种锁，以及cpu指令集支持的原子操作和CAS。</p><p>主线程启动后创建十个线程，并将主线程中的count变量当作参数传入子线程中，也就是说十个线程同时操作一个共享资源count，子线程执行10w次count++ 操作，主线程每隔两秒打印一次count的值。下面来看看加锁与不加锁的区别。</p><h3 id="2-2-多线程操作临界资源且不加锁">2.2 多线程操作临界资源且不加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们预期count最终是达到100w，为什么在不加锁的时候没有达到预期效果？很明显，count++不是原子操作</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120141957.png" alt="image-20240702120141957"></p><h3 id="2-3-i-不是原子操作-i-对应三条汇编指令">2.3 i++不是原子操作,i++对应三条汇编指令</h3><p>如果i++是原子操作，那么必然会累加到100w，那么i++到底对应着那几步呢？</p><p>下面以idx++举例，idx的值是存储在内存里面，首先从内存MOV到eax寄存器里面，然后通过寄存器进行自增，最后再从eax写回到内存中。在编译器不做任何优化的情况下，idx++就对应这三个步骤。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120158334.png" alt="image-20240702120158334"></p><p>在大多数情况下，程序是这样执行的</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120209782.png" alt="image-20240702120209782"></p><p>但是也会存在下面这两种情况。线程1首先将idx的值读到了寄存器，然后cpu执行线程2，线程2执行完三步骤后，又回到线程1，线程1接着执行剩下的两步。有人可能会想，两个线程不都执行完了吗？有什么不同？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120226769.png" alt="image-20240702120226769"></p><p>首先，在线程1让出后，线程1的上下文(比如这里的eax)，是存储到线程1里面的，线程1恢复后，又将上下文load回去。这里就涉及到yield和resume了，详细介绍看纯c协程框架NtyCo实现与原理的第二节与第三节。 理解了上下文的切换后，就容易理解了，有没有发现，两次++操作，最终会漏加。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120244473.png" alt="image-20240702120244473"></p><p>所以在多线程中，操作临界资源时，那么这个临界资源是原子的，那么就不用加锁，要么就必须加锁，否在就会出现上述问题！</p><p>那么所谓加锁是什么意思？就是将这三条汇编指令变成一个原子操作，只要有一个线程lock加锁了，别的线程就不能执行进来，直到加锁的线程解锁，别的线程才能加锁。那么这三条汇编指令就是原子的了。下面将介绍3中锁以及2个原子操作。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120256216.png" alt="image-20240702120256216"></p><h3 id="2-4-多线程操作临界资源且加互斥锁">2.4 多线程操作临界资源且加互斥锁</h3><p>下面来看看两种加锁方式，这两种都可以跑了100w，但是这两种加锁的粒度是不一样的，在这个程序中，谁是临界资源？是pcount，而不是while，所以第二种加锁虽然可以跑通，但是它加锁的粒度太大了，就本程序而言，第二种加锁方式这和单线程跑有什么区别？所以我们要对临界资源加锁,不是临界资源的不加锁，掌控好锁的粒度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确加锁</span></span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    (*pcount)++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误加锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">    (*pcount)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到加锁之后，成功达到我们的预期</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120337410.png" alt="image-20240702120337410"></p><h3 id="2-5-多线程操作临界资源且加读写锁">2.5 多线程操作临界资源且加读写锁</h3><p>读写锁，顾名思义，读临界资源的时候加读锁，写临界资源的时候加写锁。适用于读多写少的场景。</p><p>A线程加了读锁，B线程可以继续加读锁，但是不能加写锁。 A线程加了写锁，B线程不能加读锁，也不能加写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120405727.png" alt="image-20240702120405727"></p><h3 id="2-6-多线程操作临界资源且加自旋锁">2.6 多线程操作临界资源且加自旋锁</h3><p>spinlock与mutex一样，mutex在哪里加锁，spinlock就在哪加锁，使用方法是一样的，但是其内部行为不一样。那么mutex和spinlock的区别在哪呢？</p><p>互斥锁在获取不到锁时，会进入休眠，等待释放时被唤醒。会让出CPU。 自旋锁在获取不到锁时，一直等待，在等待过程种不会有进程，线程切换。只会一直等，死等。</p><p>互斥锁与自旋锁的使用场景下文介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_spin_lock</span>(&amp;spinlock);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_spin_unlock</span>(&amp;spinlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;spinlock, PTHREAD_PROCESS_SHARED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120430596.png" alt="image-20240702120430596"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120437972.png" alt="image-20240702120437972"></p><p>补充：<strong>自旋锁会不会死锁</strong>？</p><p>给出我的观点：是锁就会有死锁问题！</p><p><strong>嵌套自旋锁导致的死锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock);  <span class="comment">// 第一次获取锁</span></span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock);  <span class="comment">// 再次尝试获取同一个锁，会导致死锁</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock);</span><br><span class="line">    spin_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环依赖导致的死锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock1, lock2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_A</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock1);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock2);  <span class="comment">// 线程A等待lock2</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock2);</span><br><span class="line">    spin_unlock(&amp;lock1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_B</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock2);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock1);  <span class="comment">// 线程B等待lock1</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock1);</span><br><span class="line">    spin_unlock(&amp;lock2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，线程A持有lock1并等待获取lock2，而线程B持有lock2并等待获取lock1，这种情况会导致两个线程都无法继续执行，从而导致死锁。</p><p><strong>总结</strong></p><p>自旋锁本身并不会直接导致死锁，但在特定的使用场景下，如果代码设计不合理，可能会出现死锁。为了避免死锁，开发者应该：</p><ul><li>避免嵌套使用同一个自旋锁。</li><li>设计时避免循环依赖关系，确保获取锁的顺序一致。</li><li>考虑使用其他同步机制，如互斥锁（mutex）或读写锁（rwlock），这些锁可以避免自旋锁的一些问题，特别是在锁持有时间较长的情况下。</li></ul><h3 id="2-7-原子操作">2.7 原子操作</h3><p>我们发现加锁，都是将i++对应的汇编的三个步骤，变成原子性。那么我们有没有办法直接将i++对应的汇编指令，变成一条指令？可以，我们使用xaddl这条指令。</p><p>Intel X86指令集提供了指令前缀lock⽤于锁定前端串⾏总线FSB，保证了指令执⾏时不会收到其他处理器的⼲扰。</p><p>所谓原子操作，它不是某条具体的指令，它是CPU支持的指令集，都是原子操作。比如说CAS，CAS是原子操作的一种，而不能说原子操作就是CAS。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">xaddl -----&gt; Inc</span><br><span class="line">xaddl：第二个参数加第一个参数，并把值存储到第一个参数里</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;lock; xaddl %2, %1;&quot;</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;=a&quot;</span> (old)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;m&quot;</span> (*value), <span class="string">&quot;a&quot;</span> (add)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(pcount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmpxchg-----&gt; CAS CAS：Compare And Swap，先比较，再赋值，翻译成代码就是下面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a==b)&#123;<span class="comment">//Compare</span></span><br><span class="line">a=c;<span class="comment">//Swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPU的指令集支持了先比较后赋值的指令，叫cmpxchg。正因为CPU执行了这个指令，它才是原子操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Perform atomic &#x27;compare and swap&#x27; operation on the pointer.</span></span><br><span class="line"><span class="comment">//  The pointer is compared to &#x27;cmp&#x27; argument and if they are</span></span><br><span class="line"><span class="comment">//  equal, its value is set to &#x27;val&#x27;. Old value of the pointer is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T *<span class="title">cas</span> <span class="params">(T *cmp_, T *val_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T *old;</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;lock; cmpxchg %2, %3&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;=a&quot;</span> (old), <span class="string">&quot;=m&quot;</span> (ptr)</span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;r&quot;</span> (val_), <span class="string">&quot;m&quot;</span> (ptr), <span class="string">&quot;0&quot;</span> (cmp_)</span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-三种锁的api介绍">3.三种锁的api介绍</h2><h3 id="3-1-互斥锁-mutex">3.1 互斥锁 mutex</h3><p>有两个特殊的api，pthread_mutex_trylock 尝试加锁，如果没有获取到锁则返回，而不是休眠。pthread_mutex_timedlock 等待一段时间，超时了还没获取倒锁则返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mutex handling.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__mutexattr)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try locking a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/* Wait until lock becomes available, or specified time passes. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_timedlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__restrict __mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">    __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-读写锁-rdlock">3.2 读写锁 rdlock</h3><p>读写锁适用于多读少写的情况，否则还是用互斥锁。</p><p>A线程加了读锁，B线程可以继续加读锁，但是不能加写锁。 A线程加了写锁，B线程不能加读锁，也不能加写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling read-write locks.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize read-write lock RWLOCK using attributes ATTR, or use</span></span><br><span class="line"><span class="comment">   the default values if later is NULL.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">__attr)</span> __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy read-write lock RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire read lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire read lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">  __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire read lock for RWLOCK or return after specfied time.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_timedrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">       __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire write lock for RWLOCK or return after specfied time.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_timedwrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">       __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-自旋锁-spinlock">3.3 自旋锁 spinlock</h3><p>自旋锁最大的特点是，获取不到锁就一直等待，即使CPU时间片用完了也不会发生切换，死等。而上面两种锁不一样，获取不到就会休眠，让出CPU时间片，切换到其他线程或进程执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions to handle spinlocks.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can</span></span><br><span class="line"><span class="comment">   be shared between different processes.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_init</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock, <span class="type">int</span> __pshared)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy the spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_destroy</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait until spinlock LOCK is retrieved.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_lock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to lock spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_trylock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_unlock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-递归锁">3.4 递归锁</h3><p>递归锁（Recursive Lock）也称为可重入<a href="https://so.csdn.net/so/search?q=%E4%BA%92%E6%96%A5%E9%94%81&amp;spm=1001.2101.3001.7020">互斥锁</a>（reentrant mutex），是互斥锁的一种，<strong>同一线程对其多次加锁不会产生死锁</strong>。递归锁会使用引用计数机制，以便可以从同一线程多次加锁、解锁，当加锁、解锁次数相等时，锁才可以被其他线程获取。</p><p>递归锁（Reentrant Lock）在C++中的实现和应用场景，主要是为了处理递归函数或在同一线程中多次进入临界区的情况。递归锁可以避免因多次获取同一个锁而导致的死锁问题。</p><p><strong>递归锁的用途</strong></p><ol><li><strong>递归函数中的同步</strong>：<ul><li>当一个递归函数需要同步时，使用普通的互斥锁会导致在递归调用时锁无法再次获取，从而导致死锁。递归锁允许同一个线程多次获取锁，因此在递归函数中非常有用。</li></ul></li><li><strong>复杂逻辑中的多次加锁</strong>：<ul><li>在某些复杂的逻辑中，同一个线程可能需要多次进入临界区。使用递归锁可以避免由于多次加锁而导致的死锁问题。</li></ul></li><li><strong>代码重用和模块化</strong>：<ul><li>当函数A调用函数B，而函数B又需要同步时，且函数A已经持有锁，这种情况下使用递归锁可以使代码更加模块化，减少代码耦合。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义递归锁</span></span><br><span class="line">std::recursive_mutex recMutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取递归锁</span></span><br><span class="line">    recMutex.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock acquired by thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; with count &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用自身</span></span><br><span class="line">    <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放递归锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock released by thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; with count &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    recMutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(recursiveFunction, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-三种锁的使用场景">4.三种锁的使用场景</h2><p>比如说读一个文件，就使用mutex。而如果是简单的加加减减操作，就是用spinlock。如果系统提供了原子操作的接口，对于i++这种操作来说，用原子操作更合适。</p><p>spinlock：临界资源操作简单/没有发生系统调用/持续时间较短（<strong>自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，等待时消耗cpu资源较多，自旋锁一般用于多核的服务器</strong>。）</p><p>mutex：临界资源操作复杂/发生系统调用/持续时间比较长</p><ul><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li><li>临界区竞争非常激烈</li><li>单核处理器</li></ul><p>补充：</p><p><strong>案例1：单核处理器上的自旋锁讲述</strong></p><p>在单核处理器上，虽然同时只有一个进程在执行，但通过操作系统的调度，多个进程仍然可以并发地运行。比如，进程A正在执行，并且持有自旋锁，这时操作系统决定切换到进程B。</p><ol><li><strong>进程A持有自旋锁</strong>：进程A获取了自旋锁，并正在执行某些操作。</li><li><strong>上下文切换</strong>：操作系统决定切换到进程B，因为进程A的时间片用完了，或者操作系统认为进程B需要运行。</li><li><strong>进程B尝试获取自旋锁</strong>：进程B开始运行，并试图获取同一个自旋锁。因为锁被进程A持有，进程B会进入自旋等待状态，不断地检查锁的状态。</li><li><strong>再次切换到进程A</strong>：操作系统可能再次切换回进程A，进程A继续运行并最终释放自旋锁。</li><li><strong>进程B获取自旋锁</strong>：一旦进程A释放锁，操作系统可能会切换回进程B，进程B就可以成功获取锁并继续执行。</li></ol><p><strong>案例2：多核处理器上的自旋锁讲述</strong></p><p><strong>初始状态</strong>：</p><ul><li>共享资源初始状态为未被锁定。</li><li>自旋锁初始状态为未被持有。</li></ul><p><strong>进程A尝试获取锁</strong>：</p><ul><li>进程A运行在CPU核1上，它试图获取自旋锁来访问共享资源。</li><li>自旋锁目前未被持有，因此进程A成功获取锁，并进入临界区开始访问共享资源。</li></ul><p><strong>进程B尝试获取锁</strong>：</p><ul><li>在进程A持有锁的同时，进程B在CPU核2上运行，也试图获取同一个自旋锁。</li><li>由于锁已被进程A持有，进程B进入自旋等待状态，在CPU核2上不断循环检查锁的状态。</li></ul><p><strong>进程A释放锁</strong>：</p><ul><li>进程A完成对共享资源的访问，释放自旋锁。</li><li>锁的状态变为未被持有。</li></ul><p><strong>进程B获取锁</strong>：</p><ul><li><p>进程B在自旋等待中检测到锁已被释放，立即获取自旋锁。</p></li><li><p>进程B进入临界区开始访问共享资源。</p><p>【因为始终只有一把自旋锁】</p></li></ul><p>原子操作：使用场景很小，必须需要CPU的指令集支持才行。（原子操作适用于简单的加减等数学运算，属于粒度最小的操作。比如往链表里增加一个结点，可以做出原子操作吗？不行，因为CPU指令集没有同时多个赋值的指令。cas 多线程同时竞争的时候效率并不会特别高，如果互斥锁和自旋锁能满足要求了尽量不要用cas）</p><h2 id="5-原子操作的接口">5.原子操作的接口</h2><p>对于gcc、g++编译器来讲，它们提供了⼀组API来做原⼦操作：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_add </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_sub </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_or </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_and </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_xor </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_nand </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"></span><br><span class="line">bool __sync_bool_compare_and_swap (<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">oldval </span><span class="keyword">type</span> <span class="type">newval, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_val_compare_and_swap </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">oldval </span><span class="keyword">type</span> <span class="type">newval, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_lock_test_and_set </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line">void __sync_lock_release (<span class="keyword">type</span> <span class="type">*ptr, </span>...)</span><br></pre></td></tr></table></figure><p>详细⽂档⻅：<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins">https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins</a></p><p>详细⽂档⻅：<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins">https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins</a></p><p>学习自：<a href="https://blog.csdn.net/qq_42956653/article/details/126141284">互斥锁、读写锁、自旋锁，以及原子操作指令xaddl、cmpxchg的使用场景剖析</a></p>]]></content>
    
    
    <summary type="html">锁向无敌</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://penge666.github.io/posts/735e5788.html"/>
    <id>https://penge666.github.io/posts/735e5788.html</id>
    <published>2024-07-01T14:51:48.000Z</published>
    <updated>2024-07-08T02:46:35.698Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序、插入排序、选择排序、计数排序、堆排序、快速排序、归并排序</p><p><strong>基本概念</strong></p><p>排序算法的稳定性：如果待排序的序列中存在相同键值的元素，排序前后的相对顺序保持不变。【相同的元素不交换位置】</p><p><strong>最坏时间复杂度、最好时间复杂度和平均时间复杂度.</strong></p><p><strong><code>最坏时间复杂度</code></strong><br>最坏情况下的时间复杂度称最坏时间复杂度，一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。</p><p><strong><code>平均时间复杂度</code></strong><br>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间，设每种情况的出现的概率为pi,平均时间复杂度则为sum(pi*f(n)) 。</p><p><strong><code>最好时间复杂度</code></strong><br>最理想情况下的时间复杂度称最好时间复杂度。</p><h2 id="冒泡排序">冒泡排序</h2><p>【分组插入排序】</p><p>思路分析：</p><p>①比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>②对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p><p>③针对所有的元素重复以上的步骤，除了最后一个。</p><p>④持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>过程动态图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/BubbleSort.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：冒泡排序算法最坏的情况和平均复杂度是O(n^2)，最好时间复杂度为O(n)，空间复杂度为O(1)，排序算法稳定。</p><h2 id="直接插入排序">直接插入排序</h2><p>思路分析：</p><p>①在长度为N的数组，将数组中第i  [1~（N-1) ] 个元素，插入到数组 [0~i] 适当的位置上。</p><p>②在排序的过程中当前元素之前的数组元素已经是有序的了。</p><p>③在插入的过程中，有序的数组元素，需要向右移动为更小的元素腾出空间，直到为当前元素找到合适的位置。</p><p>过程动态图展示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/insert_sort.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="keyword">for</span> (j; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; temp) &#123;</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：时间复杂度平均为O(n^2)，最坏为O(n^2)，最好为O(n)，空间复杂度为O(1)，排序算法稳定。</p><h2 id="希尔排序">希尔排序</h2><p><strong>基本思想</strong></p><p>希尔排序的核心思想是先将数组分割成若干个子序列，然后对每个子序列进行插入排序。随着算法的进行，子序列之间的间隔（gap）逐渐减小，直到最后变为1，此时整个数组变为一个子序列行最后一次插入排序。</p><p><strong>希尔排序的过程</strong></p><ol><li>选择一个初始的间隔序列（通常为数组长度的一半）。</li><li>对于每个间隔 gap，将数组分割成若干个子序列。</li><li>对每个子序列进行插入排序。</li><li>减少间隔，重复步骤2和3，直到间隔为1。</li></ol><p><strong>举例说明</strong></p><p>假设我们有一个长度为 8 的数组 [8, 4, 1, 3, 2, 7, 6, 5]，按照希尔排序的步骤进行排序：</p><ol><li>初始间隔 gap = 4：<ul><li>子序列1：[8, 2]</li><li>子序列2：[4, 7]</li><li>子序列3：[1, 6]</li><li>子序列4：[3, 5]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 2：<ul><li>子序列1：[2, 1, 6, 5]</li><li>子序列2：[8, 4, 3, 7]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 1：<ul><li>整个数组进行一次插入排序。</li></ul></li></ol><p>通过这个例子，可以看到希尔排序如何逐步减少间隔并进行排序。</p><p>假设我们有一个长度为 8 的数组 [8, 4, 1, 3, 2, 7, 6, 5]，按照希尔排序的步骤进行排序：</p><ol><li>初始间隔 gap = 4：<ul><li>子序列1：[8, 2]</li><li>子序列2：[4, 7]</li><li>子序列3：[1, 6]</li><li>子序列4：[3, 5]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 2：<ul><li>子序列1：[2, 1, 6, 5]</li><li>子序列2：[8, 4, 3, 7]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 1：<ul><li>整个数组进行一次插入排序。</li></ul></li></ol><p>通过这个例子，可以看到希尔排序如何逐步减少间隔并进行排序。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">int</span> gap = n;</span><br><span class="line"><span class="keyword">while</span>(gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap/<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//控制分组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; n-gap;i++)<span class="comment">//注意边界条件，避免越界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = a[end+gap];</span><br><span class="line"><span class="keyword">while</span>(end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[end] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">a[end+gap] = a[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[end+gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【✳】<strong>时间复杂度分析</strong></p><p>希尔排序的时间复杂度分析涉及到以下几个方面：</p><p><strong>1. 间隔序列的选择</strong></p><p>希尔排序的效率很大程度上取决于所选择的间隔序列。常见的间隔序列有：</p><ul><li>希尔序列：间隔序列为 { n/2, n/4, …, 1 }。</li><li>Hibbard 序列：间隔序列为 { 1, 3, 7, …, 2^k - 1 }。</li><li>Knuth 序列：间隔序列为 { 1, 4, 13, 40, …, (3^k - 1) / 2 }。</li></ul><p>不同的间隔序列会影响排序的时间复杂度。这里我们以希尔序列为例进行分析。</p><p><strong>2. 插入排序的时间复杂度</strong></p><p>对于一个长度为 h 的子序列，插入排序的时间复杂度为 O(h^2)。</p><p><strong>3. 总时间复杂度</strong></p><p><strong>计算方式</strong></p><p>假设数组长度为 n，间隔序列为 { n/2, n/4, …, 1 }。在每个间隔 gap 下进行插入排序的时间复杂度可以近似看作 O(n)。</p><p>具体分析如下：</p><ul><li>当 gap = n/2 时，进行 n/2 次插入排序，每次插入排序的时间复杂度为 O((n/2)^2) = O(n^2/4)。</li><li>当 gap = n/4 时，进行 n/4 次插入排序，每次插入排序的时间复杂度为 O((n/4)^2) = O(n^2/16)。</li><li>依次类推，直到 gap = 1。</li></ul><p>由于每次 gap 变为原来的一半，总的时间复杂度可以表示为：<br>T(n) = O(n^2/4) + O(n^2/16) + … + O(1)</p><p>这实际上是一个几何级数，求和结果为：<br>T(n) = O(n^2 * (1/4 + 1/16 + … + 1/n^2))</p><p>因为这个和趋近于 O(n log^2 n)，所以希尔排序的平均时间复杂度为 O(n log^2 n)。</p><p><strong>总结</strong></p><p>时间复杂度可以在 O(n^(1.3)) 到 O(n^2) 之间。</p><p><strong>常见的间隔序列及其时间复杂度</strong></p><ol><li>希尔序列（Shell Sequence）：间隔序列为 {n/2, n/4, …, 1}。<ul><li>时间复杂度：O(n^2)</li></ul></li><li>Hibbard 序列：间隔序列为 {1, 3, 7, …, 2^k - 1}。<ul><li>时间复杂度：O(n^(3/2))</li></ul></li><li>Knuth 序列：间隔序列为 {1, 4, 13, 40, …, (3^k - 1) / 2}。<ul><li>时间复杂度：O(n^(3/2))</li></ul></li><li>Sedgewick 序列：间隔序列为 {1, 5, 19, 41, 109, …}。<ul><li>时间复杂度：O(n^(4/3))</li></ul></li><li>Pratt 序列：间隔序列为 {1, 2, 3, 4, 6, 8, 9, …}，即2的幂和3的幂的所有组合。<ul><li>时间复杂度：O(n log^2 n)</li></ul></li></ol><p><strong>时间复杂度计算示例：Hibbard 序列</strong></p><p>假设我们使用 Hibbard 序列，间隔序列为 {1, 3, 7, …, 2^k - 1}。</p><p><strong>分析步骤</strong></p><ol><li>间隔序列长度：对于一个长度为 n 的数组，最大间隔 k 满足 2^k - 1 ≈ n，即 k ≈ log_2 n。</li><li>每个间隔下的复杂度：在每个间隔 h 下，插入排序的复杂度为 O(n / h * h) = O(n)。</li><li>总复杂度：对于每个间隔 h，我们需要进行 k 次插入排序。由于 k ≈ log_2 n，总复杂度为 O(n log_2 n)。</li></ol><p>然而，由于 Hibbard 序列的实际排序效果，实验结果表明其平均时间复杂度更接近于 O(n^(3/2))。</p><p><strong>总结</strong></p><p>希尔排序的时间复杂度范围很广，具体取决于所使用的间隔序列。一般来说，时间复杂度可以在 O(n^(1.3)) 到 O(n^2) 之间变化。对于大多数实际应用，使用优化的间隔序列（如 Sedgewick 序列或 Pratt 序列）可以得到较好的时间复杂度，接近 O(n log^2 n)。</p><p><strong>参考公式</strong></p><ul><li>希尔序列：O(n^2)</li><li>Hibbard 序列：O(n^(3/2))</li><li>Knuth 序列：O(n^(3/2))</li><li>Sedgewick 序列：O(n^(4/3))</li><li>Pratt 序列：O(n log^2 n)</li></ul><p><strong>为什么说希尔排序不稳定！</strong></p><p>举个例子来说明这个问题：</p><p>假设有以下数组：<code>[3, 3, 1, 2, 2]</code>。</p><ol><li>初始数组： <code>[3, 3, 1, 2, 2]</code></li><li>选择一个跨度（gap），例如2： 对于跨度为2的子序列，我们有两个子序列：<code>[3, 1, 2]</code>和<code>[3, 2]</code>。</li><li>对每个子序列进行插入排序：<ul><li>对子序列<code>[3, 1, 2]</code>，排序后为<code>[1, 2, 3]</code>。</li><li>对子序列<code>[3, 2]</code>，排序后为<code>[2, 3]</code>。</li></ul></li><li>合并结果： <code>[1, 2, 2, 3, 3]</code></li></ol><p>在这个例子中，原数组中两个相同的“2”的相对顺序在排序后改变了。原本位于数组后半部分的“2”被移到了前半部分，而前半部分的“2”则保持在后半部分，这说明了希尔排序的不稳定性。</p><h2 id="选择排序">选择排序</h2><p>**思路分析：**第一趟从n个元素的数据序列中选出关键字最小/大的元素并放在最前/后位置，下一趟从n-1个元素中选出最小/大的元素并放在最前/后位置。以此类推，经过n-1趟完成排序。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/select_sort.gif" alt=""></p><p>代码实现（此处代码对直接排序进行了有优化，遍历一次同时选出最大的和最小的，最大的放在最右边，最小的放在最左边，排序范围缩减）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">size_t</span> left = <span class="number">0</span>,right = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> min = left,max = left;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = left;i &lt;= right;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt; a[min])</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[min],a[left]);</span><br><span class="line"><span class="keyword">if</span>(max == left) <span class="comment">//最大值在最左边</span></span><br><span class="line">max = min;</span><br><span class="line"><span class="built_in">swap</span>(a[max],a[right]);</span><br><span class="line">--right;</span><br><span class="line">++left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**直接选择排序的最好时间复杂度号最坏时间复杂度都是O(n^2)，因为即使数组一开始就是正序的，也需要将两重循环进行完，平均时间复杂度也是O(n^2)，最好的时间复杂度为O(n^2)，空间复杂度为O(1)，因为不占用多余的空间。直接选择排序是一种原地排序并且不稳定的排序算法，优点是实现简单，占用空间小，缺点是效率低，时间复杂度高，对于大规模的数据耗时较长。</p><p><strong>为什么说选择排序不稳定</strong>！</p><p>举个例子来说明选择排序的不稳定性：</p><p>假设有以下数组：<code>[4, 2, 3, 2, 1]</code>。</p><ol><li>初始数组： <code>[4, 2, 3, 2, 1]</code></li><li>第一轮选择最小元素：<ul><li>当前数组：<code>[4, 2, 3, 2, 1]</code></li><li>最小元素是1，将其与第一个元素4交换：</li><li>交换后数组：<code>[1, 2, 3, 2, 4]</code></li></ul></li><li>第二轮选择最小元素：<ul><li>当前数组：<code>[1, 2, 3, 2, 4]</code></li><li>最小元素是2，将其与第二个元素2交换（没有实际变化）：</li><li>交换后数组：<code>[1, 2, 3, 2, 4]</code></li></ul></li><li>第三轮选择最小元素：<ul><li>当前数组：<code>[1, 2, 3, 2, 4]</code></li><li>最小元素是2，将其与第三个元素3交换：</li><li>交换后数组：<code>[1, 2, 2, 3, 4]</code></li></ul></li></ol><p>在这个例子中，原数组中两个相同的“2”的相对顺序在排序后改变了。原本位于数组第二个位置的“2”在排序后移动到了数组第三个位置，而原本在第四个位置的“2”则保持在第四个位置，这说明了选择排序的不稳定性。</p><h2 id="堆排序">堆排序</h2><p><strong>思路分析：</strong></p><p>①将长度为n的待排序的数组进行堆有序化构造成一个大顶堆</p><p>②将根节点与尾节点交换并输出此时的尾节点</p><p>③将剩余的n -1个节点重新进行堆有序化</p><p>④重复步骤2，步骤3直至构造成一个有序序列</p><p>（升序构建小堆，降序构建大堆）</p><p><strong>过程动态图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/AdjustDown.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> root,<span class="type">size_t</span> n)</span><span class="comment">//向下调整算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> parent = root;</span><br><span class="line"><span class="type">size_t</span> child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//下标为0的为第一个孩子，所以parent*2+1为下标为左孩子</span></span><br><span class="line"><span class="keyword">while</span>(child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span> &lt; n &amp;&amp; a[child+<span class="number">1</span>] &gt; a[child])</span><br><span class="line">&#123;</span><br><span class="line">++child;<span class="comment">//让child指向较大的那个孩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[child],a[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span><span class="comment">//升序，建大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//从第一个非叶子节点开始，做向下调整，调整完第一个元素为最大元素</span></span><br><span class="line"><span class="keyword">for</span>(i = (n<span class="number">-2</span>)/<span class="number">2</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(a,i,n);</span><br><span class="line">&#125;<span class="comment">//大堆建成</span></span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="comment">//交换第一个元素和最后一个元素，然后把交换后的第一个元素往下调整，再成大堆</span></span><br><span class="line"><span class="comment">//--end，即是缩小范围，每次把最大的换到end的位置</span></span><br><span class="line"><span class="keyword">for</span>(end = n<span class="number">-1</span>;end &gt;= <span class="number">0</span>;--end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[end],a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a,<span class="number">0</span>,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：堆排序的最好和最差情况时间复杂度都为O(nlog2n)，平均时间复杂度为O(nlog2n)，空间复杂度为O(1)，排序算法不稳定，无需使用多余的空间帮助排序。优点是占用空间较小，时间复杂度较低，缺点是实现较为复杂，并且当待排序序列发生改动时，哪怕是特别小的改动，都需要调整整个堆来维护堆的性质，维护开销较大。</p><p>时间复杂度</p><p><strong>构建堆的时间复杂度</strong></p><ul><li><strong>自底向上的堆化过程</strong>：在堆排序中，首先要将无序数组构建成一个最大堆。这一过程的时间复杂度为 O(n)。</li></ul><p><strong>排序过程的时间复杂度</strong></p><ul><li><strong>删除最大元素并重建堆</strong>：将最大堆的根节点（最大值）与最后一个节点交换，然后对剩余的 n−1个元素重新进行堆化。每次堆化的时间复杂度为 O(log⁡n)，因为堆化操作的高度最多为 log⁡2n</li></ul><p>这个过程需要进行 n−1 次，因此排序部分的总时间复杂度为：O(nlog2n)</p><p><strong>补充下建堆的过程</strong></p><p><strong>建堆步骤</strong></p><p>堆的性质要求每个节点的值都不小于（最大堆）或不大于（最小堆）其子节点的值。建堆的过程自底向上进行，因为这样可以确保在调整某个节点时，它的子节点已经是堆。</p><p><strong>详细步骤</strong></p><ol><li><strong>选择从最后一个非叶子节点开始</strong>：因为叶子节点本身已经是一个堆，所以我们只需要调整非叶子节点。最后一个非叶子节点的索引是 ⌊n/2⌋−1，其中 n 是数组的长度。</li><li><strong>自底向上调整堆</strong>：从最后一个非叶子节点开始，依次向前遍历每个节点，执行 <code>heapify</code> 操作以确保每个节点都满足堆的性质。</li></ol><p><strong><code>heapify</code> 操作</strong></p><p><code>heapify</code> 是调整堆的核心操作，确保以某个节点为根的子树满足堆的性质。</p><p><strong>伪代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;       <span class="comment">// 初始化 largest 为根节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于 largest</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 largest 不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]); <span class="comment">// 交换根节点和最大值节点</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);   <span class="comment">// 递归地调整受影响的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建堆的完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始自底向上调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    <span class="built_in">buildMaxHeap</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个一个地从堆中取出元素，并调整剩余的堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将当前堆的根节点（最大值）与堆的最后一个元素交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整剩余的堆，使其重新满足最大堆的性质</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>假设我们有一个数组[4,10,3,5,1]，建堆过程如下：</p><ol><li>初始数组：[4,10,3,5,1]</li><li>从最后一个非叶子节点 i=1 开始堆化：<ul><li>当前节点是 10，左子节点是 5，右子节点是 1，没有变化。</li></ul></li><li>处理根节点 i=0<ul><li>当前节点是 4，左子节点是 10，右子节点是 3。由于 10 最大，将 4 和 10 交换，得到 [][10, 4, 3, 5, 1][10,4,3,5,1]。</li><li>调整后的子树根节点是 4，它没有子节点需要调整。</li></ul></li></ol><p>结果是 [][10, 4, 3, 5, 1][10,4,3,5,1]，这个数组已经是最大堆。</p><h2 id="快速排序">快速排序</h2><p>本质上快速排序把数据划分成几份，所以快速排序通过选取一个关键数据，再根据它的大小，把原数组分成两个子数组：第一个数组里的数都比这个主元数据小或等于，而另一个数组里的数都比这个主元数据要大或等于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于交换两个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// i指向小于pivot的最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回pivot的正确位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序递归函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 获取分区点</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);  <span class="comment">// 排序左边部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 排序右边部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector版本的/手撕快排版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> i=left<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> j=right+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp=nums[left+<span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">while</span>(nums[++i]&lt;tmp) ;</span><br><span class="line"><span class="keyword">while</span>(nums[--j]&gt;tmp) ;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quickSort</span>(nums,left,j);</span><br><span class="line"><span class="built_in">quickSort</span>(nums,j+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortFun</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line"><span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">sortFun</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> resi:num) cout&lt;&lt;resi&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组中第 K 大的数</strong>：可以用快排实现，也可以用优先队列实现。</p><p>举例：</p><p>假设我们有数组 <code>arr = &#123;10, 7, 8, 9, 1, 5&#125;</code>，我们调用 <code>partition(arr, 0, 5)</code>。</p><ul><li>初始状态：<code>pivot = 5</code>，<code>i = -1</code>。</li><li>遍历数组：<ul><li><code>j = 0</code>，<code>arr[j] = 10</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 1</code>，<code>arr[j] = 7</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 2</code>，<code>arr[j] = 8</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 3</code>，<code>arr[j] = 9</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 4</code>，<code>arr[j] = 1</code>，小于 <code>pivot</code>，交换 <code>arr[0]</code> 和 <code>arr[4]</code>，<code>i = 0</code>。</li></ul></li><li>交换基准元素：<ul><li>将 <code>arr[1]</code> 和 <code>arr[5]</code> 交换，得到 <code>arr = &#123;1, 5, 8, 9, 10, 7&#125;</code>。</li></ul></li><li>返回值：<ul><li>返回 <code>i + 1 = 1</code>。</li></ul></li></ul><p>通过上述步骤，我们将数组划分为两部分：<code>&#123;1&#125;</code> 和 <code>&#123;8, 9, 10, 7&#125;</code>，其中基准元素 <code>5</code> 位于正确的位置。</p><p><strong>总结</strong>：平均时间复杂度为O(nlog2n)，最坏时间复杂度为O(n^2)，空间复杂度为O(nlog2n），排序算法不稳定。</p><p><strong>补充</strong>：</p><ul><li><p><strong>选择的枢轴（pivot）不理想</strong>：如果每次选择的枢轴总是数组中的最大或最小元素，快速排序将退化为最坏情况。例如，对于一个已经有序的数组，如果每次选择第一个元素或最后一个元素作为枢轴，快速排序会产生极度不平衡的划分，导致最坏时间复杂度 O(n^2)。</p><p>举个例子，假设我们总是选择第一个元素作为枢轴：</p><ul><li>对于一个已经有序的数组 <code>[1, 2, 3, 4, 5]</code>，第一次选择 1 作为枢轴，将数组划分为 <code>[]</code> 和 <code>[2, 3, 4, 5]</code>。</li><li>接下来，选择 2 作为枢轴，将数组划分为 <code>[]</code> 和 <code>[3, 4, 5]</code>。</li><li>继续下去，每次的划分都会导致一个子数组为空，另一个子数组包含剩余的所有元素。</li></ul><p>这样，每次递归调用都会减少一个元素，导致总体时间复杂度变为 O(n^2)。</p></li><li><p><strong>重复元素很多</strong>：当数组中有很多重复元素时，特别是所有元素都相同时，如果选择的枢轴总是那些重复的元素，快速排序也会退化。例如，对于一个全是相同元素的数组 <code>[5, 5, 5, 5, 5]</code>，如果选择枢轴为 5，每次划分后的两个子数组大小不变，这会导致快速排序退化为最坏时间复杂度。</p></li></ul><p>为了避免快速排序退化为 O(n^2)，常用的改进方法包括：</p><ul><li><strong>随机选择枢轴</strong>：在每次划分时随机选择一个元素作为枢轴，这样可以大大减少出现最坏情况的概率。</li><li><strong>三数取中法（Median of Three）</strong>：选择第一个元素、中间元素和最后一个元素的中位数作为枢轴。</li><li><strong>混合排序算法</strong>：当数组大小较小时，切换到插入排序等其他高效的排序算法，因为在小数组上，插入排序的性能通常优于快速排序。</li></ul><h2 id="归并排序">归并排序</h2><p><strong>思路分析：</strong></p><p>当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样<strong>递归下去，合并上来</strong>就是归并排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> *a, <span class="type">int</span> left, <span class="type">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">_MergeSort(a, left, mid);</span><br><span class="line">_MergeSort(a, mid+<span class="number">1</span>, right);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[right-left+<span class="number">1</span>];<span class="comment">//开辟同原数组大小的辅助空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = left;<span class="comment">//左区间的开头</span></span><br><span class="line"><span class="type">int</span> begin2 = mid+<span class="number">1</span>;<span class="comment">//右区间的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;<span class="comment">//辅助空间的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(begin1 &lt;= mid &amp;&amp; begin2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[begin1] &lt; a[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将余下的直接放入辅助空间</span></span><br><span class="line"><span class="keyword">while</span>(begin1 &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(begin2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tmp数组的值全部拷贝到a数组里面</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[left+i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;<span class="comment">//释放自己申请的空间</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line">_MergeSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手撕版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergefun</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"><span class="type">int</span> i=l;</span><br><span class="line"><span class="type">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(nums[i++]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp.<span class="built_in">push_back</span>(nums[i++]);</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) tmp.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tmp.<span class="built_in">size</span>();i++) nums[i+l]=tmp[i];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(nums,l,mid);</span><br><span class="line"><span class="built_in">mergeSort</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">mergefun</span>(nums,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortFun</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(nums,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">SortFun</span>(nums);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：平均和最坏、最好时间复杂度为O(nlog2n)，空间复杂度O(n)，排序算法稳定。</p><p>一个经典问题：数组中的逆序对（hard）</p><ul><li>[<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a>](<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/</a>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSort</span>(nums, tmp, left, mid) + <span class="built_in">mergeSort</span>(nums, tmp, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || tmp[i] &lt;= tmp[j]) &#123;</span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(nums, tmp, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240701233431874.png" alt="image-20240701233431874"></p><p>参考资料：</p><p><a href="https://blog.csdn.net/ypt523/article/details/80462873">排序算法（七大经典排序算法）</a></p><p><a href="https://segmentfault.com/a/1190000021638663#item-7-27">https://segmentfault.com/a/1190000021638663#item-7-27</a></p>]]></content>
    
    
    <summary type="html">七大经典排序算法</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>伙伴算法和slab算法</title>
    <link href="https://penge666.github.io/posts/f26278ad.html"/>
    <id>https://penge666.github.io/posts/f26278ad.html</id>
    <published>2024-06-30T09:36:48.000Z</published>
    <updated>2024-07-02T02:49:04.146Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中，用来管理物理内存页面的<strong>伙伴系统</strong>，以及负责分配比页更小的内存对象的<strong>SLAB分配器</strong>了。</p>]]></content>
    
    
    <summary type="html">Linux内存管理-伙伴算法和slab算法</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用户态和内核态</title>
    <link href="https://penge666.github.io/posts/6407ef8f.html"/>
    <id>https://penge666.github.io/posts/6407ef8f.html</id>
    <published>2024-06-30T08:30:03.000Z</published>
    <updated>2024-06-30T09:05:20.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户态和内核态概述">用户态和内核态概述</h2><p><strong>简单来说内核态就是操作系统运行线程，用户态就是线程执行用户自己的程序。</strong></p><p><strong>用户态</strong>：</p><ul><li>不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</li></ul><p><strong>内核态</strong>：</p><ul><li><p>系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行。</p></li><li><p>内核态可以使用计算机所有的硬件资源。</p></li></ul><blockquote><p><strong>为什么要区分用户态和内核态？</strong></p></blockquote><p><strong>1. 安全性</strong></p><ul><li><strong>保护系统资源</strong>：内核态拥有对所有硬件和系统资源的完全控制权。通过区分用户态和内核态，可以防止用户程序直接访问和修改系统关键数据结构和硬件资源。</li><li><strong>防止恶意行为</strong>：如果没有用户态和内核态的区分，恶意程序可能会直接操作硬件或篡改系统内核，从而危害整个系统的安全。</li></ul><p><strong>2. 稳定性</strong></p><ul><li><strong>防止错误传播</strong>：用户态程序运行在受限环境中，不能直接访问硬件和其他进程的内存。即使用户程序发生崩溃或错误，也不会直接影响到系统内核和其他程序的运行。</li><li><strong>隔离故障</strong>：通过用户态和内核态的隔离，可以确保一个程序的错误不会影响到整个系统的稳定性。</li></ul><p><strong>3. 控制和管理</strong></p><ul><li><strong>资源管理</strong>：操作系统需要对系统资源（如CPU、内存、I/O设备等）进行统一管理和调度。通过内核态，可以实现对资源的有效控制和分配。</li><li><strong>系统调用接口</strong>：通过系统调用接口，用户程序可以请求内核服务，但这些请求是受控的。内核可以检查和验证这些请求，确保其合法性和安全性。</li></ul><p><strong>4. 提高效率</strong></p><ul><li><strong>中断处理</strong>：许多硬件中断（如定时器中断、I/O中断）需要立即响应。这些中断处理程序运行在内核态，可以快速地访问和操作硬件。</li><li><strong>直接硬件访问</strong>：内核态允许直接操作硬件设备，而不需要经过额外的抽象层，从而提高了操作的效率。</li></ul><h2 id="CPU-指令集权限">CPU 指令集权限</h2><p>指令集是 C P U 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 C P U 指令，而非常非常多的 C P U 指令 在一起，可以组成一个、甚至多个集合，指令的集合叫 C P U 指令集。</p><p>同时 C P U 指令集 有权限分级，大家试想，C P U 指令集 可以直接操作硬件的，要是因为指令操作的不规范`，造成的错误会影响整个计算机系统的。好比你写程序，因为对硬件操作不熟悉，导致操作系统内核、及其他所有正在运行的程序，都可能会因为操作失误而受到不可挽回的错误，最后只能重启计算机才行。</p><p>而对于硬件的操作是非常复杂的，参数众多，出问题的几率相当大，必须谨慎的进行操作，对开发人员来说是个艰巨的任务，还会增加负担，同时开发人员在这方面也不被信任，所以操作系统内核直接屏蔽开发人员对硬件操作的可能，都不让你碰到这些 C P U 指令集。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164319388.png" alt="image-20240630164319388"></p><p>针对上面的需求，硬件设备商直接提供硬件级别的支持，做法就是对 C P U 指令集设置了权限，不同级别权限能使用的 C P U 指令集 是有限的，以 Intel C P U 为例，Inter把 CPU 指令集 操作的权限由高到低划为4级：</p><ul><li>ring 0</li><li>ring 1</li><li>ring 2</li><li>ring 3</li></ul><p>其中 ring 0 权限最高，可以使用所有 C P U 指令集，ring 3 权限最低，仅能使用常规 C P U 指令集，不能使用操作硬件资源的 C P U 指令集，比如 I O 读写、网卡访问、申请内存都不行，Linux系统仅采用ring 0 和 ring 3 这2个权限。</p><p><strong>高情商</strong></p><p><strong>ring 0被叫做内核态，完全在操作系统内核中运行</strong></p><p><strong>ring 3被叫做用户态，在应用程序中运行</strong></p><p><strong>低情商</strong></p><p>执行内核空间的代码，具有ring 0保护级别，有对硬件的所有操作权限，可以执行所有C P U 指令集，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机。</p><p>在用户模式下，具有ring 3保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的。</p><h2 id="用户态与内核态的空间">用户态与内核态的空间</h2><p>在内存资源上的使用，操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」，以Linux32位操作系统为例，它的寻址空间范围是 4G（2的32次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 1G（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 3G（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164611780.png" alt="image-20240630164611780"></p><ul><li>用户态：只能操作 0-3G 范围的低位虚拟空间地址</li><li>内核态：0-4G 范围的虚拟空间地址都可以操作，尤其是对 3-4G 范围的高位虚拟空间地址必须由内核态去操作</li><li>补充：3G-4G 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。每个进程的 4G 虚拟空间地址，高位 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用，换句话说就是， 高位 1G 的内核空间是被所有进程共享的！</li></ul><p><strong>最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用</strong></p><h2 id="用户态与内核态的栗子">用户态与内核态的栗子</h2><p><strong>用户态：应用程序请求读取文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>系统调用：从用户态到内核态</strong></p><ul><li>当应用程序调用 <code>open()</code>, <code>read()</code> 和 <code>close()</code> 函数时，这些函数实际上是对内核提供的系统调用的封装。</li><li>例如，当 <code>read()</code> 被调用时，用户程序会发出一个系统调用陷入（trap）指令，触发从用户态到内核态的切换。<ul><li><code>read</code> 函数会执行一个系统调用指令（通常是 <code>syscall</code> 或 <code>int 0x80</code>），这是一种特殊的 CPU 指令，用于<strong>从用户态切换到内核态</strong>。</li><li>系统调用指令会引发一个陷入（trap），这是一种同步的中断，触发 CPU 切换到内核态，并跳转到内核中的系统调用处理入口。</li></ul></li></ul><p><strong>内核态：操作系统处理请求</strong></p><ul><li><p>内核接管控制权，进入内核态。CPU 跳转到内核的系统调用处理程序，根据系统调用号（每个系统调用都有一个唯一的编号，<code>read</code> 对应的编号通常是 0）找到相应的内核函数（sys_read）。内核中的文件系统代码开始执行，处理文件读取请求。</p></li><li><p>内核验证文件描述符，检查访问权限，然后执行实际的文件读取操作，将数据从磁盘读取到内核缓冲区。</p></li></ul><p><strong>从内核态返回用户态</strong></p><ul><li>文件读取操作完成后，内核将读取的数据复制到用户提供的缓冲区（<code>buffer</code>）。</li><li>内核返回结果，控制权交还给用户程序【通过 <code>iret</code> 或 <code>sysret</code> 指令返回用户态】，此时切换回用户态。</li></ul><p><strong>用户态：处理读取的数据</strong></p><ul><li>用户程序继续执行，处理从文件中读取的数据（如 <code>printf()</code> 打印数据）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户态：        应用程序（用户代码）      -&gt;      内核态： 操作系统（系统调用处理）</span><br><span class="line">  <span class="built_in">read</span>(fd, buffer, count)      系统调用陷入</span><br><span class="line">                                --&gt; 保存用户态上下文</span><br><span class="line">                                --&gt; 跳转到内核系统调用处理入口</span><br><span class="line">                                --&gt; 验证参数</span><br><span class="line">                                --&gt; 查找文件对象</span><br><span class="line">                                --&gt; 执行文件读取操作</span><br><span class="line">                                --&gt; 将数据复制到用户缓冲区</span><br><span class="line">                                --&gt; 设置返回值</span><br><span class="line">                                --&gt; 恢复用户态上下文</span><br><span class="line">                                --&gt; 返回用户态，继续执行用户程序</span><br></pre></td></tr></table></figure><h2 id="用户态与内核态的切换">用户态与内核态的切换</h2><ul><li><strong>保留用户态现场（上下文、寄存器、用户栈等）</strong></li><li><strong>复制用户态参数，用户栈切到内核栈，进入内核态</strong></li><li><strong>额外的检查（因为内核代码对用户不信任）</strong></li><li><strong>执行内核态代码</strong></li><li><strong>复制内核态代码执行结果，回到用户态</strong></li><li><strong>恢复用户态现场（上下文、寄存器、用户栈等）</strong></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164810614.png" alt="image-20240630164810614"></p><p>从上图我们可以看出来通过系统调用将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。</p><p>库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。</p><p>Shell顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，它是一种特殊的应用程序，俗称命令行。Shell也是可编程的，它有标准的Shell语法，符合其语法的文本叫Shell脚本，很多人都会用Shell脚本实现一些常用的功能，可以提高工作效率。</p><p>最后来说说，什么情况会导致用户态到内核态切换</p><p><strong>系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断，也可以称为软中断</strong>。</p><p><strong>异常：当 C P U 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常</strong>。</p><p><strong>中断：当 C P U 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 C P U 发出相应的中断信号，这时 C P U 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。</strong></p><p>扩展自：<a href="https://blog.csdn.net/u014571143/article/details/129660010">「操作系统」什么是用户态和内核态？为什么要区分</a></p>]]></content>
    
    
    <summary type="html">一文说懂用户态内核态</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程线程协程</title>
    <link href="https://penge666.github.io/posts/68a40dd3.html"/>
    <id>https://penge666.github.io/posts/68a40dd3.html</id>
    <published>2024-06-29T07:30:57.000Z</published>
    <updated>2024-06-30T08:18:49.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程">进程</h2><p>计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><blockquote><p><strong>补充：细聊PCB</strong></p></blockquote><p>在Linux中，PCB结构为task_struct;</p><p>task_struct是Linux内核的一种数据结构，它会被装载到RAM里并且包含进程的信息，每个进程都把它的信息放在task_struct这个数据结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">　　　表示进程的当前状态:</span></span><br><span class="line"><span class="comment">    TASK_RUNNING:正在运行或在就绪队列run-queue中准备运行的进程，实际参与进程调度。</span></span><br><span class="line"><span class="comment">    TASK_INTERRUPTIBLE:处于等待队列中的进程，待资源有效时唤醒，也可由其它进程通过信号(signal)或定时中断唤醒后进入就绪队列run-queue。</span></span><br><span class="line"><span class="comment">    TASK_UNINTERRUPTIBLE:处于等待队列中的进程，待资源有效时唤醒，不可由其它进程通过信号(signal)或定时中断唤醒。</span></span><br><span class="line"><span class="comment">    TASK_ZOMBIE:表示进程结束但尚未消亡的一种状态(僵死状态)。此时，进程已经结束运行且释放大部分资源，但尚未释放进程控制块。</span></span><br><span class="line"><span class="comment">    TASK_STOPPED:进程被暂停，通过其它进程的信号才能唤醒。导致这种状态的原因有二，或者是对收到SIGSTOP、SIGSTP、SIGTTIN或SIGTTOU信号的反应，或者是受其它进程的ptrace系统调用的控制而暂时将CPU交给控制进程。</span></span><br><span class="line"><span class="comment">    TASK_SWAPPING: 进程页面被交换出内存的进程。</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;　　<span class="comment">//进程标志，与管理有关,在调用fork()时给出</span></span><br><span class="line">    <span class="type">int</span> sigpending;　　　　　<span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">mm_segment_t</span> addr_limit; 　　<span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span></span><br><span class="line">    <span class="comment">/*用户线程空间地址: 0..0xBFFFFFFF。</span></span><br><span class="line"><span class="comment">       内核线程空间地址: 0..0xFFFFFFFF     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">exec_domain</span> *exec_domain;　　<span class="comment">//进程执行域</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> need_resched;　　　　　<span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ptrace;</span><br><span class="line">    <span class="type">int</span> lock_depth;　　<span class="comment">//锁深度</span></span><br><span class="line">    <span class="type">long</span> counter;　　　<span class="comment">//进程的基本时间片,在轮转法调度时表示进程当前还可运行多久，在进程开始运行是被赋为priority的值，以后每隔一个tick(时钟中断)递减1，减到0时引起新一轮调 度。重新调度将从run_queue队列选出counter值最大的就绪进程并给予CPU使用权，因此counter起到了进程的动态优先级的作用</span></span><br><span class="line">    <span class="type">long</span> nice;　　　　 <span class="comment">//静态优先级</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> policy;　　<span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR,分时进程:SCHED_OTHER</span></span><br><span class="line"><span class="comment">//在Linux 中, 采用按需分页的策略解决进程的内存需求。task_struct的数据成员mm 指向关于存储管理的mm_struct结构。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm;　　<span class="comment">//进程内存管理信息</span></span><br><span class="line">    <span class="type">int</span> has_cpu, processor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpus_allowed;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> run_list;　　<span class="comment">//指向运行队列的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sleep_time; 　　<span class="comment">//进程的睡眠时间</span></span><br><span class="line">    <span class="comment">//用于将系统中所有的进程连成一个双向循环链表,其根是init_task</span></span><br><span class="line">    <span class="comment">//在Linux 中所有进程(以PCB 的形式)组成一个双向链表,next_task和prev_task是链表的前后向指针</span></span><br><span class="line">　 <span class="keyword">struct</span> <span class="title class_">task_struct</span> *next_task, *prev_task;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *active_mm;  <span class="comment">//active_mm 指向活动地址空间。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linux_binfmt</span> *binfmt;　　<span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">    <span class="type">int</span> exit_code, exit_signal;</span><br><span class="line">    <span class="type">int</span> pdeath_signal;　　　　<span class="comment">//父进程终止是向子进程发送的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> personality;</span><br><span class="line">    <span class="type">int</span> dumpable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> did_exec:<span class="number">1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid; 　　<span class="comment">//进程标识符,用来代表一个进程</span></span><br><span class="line">    <span class="type">pid_t</span> pgrp;　 <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">    <span class="type">pid_t</span> tty_old_pgrp;  　　<span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">    <span class="type">pid_t</span> session;　　　　　　<span class="comment">//进程的会话标识</span></span><br><span class="line">    <span class="type">pid_t</span> tgid;</span><br><span class="line">    <span class="type">int</span> leader;　　　　　　　　<span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">    &lt;br&gt;　　<span class="comment">//指向最原始的进程任务指针，父进程任务指针，子进程任务指针，新兄弟进程任务指针，旧兄弟进程任务指针。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> thread_group;　　 <span class="comment">//线程链表</span></span><br><span class="line">    &lt;br&gt;　　<span class="comment">//用于将进程链入HASH表,系统进程除了链入双向链表外，还被加入到hash表中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *pidhash_next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> **pidhash_pprev;   </span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait_chldexit; 　　<span class="comment">//供wait4()使用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semaphore</span> *vfork_sem;　　　　 <span class="comment">//供vfork()使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_priority;　　　　　　<span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line">   &lt;br&gt;　　 <span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies,系统根据it_real_value</span></span><br><span class="line">    <span class="comment">//设置定时器的第一个终止时间.在定时器到期时，向进程发送SIGALRM信号，同时根据</span></span><br><span class="line">    <span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span></span><br><span class="line">    <span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送信号SIGPROF，并根据it_prof_incr重置时间.</span></span><br><span class="line">    <span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span></span><br><span class="line">    <span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据it_virt_incr重置初值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_incr, it_prof_incr, it_virt_incr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timer_list</span> real_timer;　　<span class="comment">//指向实时定时器的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tms</span> times; 　　　　　　　  <span class="comment">//记录进程消耗的时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time;　　　　<span class="comment">//进程创建的时间</span></span><br><span class="line">    <span class="type">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];<span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">    <span class="comment">//内存缺页和交换信息:</span></span><br><span class="line">    <span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copyon　Write页和匿名页）和主缺页数（从映射文件或交换</span></span><br><span class="line">    <span class="comment">//设备读入的页面数）；nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span></span><br><span class="line">    <span class="comment">//cmin_flt, cmaj_flt,cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span></span><br><span class="line">    <span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">    <span class="type">int</span> swappable:<span class="number">1</span>; 　　<span class="comment">//表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">    <span class="comment">//进程认证信息</span></span><br><span class="line">    <span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid，euid，egid为有效uid,gid</span></span><br><span class="line">    <span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件系统的访问权限时使用他们。</span></span><br><span class="line">    <span class="comment">//suid，sgid为备份uid,gid</span></span><br><span class="line">    <span class="type">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">    <span class="type">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">    <span class="type">int</span> ngroups;　　　　　<span class="comment">//记录进程在多少个用户组中</span></span><br><span class="line">    <span class="type">gid_t</span> groups[NGROUPS];　　<span class="comment">//记录进程所在的组</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;<span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span></span><br><span class="line">    <span class="type">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;　　<span class="comment">//代表进程所属的用户</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> rlim[RLIM_NLIMITS]; 　　<span class="comment">//与进程相关的资源限制信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math; 　　<span class="comment">//是否使用FPU</span></span><br><span class="line">    <span class="type">char</span> comm[<span class="number">16</span>]; 　　　　<span class="comment">//进程正在运行的可执行文件名</span></span><br><span class="line">     <span class="comment">//文件系统信息</span></span><br><span class="line">    <span class="type">int</span> link_count;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tty_struct</span> *tty;　　<span class="comment">//进程所在的控制终端，如果不需要控制终端，则该指针为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> locks;     <span class="comment">/* How many file locks are being held */</span></span><br><span class="line">    <span class="comment">//进程间通信信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sem_undo</span> *semundo;　　<span class="comment">//进程在信号量上的所有undo操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sem_queue</span> *semsleeping;　　<span class="comment">//当进程因为信号量操作而挂起时，他在该队列中记录等待的操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_struct</span> thread;　　　<span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs; 　　　　<span class="comment">//文件系统信息，fs保存了进程本身与VFS（虚拟文件系统）的关系信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *files;　<span class="comment">//打开文件信息</span></span><br><span class="line">     <span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">spinlock_t</span> sigmask_lock; <span class="comment">/* Protects signal and blocked */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">signal_struct</span> *sig;　<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked;　　　　　　<span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigpending</span> pending; <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;</span><br><span class="line">    <span class="type">size_t</span> sas_ss_size;</span><br><span class="line">    <span class="built_in">int</span> (*notifier)(<span class="type">void</span> *priv);</span><br><span class="line">    <span class="type">void</span> *notifier_data;</span><br><span class="line">    <span class="type">sigset_t</span> *notifier_mask;</span><br><span class="line">    <span class="comment">/* Thread group tracking */</span></span><br><span class="line">    u32 parent_exec_id;</span><br><span class="line">    u32 self_exec_id;</span><br><span class="line">    <span class="type">spinlock_t</span> alloc_lock;   <span class="comment">//用于申请空间时用的自旋锁。自旋锁的主要功能是临界区保护</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>进程标识信息</strong>：<ul><li><strong>进程ID（Process ID, PID）</strong>：唯一标识一个进程的标识符。</li><li><strong>父进程ID</strong>：创建当前进程的父进程的ID。</li></ul></li><li><strong>处理器状态信息</strong>：<ul><li><strong>程序计数器（Program Counter, PC）</strong>：指示下一条将要执行的指令的地址。</li><li><strong>CPU寄存器的内容</strong>：包括通用寄存器、浮点寄存器、状态寄存器等，保存进程的执行状态。</li><li><strong>进程状态</strong>：如运行、就绪、阻塞等状态。</li></ul></li><li><strong>内存管理信息</strong>：<ul><li><strong>基地址和限长寄存器</strong>：用于定义进程的地址空间范围。</li><li><strong>页表或段表</strong>：用于虚拟内存管理，映射虚拟地址到物理地址。</li></ul></li><li><strong>调度和状态信息</strong>：<ul><li><strong>进程优先级</strong>：用于进程调度。</li><li><strong>调度队列指针</strong>：指向进程在调度队列中的位置，用于进程调度。</li><li><strong>其他调度参数</strong>：如时间片长度、剩余时间等。</li></ul></li><li><strong>进程间通信信息</strong>：<ul><li><strong>信号量、消息队列</strong>：用于进程间通信和同步。</li><li><strong>管道和共享内存</strong>：用于进程间数据传输。</li></ul></li><li><strong>I/O状态信息</strong>：<ul><li><strong>打开的文件列表</strong>：进程当前打开的所有文件的列表。</li><li><strong>I/O设备信息</strong>：如进程使用的I/O设备、设备状态等。</li></ul></li><li><strong>汇总信息</strong>：<ul><li><strong>CPU使用时间</strong>：进程使用的CPU时间。</li><li><strong>内存使用量</strong>：进程使用的内存量。</li><li><strong>其他资源使用信息</strong>：如I/O操作次数等。</li></ul></li></ol><h2 id="线程">线程</h2><p>随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p><blockquote><p><strong>补充：进程切换流程</strong></p></blockquote><p>这里我举个例子说明进程A切换到进程B的例子：</p><ol><li><strong>保存进程A的上下文</strong>：<ul><li>将进程A的程序计数器、通用寄存器、状态寄存器等保存到进程A的PCB中。</li><li>保存进程A的页表基地址、段表基地址到PCB中。</li><li>保存进程A的文件描述符表、信号处理信息等。</li></ul></li><li><strong>更新进程A的状态</strong>：<ul><li>将进程A的状态从“运行”改为“就绪”或“阻塞”。</li></ul></li><li><strong>调度器选择进程B</strong>：<ul><li>调度器根据调度算法选择进程B。</li><li>将进程B的状态从“就绪”改为“运行”。</li></ul></li><li><strong>加载进程B的上下文</strong>：<ul><li>从进程B的PCB中恢复程序计数器、通用寄存器、状态寄存器等内容。</li><li>设置页表基地址和段表基地址为进程B的地址空间。</li><li>恢复进程B的文件描述符表、信号处理信息等。</li></ul></li><li><strong>切换到进程B并执行</strong>：<ul><li>更新程序计数器为进程B的下一条指令地址。</li><li>CPU开始执行进程B的代码。</li></ul></li></ol><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p>为了理解线程和线程在内存的布局，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">进程A</span><br><span class="line">├── 进程控制块（PCB）</span><br><span class="line">│   ├── 进程ID（PID）</span><br><span class="line">│   ├── 进程状态</span><br><span class="line">│   ├── 调度信息</span><br><span class="line">│   └── 其他元数据</span><br><span class="line">├── 内存空间</span><br><span class="line">│   ├── 代码段</span><br><span class="line">│   ├── 数据段</span><br><span class="line">│   ├── 堆</span><br><span class="line">│   └── 共享资源</span><br><span class="line">│       ├── 文件描述符</span><br><span class="line">│       └── 信号处理信息</span><br><span class="line">├── 线程1</span><br><span class="line">│   ├── 线程控制块（TCB）</span><br><span class="line">│   │   ├── 线程ID（TID）</span><br><span class="line">│   │   ├── 线程状态</span><br><span class="line">│   │   ├── 寄存器内容</span><br><span class="line">│   │   └── 程序计数器</span><br><span class="line">│   ├── 独立栈</span><br><span class="line">│   └── 共享资源（与进程共享）</span><br><span class="line">├── 线程2</span><br><span class="line">│   ├── 线程控制块（TCB）</span><br><span class="line">│   │   ├── 线程ID（TID）</span><br><span class="line">│   │   ├── 线程状态</span><br><span class="line">│   │   ├── 寄存器内容</span><br><span class="line">│   │   └── 程序计数器</span><br><span class="line">│   ├── 独立栈</span><br><span class="line">│   └── 共享资源（与进程共享）</span><br></pre></td></tr></table></figure><p><strong>线程（Thread）</strong></p><ul><li><strong>线程控制块（TCB）</strong>：保存线程的元数据，如线程ID、状态、寄存器内容、程序计数器等。</li><li><strong>独立栈</strong>：每个线程都有自己的栈，用于存储局部变量和函数调用信息。</li><li><strong>共享资源</strong>：与进程内其他线程共享代码段、数据段、堆和文件描述符等资源。</li></ul><p><strong>因此，我们就知道线程上下文切换比进程上下文切换要快</strong>。</p><p>原因：</p><ol><li><strong>资源共享</strong>：<ul><li><strong>线程</strong>：线程共享同一进程的内存地址空间、文件描述符和其他资源，只需要切换寄存器和程序计数器等上下文信息。</li><li><strong>进程</strong>：进程切换需要切换整个内存地址空间，包括页表和其他资源，涉及更多的状态保存和恢复。</li></ul></li><li><strong>缓存效率</strong>：<ul><li><strong>线程</strong>：由于线程共享同一进程的内存空间，切换时不会导致缓存（如CPU缓存和TLB）的显著失效，提高了缓存命中率。</li><li><strong>进程</strong>：进程切换通常会导致缓存失效，需要重新加载缓存数据，增加了额外的开销。</li></ul></li><li><strong>模式切换</strong>：<ul><li><strong>线程</strong>：线程切换通常在用户态完成，不涉及内核态和用户态的频繁切换。</li><li><strong>进程</strong>：进程切换需要在内核态和用户态之间切换，涉及更多的特权级别改变和指令开销。</li></ul></li></ol><p><strong>总结</strong></p><p>简单来说：进程切换需要切换整个地址空间，包括页表切换和缓存刷新等，还需要保存进程的上下文信息，包括 CPU 寄存器状态和栈指针。但是，同一进程内的线程共享内存地址空间，只需要切换上下文。</p><h3 id="任务调度">任务调度</h3><p>在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。</p><p>上述过程中，任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。</p><p>这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。多任务运行过程的示意图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629160358544.png" alt="image-20240629160358544"></p><h3 id="多线程与多核">多线程与多核</h3><p>上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？</p><p>其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。</p><p>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。<br>内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</p><p>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629162446104.png" alt="image-20240629162446104"></p><p>超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。【超线程技术通过在每个物理核心上模拟多个逻辑处理器，使得核心能够同时处理多个线程，最大化资源利用，提高并行处理能力和整体性能。】</p><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。</p><h4 id="一对一模型">一对一模型</h4><p>对于一对一模型来说，一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果CPU没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。</p><p>但一对一模型也有两个缺点：</p><ol><li>许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163102594.png" alt="image-20240629163102594"></p><h4 id="多对一模型">多对一模型</h4><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。因此相对一对一模型，多对一模型的线程上下文切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。</p><p>但多对一模型也有两个缺点：</p><ol><li>如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；</li><li>在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163124909.png" alt="image-20240629163124909"></p><h4 id="多对多模型">多对多模型</h4><p>多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。由线程库负责在可用的可调度实体上调度用户线程，这使得线程的上下文切换非常快，因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。</p><p>多对多模型的优点有：</p><ol><li>一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；</li><li>多对多模型对用户线程的数量没有限制；</li><li>在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163145410.png" alt="image-20240629163145410"></p><h3 id="线程的生命周期">线程的生命周期</h3><p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。</p><p>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及macOS等流行的操作系统。</p><p>我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163308718.png" alt="image-20240629163308718"></p><p><strong>线程与进程的区别</strong></p><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li><li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li><li><strong>稳定性方面</strong>：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li><li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</li><li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</li></ul><h2 id="协程">协程</h2><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163537069.png" alt="image-20240629163537069"></p><h3 id="协程的目的">协程的目的</h3><p>在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p><p>对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。</p><p>而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。</p><h3 id="协程的特点">协程的特点</h3><ol><li><strong>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</strong></li><li><strong>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</strong></li><li><strong>由于在同一个线程上，因此可以避免竞争关系而使用锁。</strong></li><li><strong>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</strong></li></ol><h3 id="协程的原理">协程的原理</h3><p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由<code>coroutine</code>负责调度的线程称为<code>Fiber</code>。比如Golang里的 go关键字其实就是负责开启一个<code>Fiber</code>，让<code>func</code>逻辑跑在上面。</p><p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。<br>因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。</p><p><strong>协程与线程比较</strong></p><table><thead><tr><th>比较项</th><th style="text-align:center">线程</th><th style="text-align:center">协程</th></tr></thead><tbody><tr><td>占用资源</td><td style="text-align:center">初始单位为1MB,固定不可变</td><td style="text-align:center">初始一般为 2KB，可随需要而增大</td></tr><tr><td>调度所属</td><td style="text-align:center">由 OS 的内核完成</td><td style="text-align:center">由用户完成</td></tr><tr><td>切换开销</td><td style="text-align:center">涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td><td style="text-align:center">只有三个寄存器的值修改 - PC / SP / DX.</td></tr><tr><td>性能问题</td><td style="text-align:center">资源占用太高，频繁创建销毁会带来严重的性能问题</td><td style="text-align:center">资源占用小,不会带来严重的性能问题</td></tr><tr><td>数据同步</td><td style="text-align:center">需要用锁等机制确保数据的一直性和可见性</td><td style="text-align:center">不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td></tr></tbody></table><p><strong>线程</strong>：适合CPU密集型任务，利用多核并行计算能力，适合需要高并发的场景，但有较高的资源占用和上下文切换开销。</p><p><strong>协程</strong>：适合I/O密集型任务，通过非阻塞I/O和协作调度提高效率，轻量级且避免复杂的同步问题，但无法利用多核并行计算。</p><p>部分学习自：[<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">一文读懂什么是进程、线程、协程</a>](<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">https://www.cnblogs.com/Survivalist/p/11527949.html</a>)</p>]]></content>
    
    
    <summary type="html">理解进程、线程与协程：高效并发编程的关键</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>DNS协议解析</title>
    <link href="https://penge666.github.io/posts/2eaa30e5.html"/>
    <id>https://penge666.github.io/posts/2eaa30e5.html</id>
    <published>2024-06-28T09:17:34.000Z</published>
    <updated>2024-06-30T09:22:07.170Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/351059293">超详细 DNS 协议解析</a></p><h2 id="0-前言"><strong>0. 前言</strong></h2><p>为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171832226.png" alt="image-20240630171832226"></p><h2 id="1-什么是-DNS-协议"><strong>1. 什么是 DNS 协议</strong></h2><p>在学习 DNS 协议之前，我们先区分一下域名和 IP 地址这个两个概念：</p><ul><li><strong>IP 地址</strong>：一长串能够唯一地标记网络上的计算机的数字</li><li><strong>域名</strong>：又称网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）比如 <code>www.baidu.com</code></li></ul><blockquote><p>不知道有没有同学会混淆域名和<strong>网址</strong>的概念，可以这样理解，网址里面含有域名。举个例子：<code>www.gitee.com/veal98</code> 就是一个网址，而 <code>www.gitee.com</code> 就是域名</p></blockquote><p>由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并<strong>通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射</strong>，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析。</p><blockquote><p>DNS 协议可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。但<strong>大多数情况下 DNS 都使用 UDP 进行传输</strong>。</p></blockquote><h2 id="2-域名详解"><strong>2. 域名详解</strong></h2><p>❓ 那么域名由谁来规定和管理呢？不能是随便写吧？</p><p>全世界域名的最高管理机构，是一个叫做 ICANN （Internet Corporation for Assigned Names and Numbers）的组织，总部在美国加州。<strong>ICANN 负责管理全世界域名系统的运作</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171852966.png" alt="image-20240630171852966"></p><p>域名其实是具有一定的层次结构的，从上到下依次为：<strong>根域名</strong>、<strong>顶级域名</strong>（top level domain，TLD）、<strong>二级域名</strong>、（三级域名）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171904380.png" alt="image-20240630171904380"></p><h3 id="①-顶级域名"><strong>① 顶级域名</strong></h3><p>先来讲讲<strong>顶级域名</strong>（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<code>www.baidu.com</code> 的顶级域名就是 <code>.com</code>。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。截至 2015 年 7 月，顶级域名共有 1058 个，它们大致可以分成两类：</p><ul><li>一类是<strong>通用顶级域名</strong>（gTLD），比如<code>.com</code>、<code>.net</code>、<code>.edu</code>、<code>.org</code>、<code>.xxx</code>等等，共有 700 多个。</li><li>另一类是<strong>国家顶级域名</strong>（ccTLD），代表不同的国家和地区，比如<code>.cn</code>（中国）、<code>.io</code>（英属印度洋领地）、<code>.cc</code>（ 科科斯群岛）、<code>.tv</code>（图瓦卢）等，共有 300 多个。</li></ul><p>当然，ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个<strong>托管商</strong>，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，<code>.cn</code> 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 <code>.cn</code> 域名的各种政策。</p><h3 id="②-二级域名"><strong>② 二级域名</strong></h3><p>而<strong>二级域名</strong>(Second Level Domain,SLD) 在通用顶级域名或国家顶级域名之下具有不同的意义：</p><ul><li>通用顶级域名下的二级域名：一般是指域名注册人选择使用的网上名称，如 <code>yahoo.com</code>（商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如 <code>baidu.com</code>）</li><li>国家顶级域名下的二级域名：一般是指类似于通用顶级域名的表示注册人类别和功能的标志。例如，在 <code>.com.cn</code> 域名结构中，<code>.com</code> 此时是置于国家顶级域名 <code>.cn</code> 下的二级域名，表示中国的商业性组织，以此类推。</li></ul><p><strong>三级域名</strong>是形如 <code>www.baidu.com</code> 的域名，可以当做是二级域名的子域名，特征为域名包含两个 <code>.</code>。对于域名所有者/使用者而言，三级域名都是二级域名的附属物而无需单独费用。<strong>三级域名甚至不能称为域名，一般称之为域名下的 “二级目录”</strong>。</p><h3 id="③-根域名"><strong>③ 根域名</strong></h3><p>❓ 那么<strong>根域名</strong>在哪里呢？在层次结构中根域名不是最顶级的吗？域名中怎么没有看见它？</p><p>由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<code>www.xxx.com</code> 被写成 <code>www.xxx.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171917340.png" alt="image-20240630171917340"></p><p>理论上，<strong>所有域名的查询都必须先查询根域名</strong>，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，<strong>ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171933731.png" alt="image-20240630171933731"></p><p>比如，我要访问<code>abc.xyz</code>，也必须先去询问根域名列表，它会告诉我 <code>.xyz</code> 域名由 CentralNic 公司托管。根域名列表还记载，<code>.google</code>由谷歌公司托管，<code>.apple</code>由苹果公司托管等等。</p><p>由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。</p><h2 id="3-域名服务器详解"><strong>3. 域名服务器详解</strong></h2><p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。一个域名服务器所负责管里的分层叫作 <strong>区 (ZONE)</strong>。域名的每层都设有一个域名服务器：</p><ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器</li></ul><p>下面这幅图就很直观了：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171945529.png" alt="image-20240630171945529"></p><p>除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，即<strong>本地域名服务器</strong>。下面我们分别讲解这四种服务器都是用来干什么的</p><h3 id="①-根域名服务器"><strong>① 根域名服务器</strong></h3><p>上面我们提到，ICANN 维护着一张根域名列表，里面记载着顶级域名和对应的托管商，其实根域名列表的正式名称是 <strong>DNS 根区</strong>（DNS root zone），保存 DNS 根区文件的服务器，就叫做 <strong>DNS 根域名服务器</strong>（root name server）。根域名服务器<strong>保存所有的顶级域名服务器的地址</strong></p><p>由于早期的 DNS 查询结果是一个 512 字节的 UDP 数据包。这个包最多可以容纳 13 个服务器的地址，因此就规定全世界有 13 个根域名服务器，编号从 <code>a.root-servers.net</code> 一直到 <code>m.root-servers.net</code>。其中 10 台设置在美国，另外各有一台设置于荷兰、瑞典和日本。</p><p>前面我们说过，理论上<strong>所有域名的查询都必须先查询根域名</strong>，所以一般来说所有的域名服务器都会注册一份根域名服务器的 IP 地址的缓存，用于在必要的时候向其发送请求。</p><h3 id="②-顶级域名服务器"><strong>② 顶级域名服务器</strong></h3><p>按照根域名服务器管理顶级域名的逻辑，顶级域名服务器显然就是用来<strong>管理注册在该顶级域名下的所有二级域名</strong>的，<strong>记录这些二级域名的 IP 地址</strong>。</p><h3 id="③-权限域名服务器"><strong>③ 权限域名服务器</strong></h3><p>按照上面的逻辑，权限域名服务器应该是管理注册在二级域名下的所有三/四级域名的，但其实不是这样，如果一个二级域名或者一个三/四级域名对应一个域名服务器，则域名服务器数量会很多，我们需要使用<strong>划分区</strong>的办法来解决这个问题。那么权限域名服务器就是负责管理一个“<strong>区</strong>”的域名服务器。</p><p>❓ 什么是区？怎样划分区呢？</p><p>区和域其实是不同的，区可以有多种不同的划分方法。以百度为例，我们假设有 <code>fanyi.baidu.com</code>、<code>ai.baidu.com</code>、<code>tieba.baidu.com</code> 这三个三级域名。我们可以这样分区，<code>fanyi.baidu.com</code> 和 <code>tieba.baidu.com</code> 放在 <code>baidu.com</code> 权限域名服务器，<code>ai.baidu.com</code> 放在 <code>ai.baidu.com</code> 权限域名服务器中。并且 <code>baidu.com</code> 权限域名服务器和 <code>ai.baidu.com</code> 权限域名服务器是<strong>同等地位</strong>的，而具体怎么分区是百度公司根据域名多少、访问多少等情况去自己规定的。</p><p>画个图直观理解一下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171957318.png" alt="image-20240630171957318"></p><h3 id="④-本地域名服务器"><strong>④ 本地域名服务器</strong></h3><p>除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，就是<strong>本地域名服务器</strong>（也被称为<strong>权威域名服务器</strong>）。本地域名服务器是电脑解析时的<strong>默认</strong>域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器。常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172008191.png" alt="image-20240630172008191"></p><p>每个因特网服务提供者或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。<strong>当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</strong>。<strong>本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询</strong>。</p><p>那么具体本地域名服务器是如何向上级域名服务器转发查询请求的呢？</p><h2 id="4-DNS-查询方式"><strong>4. DNS 查询方式</strong></h2><p>具体 DNS 查询的方式有两种：</p><ul><li>递归查询</li><li>迭代查询</li></ul><p>所谓迭代就是，如果请求的接收者不知道所请求的内容，那么<strong>接收者将扮演请求者</strong>，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。</p><p>通俗点来说，在递归查询中，如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案；而迭代查询则是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。</p><p>一般来说，<strong>域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大</strong>。通过下面这两个图就能很好的理解了</p><p>1）递归查询：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172020763.png" alt="image-20240630172020763"></p><p>2）迭代查询：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172030301.png" alt="image-20240630172030301"></p><h2 id="5-域名缓存"><strong>5. 域名缓存</strong></h2><p>上面讲解的是域名服务器之间的 DNS 查询请求过程，但实际上，每个时刻都有无数网民要上网，那每次都去访问本地域名服务器去获取 IP 地址显然是不实际的。解决方法就是<strong>使用缓存保存域名和 IP 地址的映射</strong>。</p><p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p><p>1）<strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</p><p>2）<strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172049327.png" alt="image-20240630172049327"></p><p>Windows 系统默认开启 DNS 缓存服务，服务名是 <code>DNSClient</code>，可以缓存一些常用的域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172100462.png" alt="image-20240630172100462"></p><p>使用命令 <code>ipconfig/displaydns</code> 可以查看电脑中缓存的域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172113442.png" alt="image-20240630172113442"></p><p>⭐ 在浏览器中进行访问的时候，会优先查询浏览器缓存，如果未命中则继续查询操作系统缓存，最后再查询本地域名服务器，然后本地域名服务器会递归的查找域名记录，最后返回结果。<strong>主机和本地域名服务器之间的查询方式是递归查询</strong>，也就是说主机请求本地域名服务器，那么本地域名服务器作为请求的接收者一定要给主机想要的答案。</p><h2 id="6-完整域名解析过程"><strong>6. 完整域名解析过程</strong></h2><p>OK，将我们上面所说的域名服务器之间的 DNS 查询请求过程和域名缓存结合起来，就是一个完整的 DNS 协议进行域名解析的过程。这里我们以正向解析为例（域名解析成 IP 地址）：</p><p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p><p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p><p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p><p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p><ul><li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li><li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul><p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p><p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p><p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p><p>配合下图直观理解：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172124777.png" alt="image-20240630172124777"></p>]]></content>
    
    
    <summary type="html">超详细DNS协议解析</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会</title>
    <link href="https://penge666.github.io/posts/df083c4d.html"/>
    <id>https://penge666.github.io/posts/df083c4d.html</id>
    <published>2024-06-27T03:39:19.000Z</published>
    <updated>2024-06-29T07:13:44.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-了解SQL">第1章 了解SQL</h2><ol><li><p><strong>数据库（database）</strong> 保存有组织的数据的容器（通常是一个文件或一组文件）。</p></li><li><p><strong>表（table）</strong> 某种特定类型数据的结构化清单。</p></li><li><p><strong>模式（schema）</strong> 关于数据库和表的布局及特性的信息。</p></li><li><p><strong>列（column）</strong> 表中的一个字段。所有表都是由一个或多个列组成的。</p></li><li><p><strong>数据类型（datatype）</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p></li><li><p><strong>行（row）</strong> 表中的一个记录。</p></li><li><p><strong>主键（primary key）</strong> 一列（或一组列），其值能够唯一区分表中每个行。</p><p>表中的任何列都可以作为主键，只要它满足以下条件：</p><blockquote><ol><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li></ol></blockquote><p>主键的最好习惯：</p><blockquote><ol><li>不更新主键列中的值；</li><li>不重用主键列的值；</li><li>不在主键列中使用可能会更改的值。</li></ol></blockquote></li></ol><h2 id="第2章-MySQL简介">第2章 MySQL简介</h2><ol><li>DBMS（数据库管理系统）分两类：<ol><li>基于共享文件系统的DBMS，如Microsoft Access和FileMaker；</li><li>基于客户机—服务器的DBMS，如MySQL、Oracle以及Microsoft SQL Server。</li></ol></li></ol><h2 id="第3章-使用MySQL">第3章 使用MySQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">/* 显示所有数据库 */</span></span><br><span class="line">USE mysql; <span class="comment">/* 选择数据库mysql */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> TABLES; <span class="comment">/* 显示所有表 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> <span class="keyword">user</span>; <span class="comment">/* 显示user表中的列信息 */</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">user</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS; <span class="comment">/* 显示服务器状态信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mysql; <span class="comment">/* 显示创建数据库mysql的SQL语句 */</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>; <span class="comment">/* 显示创建表user的SQL语句 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> grants; <span class="comment">/* 显示用户的授权信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> ERRORS; <span class="comment">/* 显示服务器中的错误信息 */</span></span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS; <span class="comment">/* 显示服务器中的警告信息 */</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用<code>help show</code> 来查看帮助信息。</p></blockquote><h2 id="第4章-检索数据">第4章 检索数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">SELECT</span> user.User <span class="keyword">FROM</span> <span class="keyword">user</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> mysql.user; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Host,<span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span>; <span class="comment">/* 去除重复 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">3</span>; <span class="comment">/* 只显示查询结果的前3条记录 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">2</span>,<span class="number">3</span>; <span class="comment">/* 只显示查询结果的第2条开始（下标从0开始）后面的3条记录 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">2</span>; <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><blockquote><p>SQL不区分大小写，也忽略空格。</p><p>DISTINCT关键字应用于所有列而不仅是前置它的列。</p></blockquote><h2 id="第5章-排序检索数据">第5章 排序检索数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span>; <span class="comment">/* 升序排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">ASC</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">DESC</span>; <span class="comment">/* 降序排序 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span>, Host; <span class="comment">/* 先按User升序排序，再按Host升序排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">DESC</span>, Host; <span class="comment">/* 先按User降序排序，再按Host升序排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">DESC</span>, Host <span class="keyword">ASC</span>; <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><blockquote><p>DESC关键字只应用到直接位于其前面的列名。</p></blockquote><h2 id="第6章-过滤数据">第6章 过滤数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">!=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&lt;&gt;</span> <span class="number">0</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&lt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&lt;=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&gt;=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ssl_cipher <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">/* ssl_cipher字段为NULL */</span></span><br></pre></td></tr></table></figure><h2 id="第7章-数据过滤">第7章 数据过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span> <span class="keyword">OR</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span> <span class="keyword">OR</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>) <span class="keyword">AND</span> max_connections <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host <span class="keyword">IN</span> (<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>AND的优先级比OR高。</p><p>IN操作符完成与OR相同的功能，但是更快。</p></blockquote><h2 id="第8章-用通配符进行过滤">第8章 用通配符进行过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host <span class="keyword">LIKE</span> <span class="string">&#x27;local%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> <span class="keyword">LIKE</span> <span class="string">&#x27;r__t&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>百分号（%）表示任何字符出现任意次数。%不能匹配NULL值。</p><p>下划线（_）只匹配单个字符。</p></blockquote><h2 id="第9章-用正则表达式进行搜索">第9章 用正则表达式进行搜索</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> REGEXP <span class="string">&#x27;r..t&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host REGEXP <span class="string">&#x27;%|localhost&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> REGEXP <span class="string">&#x27;r[a-z]&#123;2&#125;t&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> REGEXP <span class="string">&#x27;mysql\\.sys&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用类似<code>SELECT 'hello' REGEXP '[0-9]'</code>这样的SQL来测试正常表达式，匹配成功返回1，否则返回0。</p></blockquote><h2 id="第10章-创建计算字段">第10章 创建计算字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="keyword">User</span>, <span class="string">&#x27;(&#x27;</span>, Host, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="keyword">User</span>, <span class="string">&#x27;(&#x27;</span>, Host, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> UserHost <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h2 id="第11章-使用数据处理函数">第11章 使用数据处理函数</h2><table><thead><tr><th style="text-align:left"><strong>函数</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">Left()</td><td style="text-align:left">返回串左边的字符</td></tr><tr><td style="text-align:left">Length()</td><td style="text-align:left">返回串的长度</td></tr><tr><td style="text-align:left">Locate()</td><td style="text-align:left">找出串的一个子串</td></tr><tr><td style="text-align:left">Lower()</td><td style="text-align:left">将串转换为小写</td></tr><tr><td style="text-align:left">LTrim()</td><td style="text-align:left">去掉串左边的空格返</td></tr><tr><td style="text-align:left">Right()</td><td style="text-align:left">返回串右边的字符</td></tr><tr><td style="text-align:left">RTrim()</td><td style="text-align:left">去掉串右边的空格</td></tr><tr><td style="text-align:left">Soundex()</td><td style="text-align:left">返回串的SOUNDEX值</td></tr><tr><td style="text-align:left">SubString()</td><td style="text-align:left">返回子串的字符</td></tr><tr><td style="text-align:left">Upper()</td><td style="text-align:left">将串转换为大写</td></tr><tr><td style="text-align:left">AddDate()</td><td style="text-align:left">增加一个日期（天、周等）</td></tr><tr><td style="text-align:left">AddTime()</td><td style="text-align:left">增加一个时间（时、分等）</td></tr><tr><td style="text-align:left">CurDate()</td><td style="text-align:left">返回当前日期</td></tr><tr><td style="text-align:left">CurTime()</td><td style="text-align:left">返回当前时间</td></tr><tr><td style="text-align:left">Date()</td><td style="text-align:left">返回日期时间的日期部分</td></tr><tr><td style="text-align:left">DateDiff()</td><td style="text-align:left">计算两个日期之差</td></tr><tr><td style="text-align:left">Date_Add()</td><td style="text-align:left">高度灵活的日期运算函数</td></tr><tr><td style="text-align:left">Date_Format()</td><td style="text-align:left">返回一个格式化的日期或时间串</td></tr><tr><td style="text-align:left">Day()</td><td style="text-align:left">返回一个日期的天数部分</td></tr><tr><td style="text-align:left">DayOfWeek()</td><td style="text-align:left">对于一个日期，返回对应的星期几</td></tr><tr><td style="text-align:left">Hour()</td><td style="text-align:left">返回一个时间的小时部分</td></tr><tr><td style="text-align:left">Minute()</td><td style="text-align:left">返回一个时间的分钟部分</td></tr><tr><td style="text-align:left">Month()</td><td style="text-align:left">返回一个日期的月份部分</td></tr><tr><td style="text-align:left">Now()</td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left">Second()</td><td style="text-align:left">返回一个时间的秒部分</td></tr><tr><td style="text-align:left">Time()</td><td style="text-align:left">返回一个日期时间的时间部分</td></tr><tr><td style="text-align:left">Year()</td><td style="text-align:left">返回一个日期的年份部分</td></tr><tr><td style="text-align:left">Abs()</td><td style="text-align:left">返回一个数的绝对值</td></tr><tr><td style="text-align:left">Cos()</td><td style="text-align:left">返回一个角度的余弦</td></tr><tr><td style="text-align:left">Exp()</td><td style="text-align:left">返回一个数的指数值</td></tr><tr><td style="text-align:left">Mod()</td><td style="text-align:left">返回除操作的余数</td></tr><tr><td style="text-align:left">Pi()</td><td style="text-align:left">返回圆周率</td></tr><tr><td style="text-align:left">Rand()</td><td style="text-align:left">返回一个随机数</td></tr><tr><td style="text-align:left">Sin()</td><td style="text-align:left">返回一个角度的正弦</td></tr><tr><td style="text-align:left">Sqrt()</td><td style="text-align:left">返回一个数的平方根</td></tr><tr><td style="text-align:left">Tan()</td><td style="text-align:left">返回一个角度的正切</td></tr></tbody></table><blockquote><p>不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。并且总是应该使用4位数字的年份。</p></blockquote><h2 id="第12章-汇总数据">第12章 汇总数据</h2><ol><li><p><strong>聚集函数（aggregate function）</strong> 运行在行组上，计算和返回单个值的函数。</p></li><li><p><strong>AVG()函数</strong> 计算单列的平均值。</p><blockquote><p>AVG()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>COUNT()函数</strong> 进行计数。</p><blockquote><p>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p><p>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最大值。</p><blockquote><p>MAX()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最小值。</p><blockquote><p>MIN()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>SUM()函数</strong> 用来返回指定列值的和（总计）。</p><blockquote><p>SUM()函数忽略列值为NULL的行。</p></blockquote></li><li><p>以上5个聚集函数都可以如下使用：</p><ol><li><p>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</p></li><li><p>只包含不同的值，指定DISTINCT参数。</p><blockquote><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p><p><strong>将DISTINCT用于MIN()和MAX()</strong> 。虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。</p></blockquote></li></ol></li></ol><h2 id="第13章-分组数据">第13章 分组数据</h2><ol><li><p>使用GROUP BY创建分组时需要注意：</p><ol><li><p>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</p></li><li><p>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p></li><li><p>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</p></li><li><p>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p></li><li><p>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p></li><li><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p><blockquote><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。</p></blockquote></li></ol></li><li><p>分组过滤操作HAVING支持所有WHERE操作符。</p><blockquote><p>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。</p></blockquote></li><li><p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。</p></li><li><p>SELECT子句顺序</p></li></ol><table><thead><tr><th style="text-align:left"><strong>子句</strong></th><th style="text-align:left"><strong>说明</strong></th><th style="text-align:left"><strong>是否必须使用</strong></th></tr></thead><tbody><tr><td style="text-align:left">SELECT</td><td style="text-align:left">要返回的列或表达式</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">FROM</td><td style="text-align:left">从中检索数据的表</td><td style="text-align:left">仅在从表选择数据时使用</td></tr><tr><td style="text-align:left">WHERE</td><td style="text-align:left">行级过滤</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">GROUP BY</td><td style="text-align:left">分组说明</td><td style="text-align:left">仅在按组计算聚集时使用</td></tr><tr><td style="text-align:left">HAVING</td><td style="text-align:left">组级过滤</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">ORDER BY</td><td style="text-align:left">输出排序顺序</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">LIMIT</td><td style="text-align:left">要检索的行数</td><td style="text-align:left">否</td></tr></tbody></table><h2 id="第14章-使用子查询">第14章 使用子查询</h2><ol><li>子查询就是可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</li><li>在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</li></ol><h2 id="第15章-连结表">第15章 连结表</h2><ol><li><p><strong>外键（foreign key）</strong> 为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></li><li><p>由没有联结条件的表关系返回的结果为 <strong>笛卡儿积（cartesian product）</strong> 。如下：</p><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure><blockquote><p>有时我们会听到返回称为 <strong>叉联结（cross join）</strong> 的笛卡儿积的联结类型。</p></blockquote></li><li><p><strong>等值联结（equijoin）</strong> 基于两个表之间的相等测试。这种联结也称为 <strong>内部联结</strong> 。下面的SQL都是等值联结：</p><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第16章-创建高级联结">第16章 创建高级联结</h2><ol><li><p>表别名只在查询执行中使用。</p></li><li><p>自联结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id <span class="operator">=</span> p2.vend_id</span><br><span class="line">  <span class="keyword">AND</span> p2.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>自联结远比处理子查询快得多。</p></blockquote></li><li><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。 <strong>自然联结</strong> 排除多次出现，使每个列只返回一次。这一般是通过对表使用通配符（SELECT*），对所有其他表的列使用明确的子集来完成的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.<span class="operator">*</span>, o.order_num, o.order_data, io.prod_id, io.quantity, io.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> io</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line">  <span class="keyword">AND</span> io.order_num <span class="operator">=</span> o.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;FB&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>外部联结在结果中包含了那些在另一个表中没有关联行的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure></li><li><p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN。</p></li></ol><h2 id="第17章-组合查询">第17章 组合查询</h2><ol><li>MySQL允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为 <strong>并（union）</strong> 或 <strong>复合查询（compound query）</strong> 。</li><li>使用UNION规则时需要遵循的规则：<ol><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ol></li><li>UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。这是UNION的默认行为，如果想返回所有匹配行，可使用UNION ALL而不是UNION。</li><li>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</li></ol><h2 id="第18章-全文本搜索">第18章 全文本搜索</h2><ol><li><p>MyISAM支持全文本搜索，InnoDB不支持。</p></li><li><p>为了进行全文本搜索，必须索引被搜索的列。一般在创建表时使用FULLTEXT启用全文本搜索。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id     <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id     <span class="type">CHAR</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_date   DATETIME    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_text   TEXT        <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><blockquote><p>不要在导入数据时使用FULLTEXT。应该首先导入所有数据，然后再修改表，定义FULLTEXT。</p></blockquote></li><li><p>使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;rabbit&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p><p>搜索不区分大小写，除非使用BINARY方式，否则全文本搜索不区分大小写。</p></blockquote></li><li><p>也是使用LIKE子句进行搜索。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> note_text <span class="keyword">LIKE</span> <span class="string">&#x27;%rabbit%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用LIKE子句进行搜索时，不会对结果进行排序。而使用函数Match()和Against()执行全文本搜索时，会对结果进行排序，具有较高等级的行先返回。等级可以通过下面的方式获取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text, <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;rabbit&#x27;</span>) <span class="keyword">AS</span> <span class="string">&#x27;rank&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> productnotes;</span><br></pre></td></tr></table></figure></li><li><p>在使用 <strong>查询扩展</strong> 时，MySQL对数据和索引进行两遍扫描来完成搜索：</p><ol><li><p>进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</p></li><li><p>MySQL检查这些匹配行并选择所有有用的词；</p></li><li><p>MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>即使没有FULLTEXT索引也可以使用 <strong>布尔文本搜索</strong> ，但这是一种非常缓慢的操作。</p><blockquote><p><strong>排列而不排序</strong> 在布尔方式中，不按等级值降序排序返回的</p></blockquote></li><li><p>全文本搜索的使用说明</p><ol><li><p>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</p></li><li><p>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表。</p></li><li><p>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。</p></li><li><p>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</p></li><li><p>忽略词中的单引号。例如，don’t索引为dont。</p></li><li><p>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</p></li><li><p>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;ft%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一些例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;+rabbit +bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit和bait */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;rabbit bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit或bait */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;&quot;rabbit bait&quot;&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配短语&quot;rabbit bait&quot; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;&gt;rabbit &lt;bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit和bait，增加前者的等级，降低后者的等级 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;+rabbit +(&lt;bait)&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit和bait，降低后者的等级 */</span></span><br></pre></td></tr></table></figure></li><li><p>全文本布尔操作符</p></li></ol><table><thead><tr><th style="text-align:left"><strong>布尔操作符</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">包含，词必须存在</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">排除，词必须不出现</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">包含，而且增加等级值</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">包含，且减少等级值</td></tr><tr><td style="text-align:left">()</td><td style="text-align:left">把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">取消一个词的排序值</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">词尾的通配符</td></tr><tr><td style="text-align:left">“”</td><td style="text-align:left">定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table><h2 id="第19章-插入数据">第19章 插入数据</h2><ol><li><p>如果表的定义允许，则可以在INSERT操作中省略某些列：</p><ol><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ol></li><li><p>可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> LOW_PRIORITY <span class="keyword">INTO</span></span><br></pre></td></tr></table></figure><blockquote><p>同样适用于UPDATE和DELETE。</p></blockquote></li><li><p>一些例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一次插入一条记录 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name, cust_address)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一次插入多条记录 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name, cust_address)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入检索出的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name, cust_address)</span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_address</span><br><span class="line"><span class="keyword">FROM</span> customers_new;</span><br></pre></td></tr></table></figure><blockquote><p>INSERT SELECT中不要求列名匹配。MySQL使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。</p></blockquote></li></ol><h2 id="第20章-更新和删除数据">第20章 更新和删除数据</h2><ol><li><p>如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IGNORE customers</span><br></pre></td></tr></table></figure></li><li><p>如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</p></li></ol><h2 id="第21章-创建和操纵表">第21章 创建和操纵表</h2><ol><li><p>主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p></li><li><p><strong>函数last_insert_id()</strong> 返回最后一个AUTO_INCREMENT值。</p></li><li><p>外键不能跨引擎。</p></li><li><p>一些例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id     <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id     <span class="type">CHAR</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_date   DATETIME    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_text   TEXT        <span class="keyword">NULL</span>,</span><br><span class="line">    update_cnt  <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(note_id, prod_id),</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (order_num)</span><br><span class="line"><span class="keyword">REFERENCES</span> orders (order_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br><span class="line"></span><br><span class="line">RENAME <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> customers;</span><br><span class="line">RENAME <span class="keyword">TABLE</span> customers <span class="keyword">TO</span> customers_backup, vendors <span class="keyword">TO</span> vendors_backup;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第22章-使用视图">第22章 使用视图</h2><ol><li><p>视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremaillist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>视图的规则和限制</p><ol><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。</li></ol></li><li><p>使用视图</p><ol><li>视图用CREATE VIEW语句来创建。</li><li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</li><li>用DROP删除视图，其语法为DROP VIEW viewname。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li></ol></li><li><p>视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p></li><li><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol></li></ol><h2 id="第23章-使用存储过程">第23章 使用存储过程</h2><ol><li><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(<span class="variable">@pricelow</span>, <span class="variable">@pricehigh</span>, <span class="variable">@priceaverage</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters: onumber = order number</span></span><br><span class="line"><span class="comment">--             taxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line"><span class="comment">--             ototal  = order total variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line">    <span class="keyword">IN</span>  onumber <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span>  taxable <span class="type">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">) COMMENT <span class="string">&#x27;Obtain order total, optionally adding tax&#x27;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">--Declare variable for total</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">--Declare tax percentage</span></span><br><span class="line">    <span class="keyword">DECLARE</span> taxrate <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--GET the order total</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Sum</span>(item_price<span class="operator">*</span>quantity)</span><br><span class="line">    <span class="keyword">FROM</span> orderitems</span><br><span class="line">    <span class="keyword">WHERE</span> order_num <span class="operator">=</span> onumber</span><br><span class="line">    <span class="keyword">INTO</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--Is this taxable</span></span><br><span class="line">    IF taxable <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SELECT</span> total<span class="operator">+</span>(total<span class="operator">/</span><span class="number">100</span><span class="operator">*</span>taxrate) <span class="keyword">INTO</span> total;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><blockquote><p>COMMENT的值会在<code>SHOW PROCEDURE STATUS</code>时显示出来。</p></blockquote></li><li><p>删除存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure></li><li><p>检查存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure><blockquote><p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS</code> 或<code>SHOW PROCEDURE STATUS LIKE 'ordertotal'</code>。</p></blockquote></li><li><p>使用mysql命令行实用程序时需要注意：</p><p>默认的MySQL语句分隔符为<code>;</code> mysql命令行实用程序也使用<code>;</code>作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。<br>解决办法是临时更改命令行实用程序的语句分隔符，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><blockquote><p>除<code>\</code>符号外，任何字符都可以用作语句分隔符。</p></blockquote></li></ol><h2 id="第25章-使用触发器">第25章 使用触发器</h2><ol><li><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于 BEGIN 和 END 语句之间的一组语 句）：</p><ol><li>DELETE；</li><li>INSERT；</li><li>UPDATE。</li></ol></li><li><p>在创建触发器时，需要给出4条信息：</p><ol><li><p>唯一的触发器名；</p></li><li><p>触发器关联的表；</p></li><li><p>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</p></li><li><p>触发器何时执行（处理之前或之后）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> products</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> <span class="string">&#x27;Product added&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>只有表才支持触发器，视图不支持（临时表也不支持）。</p></blockquote></li></ol></li><li><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后）。</p><blockquote><p>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL 将不执行AFTER触发器（如果有的话）。</p></blockquote></li><li><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure><blockquote><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p></blockquote></li><li><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><ol><li><p>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</p></li><li><p>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</p></li><li><p>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.order_new;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p><ol><li><p>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</p></li><li><p>OLD中的值全都是只读的，不能更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num, order_date, cust_id)</span><br><span class="line">    <span class="keyword">VALUE</span>(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p><ol><li><p>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</p></li><li><p>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p></li><li><p>OLD中的值全都是只读的，不能更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updatevendor</span><br><span class="line">BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> vendors</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SET</span> NEW.vend_state <span class="operator">=</span> <span class="built_in">UPPER</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。</p></li></ol><h2 id="第26章-管理事务处理">第26章 管理事务处理</h2><ol><li><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p><blockquote><p>MyISAM和InnoDB是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。</p></blockquote></li><li><p>相关术语：</p><ol><li><strong>事务（transaction）</strong> 指一组SQL语句；</li><li><strong>回退（rollback）</strong> 指撤销指定SQL语句的过程；</li><li><strong>提交（commit）</strong> 指将未存储的SQL语句结果写入数据库表；</li><li><strong>保留点（ savepoint ）</strong> 指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol></li><li><p>开始事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure></li><li><p>回退事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure><blockquote><p>事务处理用来管理INSERT、UPDATE和DELETE语句。你不能回退SELECT语句，也 <strong>不能回退CREATE或DROP操作</strong> 。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p></blockquote></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p></blockquote></li><li><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置保留点。这样，如果需要回退，可以回退到某个保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> delete1; <span class="comment">/* 创建保留点 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1; <span class="comment">/* 回退到保留点 */</span></span><br></pre></td></tr></table></figure><blockquote><p>保留点越多，就越能按自己的意愿灵活地进行回退，所以保留点越多越好。</p><p>保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。也可以用RELEASE SAVEPOINT明确地释放保留点。</p></blockquote></li><li><p>默认的MySQL行为是自动提交所有更改。可以关闭：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>autocommit标志决定是否自动提交更改，不管有没有COMMIT 语句。设置autocommit为0（假）指示MySQL不自动提交更改 （直到autocommit被设置为真为止）。</p><p>autocommit标志是针对每个连接而不是服务器的。</p></blockquote></li></ol><h2 id="第27章-全球化和本地化">第27章 全球化和本地化</h2><ol><li><p>重要术语：</p><ol><li><strong>字符集</strong> 为字母和符号的集合；</li><li><strong>编码</strong> 为某个字符集成员的内部表示；</li><li><strong>校对</strong> 为规定字符如何比较的指令。</li></ol></li><li><p>查看所支持的字符集完整列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看所支持校对的完整列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br></pre></td></tr></table></figure><blockquote><p>许多校对出现两次，一次区分大小写（由_cs表一次不区分大小写（由_ci表示）。</p></blockquote></li><li><p>通常系统管理在安装时定义一个默认的字符集和校对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>可以在创建数据库时，指定默认的字符集和校对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line">  <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>一般，MySQL如下确定使用什么样的字符集和校对：</p><ol><li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li><li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。</li><li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</li></ol></li><li><p>MySQL还允许对每个列设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line">  <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> lastname, firstname <span class="keyword">COLLATE</span> latin1_general_cs;</span><br></pre></td></tr></table></figure><blockquote><p>除了ORDER BY子句，COLLATE还可以用于GROUP BY、HAVING、聚集函数、别名等。</p></blockquote></li><li><p>如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。</p></li></ol><h2 id="第28章-安全管理">第28章 安全管理</h2><ol><li><p>创建用户账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ben IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>重命名用户账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> ben <span class="keyword">TO</span> kom;</span><br></pre></td></tr></table></figure></li><li><p>删除用户账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> kom;</span><br></pre></td></tr></table></figure></li><li><p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。查看用户账号权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> kom;</span><br></pre></td></tr></table></figure><blockquote><p><strong>用户定义为user@host。</strong> MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。</p></blockquote></li><li><p>为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息：</p><ol><li><p>要授予的权限；</p></li><li><p>被授予访问权限的数据库或表；</p></li><li><p>用户名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.<span class="operator">*</span> <span class="keyword">TO</span> kom;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>撤销特定的权限使用REVOKE：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.<span class="operator">*</span> <span class="keyword">FROM</span> kom;</span><br></pre></td></tr></table></figure></li><li><p>GRANT和REVOKE可在几个层次上控制访问权限：</p><ol><li>整个服务器，使用GRANT ALL和REVOKE ALL；</li><li>整个数据库，使用ON database.*；</li><li>特定的表，使用ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ol></li><li><p>更改密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> kom <span class="operator">=</span> PASSWORD(<span class="string">&#x27;456&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不指定用户名时，SET PASSWORD更新当前登录用户的口令。<code>SET PASSWORD = PASSWORD('789')</code></p></blockquote></li><li><p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。</p></li><li><p>可通过列出各权限并用逗号分隔， 将多条GRANT语句串在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON crashcourse.* TO kom</span><br></pre></td></tr></table></figure></li><li><p>权限列表</p></li></ol><table><thead><tr><th style="text-align:left"><strong>权限</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">ALL</td><td style="text-align:left">除GRANT OPTION外的所有权限</td></tr><tr><td style="text-align:left">ALTER</td><td style="text-align:left">使用ALTER TABLE</td></tr><tr><td style="text-align:left">ALTER ROUTINE</td><td style="text-align:left">使用ALTER PROCEDURE和DROP PROCEDURE</td></tr><tr><td style="text-align:left">CREATE</td><td style="text-align:left">使用CREATE TABLE</td></tr><tr><td style="text-align:left">CREATE ROUTINE</td><td style="text-align:left">使用CREATE PROCEDURE</td></tr><tr><td style="text-align:left">CREATE TEMPORARY TABLES</td><td style="text-align:left">使用CREATE TEMPORARY TABLE</td></tr><tr><td style="text-align:left">CREATE USER</td><td style="text-align:left">使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td></tr><tr><td style="text-align:left">CREATE VIEW</td><td style="text-align:left">使用CREATE VIEW</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">使用DELETE</td></tr><tr><td style="text-align:left">DROP</td><td style="text-align:left">使用DROP TABLE</td></tr><tr><td style="text-align:left">EXECUTE</td><td style="text-align:left">使用CALL和存储过程</td></tr><tr><td style="text-align:left">FILE</td><td style="text-align:left">使用SELECT INTO OUTFILE和LOAD DATA INFILE</td></tr><tr><td style="text-align:left">GRANT OPTION</td><td style="text-align:left">使用GRANT和REVOKE</td></tr><tr><td style="text-align:left">INDEX</td><td style="text-align:left">使用CREATE INDEX和DROP INDEX</td></tr><tr><td style="text-align:left">INSERT</td><td style="text-align:left">使用INSERT</td></tr><tr><td style="text-align:left">LOCK TABLES</td><td style="text-align:left">使用LOCK TABLES</td></tr><tr><td style="text-align:left">PROCESS</td><td style="text-align:left">使用SHOW FULL PROCESSLIST</td></tr><tr><td style="text-align:left">RELOAD</td><td style="text-align:left">使用FLUSH</td></tr><tr><td style="text-align:left">REPLICATION CLIENT</td><td style="text-align:left">服务器位置的访问</td></tr><tr><td style="text-align:left">REPLICATION SLAVE</td><td style="text-align:left">由复制从属使用</td></tr><tr><td style="text-align:left">SELECT</td><td style="text-align:left">使用SELECT</td></tr><tr><td style="text-align:left">SHOW DATABASES</td><td style="text-align:left">使用SHOW DATABASES</td></tr><tr><td style="text-align:left">SHOW VIEW</td><td style="text-align:left">使用SHOW CREATE VIEW</td></tr><tr><td style="text-align:left">SHUTDOWN</td><td style="text-align:left">使用mysqladmin shutdown（用来关闭MySQL）</td></tr><tr><td style="text-align:left">SUPER</td><td style="text-align:left">使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录</td></tr><tr><td style="text-align:left">UPDATE</td><td style="text-align:left">使用UPDATE</td></tr><tr><td style="text-align:left">USAGE</td><td style="text-align:left">无访问权限</td></tr></tbody></table><h2 id="第29章-数据库维护">第29章 数据库维护</h2><ol><li><p>备份数据</p><ol><li><p>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</p></li><li><p>可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。</p></li><li><p>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。</p><blockquote><p>为了保证所有数据被写到磁盘（包括索引数据）可能需要在进行备份前使用FLUSH TABLES语句。</p></blockquote></li></ol></li><li><p>进行数据库维护</p><ol><li><p>检查表键是否正确</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> orders;</span><br></pre></td></tr></table></figure></li><li><p>CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> orders, orderitems FAST QUICK;</span><br></pre></td></tr></table></figure><blockquote><p>如果 MyISAM 表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</p><p>如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。</p></blockquote></li></ol></li></ol><h2 id="第30章-改善性能">第30章 改善性能</h2><ol><li>可使用<code>SHOW PROCESSLIST</code> 显示所有活动进程（以及它们的线程ID和执行时间）。可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li><li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。</li><li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li></ol>]]></content>
    
    
    <summary type="html">《MySQL必知必会》</summary>
    
    
    
    <category term="MySQL" scheme="https://penge666.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://penge666.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>epoll原理</title>
    <link href="https://penge666.github.io/posts/808ecc04.html"/>
    <id>https://penge666.github.io/posts/808ecc04.html</id>
    <published>2024-06-26T09:04:09.000Z</published>
    <updated>2024-07-10T03:37:37.486Z</updated>
    
    <content type="html"><![CDATA[<p>文章会从网卡接收数据的流程讲起，串联起 CPU 中断、操作系统进程调度等知识；再一步步分析阻塞接收数据、select 到 epoll 的进化过程，最后探究 epoll 的实现细节。</p><h2 id="一、从网卡接收数据说起">一、从网卡接收数据说起</h2><p>下边是一个典型的计算机结构图，计算机由 CPU、存储器（内存）与网络接口等部件组成，了解 epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170512773.png" alt="image-20240626170512773"></p><p>下图展示了网卡接收数据的过程：</p><ul><li>在 1 阶段，网卡收到网线传来的数据。</li><li>经过 2 阶段的硬件电路的传输。</li><li>最终 3 阶段将数据写入到内存中的某个地址上。</li></ul><p>这个过程涉及到 DMA 传输、IO 通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170546354.png" alt="image-20240626170546354"></p><p>通过硬件传输，网卡接收的数据存放到内存中，操作系统就可以去读取它们。</p><h2 id="二、如何知道接收了数据">二、如何知道接收了数据</h2><p>了解 epoll 本质的第二步，要从 CPU 的角度来看数据接收。理解这个问题，要先了解一个概念：中断。</p><p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时，它应立即去保存数据，保存数据的程序具有较高的优先级（电容可以保存少许电量，供 CPU 运行很短的一小段时间）。</p><p>一般而言，由硬件产生的信号需要 CPU 立马做出回应，不然数据可能就丢失了，所以它的优先级很高。</p><p>CPU 理应中断掉正在执行的程序，去做出响应，当 CPU 完成对硬件的响应后，再重新执行用户程序。</p><p>中断的过程如下图，它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170632344.png" alt="image-20240626170632344"></p><p>以键盘为例，当用户按下键盘某个按键时，键盘会给 CPU 的中断引脚发出一个高电平，CPU 能够捕获这个信号，然后执行键盘中断程序。</p><p>下图展示了各种硬件通过中断与 CPU 交互的过程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170650962.png" alt="image-20240626170650962"></p><p>现在可以回答“如何知道接收了数据？”这个问题了：当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><h2 id="三、进程阻塞为什么不占用-CPU-资源"><strong>三、进程阻塞为什么不占用 CPU 资源</strong></h2><p>了解 epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法。</p><p>下边分析一下进程阻塞为什么不占用 CPU 资源？为简单起见，我们从普通的 recv 接收开始分析，先看看下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 socket</span></span><br><span class="line"><span class="type">int</span> s =socket（AF_INET， SOCK_STREAM， <span class="number">0</span>）; </span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line">bind（s， ...）</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">listen（s， ...）</span><br><span class="line"><span class="comment">//接受客户端连接</span></span><br><span class="line"><span class="type">int</span> c = accept（s， ...）</span><br><span class="line"><span class="comment">//接收客户端数据</span></span><br><span class="line">recv（c， ...）; </span><br><span class="line"><span class="comment">//将数据打印出来</span></span><br><span class="line">printf（...）</span><br></pre></td></tr></table></figure><p>这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen 与 accept，最后调用 recv 接收数据。</p><p>recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。那么阻塞的原理是什么？</p><h2 id="四、工作队列"><strong>四、工作队列</strong></h2><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。</p><p>运行状态是进程获得 CPU 使用权，正在执行代码的状态;等待状态是阻塞状态，比如上述程序运行到recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。</p><p>操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>下图的计算机中运行着 A、B 与 C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170751776.png" alt="image-20240626170751776"></p><h2 id="五、等待队列"><strong>五、等待队列</strong></h2><p>当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象（如下图）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170810525.png" alt="image-20240626170810525"></p><p>这个 socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程。</p><p>当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中（如下图）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170835637.png" alt="image-20240626170835637"></p><p>由于工作队列只剩下了进程 B 和 C，依据进程调度，CPU 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 CPU 资源。</p><p>注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程</p><p>对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p><h2 id="六、唤醒进程"><strong>六、唤醒进程</strong></h2><p>当 socket 接收到数据后，操作系统将该 socket 等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。</p><p>同时由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</p><h2 id="七、内核接收网络数据全过程">七、内核接收网络数据全过程</h2><p>这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞 recv 下内核接收数据的全过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170918164.png" alt="image-20240626170918164"></p><p>如上图所示，进程在 recv 阻塞期间：</p><ul><li><p>计算机收到了对端传送的数据（步骤 ①）</p></li><li><p>数据经由网卡传送到内存（步骤 ②）</p></li><li><p>然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序（步骤 ③）</p></li></ul><p>此处的中断程序主要有两项功能，先将网络数据写入到对应 socket 的接收缓冲区里面（步骤 ④），</p><p>再唤醒进程 A（步骤 ⑤），重新将进程 A 放入工作队列中。</p><p>唤醒进程的过程如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170937542.png" alt="image-20240626170937542"></p><p>以上是内核接收数据全过程，这里我们可能会思考两个问题：</p><ul><li><p>操作系统如何知道网络数据对应于哪个 socket？</p></li><li><p>如何同时监视多个 socket 的数据？</p></li></ul><p>第一个问题：因为一个 socket 对应着一个端口号，而网络数据包中包含了 IP 和端口的信息，内核可以通过端口号找到对应的 socket。</p><p>当然，为了提高处理速度，操作系统会维护端口号到 socket 的索引结构，以快速读取。</p><p>第二个问题是多路复用的重中之重，也正是本文后半部分的重点。</p><h2 id="八、同时监视多个-socket-的简单方法"><strong>八、同时监视多个 socket 的简单方法</strong></h2><p>服务端需要管理多个客户端连接，而 recv 只能监视单个 socket，这种矛盾下，人们开始寻找监视多个 socket 的方法。epoll 的要义就是高效地监视多个 socket。</p><p>从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进，正如 select 之于 epoll。先理解不太高效的 select，才能够更好地理解 epoll 的本质。</p><p>假如能够预先传入一个 socket 列表，如果列表中的 socket 都没有数据，挂起进程，直到有一个 socket收到数据，唤醒进程。这种方法很直接，也是 select 的设计思想。</p><p>为方便理解，我们先复习 select 的用法。在下边的代码中，先准备一个数组 FDS，让 FDS 存放着所有需要监视的 socket。</p><p>然后调用 select，如果 FDS 中的所有 socket 都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select 返回，唤醒进程。</p><p>用户可以遍历 FDS，通过 FD_ISSET 判断具体哪个 socket 收到数据，然后做出处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s =socket（AF_INET， SOCK_STREAM， <span class="number">0</span>）; </span><br><span class="line">bind（s， ...）</span><br><span class="line">listen（s， ...）</span><br><span class="line"><span class="type">int</span> fds[] = 存放需要监听的 socket</span><br><span class="line"><span class="keyword">while</span>（<span class="number">1</span>）&#123; </span><br><span class="line"> <span class="type">int</span> n = select（...， fds， ...）</span><br><span class="line"> <span class="keyword">for</span>（<span class="type">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++）&#123; </span><br><span class="line"> <span class="keyword">if</span>（FD_ISSET（fds[i]， ...））&#123; </span><br><span class="line"> <span class="comment">//fds[i]的数据处理</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、select-的流程"><strong>九、select 的流程</strong></h2><p>select 的实现思路很直接，假如程序同时监视如下图的 sock1、sock2 和 sock3 三个 socket，那</p><p>么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。</p><p>当任何一个 socket 收到数据后，中断程序将唤起进程。下图展示了 sock2 接收到了数据的处理流程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171047235.png" alt="image-20240626171047235"></p><p>注：recv 和 relect 的中断回调可以设置成不同的内容。</p><p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171100759.png" alt="image-20240626171100759"></p><p>经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket列表，就可以得到就绪的 socket。</p><p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p><ul><li><p>每次调用 select 都需要将进程加入到所有监视 socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 FDS 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024个 socket。</p></li><li><p>进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。</p></li></ul><p>那么，有没有减少遍历的方法？有没有保存就绪 socket 的方法？这两个问题便是 epoll 技术要解决的。</p><p>补充说明：本节只解释了 select 的一种情形。当程序调用 select 时，内核会先遍历一遍 socket，</p><p>如果有一个以上的 socket 接收缓冲区有数据，那么 select 直接返回，不会阻塞。</p><p>这也是为什么 select 的返回值有可能大于 1 的原因之一。如果没有 socket 有数据，进程才会阻塞。</p><h2 id="十、epoll-的设计思路"><strong>十、epoll 的设计思路</strong></h2><p>epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll（poll 和 select 基本一样，有少</p><p>量改进）的增强版本。epoll 通过以下一些措施来改进效率：</p><p><strong>1、措施一：功能分离</strong></p><p>select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171131861.png" alt="image-20240626171131861"></p><p>如上图所示，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。</p><p>epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见，效率就能得到提升。</p><p>为方便理解后续的内容，我们先了解一下 epoll 的用法。如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s =socket（AF_INET， SOCK_STREAM， <span class="number">0</span>）; </span><br><span class="line"></span><br><span class="line">bind（s， ...）</span><br><span class="line"></span><br><span class="line">listen（s， ...）</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd =epoll_create（...）; </span><br><span class="line"></span><br><span class="line">epoll_ctl（epfd， ...）; <span class="comment">//将所有需要监听的 socket 添加到 epfd 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>（<span class="number">1</span>）&#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n =epoll_wait（...）</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>（接收到数据的 socket）&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//处理</span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>功能分离，使得 epoll 有了优化的可能。</p><p><strong>2、措施二：就绪列表</strong></p><p>select 低效的另一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171211493.png" alt="image-20240626171211493"></p><p>如上图所示，计算机共有三个 socket，收到数据的 sock2 和 sock3 被就绪列表 rdlist 所引用。</p><p>当进程被唤醒后，只要获取 rdlist 的内容，就能够知道哪些 socket 收到数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171243774.png" alt="image-20240626171243774"></p>]]></content>
    
    
    <summary type="html">epoll原理学习</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络攻击</title>
    <link href="https://penge666.github.io/posts/a9bd00d7.html"/>
    <id>https://penge666.github.io/posts/a9bd00d7.html</id>
    <published>2024-06-23T16:04:43.000Z</published>
    <updated>2024-07-03T16:16:25.910Z</updated>
    
    <content type="html"><![CDATA[<p>对常见的网络攻击有个基本的了解！</p><h2 id="DOS-DDOS攻击">DOS/DDOS攻击</h2><p>DOS（Denial of Service）和DDOS（Distributed Denial of Service）攻击是网络攻击的一种，旨在通过耗尽目标系统的资源（如带宽、CPU、内存等）使其无法正常提供服务。下面举例说明这两种攻击的具体形式和工作原理。</p><h3 id="DOS攻击">DOS攻击</h3><h4 id="示例：Ping-Flood攻击">示例：Ping Flood攻击</h4><p><strong>Ping Flood攻击</strong>是一种常见的DOS攻击，通过向目标系统发送大量的ICMP Echo请求（即Ping请求）来耗尽目标的带宽和处理能力，使其无法正常响应合法的请求。</p><h4 id="工作原理：">工作原理：</h4><ol><li><strong>攻击者</strong>向目标服务器发送大量的Ping请求。</li><li><strong>目标服务器</strong>接收到Ping请求后，需要处理并回复每一个请求。</li><li><strong>大量的请求</strong>使得目标服务器的带宽和CPU资源被大量占用，最终导致服务器无法处理正常的业务请求，服务中断。</li></ol><h4 id="示例操作：">示例操作：</h4><p>假设攻击者使用命令行工具进行Ping Flood攻击：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ping</span> -f -s <span class="number">65500</span> target_ip</span><br></pre></td></tr></table></figure><ul><li><code>-f</code>选项表示快速Ping（在Linux中）。</li><li><code>-s 65500</code>表示发送65500字节的数据包。</li></ul><h3 id="DDOS攻击">DDOS攻击</h3><h4 id="示例：Botnet攻击">示例：Botnet攻击</h4><p><strong>Botnet攻击</strong>是一种常见的DDOS攻击，攻击者通过控制大量的被感染设备（称为僵尸网络，Botnet），同时向目标系统发起攻击，使得目标系统无法处理所有请求，导致服务中断。</p><h4 id="工作原理：-2">工作原理：</h4><ol><li><strong>攻击者</strong>通过恶意软件感染大量的设备（如计算机、物联网设备等），形成一个僵尸网络。</li><li><strong>攻击者</strong>控制僵尸网络中的设备，同时向目标服务器发送大量请求。</li><li><strong>目标服务器</strong>由于同时处理来自多个来源的海量请求，导致资源耗尽，无法正常提供服务。</li></ol><h4 id="示例操作：-2">示例操作：</h4><p>假设攻击者使用一个僵尸网络发起HTTP Flood攻击：</p><ol><li><strong>攻击者</strong>控制僵尸网络中的每个设备运行以下脚本：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标URL</span></span><br><span class="line">url = <span class="string">&quot;http://target_website.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟大量请求</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(response.status_code)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ol><li><strong>僵尸网络</strong>中的每个设备同时运行该脚本，向目标服务器发送大量的HTTP请求。</li></ol><h3 id="区别和防护">区别和防护</h3><h4 id="DOS和DDOS的区别：">DOS和DDOS的区别：</h4><ul><li><strong>DOS攻击</strong>：通常由单一来源发起，攻击规模相对较小。</li><li><strong>DDOS攻击</strong>：由分布在多个地理位置的多个来源发起，攻击规模较大，难以防御。</li></ul><h4 id="防护措施：">防护措施：</h4><ol><li><strong>网络防火墙和入侵检测系统</strong>：可以监控并过滤异常流量。</li><li><strong>流量清洗服务</strong>：一些专门的安全公司提供流量清洗服务，能够在攻击发生时清洗掉恶意流量。</li><li><strong>限流和速率限制</strong>：在服务器上设置请求限流和速率限制，防止单个IP发送过多请求。</li><li><strong>内容分发网络（CDN）</strong>：通过使用CDN将流量分散到多个节点，减少单一服务器的压力。</li><li><strong>IP黑名单</strong>：将可疑的IP地址加入黑名单，阻止其访问。</li></ol><p>通过以上示例和防护措施，可以更好地理解DOS和DDOS攻击的原理及其防御方法。</p><h2 id="Man-in-the-Middle攻击">Man-in-the-Middle攻击</h2><p>Man-in-the-Middle（MITM）攻击是一种网络攻击方式，攻击者通过在通信双方之间插入自己，窃取、篡改或伪造双方的通信数据，而通信双方通常并不知道有第三方存在。以下是MITM攻击的详细说明及示例：</p><h3 id="工作原理">工作原理</h3><ol><li><strong>拦截通信</strong>：攻击者在通信双方（如客户端和服务器）之间插入自己，通常通过网络监听、ARP欺骗、DNS欺骗等方式实现。</li><li><strong>伪装身份</strong>：攻击者伪装成通信的另一方，向双方发送和接收消息。客户端认为自己在与服务器通信，而服务器认为自己在与客户端通信。</li><li><strong>窃取和篡改数据</strong>：攻击者可以在传输过程中窃取敏感信息（如密码、信用卡号等），或篡改数据（如修改交易金额等）。</li></ol><h3 id="示例">示例</h3><h4 id="示例1：HTTP通信中的MITM攻击">示例1：HTTP通信中的MITM攻击</h4><p>假设用户正在使用公共Wi-Fi网络访问一个未加密的HTTP网站，攻击者可以通过以下方式进行MITM攻击：</p><ol><li><p><strong>ARP欺骗</strong>：攻击者向网络中的设备发送伪造的ARP消息，将攻击者的MAC地址绑定到网关的IP地址上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i wlan0 -t <span class="tag">&lt;<span class="name">victim_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">gateway_ip</span>&gt;</span></span><br><span class="line">arpspoof -i wlan0 -t <span class="tag">&lt;<span class="name">gateway_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">victim_ip</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>流量拦截和篡改</strong>：攻击者使用流量分析工具（如Wireshark）拦截HTTP流量，窃取敏感信息，或使用代理工具（如Burp Suite）修改传输的数据。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mitmproxy</span> -p <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><p><strong>伪装身份</strong>：攻击者将自己伪装成合法的服务器和客户端，将拦截到的请求和响应转发给各自的目标，同时进行窃取或篡改。</p></li></ol><h4 id="示例2：DNS欺骗中的MITM攻击">示例2：DNS欺骗中的MITM攻击</h4><p>攻击者通过DNS欺骗将用户重定向到恶意网站：</p><ol><li><p><strong>DNS欺骗</strong>：攻击者向受害者发送伪造的DNS响应，将某个域名解析到攻击者控制的IP地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnsspoof -<span class="selector-tag">i</span> wlan0 -f hosts<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p><code>hosts.txt</code>内容示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168.1.100</span>  example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>伪装网站</strong>：攻击者在自己的服务器上托管一个与目标网站相同的页面，用户在访问example.com时被重定向到攻击者的服务器，并在不知情的情况下输入敏感信息。</p></li></ol><h3 id="防护措施">防护措施</h3><ol><li><strong>使用HTTPS</strong>：HTTPS加密通信可以防止攻击者窃取和篡改数据。确保网站和应用程序使用HTTPS协议。</li><li><strong>证书验证</strong>：客户端应验证服务器的SSL/TLS证书，防止与伪造的服务器通信。</li><li><strong>强认证机制</strong>：使用双因素认证（2FA）等强认证机制，提高账户安全性。</li><li><strong>安全Wi-Fi网络</strong>：避免在不安全的公共Wi-Fi网络上进行敏感操作，或使用VPN加密流量。</li><li><strong>网络监控和检测</strong>：部署入侵检测系统（IDS）和网络监控工具，检测异常活动和潜在攻击。</li><li><strong>DNSSEC</strong>：使用DNS安全扩展（DNSSEC）来验证DNS响应的真实性，防止DNS欺骗。</li></ol><h3 id="总结">总结</h3><p>Man-in-the-Middle攻击通过拦截和篡改通信双方的数据，窃取敏感信息或进行其他恶意操作。了解其工作原理和实施方式，以及采取有效的防护措施，可以显著提高网络通信的安全性。</p><h2 id="Phishing攻击">Phishing攻击</h2><p><strong>Phishing攻击</strong>是一种常见的网络攻击方式，攻击者通过伪装成合法的实体（如银行、在线服务提供商等）诱骗用户提供敏感信息，如用户名、密码、信用卡号等。Phishing攻击主要依赖于社会工程学和伪造的电子邮件、网站、短信等手段来实施。以下是Phishing攻击的详细说明及示例：</p><h3 id="工作原理-2">工作原理</h3><ol><li><strong>伪装身份</strong>：攻击者伪装成合法的机构或个人，发送电子邮件、短信或创建伪造的网站。</li><li><strong>诱骗用户</strong>：通过各种手段（如紧急警告、诱人的优惠等）诱使用户点击链接或提供敏感信息。</li><li><strong>收集信息</strong>：用户提供的信息被攻击者收集并用于非法活动，如身份盗用、金融欺诈等。</li></ol><h3 id="示例-2">示例</h3><h4 id="示例1：电子邮件Phishing攻击">示例1：电子邮件Phishing攻击</h4><p>攻击者通过发送伪造的电子邮件，诱骗用户点击恶意链接或提供敏感信息。</p><ol><li><p><strong>伪造电子邮件</strong>：</p><ul><li>电子邮件看起来来自合法机构（如银行、在线服务提供商等）。</li><li>内容通常包含紧急通知或诱人的优惠，要求用户立即采取行动。</li></ul><p>示例电子邮件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span>: support<span class="variable">@bank</span>.com</span><br><span class="line"><span class="keyword">To</span>: <span class="keyword">user</span><span class="variable">@example</span>.com</span><br><span class="line">Subject: Urgent: <span class="keyword">Update</span> Your Account Information</span><br><span class="line"></span><br><span class="line">Dear Customer,</span><br><span class="line"></span><br><span class="line">We have detected unusual activity <span class="keyword">on</span> your account. Please <span class="keyword">update</span> your account information immediately <span class="keyword">by</span> clicking the link below:</span><br><span class="line"></span><br><span class="line">[<span class="keyword">Update</span> Account Information](http:<span class="operator">/</span><span class="operator">/</span>fakebank.com<span class="operator">/</span><span class="keyword">update</span>)</span><br><span class="line"></span><br><span class="line">Failure <span class="keyword">to</span> <span class="keyword">update</span> your information may <span class="keyword">result</span> <span class="keyword">in</span> account suspension.</span><br><span class="line"></span><br><span class="line">Best regards,</span><br><span class="line">Bank Support Team</span><br></pre></td></tr></table></figure></li><li><p><strong>诱骗用户</strong>：</p><ul><li>用户点击链接后，会被重定向到一个伪造的银行登录页面。</li><li>页面设计与银行官方网站非常相似，诱使用户输入用户名和密码。</li></ul></li><li><p><strong>收集信息</strong>：</p><ul><li>用户输入的敏感信息被攻击者收集，用于非法活动。</li></ul></li></ol><h4 id="示例2：短信Phishing攻击（Smishing）">示例2：短信Phishing攻击（Smishing）</h4><p>攻击者通过发送伪造的短信，诱骗用户点击恶意链接或提供敏感信息。</p><ol><li><p><strong>伪造短信</strong>：</p><ul><li>短信看起来来自合法机构（如银行、快递公司等）。</li><li>内容通常包含紧急通知或诱人的优惠，要求用户立即采取行动。</li></ul><p>示例短信：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">From: BankAlert</span><br><span class="line"><span class="keyword">To</span>: +<span class="number">1234567890</span></span><br><span class="line"><span class="keyword">Message</span>: </span><br><span class="line">[Bank] We have detected suspicious activity <span class="keyword">on</span> your account. Please verify your identity immediately: http:<span class="comment">//fakebank.com/verify</span></span><br></pre></td></tr></table></figure></li><li><p><strong>诱骗用户</strong>：</p><ul><li>用户点击链接后，会被重定向到一个伪造的银行验证页面。</li><li>页面设计与银行官方网站非常相似，诱使用户输入用户名、密码和其他个人信息。</li></ul></li><li><p><strong>收集信息</strong>：</p><ul><li>用户输入的敏感信息被攻击者收集，用于非法活动。</li></ul></li></ol><h3 id="防护措施-2">防护措施</h3><ol><li><strong>注意电子邮件和短信的来源</strong>：<ul><li>检查发件人的电子邮件地址和短信号码。</li><li>谨慎对待不明来源的邮件和短信，尤其是包含链接或附件的。</li></ul></li><li><strong>不随意点击链接</strong>：<ul><li>在点击电子邮件或短信中的链接前，悬停在链接上查看实际网址。</li><li>直接访问官方网站，而不是通过邮件或短信中的链接。</li></ul></li><li><strong>双因素认证（2FA）</strong>：<ul><li>启用双因素认证，增加额外的安全层，防止未经授权的访问。</li></ul></li><li><strong>使用防钓鱼软件</strong>：<ul><li>安装和使用防钓鱼工具和浏览器扩展，检测和阻止钓鱼网站。</li></ul></li><li><strong>定期更新密码</strong>：<ul><li>定期更改账户密码，使用强密码，并避免重复使用密码。</li></ul></li><li><strong>教育和意识</strong>：<ul><li>提高员工和用户的安全意识，定期进行安全培训，教导如何识别和应对钓鱼攻击。</li></ul></li></ol><h3 id="总结-2">总结</h3><p>Phishing攻击通过伪装和社会工程学手段，诱骗用户提供敏感信息。了解其工作原理和常见手段，并采取有效的防护措施，可以显著降低成为Phishing攻击受害者的风险。</p><h2 id="SQL注入">SQL注入</h2><p>SQL注入（SQL Injection）攻击是一种常见的网络攻击方式，攻击者通过在输入字段中插入恶意的SQL代码，使得后台数据库执行未经授权的SQL查询，从而获取、修改或删除数据库中的数据。以下是SQL注入攻击的详细说明及示例：</p><h3 id="工作原理-3">工作原理</h3><ol><li><strong>用户输入</strong>：攻击者在应用程序的输入字段（如登录表单、搜索框等）中输入恶意的SQL代码。</li><li><strong>未处理的输入</strong>：应用程序将用户输入直接插入到SQL查询中，未进行充分的验证或转义。</li><li><strong>执行恶意查询</strong>：数据库服务器执行构造后的SQL查询，导致数据库中的数据泄露、篡改或删除。</li></ol><h3 id="示例-3">示例</h3><p>假设有一个网站登录表单，用户输入用户名和密码后，后台会生成并执行一个SQL查询来验证用户身份。</p><h4 id="原始代码示例">原始代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户输入的用户名和密码</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;Enter your username: &quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;Enter your password: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造SQL查询</span></span><br><span class="line">query = <span class="string">f&quot;SELECT * FROM users WHERE username = &#x27;<span class="subst">&#123;username&#125;</span>&#x27; AND password = &#x27;<span class="subst">&#123;password&#125;</span>&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行SQL查询</span></span><br><span class="line">cursor.execute(query)</span><br><span class="line">result = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查查询结果</span></span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Login successful&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid username or password&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="攻击示例">攻击示例</h4><p>攻击者在用户名字段中输入<code>' OR '1'='1</code>，在密码字段中输入任意值，如<code>' OR '1'='1</code>。</p><p>构造后的SQL查询如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username = <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> <span class="keyword">password</span> = <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个查询始终为真，因为<code>'1'='1'</code>永远为真，导致数据库返回所有用户的数据，攻击者可以绕过身份验证。</p><h3 id="防护措施-3">防护措施</h3><ol><li><p><strong>使用参数化查询</strong>：参数化查询将用户输入与SQL语句分开，防止恶意输入被当作SQL代码执行。</p><figure class="highlight graphql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用参数化查询</span></span><br><span class="line"><span class="keyword">query</span> <span class="punctuation">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = %s AND password = %s&quot;</span></span><br><span class="line">cursor.execute<span class="punctuation">(</span><span class="keyword">query</span>, <span class="punctuation">(</span>username, password<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用ORM（对象关系映射）工具</strong>：ORM工具提供了安全的数据操作接口，避免了直接编写SQL查询。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Django ORM进行查询</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models import<span class="built_in"> User</span></span><br><span class="line"><span class="built_in"></span><span class="built_in"></span></span><br><span class="line"><span class="built_in">user </span>= User.objects.<span class="built_in">get</span>(<span class="attribute">username</span>=username, <span class="attribute">password</span>=password)</span><br></pre></td></tr></table></figure></li><li><p><strong>输入验证和转义</strong>：对用户输入进行严格的验证和转义，防止恶意代码注入。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证用户名和密码</span></span><br><span class="line"><span class="keyword">if</span> not re.<span class="keyword">match</span>(<span class="string">&quot;^[a-zA-Z0-9_]+$&quot;</span>, username):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid username&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> not re.<span class="keyword">match</span>(<span class="string">&quot;^[a-zA-Z0-9_]+$&quot;</span>, password):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid password&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>最小权限原则</strong>：数据库账户应具有最小的权限，仅允许执行必要的操作，减少攻击面。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个具有最小权限的数据库用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;appuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> database_name.* <span class="keyword">TO</span> <span class="string">&#x27;appuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>定期安全审计</strong>：定期进行代码和数据库的安全审计，及时发现和修复潜在的安全漏洞。</p></li></ol><h3 id="总结-3">总结</h3><p>SQL注入攻击通过在输入字段中插入恶意的SQL代码，使得数据库执行未经授权的查询，从而获取、修改或删除数据。了解其工作原理和常见攻击方式，并采取有效的防护措施，如参数化查询、输入验证和最小权限原则，可以显著降低SQL注入攻击的风险。</p><h2 id="XSS攻击">XSS攻击</h2><p>**XSS（Cross-Site Scripting）攻击【**跨站脚本攻击】**是一种网络攻击方式，攻击者在网页中插入恶意的脚本代码，使得脚本在其他用户的浏览器中执行，从而窃取敏感信息、劫持会话、伪造请求等。XSS攻击主要分为三种类型：存储型、反射型和基于DOM的XSS。以下是XSS攻击的详细说明及示例：</p><h3 id="XSS攻击类型">XSS攻击类型</h3><ol><li><strong>存储型XSS（Stored XSS）</strong>：<ul><li>恶意脚本被永久存储在目标服务器上（如数据库、日志文件等）。</li><li>受害者在浏览页面时，脚本会自动执行。</li></ul></li><li><strong>反射型XSS（Reflected XSS）</strong>：<ul><li>恶意脚本通过URL参数传递，并在响应中立即返回并执行。</li><li>攻击者通常通过诱导用户点击恶意链接来实现。</li></ul></li><li><strong>基于DOM的XSS（DOM-based XSS）</strong>：<ul><li>恶意脚本通过修改页面的DOM结构来执行。</li><li>攻击发生在客户端，由浏览器解析和执行。</li></ul></li></ol><h3 id="示例-4">示例</h3><h4 id="示例1：存储型XSS">示例1：存储型XSS</h4><p>攻击者在留言板上插入恶意脚本代码，该脚本被存储在服务器数据库中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 攻击者在留言板上提交恶意脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit_comment&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当其他用户访问包含恶意评论的页面时，浏览器会执行插入的脚本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示评论的页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>User comment: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="示例2：反射型XSS">示例2：反射型XSS</h4><p>攻击者构造恶意URL，诱导用户点击，恶意脚本通过URL参数传递并在响应中执行。</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 攻击者构造的恶意URL --&gt;</span></span></span><br><span class="line"><span class="language-xml">http://example.com/search?query=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 搜索结果页面 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 不安全地将用户输入输出到页面 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Search results for: </span><span class="language-vbscript">&lt;%= <span class="built_in">request</span>.getParameter(<span class="string">&quot;query&quot;</span>) %&gt;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>用户点击恶意链接后，脚本在浏览器中执行，显示一个警告框。</p><h4 id="示例3：基于DOM的XSS">示例3：基于DOM的XSS</h4><p>攻击者通过修改页面的DOM结构来执行恶意脚本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 受害者访问的页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 从URL参数中读取数据并插入到DOM中</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> query = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>).<span class="title function_">get</span>(<span class="string">&#x27;query&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;output&#x27;</span>).<span class="property">innerHTML</span> = query;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者构造恶意URL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 攻击者构造的恶意URL --&gt;</span></span><br><span class="line">http://example.com/page?query=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户点击恶意链接后，脚本在浏览器中执行。</p><h3 id="防护措施-4">防护措施</h3><ol><li><p><strong>输入验证和转义</strong>：</p><ul><li>对用户输入进行严格的验证和转义，防止恶意代码注入。</li><li>在输出时转义HTML特殊字符。</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, escape</span><br><span class="line"></span><br><span class="line"><span class="keyword">app</span> = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@<span class="keyword">app</span>.route(&#x27;/<span class="keyword">search</span>&#x27;)</span><br><span class="line">def <span class="keyword">search</span>():</span><br><span class="line">    <span class="keyword">query</span> = request.<span class="keyword">args</span>.<span class="built_in">get</span>(&#x27;<span class="keyword">query</span>&#x27;)</span><br><span class="line">    safe_query = escape(<span class="keyword">query</span>)</span><br><span class="line">    <span class="keyword">return</span> f&#x27;<span class="keyword">Search</span> results <span class="keyword">for</span>: &#123;safe_query&#125;&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用安全的库和框架</strong>：</p><ul><li>使用经过验证的库和框架来处理用户输入和输出。</li><li>如Django、Rails等框架自带防XSS功能。</li></ul></li><li><p><strong>内容安全策略（CSP）</strong>：</p><ul><li>配置内容安全策略，通过限制脚本资源来源，减少XSS攻击风险。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>HTTP-only和Secure标志</strong>：</p><ul><li>设置HTTP-only和Secure标志，防止JavaScript访问敏感的Cookie。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(<span class="string">&#x27;session_id&#x27;</span>, value, <span class="attribute">httponly</span>=<span class="literal">True</span>, <span class="attribute">secure</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>避免使用危险的JavaScript函数</strong>：</p><ul><li>避免使用<code>innerHTML</code>、<code>document.write</code>等容易引起XSS的函数，使用安全的DOM操作方法。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用textContent代替innerHTML</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>).textContent = query;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-4">总结</h3><p>XSS攻击通过在网页中插入恶意的脚本代码，使得脚本在用户的浏览器中执行。了解其工作原理和常见攻击方式，并采取有效的防护措施，如输入验证和转义、内容安全策略等，可以显著降低XSS攻击的风险。</p>]]></content>
    
    
    <summary type="html">常见网络攻击方式</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Cpp输入方式</title>
    <link href="https://penge666.github.io/posts/2fa03bf9.html"/>
    <id>https://penge666.github.io/posts/2fa03bf9.html</id>
    <published>2024-06-23T09:07:53.000Z</published>
    <updated>2024-06-23T11:41:35.192Z</updated>
    
    <content type="html"><![CDATA[<p>在算竞中经常需要读取数据，这篇文章对Cpp的输入方式总结。</p><h2 id="输入方式">输入方式</h2><h3 id="1-cin"><strong>1.cin</strong></h3><p>（1）cin&gt;&gt;等价于cin.operator&gt;&gt;()，即调用成员函数operator&gt;&gt;()进行读取数据。</p><p>（2）当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。<strong>但是如果读取成功，字符后面的分隔符是残留在</strong>缓冲区的，cin&gt;&gt;不做处理。如果后续接getline()要记得处理换行符！</p><p>补充：</p><ul><li><p><strong>Tab键</strong>：通常在键盘上标记为<code>Tab</code>，按下后插入一个制表符（Tab字符）。制表符的长度通常为多个空格，可以在不同的编辑器或环境中设置长度，常见的设置是4个或8个空格。【在计算机中用于对齐文本的特殊字符】</p></li><li><p><strong>空格键</strong>：按下后插入一个空格字符。每次按下空格键插入一个空格，长度固定。</p></li></ul><p>（3）不想略过空白字符，那就使用 noskipws 流控制。比如：cin&gt;&gt;noskipws&gt;&gt;input;</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, std::string&amp; str) &#123;</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">// 清空字符串</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    is &gt;&gt; std::ws; <span class="comment">// 跳过前导的空白字符</span></span><br><span class="line">    <span class="keyword">while</span> (is.<span class="built_in">get</span>(ch) &amp;&amp; !<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">        str += ch; <span class="comment">// 将字符添加到字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is; <span class="comment">// 返回输入流对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><p>C 库函数 <strong>int isspace(int c)</strong> 检查所传的字符是否是空白字符。</p><p>标准的空白字符包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>     (0x20)    space (SPC) 空格符</span><br><span class="line"><span class="string">&#x27;\t&#x27;</span>    (0x09)    horizontal tab (TAB) 水平制表符    </span><br><span class="line"><span class="string">&#x27;\n&#x27;</span>    (0x0a)    newline (LF) 换行符</span><br><span class="line"><span class="string">&#x27;\v&#x27;</span>    (0x0b)    vertical tab (VT) 垂直制表符</span><br><span class="line"><span class="string">&#x27;\f&#x27;</span>    (0x0c)    feed (FF) 换页符</span><br><span class="line"><span class="string">&#x27;\r&#x27;</span>    (0x0d)    carriage <span class="built_in">return</span> (CR) 回车符</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> n,m,k,p,q;</span><br><span class="line">cin&gt;&gt;std::noskipws&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p&gt;&gt;q;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;q&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q w e a z</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q w e a z</span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-cin-get"><strong>2.cin.get()</strong></h3><p>单用cin.get()只能读取其中一个字符，不能存储为string全部的字符。</p><p>若要存储全部则必须传入一个数组以及长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">main</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[n];</span><br><span class="line">    cin.<span class="built_in">get</span>(a,n); <span class="comment">//实际包括空格只能存n-1个字符，最后一个字符</span></span><br><span class="line">是<span class="string">&#x27;\n&#x27;</span>以回车作为结束符。</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-cin-getline"><strong>3.cin.getline()</strong></h3><p>接受一个字符串，可以接收空格并输出,吃掉末尾的换行符的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(m,<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>cin.getline(m, 5)</code> 时，函数从输入流中读取最多 <code>5 - 1 = 4</code> 个字符，并在读取到的字符后添加一个终止空字符 <code>\0</code>。</p><p>延伸：</p><p>cin.getline()实际上有三个参数，<code>cin.getline(接受字符串的看中间的m,接受个数5,结束字符) </code></p><p>当第三个参数省略时，系统默认为’\0’ 。</p><p>如果将例子中cin.getline()改为cin.getline(m,5,‘a’);当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</p><p>当用在多维数组中的时候，也可以用cin.getline(m[i],20)之类的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> m[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin.<span class="built_in">getline</span>(m[i], <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输出m[&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;]的值:&quot;</span> &lt;&lt; m[j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string输入">string输入</h2><h3 id="4-getline"><strong>4.getline()</strong></h3><p>接受一个字符串，可以接收空格并输出，需包含“#include”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str); <span class="comment">// 和cin.getline()一样可以按某个字符结尾</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-getchar"><strong>5.getchar()</strong></h3><p>函数原型：int getchar(void);</p><p>返回类型为int,参数为void</p><p>头  文  件：#include&lt;stdio.h&gt;</p><p>返  回  值：</p><ol><li>getchar返回的是字符的ASCII码值（整数）</li><li>getchar在读取结束或者失败的时候，会返回EOF。(EOF意思是end of file,本质上是-1）</li></ol><p>读取方式：只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符。<br>结束输入的方式：以Enter结束输入（空格不结束），接受空格符。<br>舍弃回车符的方法：以Enter结束输入时，接受空格，会舍弃最后的回车符。</p><p><strong>getchar函数执行过程详解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">getchar</span>();<span class="comment">//输入字符</span></span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的简单意思就是从键盘读入一个字符，然后输出到屏幕。理所当然，我们输入A，输出就是A，输入B，输出就是B。</p><p>那么我们如果输出的是ABC呢？答案是A。</p><p>解释如下：当我们从键盘输入字符‘A’，‘B’,  ‘C’，并按下回车后，我们的输入被放入了输入缓冲区，这个时候getchar()会从缓冲区中读取我们刚才的输入，一次只读一个字符，所以字符A就被拿出来了，赋值给了ch，然后putchar()又将ch放在了标准输出，也就是这里的屏幕，所以我们看见了最终的显示结果A。同时字符‘A’也被缓冲区释放了，而字符‘B’,'C’仍然被留在了缓冲区。而这样是很不安全的，有可能下次使用的时候，我们的缓冲区会读到一些垃圾，但是当程序结束的时候，它会自动刷新。</p><p>解释：现在，考虑这样一个场景：你的程序在接收了用户的一些输入之后，由于某种原因突然终止了，没有正常退出。这种情况下，这些未处理的输入可能会留在输入缓冲区中，没有被清理掉。当你的程序下次运行并再次试图从输入缓冲区获取输入时，它可能会先读取到这些残留的旧数据，而不是新的用户输入。这就是我们所说的&quot;可能会读到一些垃圾&quot;的含义。</p><h3 id="6-gets">6.gets()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gets</span>(m)用于string类的，需包含<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>。可以接收空格，遇回车结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span><span class="comment">//必须是cstring，否则strlen()方法不能用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">40000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(a);<span class="comment">//必须是char型数组，不能是其他类型数组</span></span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(a);<span class="comment">//得到char型数组的实际长度</span></span><br><span class="line">    <span class="comment">//执行其余操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于多维数组。</p><p>可用于多维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">　　<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">　　<span class="built_in">main</span> ()</span><br><span class="line">　　&#123;</span><br><span class="line">    　　<span class="type">char</span> m[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;\n请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">gets_s</span>(m[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"> <span class="type">int</span> len = <span class="built_in">strlen</span>(m[j]);<span class="comment">//得到char型数组的实际长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;输出m[&quot;</span> &lt;&lt; j &lt;&lt; k &lt;&lt; <span class="string">&quot;]的值:&quot;</span> &lt;&lt; m[j][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="算竞输入补充">算竞输入补充</h2><ul><li><a href="https://blog.csdn.net/ZER00000001/article/details/126345457">竞赛中应该用scanf还是cin？ scanf&amp;printf与cin&amp;cout的比较+快读快写</a></li></ul><p>我利用代码生成了<strong>三千万</strong>个【1，100】以内的随机数，并且将分别用<code>cin</code>和<code>scanf</code>输入到一个数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXNUM  = <span class="number">30000000</span>;</span><br><span class="line"><span class="type">int</span> RandomNumber;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    RandomNumber = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//scanf(&quot;%d &quot;, &amp;number[i]);</span></span><br><span class="line">cin &gt;&gt; number[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;scanf用时：%.3lf\n&quot;</span>, <span class="built_in">double</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在Windows系统<a href="https://so.csdn.net/so/search?q=GCC%E7%BC%96%E8%AF%91%E5%99%A8&amp;spm=1001.2101.3001.7020">GCC编译器</a>下得出的用时数据（单位：秒），且已验证过不存在偶然性：</p><table><thead><tr><th>scanf</th><th>cin</th></tr></thead><tbody><tr><td>6.836</td><td>11.303</td></tr></tbody></table><p>同时，我用printf和cout分别输出<strong>十万个正整数</strong>。</p><table><thead><tr><th>printf</th><th>cout</th></tr></thead><tbody><tr><td>6.172</td><td>11.509</td></tr></tbody></table><p>于是可以得出结论：<strong>cin&amp;cout的确在效率上是低于scanf&amp;printf的</strong></p><p>而我们可以通过std::ios::sync_with_stdio(false);指令关闭同步（这里要注意：当关闭同步之后为了确保准确，不要使用 printf&amp;scanf了），除此之外我们还可以通过std::cin.tie(nullptr);获取cin更优的性能（解除std :: cin和std :: cout之间的绑定，来降低IO的负担使效率提升）。那么在对iostream优化之后的 printf&amp;scanf 和 cin&amp;cout效率差距又有多大呢？我通过上述的实验得出以下数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world!Hello,</span><br></pre></td></tr></table></figure><p>Note：<code>std::ios::sync_with_stdio(false);</code> 这条语句的作用是关闭C++的iostream和C的stdio之间的同步。</p><p>在默认情况下（同步开启），程序的输出会是 “Hello, world!”。因为cout和printf是同步的，所以他们的输出顺序是按照我们写的顺序来的。</p><p>但是，如果我们关闭同步，那么程序的输出就可能不是&quot;Hello, world!&quot;了。可能cout的输出先出现，也可能printf的输出先出现，这取决于哪个操作更快。所以，在关闭同步后，我们就不能再预期混合使用C++的iostream和C的stdio时的输出顺序了。</p><p><strong>疑问：关闭C++的iostream和C的stdio之间的同步为什么能提高速度？</strong></p><p><strong>有趣的解答：</strong></p><p>假设你正在举办一场派对，你邀请了两个DJ，一个是专门播放摇滚音乐的，另一个是专门播放爵士乐的。你希望他们能够交替播放音乐，这样你的派对就可以同时享受到摇滚和爵士的风格。</p><p>但是，为了确保他们能够顺利地交替播放，你需要找一个协调员来时刻注意两位DJ的状态，告诉他们什么时候该停，什么时候该播。这个协调员就相当于同步机制，他确保了摇滚DJ和爵士DJ（相当于iostream和stdio）能够和谐工作。</p><p>然而，这个协调员并不是免费的。他需要时间去观察和指挥，这就可能会延迟音乐的切换，也就是说，派对的整体节奏可能会因为等待协调员的指示而变慢。这就像为了维持iostream和stdio的同步，系统需要做额外的工作（比如刷新缓冲区），这会导致效率的降低。</p><p>现在假设你决定不再需要协调员，让两位DJ自己决定何时播放音乐。这样，你就节省了协调员的成本，派对的节奏也可能会更快。但是，你也无法再保证摇滚音乐和爵士乐能够完美交替，他们可能会同时播放，也可能会有短暂的静音。这就像当你关闭iostream和stdio的同步时，虽然提高了效率，但也无法保证他们的操作顺序。</p><p>总的来说，关闭iostream和stdio的同步可以提高效率，但同时也会牺牲他们的协调性。在某些情况下，这可能是值得的，但在其他情况下，可能就需要考虑其他解决方案了。</p><table><thead><tr><th>scanf</th><th>cin（优化后）</th></tr></thead><tbody><tr><td>6.836</td><td>2.695</td></tr></tbody></table><table><thead><tr><th>printf</th><th>cout （优化后）</th></tr></thead><tbody><tr><td>6.172</td><td>6.178</td></tr></tbody></table><p>可以看见在关闭同步之后cin的效率已经是高于scanf了，并且cout的速度与printf的速度也相差无几，那我们还能不能继续优化呢？</p><p>我们注意到通常在用cout输出的时候，更习惯去使用endl，它既可以达到换行的需求又可以刷新缓冲区，然而在如此高度的循环下它一直对缓冲区的操作却降低了效率，所以将endl换成’\n’cout的效率将会起飞</p><p>（顺带一提，我在开启同步的条件发现endl或是<code>\n</code> 对cout效率的影响并不大，不知道是不是我的问题，希望各位指出）</p><table><thead><tr><th>printf</th><th>cout（‘\n’）</th></tr></thead><tbody><tr><td>6.172</td><td>1.106</td></tr></tbody></table><p>如此一来我们再一次得出结论：<strong>在同步开启时，scanf&amp;printf的效率要高于cin&amp;cout；当同步关闭时，cin&amp;cout的效率要高于scanf&amp;printf。</strong></p><p>最后，附上ACMer喜欢的快读模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*快读快写*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span><span class="comment">//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//自定义的类型T</span></span><br><span class="line">   <span class="keyword">register</span> T sum = <span class="number">0</span>, f1 = <span class="number">1</span>;<span class="comment">//f1是标志位</span></span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="comment">//如果输入的是负数</span></span><br><span class="line">   <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           f1 = <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       sum = sum * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum * f1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int a = read&lt;int&gt;();</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> stk[<span class="number">20</span>];<span class="comment">//模拟压栈</span></span><br><span class="line">   <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       stk[top++] = x % <span class="number">10</span>;</span><br><span class="line">       x /= <span class="number">10</span>;</span><br><span class="line">   &#125;<span class="keyword">while</span>(x);</span><br><span class="line">   <span class="keyword">while</span>(top)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//write(a);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>read</th><th>cin</th></tr></thead><tbody><tr><td>0.485</td><td>2.695</td></tr></tbody></table><table><thead><tr><th>write</th><th>cout</th></tr></thead><tbody><tr><td>18.908</td><td>1.106</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Cpp输入方式总结</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp异常机制</title>
    <link href="https://penge666.github.io/posts/85e41e12.html"/>
    <id>https://penge666.github.io/posts/85e41e12.html</id>
    <published>2024-06-22T13:46:01.000Z</published>
    <updated>2024-06-24T06:47:20.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-异常机制概述">C++异常机制概述</h2><p>异常处理是C++ 的一项语言机制，用于在程序中处理异常事件。异常事件在C++中表示为异常对象。异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为<strong>异常出现点</strong>，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块，在包含了异常出现点的最内层的try块，依次匹配catch语句中的异常对象（<strong>只进行类型匹配，catch参数有时在catch语句中并不会使用到</strong>）。<strong>若匹配成功，则执行catch块内的异常处理语句，然后接着执行try…catch…块之后的代码</strong>。如果在当前的try…catch…块内找不到匹配该异常对象的catch语句,则由更外层的try…catch…块来处理该异常；<strong>如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常</strong>。<strong>如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序。</strong></p><p>一个最简单的try…catch…的例子如下所示。我们有个程序用来记班级学生考试成绩，考试成绩分数的范围在0-100之间，不在此范围内视为数据异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> score;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将分数写入文件或进行其他操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> score)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;你输入的分数数值有问题，请重新输入！&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throw-关键字">throw 关键字</h2><p>在上面这个示例中，throw是个关键字，与抛出表达式构成了throw语句。其语法为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw 表达式<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>throw语句必须包含在try块中，也可以是被包含在调用栈的外层函数的try块中，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：throw包含在外层函数的try块中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> score; <span class="comment">//throw语句被包含在外层main的try语句块中</span></span><br><span class="line">    <span class="comment">//将分数写入文件或进行其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">registerScore</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> score)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;你输入的分数数值有问题，请重新输入！&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行throw语句时，==throw表达式将作为对象被复制构造为一个新的对象，称为异常对象==。异常对象放在内存的特殊位置，<strong>该位置既不是栈也不是堆</strong>，<strong>在window上是放在线程信息块TIB中</strong>。这个构造出来的新对象与本级的try所对应的catch语句进行类型匹配，类型匹配的原则在下面介绍.</p><p>补充：</p><p><strong>在Linux下，异常对象被存放在一个特殊的内存区域，这个内存区域被称为异常处理堆（Exception Handling Heap）</strong>。这个堆是由操作系统提供的，它不同于程序员常说的堆（即通过new、malloc等函数进行动态分配的堆），也不同于栈（即函数调用时用来存储局部变量和函数调用信息的栈）。</p><p>当一个异常被抛出时，异常对象会被复制构造到这个异常处理堆上。这个异常对象会在整个异常处理过程中保持其生命周期，直到异常被完全处理并恢复程序的正常执行流程，这时异常对象才会被销毁。</p><p>这样设计的原因是，异常处理涉及到栈的展开，也就是局部变量的销毁。如果异常对象存储在栈上，那么在异常处理过程中，异常对象可能会被销毁，这显然是不合理的。所以，异常对象被存储在一个独立的、由操作系统提供的异常处理堆上。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240623222008901.png" alt="image-20240623222008901"></p><p>在本例中，依据score构造出来的对象类型为int，与catch(int score)匹配上，程序控制权转交到catch的语句块，进行异常处理代码的执行。如果在本函数内与catch语句的类型匹配不成功，则在调用栈的外层函数继续匹配，如此递归执行直到匹配上catch语句，或者直到main函数都没匹配上而调用系统函数terminate()终止程序。 当执行一个throw语句时，跟在throw语句之后的语句将不再被执行，throw语句的语法有点类似于return，因此导致在调用栈上的函数可能提早退出。</p><h2 id="异常对象">异常对象</h2><p>异常对象是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型。不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的。【因为要复制构造异常对象以及catch之后析构对象，因此不应该将其设置为private】</p><p>异常对象不同于函数的局部对象，局部对象在函数调用结束后就被自动销毁，<strong>而异常对象将驻留在所有可能被激活的catch语句都能访问到的内存空间中，也即上文所说的TIB。当异常对象与catch语句成功匹配上后，在该catch语句的结束处被自动析构。</strong></p><p>在函数中返回局部变量的引用或指针几乎肯定会造成错误，同样的道理，<strong>在throw语句中抛出局部变量的指针或引用也几乎是错误的行为</strong>。如果指针所指向的变量在执行catch语句时已经被销毁，对指针进行解引用将发生意想不到的后果。</p><p>throw出一个表达式时，<strong>该表达式的静态编译类型将决定异常对象的类型</strong>。所以当throw出的是基类指针的解引用，而该指针所指向的实际对象是派生类对象，此时将发生派生类对象切割。</p><p>来看个例子解释下：</p><p>在C++中，如果你抛出一个基类的引用或者指针，但它实际上指向一个派生类对象，那么在抛出异常时，只有基类部分会被抛出，派生类的部分会被切割掉。这就是所谓的&quot;对象切割&quot;问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived d;</span><br><span class="line">        <span class="built_in">foo</span>(d);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (Base&amp; b) &#123;</span><br><span class="line">        b.<span class="built_in">print</span>(); <span class="comment">// 输出 &quot;Base&quot; 而不是 &quot;Derived&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在这个例子中，<code>Derived</code>是<code>Base</code>的派生类。<code>foo</code>函数接收一个<code>Base</code>的引用，并抛出这个引用。在<code>main</code>函数中，我们创建了一个<code>Derived</code>对象<code>d</code>，并将它作为<code>Base</code>的引用传递给<code>foo</code>函数。当<code>foo</code>函数抛出这个引用时，只有<code>Base</code>部分被抛出，<code>Derived</code>部分被切割掉。所以，当我们在<code>catch</code>块中捕获这个异常并调用<code>print</code>函数时，输出的是&quot;Base&quot;，而不是&quot;Derived&quot;。</p><p>除了抛出用户自定义的类型外，C++标准库定义了一组类，用户报告标准库函数遇到的问题。这些标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。</p><table><thead><tr><th>标准异常类</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>exception</td><td>最通用的异常类，只报告异常的发生而不提供任何额外的信息</td><td>exception</td></tr><tr><td>runtime_error</td><td>只有在运行时才能检测出的错误</td><td>stdexcept</td></tr><tr><td>rang_error</td><td>运行时错误：产生了超出有意义值域范围的结果</td><td>stdexcept</td></tr><tr><td>overflow_error</td><td>运行时错误：计算上溢</td><td>stdexcept</td></tr><tr><td>underflow_error</td><td>运行时错误：计算下溢</td><td>stdexcept</td></tr><tr><td>logic_error</td><td>程序逻辑错误</td><td>stdexcept</td></tr><tr><td>domain_error</td><td>逻辑错误：参数对应的结果值不存在</td><td>stdexcept</td></tr><tr><td>invalid_argument</td><td>逻辑错误：无效参数</td><td>stdexcept</td></tr><tr><td>length_error</td><td>逻辑错误：试图创建一个超出该类型最大长度的对象</td><td>stdexcept</td></tr><tr><td>out_of_range</td><td>逻辑错误：使用一个超出有效范围的值</td><td>stdexcept</td></tr><tr><td>bad_alloc</td><td>内存动态分配错误</td><td>new</td></tr><tr><td>bad_cast</td><td>dynamic_cast类型转换出错</td><td>type_info</td></tr></tbody></table><h2 id="catch-关键字">catch 关键字</h2><p>catch语句匹配被抛出的异常对象。如果catch语句的参数是引用类型，则该参数可直接作用于异常对象，即参数的改变也会改变异常对象，==而且在catch中<strong>重新抛出异常</strong>时会继续传递这种改变==。如果catch参数是传值的，则复制构函数将依据异常对象来构造catch参数对象。在该catch语句结束的时候，先析构catch参数对象，然后再析构异常对象。</p><p>在进行异常对象的匹配时，<strong>编译器不会做任何的隐式类型转换或类型提升</strong>。</p><p>除了以下几种情况外，异常对象的类型必须与catch语句的声明类型完全匹配：</p><ul><li>允许从非常量到常量的类型转换。</li><li>允许派生类到基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针。</li><li>函数被转换成指向函数类型的指针。</li></ul><p>寻找catch语句的过程中，匹配上的未必是类型完全匹配那项，而在是最靠前的第一个匹配上的catch语句（我称它为<strong>最先匹配原则</strong>）。<strong>所以，派生类的处理代码catch语句应该放在基类的处理catch语句之前，否则先匹配上的总是参数类型为基类的catch语句，而能够精确匹配的catch语句却不能够被匹配上。</strong></p><p>解释：</p><p>在查找适合的<code>catch</code>块以处理抛出的异常时，C++会按照代码的顺序从上到下查找，当找到第一个能够匹配抛出的异常类型的<code>catch</code>块时，就会执行这个<code>catch</code>块。如果派生类的<code>catch</code>块被放在了基类的<code>catch</code>块之后，那么基类的<code>catch</code>块就会先被匹配上，派生类的<code>catch</code>块就无法被执行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Derived</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Base&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Base\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Derived&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Derived\n&quot;</span>; <span class="comment">// 这个catch块永远不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>foo</code>函数抛出了一个<code>Derived</code>类型的异常，但是在<code>main</code>函数中，先匹配上的是<code>Base</code>类型的<code>catch</code>块，所以输出的是&quot;Caught Base&quot;。尽管有一个精确匹配<code>Derived</code>类型的<code>catch</code>块，但是由于它被放在了<code>Base</code>类型的<code>catch</code>块之后，所以它永远不会被执行。</p><p>为了避免这种情况，我们应该将派生类的<code>catch</code>块放在基类的<code>catch</code>块之前，就像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Derived&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Derived\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Base&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Base\n&quot;</span>; <span class="comment">// 只有当抛出的异常不是Derived类型时，这个catch块才会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当<code>foo</code>函数抛出一个<code>Derived</code>类型的异常时，就会先匹配上<code>Derived</code>类型的<code>catch</code>块，输出的就是&quot;Caught Derived&quot;了。</p><hr><p>在catch块中，如果在当前函数内无法解决异常，可以继续向外层抛出异常，让外层catch异常处理块接着处理。此时可以使用不带表达式的throw语句将捕获的异常重新抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(type x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//做了一部分处理</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被重新抛出的异常对象为保存在TIB中的那个异常对象</strong>，与catch的参数对象没有关系，若catch参数对象是引用类型，<strong>可能在catch语句内已经对异常对象进行了修改，那么重新抛出的是修改后的异常对象</strong>；若catch参数对象是非引用类型，则重新抛出的异常对象并没有受到修改。</p><p>使用<code>catch(...)&#123;&#125;</code>可以捕获所有类型的异常，根据最先匹配原则，<code>catch(...)&#123;&#125;</code>应该<strong>放在所有catch语句的最后面</strong>，否则无法让其他可以精确匹配的catch语句得到匹配。通常在catch(…){}语句中执行当前可以做的处理，然后再重新抛出异常。<strong>注意，catch中重新抛出的异常只能被外层的catch语句捕获。</strong></p><h2 id="栈展开、RAII">栈展开、RAII</h2><p>其实栈展开已经在前面说过，就是从异常抛出点一路向外层函数寻找匹配的catch语句的过程，寻找结束于某个匹配的catch语句或标准库函数terminate。这里重点要说的是栈展开过程中对局部变量的销毁问题。我们知道，在函数调用结束时，函数的局部变量会被系统自动销毁，类似的，<strong>throw可能会导致调用链上的语句块提前退出，此时，语句块中的局部变量将按照构成生成顺序的逆序，依次调用析构函数进行对象的销毁</strong>。例如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个没有任何意义的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() :<span class="built_in">a</span>(<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;A默认构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span>  A&amp; rsh)&#123; cout &lt;&lt; <span class="string">&quot;A复制构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; cout &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a ;</span><br><span class="line">            <span class="keyword">throw</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (A a)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A默认构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br></pre></td></tr></table></figure><p>定义变量a时调用了默认构造函数，使用a初始化异常变量时调用了复制构造函数，使用异常变量复制构造catch参数对象时同样调用了复制构造函数。三个构造对应三个析构，也即try语句块中局部变量a自动被析构了。然而，如果a是在自由存储区上分配的内存时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        A * a= <span class="keyword">new</span> A;</span><br><span class="line">        <span class="keyword">throw</span> *a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (A a)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A默认构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br></pre></td></tr></table></figure><p>同样的三次构造，却只调用了两次的析构函数！说明a的内存在发生异常时并没有被释放掉，发生了内存泄漏。 ==RAII机制有助于解决这个问题==，RAII（Resource acquisition is initialization，资源获取即初始化）。它的思想是以对象管理资源。为了更为方便、鲁棒地释放已获取的资源，避免资源死锁，一个办法是把资源数据用对象封装起来。程序发生异常，执行栈展开时，封装了资源的对象会被自动调用其析构函数以释放资源。C++ 中的智能指针便符合RAII。关于这个问题详细可以看《Effective C++》条款13.</p><p><strong>条款13：以对象管理资源</strong></p><p>为了防止资源泄漏，请使用RAII(Resource Acquisition Is Initialization)对象，在构造函数里面获得资源，在析构函数里面释放资源 <code>auto_ptr</code>(c++11废弃，原因见笔记)，<code>shared_ptr</code>，<code>unique_lock</code>都是RAII类。</p><h2 id="异常机制与构造函数">异常机制与构造函数</h2><p>异常机制的一个合理的使用是在构造函数中。<strong>构造函数没有返回值，所以应该使用异常机制来报告发生的问题</strong>。更重要的是，构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用，因此析构函数应该先析构所有所有已初始化的基对象，成员对象，再抛出异常。 C++类<strong>构造函数初始化列表的异常机制</strong>，称为function-try block。一般形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myClass::<span class="built_in">myClass</span>(type1 pa1)</span><br><span class="line">    <span class="keyword">try</span>:  _myClass_val (初始化值) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">/*构造函数的函数体 */</span></span><br><span class="line">&#125; </span><br><span class="line">  <span class="built_in">catch</span> ( exception&amp; err ) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 构造函数的异常处理部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用.可能会存在内存泄漏。因此提出<strong>构造函数初始化列表的异常机制</strong></p><h2 id="异常机制与析构函数">异常机制与析构函数</h2><p>C++不禁止析构函数向外界抛出异常，==但析构函数被期望不向外界函数抛出异常==。析构函数中向函数外抛出异常，将直接调用terminator()系统函数终止程序。如果一个析构函数内部抛出了异常，就应该在析构函数的内部捕获并处理该异常，不能让异常被抛出析构函数之外。可以如此处理：</p><ul><li>若析构函数抛出异常，调用std::abort()来终止程序。</li><li>在析构函数中catch捕获异常并作处理。</li></ul><p>关于具体细节，有兴趣可以看《Effective C++》条款08：别让异常逃离析构函数。</p><p><strong>解释</strong></p><p>在C++中，析构函数是不应该抛出异常的。如果析构函数中抛出了异常，那么当对象被销毁，或者在异常处理过程中，对象被销毁时，如果析构函数再次抛出异常，程序就会调用<code>std::terminate</code>函数，导致程序立即崩溃。</p><p>这是因为在C++中，如果一个异常没有被捕获，那么程序就会调用<code>std::terminate</code>函数，结束程序的运行。而在一个异常处理过程中，如果又抛出了新的异常，那么这个新的异常就无法被捕获，因为异常处理机制已经在处理一个异常了。</p><p>此外，如果析构函数在执行过程中抛出异常并且没有被正确处理，那么对象可能无法被完全销毁，这就可能导致内存泄漏。</p><p>所以，为了避免这种情况，我们通常推荐在析构函数中使用try/catch块来捕获并处理可能的异常，或者设计析构函数使其不会抛出异常。如果必须在析构函数中执行可能会抛出异常的操作，那么应该将这些操作放在一个单独的函数中，而不是直接放在析构函数中。</p><h2 id="noexcept修饰符与noexcept操作符">noexcept修饰符与noexcept操作符</h2><p>noexcept修饰符是C++ 11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中你可能会看到这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span> ,<span class="type">double</span> )</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这是throw作为函数异常说明，前者表示func（）这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++ 11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//等价于void func() throw()&#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此，被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是阻止异常的传播,提高安全性.</p><p>上面一点提到了，我们不能让异常逃出析构函数，因为那将导致程序的不明确行为或直接终止程序。实际上出于安全的考虑，<strong>C++ 11标准中让类的析构函数默认也是noexcept的</strong>。 <strong>同样是为了安全性的考虑，经常被析构函数用于释放资源的delete函数，C++11也默认将其设置为noexcept</strong>。</p><p>noexcept也可以接受一个常量表达式作为参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure><p>常量表达式的结果会被转换成bool类型，noexcept(bool)表示函数不会抛出异常，noexcept(false)则表示函数有可能会抛出异常。<strong>故若你想更改析构函数默认的noexcept声明，可以显式地加上noexcept(false)声明，但这并不会带给你什么好处</strong>。</p><p>【异常后果自负】</p><p><strong>在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是阻止异常的传播,提高安全性.</strong></p><h2 id="异常处理的性能分析">异常处理的性能分析</h2><p>异常处理机制的主要环节是运行期类型检查。当抛出一个异常时，必须确定异常是不是从try块中抛出。异常处理机制为了完善异常和它的处理器之间的匹配，需要存储每个异常对象的类型信息以及catch语句的额外信息。由于异常对象可以是任何类型（如用户自定义类型），并且也可以是多态的，获取其动态类型必须要使用运行时类型检查（RTTI），此外还需要运行期代码信息和关于每个函数的结构。</p><p>当异常抛出点所在函数无法解决异常时，异常对象沿着调用链被传递出去，程序的控制权也发生了转移。转移的过程中为了将异常对象的信息携带到程序执行处（如对异常对象的复制构造或者catch参数的析构），在时间和空间上都要付出一定的代价，本身也有不安全性，特别是异常对象是个复杂的类的时候。</p><p>异常处理技术在不同平台以及编译器下的实现方式都不同，但都会给程序增加额外的负担，当异常处理被关闭时，额外的数据结构、查找表、一些附加的代码都不会被生成，正是因为如此，对于明确不抛出异常的函数，我们需要使用noexcept进行声明。</p><p>学习自：<a href="https://www.cnblogs.com/QG-whz/p/5136883.html">C++异常机制概述</a></p>]]></content>
    
    
    <summary type="html">Cpp异常机制</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>动态内存分配</title>
    <link href="https://penge666.github.io/posts/49f482c.html"/>
    <id>https://penge666.github.io/posts/49f482c.html</id>
    <published>2024-06-21T07:32:17.000Z</published>
    <updated>2024-06-21T07:40:17.931Z</updated>
    
    <content type="html"><![CDATA[<p>虽然可以mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当需要额外的虚拟内存时，用<strong>动态内存分配器</strong>更方便，也有更好的可移植性。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种基本风格，<strong>显式分配器</strong>要求应用显式释放分配的块，而<strong>隐式分配器</strong>(<strong>也叫做垃圾收集器</strong>)则要求分配器检查不再使用的块并释放。本文将对显示分配器和隐式分配器做更深入的讨论。</p><h3 id="1、malloc和free函数">1、malloc和free函数</h3><h4 id="1-1-malloc函数">1.1 malloc函数</h4><p>c标准库提供了一个称为malloc程序包的显式分配器。程序通过调用malloc函数来从堆中分配块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>; <span class="comment">//返回：若成功则为已分配块的指针，若出错则为null.</span></span><br></pre></td></tr></table></figure><p>malloc函数返回一个指针，指向大小至少为size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。如果malloc遇到问题，那么它就返回null，并设置errno。<strong>malloc不初始化它返回的内存，如果想要已初始化的内存则通过calloc分配，如果想要改变已分配块的大小则使用realloc函数</strong>。</p><h4 id="1-2-malloc的底层——sbrk函数">1.2 malloc的底层——sbrk函数</h4><p>malloc可以通过mmap和munmap来显式分配和释放堆内存，或则还可以使用sbrk函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span></span>; <span class="comment">//成功返回brk的旧值，出错返回-1</span></span><br></pre></td></tr></table></figure><p>sbrk函数通过将内核的brk(指向堆顶部)指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1并设置errno为ENOMEM。如果sbrk的参数为0，则返回的为原来的brk地址。</p><h4 id="1-3-free函数">1.3 free函数</h4><p>程序通过调用free函数来释放已分配的堆块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span>; <span class="comment">//不返回值</span></span><br></pre></td></tr></table></figure><p>ptr必须指向一个已分配块的起始位置，如果不是，那么free的行为就是未定义的。</p><h3 id="2、为什么要使用动态内存">2、为什么要使用动态内存</h3><p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。比如我们需要根据输入的n分配一个对应大小的数据来临时存储数据，这是就用动态分配比较好。</p><blockquote><p>值得注意的是，c99提供了动态的数组大小分配，可以不再需要由程序员显式分配动态空间。不过这种分配方式是否是堆上的空间就需要进一步验证了。</p></blockquote><h3 id="3、分配器的要求和目标">3、分配器的要求和目标</h3><p>显式分配器必须在一些相当严格的约束条件下工作：</p><ul><li><strong>处理任意请求序列</strong>：一个应用可以有任意的分配请求和释放请求序列，分配器不可以假设分配和释放请求的顺序。</li><li><strong>立即响应请求</strong>：分配器必须立即响应分配请求。因此不允许分配器提高性能，从新排列或者缓冲请求。</li><li><strong>只使用堆</strong>：分配器使用的任何数据结构都保存在堆里。</li><li><strong>对齐块</strong>：比如8个字节的对齐。</li><li><strong>不修改已分配的块</strong>：分配器只能操作或者改变空闲块，不允许不能压缩已分配的块。</li></ul><p>分配器在满足上述要求的情况下，需要达到以下两个目标：</p><ul><li>(1)最大化吞吐率,单位时间完成尽可能多的请求。</li><li>(2)最大化存储器的利用率。天真的程序员经常不正确的假设虚拟存储器是一个无限的资源**，事实上，一个系统中被所有进程分配的虚拟存储器的全部数量是受磁盘上交换空间的数量限制的**。好的程序员知道虚拟内存是一个有限的空间，必须高效地使用。</li></ul><p>分配器设计中一个有趣的挑战就是在上述两个目标之间找到一个适当的平衡。</p><h3 id="3、碎片">3、碎片</h3><p>造成堆的空间利用率很低的主要原因是一种被称为碎片的现象，当虽然有未使用的内存但这块内存并不能满足分配请求时，就会产生碎片。有以下两种形式的碎片：内部碎片和外部碎片。</p><ul><li><strong>内部碎片</strong>：在一个已分配块比有效载荷大时发生。比如分配器限制的最小分配至比实际请求值要大，又或者为了对齐而增加块的大小。意味着已分配但是未使用。</li><li>外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大到可以来处理这个请求时发生。<strong>外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块</strong>。</li></ul><h3 id="4、分配器设计">4、分配器设计</h3><p>一个分配器需要在吞吐率和利用率之间把握好平衡，必须要考虑以下几个因素：</p><ul><li>组织空闲块：如何组织</li><li>放置：怎么选择一个合适的块来放置新分配的块。</li><li>分割：新分配的块放到某个空闲块后，如何处理剩余部分。</li><li>合并：如何处理一个刚刚被释放的块。</li></ul><blockquote><p><strong>动态内存分配器补充</strong></p></blockquote><p>动态内存分配器可以是内核的一部分，也可以是运行在用户空间的库。这取决于具体的操作系统和编程环境。</p><p>在许多操作系统中，如Unix和Windows，动态内存分配器是作为C标准库的一部分提供的，例如<code>malloc</code>，<code>calloc</code>，<code>realloc</code>和<code>free</code>函数。这些库函数在用户空间运行，并通过系统调用来请求内核分配或释放内存。</p><p>然而，这些函数的实现通常是建立在操作系统内核提供的更底层的内存管理机制之上的。例如，Unix系统的<code>brk</code>和<code>sbrk</code>系统调用，或者Windows的<code>VirtualAlloc</code>函数。这些底层的内存管理函数是由内核直接提供的，因此可以说，动态内存分配器的这一部分是内核程序。</p><h3 id="5、隐式空闲链表">5、隐式空闲链表</h3><h4 id="5-1-组织空闲块">5.1 组织空闲块</h4><p>假设用下图结构来组织堆块，并且已知采用双字对齐，头部后面的就是应用调用malloc时请求的有效载荷。</p><p><strong>双字对齐(Double Word Alignment)指的是数据在内存中的存储方式,使其地址是4字节(即32位)的倍数。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153323077.png" alt="image-20240621153323077"></p><p>分配器将堆组织为下图式样的一个连续的已分配块和空闲块的序列，该序列被称为<strong>隐式空闲链表</strong>。之所以称为隐式空闲链表是因为分配需要遍历堆中所有的块，才能知道空闲块的集合。注意，<strong>图中用一个已分配而大小为的零的块来标记结束</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153332878.png" alt="image-20240621153332878"></p><p>隐式空闲链表的有点是简单，缺点是放置开销会与已分配块和空闲块块的总数呈线性关系。</p><h4 id="5-2-放置已分配的块">5.2 放置已分配的块</h4><p>当应用发起一个分配请求时，分配器需要从空闲链表中选择一个合适的块来满足请求。分配器的选择方式称为<strong>放置策略</strong>。常见的放置策略有以下几种：</p><ul><li><strong>首次适配</strong>：从头开始搜索空闲链表，选择第一个遇见的合适的空闲块。它的优点在于趋向于将大的空闲块保留在链表的后面，缺点是它趋向于在靠近链表前部处留下小空闲块的碎片，从而增加较大请求块的放置时间。</li><li><strong>下一次适配</strong>：每次从上一次查询结束的地方开始进行搜索，直到遇见合适的空闲块。这种策略通常比首次适配效率高，但是内存利用率则要低得多了</li><li><strong>最佳适配</strong>：检查每个空闲块，选择适合所需请求大小的最小空闲块。最佳适配的内存利用率是三种策略中最高的，但它需要对堆进行彻底的搜索。</li></ul><h4 id="5-3-分割空闲块">5.3 分割空闲块</h4><p>分配器在匹配到一个合适的空闲块后，就需要决定分配这个空闲块中多少空间，可以称之为分割策略，一般有以下两种方式：</p><p>（1）选择用整个空闲块，这个方式简单而且快捷，缺点是可能会造成很多内部碎片。</p><p>（2）分配器嫁给你空闲块分为两个部分，第一部分变成分配块，而剩下的那部分则组织成一个新的空闲块。</p><h4 id="5-4-合并空闲块">5.4 合并空闲块</h4><p>为了避免假碎片问题，分配器需要在释放一个已分配块时，除了重新标记当前块外也需要合并相邻空闲块。合并空闲块的方式称为合并策略，主要分为两种：</p><p>（1）立即合并：就是在每次释放块时，就立即合并所有相邻块，这种方式可能会产生抖动（比如频繁在一个8字节的空闲块中执行3字节的分配与释放，就可能产生大量不必要的分割与合并）。</p><p>（2）推迟合并：即推迟合并空闲块的时机，比如直到某个分配请求失败才扫描整个堆，合并所有的空闲块。快速的分配器通常会选择某种形式的推迟合并。</p><h4 id="5-5-合并空闲块的具体实现">5.5 合并空闲块的具体实现</h4><p>对于向后合并，我们可以通过当前块的头部指针判断下一个块是否空闲，从而进行合并，但是如何合并前面的块呢？搜索整个链表？</p><p>Knuth提出了一种叫做<strong>边界标记</strong>的技术用于常数时间对前面的块进行合并。其实现如下图，通过在每个块的结尾处添加一个脚部，其是头部的一个副本。这样分配器就可以通过检查当前块的前一个字节的内容从而判断前一个块的起始位置和状态。</p><p>比如有一个释放当前块，其前一个块和后一块都是空闲的，此时需要将三块的大小求和然后更新前一块的头部和后一块脚部，明显能在常数时间内完成。</p><p>边界标记的一个缺陷是每一块都要保持一个头部和一个脚部，这会导致显著的内存开销。一种可能的优化方案是在已分配的块剩余部分保存脚部信息，从而减小开销。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153338881.png" alt="image-20240621153338881"></p><h3 id="6、显式空闲链表">6、显式空闲链表</h3><h4 id="6-1-空闲块组织">6.1 空闲块组织</h4><p>其实对于通用的分配器来说，隐式空闲链表是不适合的，一种更好的方法是将空闲块组织为某种形式的显式空闲链表。</p><p>如下图，我们用一个双向链表组织空闲块，为了节省空间，我们将前驱指针pred和后继指针succ放在空闲块的主体当中。双向链表使得首次适配的时间从块总数的线性时间减少到了空闲块总数的线性时间。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153345698.png" alt="image-20240621153345698"></p><p>在释放分配块时，有两种方式，分别为：</p><ul><li><strong>后进先出</strong>LIFO顺序维护链表：将新释放的块放在链表的开始处，加上边界标记后能快速合并完成并放置。</li><li><strong>按照地址顺序维护链表</strong>：这种方式使得每个块的地址都小于它后继的地址。释放一个块比较麻烦，但是首次适配有更高的内存利用率。</li></ul><p>显式空闲链表的需要存储前向和后向指针，这会限制最小块的大小，从而增加内存碎片。</p><h4 id="6-2-分离的空闲链表">6.2 分离的空闲链表</h4><p>为了减少分配时间，人们想出了另一种叫做<strong>分离存储</strong>的方法，主要是通过维护多个空闲链表，其中每个链表中的块有大致相等的大小。也即是分配器维护一个空闲链表数组，然后每个空闲链表中的空闲块按照大小进行升序排序。<strong>简单分离存储</strong>中采用的方式是每个空闲链中的空闲块大小一样，而<strong>分离适配</strong>方式的每个空闲链表中的块大小却不一样，这样适配时需要在空闲链表中进行匹配。</p><p>当有一个分配请求时，我们检查相应的空闲链表。如果链表非空，那么就分配其中第一块的全部。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，然后将这些块链接起来形成新的空闲链表。类型vector中的free list。</p><p>要释放一个块，分配器只需要简单地将这个块插入到相应的空闲链表的头部。</p><h3 id="7、垃圾收集">7、垃圾收集</h3><p>在编写C程序时，一般只能显式地分配与释放堆中的内存（malloc()与free()），程序员不仅需要分配内存，还需要负责内存的释放。但如果能自动回收是不是更好呢？</p><p><strong>垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块</strong>。这些块被称为垃圾，自动回收堆存储的过程叫做垃圾收集。接下来讨论一种垃圾收集算法——Mark&amp;Sweep法，可以称为标记清除法。</p><h4 id="7-1-垃圾收集器垃圾组织">7.1 垃圾收集器垃圾组织</h4><p>垃圾器将内存视为一张有向可达图，组织如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153351873.png" alt="image-20240621153351873"></p><p>垃圾收集器一般采用以下两种（之一）的策略来判断一块堆内存是否为垃圾内存：</p><ul><li>引用计数器：在数据的物理空间中添加一个计数器，当有其他数据与其相关时（引用），该计数器加一，反之则减一。通过定期检查计数器的值，只要为0则认为是垃圾内存，可以释放它所占用的已分配块。使用引用计数器，实现简单直接，但缺点也很明显，它无法回收循环引用的两个对象（假设有对象A与对象B，它们2个互相引用，但实际上对象A与对象B都已经是没用的对象了）。</li><li>可达性分析：垃圾收集器将堆内存视为一张有向图，然后选出一组根节点（例如，在Java中一般为类加载器、全局变量、运行时常量池中的引用类型变量等），根节点必须是足够“活跃“的对象。然后计算从根节点集合出发的可达路径，只要从根节点出发不可达的节点，都视为垃圾内存。</li></ul><h4 id="7-2-Mark-Sweep垃圾收集器">7.2 Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记阶段和清除阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。标记-清除算法实现简单，但它的效率不高，而且会产生许多内存碎片。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153403384.png" alt="image-20240621153403384"></p><p>再介绍两种垃圾收集器进行回收的算法：</p><ul><li>复制：将程序所拥有的内存空间划分为大小相等的两块，每次都只使用其中的一块。当这一块的内存用完了，就把还存活着的对象复制到另一块内存上，然后将已使用过的内存空间进行清理。这种方法不必考虑内存碎片问题，但内存利用率很低。这个比例不是绝对的，像HotSpot虚拟机为了避免浪费，将内存划分为Eden空间与两个Survivor空间，每次都只使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一个Survivor空间上，然后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例为8：1，只有10%的内存空间会被闲置浪费。</li><li>分代：分代算法根据对象的存活周期的不同将内存划分为多块，这样就可以对不同的年代采用不同的回收算法。一般分为新生代与老年代，新生代存放的是存活率较低的对象，可以采用复制算法；老年代存放的是存活率较高的对象，如果使用复制算法，那么内存空间会不够用，所以必须使用标记-清除或标记-整理算法。</li></ul><h3 id="8、小结">8、小结</h3><p>本节主要讨论动态内存的分配与垃圾回收，主要是大概了解常见的内存管理方式。</p><p>学习自：<a href="https://wendeng.github.io/2019/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/#5%E3%80%81%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">第9章 虚拟内存之动态内存分配与垃圾收集</a></p>]]></content>
    
    
    <summary type="html">VM之动态内存分配</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
