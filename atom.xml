<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-08-25T12:28:38.752Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程实战总结</title>
    <link href="https://penge666.github.io/posts/cb6fdc44.html"/>
    <id>https://penge666.github.io/posts/cb6fdc44.html</id>
    <published>2024-08-13T12:39:22.000Z</published>
    <updated>2024-08-25T12:28:38.752Z</updated>
    
    <content type="html"><![CDATA[<p>之前在503接触过些多线程编程。现在将其总结下！</p><h2 id="多线程注意事项">多线程注意事项</h2><h3 id="避免使用全局变量"><strong>避免使用全局变量</strong></h3><p><strong>原因</strong>：全局变量在多线程环境中是共享的，多个线程可能同时访问或修改它，导致数据竞争。</p><p><strong>解决方案</strong>：</p><ul><li>使用 <code>std::mutex</code> 来保护对全局变量的访问。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> global_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ++global_counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global counter: &quot;</span> &lt;&lt; global_counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进一步思考</strong>：全局变量在一个进程中修改，会影响到另一个进程吗？</p><p>答案：不会</p><p>在操作系统中，每个进程都有自己独立的内存空间。全局变量是定义在函数之外的变量，它们的作用域是整个文件，但在多进程环境中，每个进程都有自己的全局变量副本。因此，一个进程中修改全局变量不会影响到另一个进程。</p><p>验证：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        global_var = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process: global_var = %d\n&quot;</span>, global_var);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 等待子进程修改全局变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process: global_var = %d\n&quot;</span>, global_var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork 失败</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子操作"><strong>原子操作</strong></h3><p><strong>使用</strong>：使用 <code>std::atomic</code> 进行原子操作，避免使用锁。</p><p>1.自己不会被优化，相当于voliate（经验之谈：当两个线程都访问同一个变量，请使用atomic，防止优化产生逾期错误，因为atomic修饰的变量不会被优化）</p><p>2.使用内存序</p><p><strong>避免</strong>：直接操作共享变量没有加锁或使用不安全的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">atomic_counter</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++atomic_counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(increment)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(increment)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Atomic counter: &quot;</span> &lt;&lt; atomic_counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>std::atomic</code> 的底层原理</strong></p><ol><li><strong>原子指令</strong>：<ul><li>CPU 提供了专门的原子指令来保证操作的原子性。例如，Intel 的 <code>x86</code> 架构提供了 <code>LOCK</code> 前缀和 <code>CMPXCHG</code>（比较并交换）指令，ARM 架构提供了 <code>LDREX</code> 和 <code>STREX</code> 指令。</li><li>这些原子指令确保在执行操作时，其他线程或进程不能干扰当前操作，从而避免数据竞争和一致性问题。</li></ul></li><li><strong>内存屏障</strong>：<ul><li>内存屏障（Memory Barriers）或内存顺序（Memory Order）用于确保指令执行的顺序和可见性。<code>std::atomic</code> 提供了不同的内存顺序选项（如 <code>memory_order_relaxed</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>、<code>memory_order_seq_cst</code>）来控制这些屏障。</li><li>内存屏障可以确保在多线程环境下对原子变量的操作按预期顺序执行。例如，<code>memory_order_acquire</code> 确保在读取原子变量后，所有后续操作的读写在该线程中都不会被重排到读取之前。</li></ul></li><li><strong>CAS（比较并交换）</strong>：<ul><li><code>std::atomic</code> 中许多原子操作（如 <code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code>）基于 CAS 操作。CAS 操作的基本原理是：比较当前值和期望值，如果它们相等，则将变量更新为新值。</li><li>这个操作是原子的，确保在更新过程中不会被其他线程的操作干扰。</li></ul></li></ol><p><strong><code>std::atomic</code> 的常见操作</strong></p><ol><li><strong>原子加载和存储</strong>：<ul><li><code>std::atomic</code> 提供了 <code>load()</code> 和 <code>store()</code> 方法【load()和store()是重载函数】来进行原子读取和写入。底层这些操作会利用 CPU 提供的原子指令来保证操作的原子性。</li></ul></li><li><strong>原子交换</strong>：<ul><li><code>std::atomic</code> 提供了 <code>exchange()</code> 方法来进行原子交换操作。它会将原子变量的当前值替换为新值，并返回旧值。</li></ul></li><li><strong>原子加法和减法</strong>：<ul><li><code>std::atomic</code> 提供了 <code>fetch_add()</code> 和 <code>fetch_sub()</code> 方法来进行原子加法和减法操作。这些操作保证了对变量的增加或减少是原子的。</li></ul></li><li><strong>原子比较和交换</strong>：<ul><li><code>std::atomic</code> 提供了 <code>compare_exchange_weak()</code> 和 <code>compare_exchange_strong()</code> 方法来进行原子比较和交换操作。它们允许在某个值等于期望值时进行原子更新。</li></ul></li></ol><p>简单问题：++i和i++是否是原子操作？</p><p>答案：不是</p><p>无论是 <code>++i</code> 还是 <code>i++</code>，它们都涉及以下步骤：</p><ol><li><strong>读取变量值</strong>：从内存中读取变量的当前值。</li><li><strong>修改值</strong>：将读取的值加 1。</li><li><strong>写回变量</strong>：将修改后的值写回内存中的变量。</li></ol><p>【可以防止被编译器优化】</p><h3 id="线程本地存储（TLS）"><strong>线程本地存储（TLS）</strong></h3><p><strong>使用</strong>：如果每个线程需要独立的数据副本，可以使用 <code>thread_local</code> 关键字。</p><p><strong>避免</strong>：共享变量不适用于每个线程需要独立的数据场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_local_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_local_variable++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread-local variable: &quot;</span> &lt;&lt; thread_local_variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层原理</strong></p><ol><li><strong>线程本地存储（TLS）</strong>：<ul><li><code>thread_local</code> 变量的底层实现通常利用<strong>操作系统提供的 TLS 机制</strong>。线程本地存储允许线程在其自身的地址空间中拥有私有的数据区域，这些数据区域对其他线程是不可见的。</li><li>在 Windows 上，TLS 由线程局部存储的 API（如 <code>TlsAlloc</code>、<code>TlsSetValue</code> 和 <code>TlsGetValue</code>）提供支持。在 POSIX 系统（如 Linux）上，通常通过线程控制块（Thread Control Block，TCB）或线程局部存储段（Thread-Local Storage Segment）实现。</li></ul></li><li><strong>编译器支持</strong>：<ul><li>编译器为 <code>thread_local</code> 变量生成特定的代码，以确保每个线程都有独立的数据副本。编译器会将 <code>thread_local</code> 变量的数据存储在专门的线程本地存储区域，并使用操作系统提供的机制来分配和管理这些区域。【<strong><code>thread_local</code> 变量通常被存储在线程本地存储区域（Thread-Local Storage, TLS）</strong>】</li><li>在编译时，编译器通常会为每个 <code>thread_local</code> 变量生成额外的代码，以处理变量的初始化、销毁和访问。</li></ul></li><li><strong>线程局部存储的访问</strong>：<ul><li>访问 <code>thread_local</code> 变量时，编译器生成的代码会根据当前线程的标识符（Thread ID）从线程本地存储区域中检索变量的值。这通常涉及到查询线程控制块或其他线程本地数据结构。</li><li>线程本地存储机制可能会在变量首次被访问时初始化变量，并在线程结束时销毁变量。</li></ul></li></ol><h3 id="锁的使用"><strong>锁的使用</strong></h3><h4 id="锁粒度优化">锁粒度优化</h4><p><strong>使用</strong>：在访问共享资源时使用 <code>std::mutex</code> 或 <code>std::shared_mutex</code>。使用 RAII 的锁类（如 <code>std::lock_guard</code>）以确保锁的正确释放。</p><p><strong>避免</strong>：使用过多或不恰当的锁导致性能低下或死锁。</p><h5 id="读写锁">读写锁</h5><p><strong>读写锁</strong></p><p><strong>读写锁</strong>允许多个线程同时读取数据，但在写数据时会对所有读线程和其他写线程加锁。这种锁适用于读操作远多于写操作的场景，可以显著减少锁竞争。</p><p><strong>示例</strong>（使用 <code>std::shared_mutex</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::shared_mutex rw_lock;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title function_">lock</span><span class="params">(rw_lock)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read data: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : data) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_data</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title function_">lock</span><span class="params">(rw_lock)</span>;</span><br><span class="line">    data.push_back(value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Added value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">writer1</span><span class="params">(write_data, <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">writer2</span><span class="params">(write_data, <span class="number">2</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">reader1</span><span class="params">(read_data)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">reader2</span><span class="params">(read_data)</span>;</span><br><span class="line"></span><br><span class="line">    writer1.join();</span><br><span class="line">    writer2.join();</span><br><span class="line">    reader1.join();</span><br><span class="line">    reader2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是如何保证线程安全的呢？</p><p>在 <code>write_data</code> 函数中使用 <code>std::unique_lock</code> 来锁定 <code>std::shared_mutex</code>，确保在写入数据时，其他线程不能持有共享锁（读操作），从而保证写操作的线程安全。具体机制如下：</p><ol><li><strong>写操作的独占锁</strong>：<ul><li>当一个线程调用 <code>write_data</code> 函数并尝试获取 <code>std::unique_lock</code> 时，它会尝试获取 <code>std::shared_mutex</code> 的独占锁。</li><li>如果存在其他线程持有共享锁或独占锁，当前线程会被阻塞，直到这些锁被释放。</li><li>一旦独占锁成功获取，所有其他线程（无论是持有共享锁还是独占锁）都会被阻塞。</li></ul></li><li><strong>读操作的共享锁</strong>：<ul><li>当线程调用 <code>read_data</code> 函数并尝试获取 <code>std::shared_lock</code> 时，它会尝试获取 <code>std::shared_mutex</code> 的共享锁。</li><li>如果没有线程持有独占锁，线程可以成功获取共享锁。</li><li>如果有线程持有独占锁，获取共享锁的线程会被阻塞，直到独占锁被释放。</li></ul></li></ol><p>我们也可以自己实现下share_mutex【本质：条件变量，锁机制和引用计数来实现！】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedMutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedMutex</span>() : <span class="built_in">readers</span>(<span class="number">0</span>), <span class="built_in">writer_waiting</span>(<span class="literal">false</span>), <span class="built_in">writer_active</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock_shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        reader_cv.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !writer_active &amp;&amp; !writer_waiting;</span><br><span class="line">        &#125;);</span><br><span class="line">        ++readers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock_shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (--readers == <span class="number">0</span> &amp;&amp; writer_waiting) &#123;</span><br><span class="line">            writer_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        writer_waiting = <span class="literal">true</span>;</span><br><span class="line">        writer_cv.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> readers == <span class="number">0</span> &amp;&amp; !writer_active;</span><br><span class="line">        &#125;);</span><br><span class="line">        writer_active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        writer_active = <span class="literal">false</span>;</span><br><span class="line">        writer_waiting = <span class="literal">false</span>;</span><br><span class="line">        reader_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex;</span><br><span class="line">    std::condition_variable reader_cv;</span><br><span class="line">    std::condition_variable writer_cv;</span><br><span class="line">    <span class="type">int</span> readers;</span><br><span class="line">    <span class="type">bool</span> writer_waiting;</span><br><span class="line">    <span class="type">bool</span> writer_active;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="死锁">死锁</h4><p><strong>死锁</strong>：通过锁排序和分层锁来避免。</p><h5 id="分层锁">分层锁</h5><p><strong>分层锁的原理</strong></p><ul><li><strong>层次结构</strong>：将锁分为多个层次，每个层次的锁都有一个固定的优先级。例如，层次 1 是最基础的锁，层次 2 是中级锁，层次 3 是高级锁。</li><li><strong>固定顺序</strong>：线程在获取多个锁时，必须按照从低层到高层的顺序获取锁。这可以确保在任意情况下，所有线程都遵循相同的顺序来获取锁，从而避免了循环等待条件。</li></ul><p><strong>为什么分层锁可以防止死锁？</strong></p><p>死锁发生的四个必要条件是：</p><ol><li><strong>互斥条件</strong>：至少有一个资源被一个线程持有，并且其他线程不能获取。</li><li><strong>请求和保持条件</strong>：持有资源的线程正在等待其他线程持有的资源。</li><li><strong>不可剥夺条件</strong>：已获得的资源不能被强制剥夺。</li><li><strong>循环等待条件</strong>：存在一种资源的循环等待关系。</li></ol><p>分层锁通过确保线程在获取多个锁时始终按照相同的顺序进行，可以避免循环等待条件，从而防止死锁。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁的层次</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LockLevel</span> &#123;</span><br><span class="line">    LEVEL_1,</span><br><span class="line">    LEVEL_2,</span><br><span class="line">    LEVEL_3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁类，包含层次信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HierarchicalMutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HierarchicalMutex</span><span class="params">(LockLevel level)</span> : level_(level) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁时，确保按层次顺序</span></span><br><span class="line">        <span class="built_in">check_lock_order</span>();</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_lock_order</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查当前锁的层次是否低于之前获取的锁的层次</span></span><br><span class="line">        <span class="comment">// 这部分可以根据实际需求实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    LockLevel level_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁的层次</span></span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level1</span><span class="params">(LEVEL_1)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level2</span><span class="params">(LEVEL_2)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level3</span><span class="params">(LEVEL_3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    level1.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level2.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level3.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread1 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    level3.<span class="built_in">unlock</span>();</span><br><span class="line">    level2.<span class="built_in">unlock</span>();</span><br><span class="line">    level1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    level1.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level3.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level2.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread2 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    level2.<span class="built_in">unlock</span>();</span><br><span class="line">    level3.<span class="built_in">unlock</span>();</span><br><span class="line">    level1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好的学习例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁的层次</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LockLevel</span> &#123;</span><br><span class="line">    LEVEL_1,</span><br><span class="line">    LEVEL_2,</span><br><span class="line">    LEVEL_3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁类，包含层次信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HierarchicalMutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HierarchicalMutex</span><span class="params">(LockLevel level)</span> : level_(level) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁时，确保按层次顺序</span></span><br><span class="line">        <span class="built_in">check_lock_order</span>();</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 更新当前线程持有的最大锁层次</span></span><br><span class="line">        max_lock_level = std::<span class="built_in">max</span>(max_lock_level.<span class="built_in">load</span>(), level_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁时，更新当前线程持有的最大锁层次</span></span><br><span class="line">        max_lock_level = std::<span class="built_in">max_element</span>(lock_levels.<span class="built_in">begin</span>(), lock_levels.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_lock_order</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查当前锁的层次是否低于之前获取的锁的层次</span></span><br><span class="line">        LockLevel held_lock_level = max_lock_level.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">if</span> (level_ &lt; held_lock_level) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Lock order violation detected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    LockLevel level_;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::atomic&lt;LockLevel&gt; max_lock_level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程本地变量</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> std::atomic&lt;LockLevel&gt; <span class="title">HierarchicalMutex::max_lock_level</span><span class="params">(LEVEL_1 - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁的层次</span></span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level1</span><span class="params">(LEVEL_1)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level2</span><span class="params">(LEVEL_2)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level3</span><span class="params">(LEVEL_3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        level1.<span class="built_in">lock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level2.<span class="built_in">lock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level3.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread1 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        level3.<span class="built_in">unlock</span>();</span><br><span class="line">        level2.<span class="built_in">unlock</span>();</span><br><span class="line">        level1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread1: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        level1.<span class="built_in">lock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level3.<span class="built_in">lock</span>();  <span class="comment">// This will cause a lock order violation</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level2.<span class="built_in">lock</span>();  <span class="comment">// This will also cause a lock order violation</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread2 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        level2.<span class="built_in">unlock</span>();</span><br><span class="line">        level3.<span class="built_in">unlock</span>();</span><br><span class="line">        level1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread2: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="scoped-lock">scoped_lock</h5><p><code>std::scoped_lock</code> 是 C++17 引入的一个锁管理类，用于简化多互斥量的加锁过程并防止死锁。它在构造时会尝试锁定所有提供的互斥量，并在析构时自动解锁，确保了加锁和解锁的正确性和异常安全性。</p><p><strong>主要特点</strong></p><ul><li><strong>自动加锁和解锁</strong>：<code>std::scoped_lock</code> 在构造时加锁，在析构时解锁，确保锁的正确管理。</li><li><strong>支持多个互斥量</strong>：可以同时锁定多个 <code>std::mutex</code> 或其他同步原语，防止死锁。</li><li><strong>异常安全</strong>：即使在加锁后抛出异常，析构函数也会保证锁被正确释放。</li></ul><p><strong>示例代码</strong></p><p>下面是一个使用 <code>std::scoped_lock</code> 的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个互斥量</span></span><br><span class="line"><span class="built_in">std</span>::mutex mutex1;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，演示如何使用 std::scoped_lock</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; attempting to acquire locks...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::scoped_lock 同时锁定两个互斥量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::scoped_lock <span class="title function_">lock</span><span class="params">(mutex1, mutex2)</span>; <span class="comment">// 自动加锁</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; acquired both locks!\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟工作</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; releasing locks...\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished execution.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        threads.emplace_back(thread_function, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释</p><ol><li><strong><code>std::scoped_lock</code></strong>：<ul><li>在构造时，<code>std::scoped_lock</code> 会尝试锁定 <code>mutex1</code> 和 <code>mutex2</code>。它会按照一定的顺序加锁这些互斥量，避免死锁问题。</li><li>当 <code>std::scoped_lock</code> 对象离开作用域时，它的析构函数会自动解锁这些互斥量。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>多个互斥量的加锁</strong>：当一个操作需要同时锁定多个互斥量时，使用 <code>std::scoped_lock</code> 可以简化代码，避免手动管理锁的复杂性。</li><li><strong>死锁预防</strong>：<code>std::scoped_lock</code> 通过确保按照固定的顺序加锁多个互斥量，可以减少死锁的风险。</li><li><strong>异常安全</strong>：<code>std::scoped_lock</code> 确保即使在持锁期间发生异常，锁也能被正确释放。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><strong>锁顺序</strong>：<code>std::scoped_lock</code> 会自动处理锁的顺序，但在某些复杂的应用场景下，仍然需要确保设计上的锁顺序一致性。</li><li><strong>性能</strong>：虽然 <code>std::scoped_lock</code> 简化了锁管理，但在性能要求极高的场景下，仍然需要考虑锁的开销和锁的竞争。</li></ul><p>通过使用 <code>std::scoped_lock</code>，可以提高代码的可读性和可靠性，简化多互斥量加锁的管理。</p><h4 id="活锁">活锁</h4><p>举个有意思的例子吧</p><p><strong>例子：两个自动门</strong></p><p>想象一下，两个自动门（A和B）在同一条走廊的两侧，门上装有传感器。如果有人靠近一扇门，门会自动打开。门的设计是这样的：当两扇门同时检测到有人接近时，它们都会尝试打开。假设门的逻辑是这样的：</p><ul><li>如果门A检测到门B正在打开，它会等待并重新检测，如果门B打开得足够久，门A就会尝试打开。</li><li>如果门B检测到门A正在打开，它会等待，并重新检测，如果门A打开得足够久，门B就会尝试打开。</li></ul><p><strong>活锁的发生</strong></p><ol><li><strong>状态检测</strong>：门A和门B都检测到对方正在尝试打开。</li><li><strong>状态改变</strong>：门A和门B都决定等待并重新检测。</li><li><strong>不断改变</strong>：由于它们在不断检测对方的状态并改变自己的状态，它们永远不会真正打开。</li></ol><p><strong>实际结果</strong>：两个门不断检测对方，尝试解决冲突，但没有任何一个门能够完全打开，因为它们始终在等待对方完成操作，造成了一个典型的活锁情形。</p><p>概念：</p><p><strong>活锁</strong>发生在系统中的线程一直在改变状态，但是系统并没有向前推进，所有线程都在忙碌地试图解决冲突。活锁通常发生在设计上不是很合理的重试逻辑中。</p><p><strong>活锁</strong>：通过合理的重试机制和退出条件来避免。</p><p><strong>示例：活锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; <span class="title function_">flag1</span><span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; <span class="title function_">flag2</span><span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag1 &amp;&amp; !flag2) &#123;</span><br><span class="line">            flag1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">            flag2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread1 finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag1 &amp;&amp; !flag2) &#123;</span><br><span class="line">            flag2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">            flag1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread2 finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(thread1)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(thread2)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：两个线程不断地尝试切换 <code>flag1</code> 和 <code>flag2</code>，但由于没有充分的条件，始终在重试而没有进展。</p><p><strong>避免活锁</strong></p><p>要避免活锁，需要设计合理的重试机制和退出条件，确保线程能够在某些情况下放弃重试，从而避免无限循环。</p><h3 id="线程池"><strong>线程池</strong></h3><p><strong>使用</strong>：使用线程池来管理线程资源，避免频繁创建和销毁线程。可以使用 <code>std::thread</code> 结合 <code>std::future</code> 和 <code>std::promise</code> 实现简单的线程池。</p><p><strong>避免</strong>：直接使用裸线程增加管理难度和资源泄漏风险。</p><h3 id="无锁编程"><strong>无锁编程</strong></h3><p><strong>使用</strong>：在高性能场景下，可以考虑使用无锁数据结构（如无锁队列）。</p><p><strong>避免</strong>：无锁编程复杂且容易出错，仅在必要时使用。</p><h3 id="线程安全的数据结构"><strong>线程安全的数据结构</strong></h3><p>tbb</p><h3 id="C-11的std-call-once">C++11的std::call_once</h3><p><code>std::call_once</code> 是 C++11 引入的一种机制，用于确保某段代码在多线程环境中只被执行一次。这对于初始化操作或需要保证单一执行的场景特别有用。例如，在单例模式实现中，我们可以使用 <code>std::call_once</code> 来保证初始化代码只执行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization code executed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread finished executing.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>std::once_flag flag</code></strong>: 这是用于控制 <code>std::call_once</code> 的标志，确保初始化代码只会执行一次。</p><p><strong><code>initialize</code> 函数</strong>: 这是我们希望只执行一次的初始化代码。在多线程环境中，确保 <code>initialize</code> 只被执行一次是关键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="type">static</span> Singleton&amp; <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(initFlag, initSingleton);</span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值操作符，防止拷贝</span></span><br><span class="line">    Singleton(<span class="type">const</span> Singleton&amp;) = delete;</span><br><span class="line">    Singleton&amp; operator=(<span class="type">const</span> Singleton&amp;) = delete;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化单例实例的函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">initSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="built_in">std</span>::once_flag initFlag;</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line"><span class="built_in">std</span>::once_flag Singleton::initFlag;</span><br><span class="line">Singleton* Singleton::instance = nullptr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadFunc</span><span class="params">()</span> &#123;</span><br><span class="line">    Singleton&amp; singleton = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; got the singleton instance.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(threadFunc)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(threadFunc)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常捕获">异常捕获</h3><p>异常处理：合理处理线程中的异常，避免异常导致线程终止或整个应用崩溃。可以使用 try-catch 块捕获异常，并根据具体情况选择合适的处理方式，例如记录日志、重新抛出异常或进行适当的回滚操作。</p><h3 id="异步回调加锁">异步回调加锁</h3><p>异步回调（Asynchronous Callback）是指在异步操作完成后，系统或库调用的回调函数。由于异步回调通常在不同的线程或事件循环中执行，因此加锁是为了避免多个回调同时访问共享资源而引发竞态条件。</p><p>可以学习陈硕大佬的swap机制，加速以及防止死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stats</span> &#123;</span><br><span class="line">    <span class="type">int</span> request_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> total_response_time = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源的锁</span></span><br><span class="line">std::mutex stats_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_response</span><span class="params">(<span class="type">double</span> response_time, Stats&amp; stats)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保护共享资源</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(stats_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新共享资源</span></span><br><span class="line">    stats.request_count++;</span><br><span class="line">    stats.total_response_time += response_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁后可以继续处理其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Response handled. Count: &quot;</span> &lt;&lt; stats.request_count</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Total Time: &quot;</span> &lt;&lt; stats.total_response_time &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异步网络请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simulate_request</span><span class="params">(Stats&amp; stats)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个网络延迟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设收到响应，调用回调函数</span></span><br><span class="line">    <span class="type">double</span> simulated_response_time = (<span class="built_in">rand</span>() % <span class="number">1000</span>) / <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">on_response</span>(simulated_response_time, stats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stats stats;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程模拟并发请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(simulate_request, std::<span class="built_in">ref</span>(stats)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final Count: &quot;</span> &lt;&lt; stats.request_count</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Final Total Time: &quot;</span> &lt;&lt; stats.total_response_time &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile">volatile</h3><p>在多线程编程中，<code>volatile</code> 关键字的主要用途是告诉编译器该变量可能会被异步修改，从而防止编译器优化该变量的访问。然而，在现代 C++ 编程中，更推荐使用 <code>std::atomic</code> 来处理多线程中的共享数据访问，因为 <code>std::atomic</code> 不仅提供了防止优化的功能，还确保了操作的原子性和线程安全性。</p><p>这个示例演示了如何使用 <code>volatile</code> 变量来标记一个线程的停止标志。请注意，这种做法在多线程编程中并不是最佳实践，仅用于演示 <code>volatile</code> 的使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 volatile 关键字声明停止标志</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> stop_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop_flag) &#123;</span><br><span class="line">        <span class="comment">// 模拟做一些工作</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread stopped.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待一段时间，然后设置停止标志</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    stop_flag = <span class="literal">true</span>; <span class="comment">// 设置标志以停止线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Sleep">Sleep</h3><p><strong>定时任务调度</strong>: 使用 <code>sleep</code> 实现周期性任务调度。</p><p><strong>模拟长时间运行的任务</strong>: 在测试中模拟任务的延迟。</p><p><strong>等待外部事件</strong>: 使用 <code>sleep</code> 轮询条件，避免忙等待。</p><p><strong>限流和节流</strong>: 控制请求或任务的处理频率。</p><p><strong>模拟延迟网络请求</strong>: 测试应用程序对网络延迟的响应能力。</p><h2 id="线程安全的模板库">线程安全的模板库</h2><h3 id="Boost">Boost</h3><p><strong>描述</strong>: Boost.Lockfree 提供了无锁的数据结构，如无锁队列、无锁栈等。它们利用原子操作实现了高效的并发访问。</p><p><strong>使用场景</strong>: 适用于需要高并发且性能敏感的场景，如任务队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/lockfree/queue.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">boost::<span class="function">lockfree::queue&lt;<span class="type">int</span>&gt; <span class="title">queue</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    queue.<span class="built_in">push</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">if</span> (queue.<span class="built_in">pop</span>(value)) &#123;</span><br><span class="line">        <span class="comment">// Process value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TBB-Threading-Building-Blocks"><strong>TBB (Threading Building Blocks)</strong></h3><p><strong>描述</strong>: TBB 是一个用于并行编程的模板库，提供了线程安全的容器（如 <code>tbb::concurrent_queue</code>、<code>tbb::concurrent_vector</code>），以及并行算法和任务调度器。</p><p><strong>使用场景</strong>: 适用于需要并行算法、线程安全容器的复杂多线程应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/concurrent_vector.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">tbb::concurrent_vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>了解</strong></p><p><code>tbb::concurrent_queue</code></p><ul><li><strong>描述</strong>：<code>tbb::concurrent_queue</code> 是一个线程安全的队列，支持多线程的入队和出队操作。</li><li>底层机制<ul><li><strong>锁-free 技术</strong>：<code>tbb::concurrent_queue</code> 通常使用基于锁-free 的技术来实现线程安全，例如使用 CAS（Compare-And-Swap）操作来避免锁的使用。</li><li><strong>分段锁</strong>：为了减少锁的竞争，有时会使用分段锁（Segmented Locking），将队列分成多个段，每个段有自己的锁。</li></ul></li></ul><p><code>tbb::concurrent_vector</code></p><ul><li><strong>描述</strong>：<code>tbb::concurrent_vector</code> 是一个线程安全的动态数组，支持并发插入和访问。</li><li>底层机制<ul><li><strong>分段锁</strong>：<code>tbb::concurrent_vector</code> 使用分段锁来保护其内部的数据结构。每个段有自己的锁，这样可以减少线程竞争，允许多个线程同时操作不同的段。</li><li><strong>无锁设计</strong>：在某些情况下，使用无锁算法（如乐观锁）来进一步减少锁的开销和线程竞争。</li></ul></li></ul><p><code>tbb::concurrent_hash_map</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Segment</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(size, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定位置的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            data[index] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定位置的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 代表无效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentedArray</span>(<span class="type">size_t</span> segment_count, <span class="type">size_t</span> segment_size)</span><br><span class="line">        : <span class="built_in">segments</span>(segment_count, <span class="built_in">Segment</span>(segment_size)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定段和位置的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> segment_index, <span class="type">size_t</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment_index &lt; segments.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            segments[segment_index].<span class="built_in">set</span>(index, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定段和位置的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> segment_index, <span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment_index &lt; segments.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> segments[segment_index].<span class="built_in">get</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 代表无效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Segment&gt; segments;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试分段锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(SegmentedArray&amp; array, <span class="type">size_t</span> segment, <span class="type">size_t</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    array.<span class="built_in">set</span>(segment, index, value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; set segment &quot;</span> &lt;&lt; segment</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> num_segments = <span class="number">4</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> segment_size = <span class="number">10</span>;</span><br><span class="line">    <span class="function">SegmentedArray <span class="title">array</span><span class="params">(num_segments, segment_size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动线程</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_segments; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; segment_size; ++j) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(array), i, j, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q：TBB 的 tbb::concurrent_vector 底层实现采用了结合无锁和分段锁的策略来优化性能。是以什么策略结合的呢</strong></p><ol><li><strong>数据分段</strong></li></ol><ul><li>分段锁：tbb::concurrent_vector 将内部存储的数据分成多个段（segments），每个段使用独立的锁来保护。这种方法减少了线程间的竞争，因为多个线程可以同时操作不同的段，而不需要竞争同一个锁。<ul><li><strong>锁粒度</strong>：通过将数据分成多个段，每个段有自己独立的锁，从而实现更细粒度的锁控制，减少了锁竞争。</li></ul></li></ul><ol start="2"><li><strong>无锁操作</strong></li></ol><ul><li>无锁机制：在某些操作中，如向数组末尾追加元素，tbb::concurrent_vector使用无锁机制来提高性能。例如，可能会使用无锁队列或其他无锁数据结构来管理并发插入操作。<ul><li><strong>原子操作</strong>：在处理简单的并发操作时，使用原子操作（如 CAS，Compare-And-Swap）来管理元素的插入和删除，从而避免传统的锁操作。</li></ul></li></ul><ol start="3"><li><strong>策略结合</strong></li></ol><ul><li>分段锁 + 无锁操作tbb::concurrent_vector 的实际实现结合了分段锁和无锁操作，根据不同操作的性质和并发模式来选择合适的策略。<ul><li><strong>分段锁</strong>：主要用于保护和管理内部数据的不同部分，例如在进行扩展容量或删除元素时使用。</li><li><strong>无锁操作</strong>：用于优化一些简单的并发操作，例如在数组末尾追加元素时使用，以减少锁的开销。</li></ul></li></ul><h3 id="Folly-Facebook-Open-source-Library"><strong>Folly (Facebook Open-source Library)</strong></h3><p><strong>描述</strong>: Folly 提供了高性能的并发数据结构和工具，特别是在高并发的场景下表现出色。例如，<code>folly::ProducerConsumerQueue</code> 是一种高效的单生产者-单消费者队列。</p><p><strong>使用场景</strong>: 适用于高并发的生产者-消费者模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/ProducerConsumerQueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">folly::ProducerConsumerQueue&lt;<span class="type">int</span>&gt; <span class="title">pc_queue</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!pc_queue.<span class="built_in">write</span>(value)) &#123;</span><br><span class="line">        <span class="comment">// wait or try again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">while</span> (!pc_queue.<span class="built_in">read</span>(value)) &#123;</span><br><span class="line">        <span class="comment">// wait or try again</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发编程支持">并发编程支持</h4><p>Folly 提供了一系列高性能的并发工具和数据结构，其中包括 <code>ForkJoinPool</code> 和 <code>MPMCQueue</code>。</p><p><a href="https://blog.csdn.net/mars21/article/details/128579392">folly库安装</a></p><p><a href="https://blog.csdn.net/haokan123456789/article/details/139759621">Folly，一个强大的C++库</a></p><h5 id="ForkJoinPool"><strong>ForkJoinPool</strong></h5><p><strong>概述</strong></p><p><code>ForkJoinPool</code> 是一个并行执行框架，允许将大任务拆分成更小的子任务，然后并行执行这些子任务。最终，子任务的结果会被合并，形成整体的结果。</p><p><strong>特点</strong></p><ul><li><strong>任务分解与并行执行</strong>: 可以递归地将任务分解成子任务，并将这些子任务分配给多个线程并行执行。</li><li><strong>工作窃取机制</strong>: 实现了工作窃取机制，空闲线程可以从忙碌线程的任务队列中窃取任务，从而平衡负载，提高性能。</li><li><strong>灵活的线程池管理</strong>: 可以配置线程池的大小，并灵活地管理线程的生命周期。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/experimental/ThreadedExecutor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/experimental/ForkJoinPool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个递归计算斐波那契数列的任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程池执行器</span></span><br><span class="line">    folly::ThreadedExecutor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 ForkJoinPool，指定线程池大小为4</span></span><br><span class="line">    <span class="function">folly::ForkJoinPool <span class="title">forkJoinPool</span><span class="params">(executor, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ForkJoinPool 来执行任务</span></span><br><span class="line">    <span class="keyword">auto</span> result = forkJoinPool.<span class="built_in">run</span>([](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> task) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务足够小，直接计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (task &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fib</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，分割任务并行执行</span></span><br><span class="line">        <span class="keyword">auto</span> left = self.fork(task - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = self.fork(task - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子任务完成并合并结果</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">join</span>(left) + self.<span class="built_in">join</span>(right);</span><br><span class="line">    &#125;, <span class="number">30</span>);  <span class="comment">// 计算 Fibonacci(30)</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>ForkJoinPool Initialization</strong>:<ul><li><code>folly::ForkJoinPool</code> 被初始化为一个有 4 个线程的池。这意味着最多可以并行执行 4 个任务。</li></ul></li><li><strong>Task Decomposition</strong>:<ul><li>在 <code>forkJoinPool.run</code> 中，我们递归地分解了计算斐波那契数列的任务。如果任务小于或等于 10，直接计算结果；否则，将任务分解为两个子任务，并行执行。</li></ul></li><li><strong>Work Stealing</strong>:<ul><li>在 <code>ForkJoinPool</code> 中，每个线程维护一个任务队列。空闲线程会从其他线程的任务队列中窃取任务，这就是所谓的工作窃取机制。通过这种机制，可以确保所有线程都尽可能保持忙碌，从而提高整体性能。</li></ul></li><li><strong>Fork and Join</strong>:<ul><li><code>self.fork()</code> 用于分解任务并将其放入队列中，而 <code>self.join()</code> 用于等待子任务完成并获取结果。</li></ul></li></ol><p><strong>在这个例子中，我们将 <code>fib(30)</code> 的计算分割为 <code>fib(29)</code> 和 <code>fib(28)</code> 两个子任务。每次分割都递归地创建更多子任务，这些子任务会被分配给线程池中的不同线程执行。</strong></p><p>接下来，简单写份代码说明任务窃取的原理！</p><p><strong>工作窃取机制简介</strong></p><p>在 <code>ForkJoinPool</code> 中，每个工作线程都维护一个双端队列（deque）。当线程有任务要执行时，它会将任务推送到自己的任务队列中，通常是从双端队列的末端入队。线程从队列的末端取任务执行。如果某个线程的任务队列为空，它会尝试从其他线程的任务队列头部窃取任务来执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkStealingQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向队列中添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        deque_.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取任务</span></span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (deque_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> task = deque_.<span class="built_in">back</span>();</span><br><span class="line">        deque_.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列头部窃取任务</span></span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">steal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (deque_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> task = deque_.<span class="built_in">front</span>();</span><br><span class="line">        deque_.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程执行的工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(WorkStealingQueue&amp; myQueue, std::vector&lt;WorkStealingQueue&gt;&amp; allQueues, <span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 尝试从自己的队列中获取任务</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> task = myQueue.<span class="built_in">pop</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; is processing task &quot;</span> &lt;&lt; *task &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 窃取其他线程的任务</span></span><br><span class="line">            <span class="type">bool</span> stolen = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; allQueues.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (&amp;allQueues[i] != &amp;myQueue) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> stolenTask = allQueues[i].<span class="built_in">steal</span>()) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; stole task &quot;</span> &lt;&lt; *stolenTask &lt;&lt; <span class="string">&quot; from thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                        stolen = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stolen) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; has no tasks left and can&#x27;t steal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">4</span>;</span><br><span class="line">    <span class="function">std::vector&lt;WorkStealingQueue&gt; <span class="title">queues</span><span class="params">(numThreads)</span></span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        queues[i % numThreads].<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(queues[i]), std::<span class="built_in">ref</span>(queues), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建一个新线程并传递参数时，参数通常是按值复制的。<strong>如果你想传递一个对象的引用给线程，可以使用 <code>std::ref</code>。</strong></p><h5 id="Folly-MPMCQueue-Multi-Producer-Multi-Consumer-Queue"><strong>Folly MPMCQueue (Multi-Producer Multi-Consumer Queue)</strong></h5><p><strong>概述</strong></p><p><code>MPMCQueue</code> 是一个高性能的多生产者多消费者队列，设计用于在多线程环境下进行高效的数据传递。它允许多个线程同时向队列中添加和取出元素，而不会引起数据竞争或锁的争用。</p><p><strong>特点</strong></p><ul><li><strong>无锁设计</strong>: 使用无锁算法实现，高效且线程安全。</li><li><strong>高并发支持</strong>: 支持多生产者和多消费者同时进行操作，适用于需要高吞吐量的场景。</li><li><strong>固定容量</strong>: 队列的容量是固定的，可以在初始化时指定。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/MPMCQueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">folly::MPMCQueue&lt;<span class="type">int</span>&gt; <span class="title">queue</span><span class="params">(<span class="number">1024</span>)</span></span>;  <span class="comment">// 创建一个容量为1024的MPMC队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        queue.<span class="built_in">write</span>(i);  <span class="comment">// 向队列中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="built_in">read</span>(value)) &#123;  <span class="comment">// 从队列中取出元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">prod1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">prod2</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">cons1</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">cons2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    prod1.<span class="built_in">join</span>();</span><br><span class="line">    prod2.<span class="built_in">join</span>();</span><br><span class="line">    cons1.<span class="built_in">join</span>();</span><br><span class="line">    cons2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Moodycamel">Moodycamel</h3><p>MoodyCamel的无锁队列（MoodyCamel’s Lock-Free Queue），也叫做ConcurrentQueue，是一个用于高性能多线程环境的多生产者多消费者（MPMC，Multi-Producer Multi-Consumer）无锁队列。这个队列旨在提供高效且线程安全的并发访问，而不需要传统的锁机制，从而避免了锁竞争带来的性能瓶颈。</p><p><strong>主要特点</strong></p><ol><li><strong>无锁设计</strong>: 使用无锁算法来实现高效的队列操作，避免了锁竞争，提高了并发性能。</li><li><strong>多生产者多消费者</strong>: 支持多个生产者线程同时向队列中插入元素，以及多个消费者线程同时从队列中取出元素。</li><li><strong>高性能</strong>: 队列采用了缓存行对齐、无伪共享（false sharing）等技术优化，最大程度减少了CPU缓存冲突和内存访问延迟。</li><li><strong>支持单生产者单消费者优化</strong>: 虽然是多生产者多消费者队列，但在只有一个生产者或一个消费者的情况下，队列会自动优化以进一步提高性能。</li><li><strong>有界与无界版本</strong>: 提供了有界队列（bounded queue）和无界队列（unbounded queue）的实现。前者在容量满时会阻塞插入操作，而后者会自动扩展容量。</li></ol><p><strong>工作原理</strong></p><ol><li><p>原子操作 (Atomic Operations)<br>MoodyCamel 的无锁队列依赖于原子操作，如比较并交换（Compare-And-Swap, CAS），来保证多个线程之间的同步。CAS 是一种硬件级别的原子操作，能够在多个线程试图同时更新某个变量时，确保只有一个线程成功修改了该变量，从而避免竞态条件（Race Condition）。</p></li><li><p>分段缓存（Chunk-Based Buffering）<br>队列内部使用了一种分段的缓存机制，将队列划分为多个独立的“块”（chunks）。每个块是一个固定大小的环形缓冲区。生产者线程和消费者线程各自操作不同的块，从而减少了线程之间的直接竞争。块的大小通常是固定的，并根据队列的负载动态分配。</p></li><li><p>无伪共享 (False Sharing)<br>为了避免伪共享，队列通过缓存行对齐（Cache Line Alignment）技术，确保每个线程操作的数据位于不同的缓存行上。伪共享是指多个线程访问同一缓存行中的不同变量时，导致缓存一致性协议频繁触发，从而降低性能。通过缓存行对齐，MoodyCamel 队列最大限度地减少了这种冲突。</p></li><li><p>环形缓冲区 (Ring Buffer)<br>每个块内部使用环形缓冲区来管理元素的位置。环形缓冲区允许生产者和消费者以固定大小的数组形式存储元素，并且通过原子索引递增操作，确保多个线程可以安全地访问和更新队列。</p></li><li><p>无锁入队和出队操作 (Lock-Free Enqueue/Dequeue)<br>入队操作 (Enqueue): 生产者线程首先通过原子操作获取一个块中的空闲位置，然后在该位置插入新元素。使用 CAS 操作，确保在高并发情况下多个生产者不会同时插入到同一个位置。</p></li></ol><p>出队操作 (Dequeue): 消费者线程通过原子操作获取一个块中已有元素的位置，然后从该位置取出元素。类似地，使用 CAS 操作确保多个消费者不会同时访问同一个位置。</p><ol start="6"><li><p>进退策略 (Backoff Strategy)<br>为了提高性能，当一个线程发现它无法立即完成某个操作时（如因为另一个线程正在执行相关操作），它可能会采取一种“退避策略”。这意味着线程会短暂地放弃 CPU，以减少对其他线程的干扰，然后稍后重试。这种策略避免了忙等待的资源浪费。</p></li><li><p>内存模型 (Memory Model)<br>MoodyCamel 队列的实现高度依赖于 C++ 内存模型中的内存序（Memory Order）语义，特别是 memory_order_acquire 和 memory_order_release，这些语义用于保证操作的可见性和顺序性。它们帮助在无锁队列中实现线程安全，确保在一个线程发布的数据对另一个线程可见。</p></li></ol><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;concurrentqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">moodycamel::ConcurrentQueue&lt;<span class="type">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.enqueue(i + id * <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; enqueued &quot;</span> &lt;&lt; i + id * <span class="number">100</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">queue</span>.try_dequeue(item)) &#123;</span><br><span class="line">            <span class="comment">// busy-wait until an item is available</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; dequeued &quot;</span> &lt;&lt; item &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; producers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; consumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create producer threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        producers.emplace_back(producer, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create consumer threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        consumers.emplace_back(consumer, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Join threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : producers) &#123;</span><br><span class="line">        p.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : consumers) &#123;</span><br><span class="line">        c.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无锁并发测试效率：moodycamel &gt; tbb &gt; boost</p>]]></content>
    
    
    <summary type="html">多线程实战总结</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>改善网络程序的44个技巧</title>
    <link href="https://penge666.github.io/posts/bfaa091a.html"/>
    <id>https://penge666.github.io/posts/bfaa091a.html</id>
    <published>2024-08-12T01:46:36.000Z</published>
    <updated>2024-08-25T12:13:51.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技巧1-理解面向链接和无连接协议之间的区别">技巧1:理解面向链接和无连接协议之间的区别</h2><ul><li>对于无连接协议来说，每个分组的处理都独立于所有其他分组，而对于面向连接的协议来说，协议实现维护了与后继分组有关的状态信息。</li><li>对TCP来说，连接完全是想象的，它是由端点所记忆的状态组成的， 并不存在“物理”连接。</li></ul><p><strong>面向链接</strong></p><p><strong>定义</strong>: 面向连接的协议在数据传输之前，需要建立一个稳定的连接，并在数据传输完成后拆除这个连接。它确保数据在传输过程中不会丢失、重复、乱序或损坏。</p><p><strong>示例</strong>:</p><ul><li><p>TCP（传输控制协议）</p><p>: 用于互联网中的许多应用，如网页浏览、电子邮件、文件传输等。</p><ul><li><strong>连接建立</strong>: 通过三次握手（SYN, SYN-ACK, ACK）建立连接。</li><li><strong>可靠性</strong>: 确保数据包的可靠传输和顺序。</li></ul></li></ul><p><strong>无连接协议</strong></p><p><strong>定义</strong>: 无连接的协议在数据传输过程中不需要建立连接，每个数据包（或称为数据报）都是独立的。它不保证数据的到达、顺序或完整性，接收方可能需要处理数据丢失或乱序的问题。</p><p><strong>示例</strong>:</p><ul><li><p>UDP（用户数据报协议）</p><p>: 用于需要低延迟和高吞吐量的应用，如视频流、在线游戏、DNS 查询等。</p><ul><li><strong>无连接</strong>: 发送数据包时不需要建立连接。</li><li><strong>不可靠</strong>: 数据包可能会丢失、重复或乱序。</li></ul></li></ul><p><strong>以下是一个简单的 UDP 客户端和服务器示例，展示了如何使用 UDP 进行数据传输。</strong></p><p><strong>UDP 服务器（C++）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 UDP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    servaddr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> n = recvfrom(sockfd, (<span class="type">char</span>*)buffer, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, (<span class="type">socklen_t</span>*)&amp;len);</span><br><span class="line">    buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Client: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">    sendto(sockfd, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP 客户端（C++）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 UDP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(PORT);</span><br><span class="line">    servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line">    sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(servaddr);</span><br><span class="line">    <span class="type">int</span> n = recvfrom(sockfd, (<span class="type">char</span>*)buffer, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, (<span class="type">socklen_t</span>*)&amp;len);</span><br><span class="line">    buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Server: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧2-理解子网和CIDR的概念">技巧2:理解子网和CIDR的概念</h2><p><strong>A、B、C、D、E类网络，网络ID和主机ID</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240822100022842.png" alt="image-20240822100022842"></p><p>D类地址用于多播编址，E类地址留作未来使用。剩下的A、B和C类地址是用于标识单个网络和主机的主要地址类型。</p><p>地址类别是由前导1比特的个数标识的。A类有零个前导1比特，B类有一个,C类有两个，以此类推。标识地址的类型是非常重要的，因为对其余比特的解释都取决于地址的类型。</p><p><strong>子网划分</strong></p><ul><li><p>概念：<strong>子网划分</strong>是通过修改 IP 地址和子网掩码来创建多个逻辑上的子网络。每个子网都是原始网络的一部分，但它们在逻辑上是分开的。子网划分的核心是调整 IP 地址中的网络部分和主机部分，以便将一个大的网络拆分成多个小的网络。</p></li><li><p>例子：</p><p>192.168.1.0/26 (地址范围：192.168.1.0 到 192.168.1.63)<br>192.168.1.64/26 (地址范围：192.168.1.64 到 192.168.1.127)<br>192.168.1.128/26 (地址范围：192.168.1.128 到 192.168.1.191)<br>192.168.1.192/26 (地址范围：192.168.1.192 到 192.168.1.255)</p></li><li><p>好处：</p><ul><li><p><strong>提高网络性能</strong>:</p><ul><li>将大型网络划分为多个子网可以减少广播风暴的范围。广播仅在子网内部传播，从而降低了网络的负荷和拥塞。</li></ul></li><li><p><strong>增强网络安全</strong>:</p><ul><li>子网划分可以隔离网络中的不同部门或功能，使得安全策略可以在每个子网中独立应用。这可以限制潜在的安全威胁和数据泄露。</li></ul><p><strong>优化地址空间使用</strong>:</p><ul><li>子网划分可以有效地利用 IP 地址空间，避免了地址浪费。例如，将一个大型网络划分为多个小网络可以更精确地分配 IP 地址。</li></ul></li></ul></li></ul><p><strong>CIDR——Classless Inter Domain Routing，无类别域间路由</strong></p><p>CIDR（Classless Inter-Domain Routing，无类别域间路由）是一种用于 IP 地址分配和路由选择的方法，旨在解决传统分类地址（Classful Addressing）中的一些限制。CIDR 通过引入更灵活的子网掩码和更有效的路由聚合方法来提高 IP 地址的利用率和路由效率。</p><p><strong>CIDR 的主要特点</strong></p><ol><li><strong>无类别地址分配</strong>:<ul><li><strong>传统分类地址</strong>: IP 地址分为 A、B、C 类等，每类有固定的子网掩码（如 A 类是 8 位，B 类是 16 位，C 类是 24 位）。</li><li><strong>CIDR</strong>: <strong>IP 地址和子网掩码的长度不再受到固定分类的限制</strong>。CIDR 允许使用任意长度的子网掩码，使得地址分配更灵活和高效。</li></ul></li><li><strong>前缀长度表示法</strong>:<ul><li>CIDR 使用前缀长度来表示子网掩码的大小，例如 <code>192.168.0.0/24</code>。</li><li><code>192.168.0.0/24</code> 表示前 24 位是网络部分，剩余的 8 位是主机部分。<strong>这种表示方法比传统的 IP 地址和子网掩码形式更加直观。</strong></li></ul></li><li><strong>路由聚合（Prefix Aggregation）</strong>:<ul><li>CIDR 支持路由聚合，<strong>即将多个连续的 IP 地址块聚合为一个更大的路由前缀</strong>，从而减少路由表的大小和复杂性。</li><li>例如，将 <code>192.168.0.0/24</code> 和 <code>192.168.1.0/24</code> 聚合为 <code>192.168.0.0/23</code>。</li></ul></li><li><strong>改进了路由表的可扩展性</strong>:<ul><li>由于路由聚合的能力，CIDR 减少了需要在网络路由器中存储的路由条目数量，从而减轻了路由器的负担，提高了网络的可扩展性。</li></ul></li></ol><p><strong>CIDR 的示例</strong></p><p><strong>1. IP 地址和前缀长度</strong></p><ul><li><strong>地址</strong>: <code>192.168.1.0</code></li><li>前缀长度/24<ul><li><strong>子网掩码</strong>: <code>255.255.255.0</code></li></ul></li></ul><p>这表示 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 的所有地址属于同一网络。</p><p><strong>2. 路由聚合</strong></p><ul><li>原始网络<ul><li><code>192.168.0.0/24</code></li><li><code>192.168.1.0/24</code></li><li><code>192.168.2.0/24</code></li></ul></li><li>聚合后的网络<ul><li><code>192.168.0.0/22</code></li></ul></li></ul><p><code>192.168.0.0/22</code> 覆盖了从 <code>192.168.0.0</code> 到 <code>192.168.3.255</code> 的地址范围，可以将多个小的网络聚合为一个更大的网络，从而减少路由条目。</p><h2 id="技巧3-理解私有地址和NAT">技巧3:理解私有地址和NAT</h2><p><strong>NAT（Network Address Translation）</strong> 和 <strong>PAT（Port Address Translation）</strong> 是两种在网络中常见的地址转换技术，用于处理 IP 地址的分配和管理。</p><ul><li>NAT——Network Address Translation，网络地址翻译</li><li>PAT——Port Address Translation，端口地址转换</li></ul><h3 id="NAT（网络地址翻译）">NAT（网络地址翻译）</h3><p><strong>NAT</strong> 是一种技术，用于将私有网络中的 IP 地址转换为公共网络中的 IP 地址，允许多个设备共享一个公共 IP 地址。这主要用于解决 IP 地址短缺问题以及提供网络安全性。</p><p><strong>NAT 的工作原理</strong>:</p><ol><li><strong>内部网络（私有网络）</strong>:<ul><li>在本地网络中，设备使用私有 IP 地址（例如 <code>192.168.1.0/24</code>）。</li><li>这些私有地址在互联网上是不可路由的。</li></ul></li><li><strong>NAT 设备（通常是路由器或防火墙）</strong>:<ul><li>NAT 设备将内部网络中的私有 IP 地址转换为公共 IP 地址。</li><li>内部设备发出的数据包在离开本地网络时，源 IP 地址被替换为 NAT 设备的公共 IP 地址。</li></ul></li><li><strong>外部网络（公共网络）</strong>:<ul><li>返回的数据包通过 NAT 设备，将公共 IP 地址和端口号转换回原始的私有 IP 地址和端口号。</li></ul></li></ol><p><strong>NAT 示例</strong>:</p><ul><li><strong>私有 IP 地址</strong>: <code>192.168.1.10</code></li><li><strong>公共 IP 地址</strong>: <code>203.0.113.1</code></li><li>转换过程<ul><li>内部设备 <code>192.168.1.10</code> 发出请求到互联网。</li><li>NAT 设备将源 IP 地址 <code>192.168.1.10</code> 替换为公共 IP 地址 <code>203.0.113.1</code>。</li><li>外部服务器看到的请求来源是 <code>203.0.113.1</code>。</li><li>响应返回时，NAT 设备将目标 IP 地址 <code>203.0.113.1</code> 转换回 <code>192.168.1.10</code>，并将数据包送回内部设备。</li></ul></li></ul><h3 id="PAT（端口地址转换）">PAT（端口地址转换）</h3><p><strong>PAT</strong>，也称为 <strong>NAT Overloading</strong>，是 NAT 的一种扩展，允许多个内部设备通过同一个公共 IP 地址访问互联网。它通过使用不同的端口号来区分不同的会话。</p><p><strong>PAT 的工作原理</strong>:</p><ol><li><strong>内部网络（私有网络）</strong>:<ul><li>多个设备使用私有 IP 地址。</li></ul></li><li><strong>PAT 设备（通常是路由器或防火墙）</strong>:<ul><li>PAT 设备将内部设备的 IP 地址和端口号映射到一个公共 IP 地址的不同端口号上。</li><li>例如，两个内部设备的流量都可以通过公共 IP 地址的不同端口号进行区分。</li></ul></li><li><strong>外部网络（公共网络）</strong>:<ul><li>外部服务器看到的是公共 IP 地址和端口号。</li><li>响应数据包通过 PAT 设备，将公共 IP 地址和端口号映射回内部设备的 IP 地址和端口号。</li></ul></li></ol><p><strong>PAT 示例</strong>:</p><ul><li>私有 IP 地址和端口号<ul><li><code>192.168.1.10:12345</code></li><li><code>192.168.1.11:54321</code></li></ul></li><li><strong>公共 IP 地址</strong>: <code>203.0.113.1</code></li><li>PAT 映射<ul><li><code>192.168.1.10:12345</code> → <code>203.0.113.1:10001</code></li><li><code>192.168.1.11:54321</code> → <code>203.0.113.1:10002</code></li></ul></li><li>转换过程<ul><li>内部设备 <code>192.168.1.10</code> 通过端口 <code>12345</code> 发出请求。</li><li>PAT 设备将请求的源地址 <code>192.168.1.10:12345</code> 转换为 <code>203.0.113.1:10001</code>。</li><li>内部设备 <code>192.168.1.11</code> 通过端口 <code>54321</code> 发出请求。</li><li>PAT 设备将请求的源地址 <code>192.168.1.11:54321</code> 转换为 <code>203.0.113.1:10002</code>。</li><li>外部服务器响应时，返回的目标地址 <code>203.0.113.1:10001</code> 和 <code>203.0.113.1:10002</code> 被 PAT 设备映射回内部设备的 IP 地址和端口号。</li></ul></li></ul><p><strong>总结</strong></p><ul><li><strong>NAT</strong> 用于将私有 IP 地址转换为公共 IP 地址，以便多个设备可以共享一个公共 IP 地址进行互联网访问。</li><li><strong>PAT</strong> 是 NAT 的一种形式，通过不同的端口号来区分不同的内部会话，允许多个内部设备共享同一个公共 IP 地址。</li></ul><p><strong>补充</strong>：</p><p><strong>私有 IP 地址范围</strong>：</p><ol><li><strong><code>10.0.0.0/8</code></strong>:<ul><li>范围：<code>10.0.0.0</code> 到 <code>10.255.255.255</code></li><li>这个范围支持 1677 万个地址。</li></ul></li><li><strong><code>172.16.0.0/12</code></strong>:<ul><li>范围：<code>172.16.0.0</code> 到 <code>172.31.255.255</code></li><li>这个范围支持 1048 万个地址。</li></ul></li><li><strong><code>192.168.0.0/16</code></strong>:<ul><li>范围：<code>192.168.0.0</code> 到 <code>192.168.255.255</code></li><li>这个范围支持 65,536 个地址。</li></ul></li></ol><h2 id="技巧4-开发并使用应用程序“框架”">技巧4:开发并使用应用程序“框架”</h2><ul><li>TCP服务端：socket-&gt;bind-&gt;listen-&gt;accept</li><li>TCP客户端：socket-&gt;connect</li><li>UDP服务端：socket-&gt;bind</li><li>UDP客户端：socket</li></ul><h2 id="技巧5-套接字接口比XTI-TLI更好用">技巧5:套接字接口比XTI/TLI更好用</h2><p>略</p><h2 id="技巧6-记住，TCP是一种流协议">技巧6:记住，TCP是一种流协议</h2><ul><li>TCP是一种流协议,数据以字节流的形式传递给接收者的，没有固有的“报文”或“报文边界”的概念</li></ul><h2 id="技巧7-不要低估TCP的性能">技巧7:不要低估TCP的性能</h2><p>可以查看原书中的性能对比</p><h2 id="技巧8-避免重新编写TCP">技巧8:避免重新编写TCP</h2><p>假设你正在开发一个需要可靠数据传输的网络应用程序：</p><ul><li><strong>正确做法</strong>: 使用操作系统提供的 TCP 协议栈，通过 <code>socket</code> 创建 TCP 连接，使用 <code>send</code> 和 <code>recv</code> 函数进行数据传输。这样，你可以利用 TCP 的流量控制、拥塞控制等特性，确保数据的可靠传输。</li><li><strong>错误做法</strong>: 重新实现 TCP 协议的所有功能，例如手动实现数据重传、顺序保证、流量控制等，这将是一个非常复杂且容易出错的任务。</li></ul><h2 id="技巧9-要认识到TCP是一个可靠的，但并不绝对可靠的协议">技巧9:要认识到TCP是一个可靠的，但并不绝对可靠的协议</h2><p><strong>（1) 永久或临时的网络中断</strong></p><p><strong>背景</strong>:</p><ul><li><strong>场景</strong>: 一个分布式应用程序在不同地理位置的数据中心之间传输数据。连接依赖于互联网或广域网，这些网络可能会遭遇临时或永久的中断。</li></ul><p><strong>解释</strong>:</p><ul><li><strong>临时网络中断</strong>: 网络中断可能是暂时的，例如由于网络设备重启或维护。TCP 会尝试重新连接和重传数据，但可能会引入延迟。</li><li><strong>永久网络中断</strong>: 如果网络中断是永久性的，例如由于物理链路断裂或网络设备故障，TCP 连接将无法恢复，应用程序需要检测连接中断并采取适当措施，如尝试重新建立连接或通知用户。</li></ul><p><strong>示例</strong>:</p><ul><li>在一个跨国企业的文件同步应用中，如果两地之间的网络链路出现故障，TCP 可能会重试连接，但长时间的中断可能导致数据同步失败。</li></ul><p><strong>(2) 对等的应用程序崩溃</strong></p><p><strong>背景</strong>:</p><ul><li><strong>场景</strong>: 一个客户端-服务器应用程序，其中客户端和服务器通过 TCP 连接进行通信。服务器应用程序崩溃或退出时，连接将被中断。</li></ul><p><strong>解释</strong>:</p><ul><li><strong>应用程序崩溃</strong>: 如果服务器端应用程序崩溃或异常退出，TCP 连接将被断开。虽然 TCP 会尝试重连，但在应用程序崩溃的情况下，重新建立连接可能无法进行，且数据丢失或未处理的数据需要应用层进行补救。</li></ul><p><strong>示例</strong>:</p><ul><li>在一个实时聊天应用中，如果服务器端的聊天服务崩溃，客户端会失去连接。TCP 会检测到连接丢失，但客户端需要能够处理连接丢失，重新连接或通知用户。</li></ul><p><strong>(3) 运行对等应用程序的主机崩溃</strong></p><p><strong>背景</strong>:</p><ul><li><strong>场景</strong>: 一个分布式系统，其中某些应用程序运行在主机上。这些主机可能会因为硬件故障或操作系统崩溃而宕机。</li></ul><p><strong>解释</strong>:</p><ul><li><strong>主机崩溃</strong>: 如果运行 TCP 应用程序的主机崩溃或关闭，TCP 连接会被断开。虽然 TCP 连接的另一端可能会检测到连接中断并尝试重连，但主机崩溃的情况通常需要应用层处理，以便在主机恢复后能够继续操作或重启服务。</li></ul><p><strong>示例</strong>:</p><ul><li>在一个分布式数据库系统中，如果存储节点的主机崩溃，数据传输会中断。数据库系统需要实现机制来检测节点故障、重新分配任务，并在节点恢复时重新同步数据。</li></ul><h2 id="技巧10-记住，TCP-IP不是轮询的">技巧10:记住，TCP/IP不是轮询的</h2><ul><li>TCP没有提供将连接丢失即时通知给应用程序的方法。<ul><li>TCP 协议本身并不会主动或立即通知应用程序某个连接已经断开或失效。TCP 提供了可靠的数据传输保证，但它不会即时地将连接状态的变化（如连接丢失）反馈给应用程序。</li></ul></li><li>保持活跃(keep-alive)</li><li>心跳信号(epoll, pthread)</li></ul><h2 id="技巧11-提防对等实体的不友好动作">技巧11:提防对等实体的不友好动作</h2><h2 id="技巧12-成功的LAN策略不一定能推广到WAN中">技巧12:成功的LAN策略不一定能推广到WAN中</h2><p><strong>核心思想</strong></p><ol><li><strong>网络特性差异</strong>:<ul><li><strong>局域网（LAN）</strong>: 通常具有较低的延迟和较高的带宽，网络环境相对稳定，数据传输速度较快。</li><li><strong>广域网（WAN）</strong>: 包括多个网络环境，通常存在较高的延迟和较低的带宽，网络波动和丢包率可能较高。</li></ul></li><li><strong>策略和优化</strong>:<ul><li><strong>LAN 策略</strong>: 在 LAN 环境中，应用程序和网络策略可能会基于高速连接和低延迟的假设进行设计和优化。</li><li><strong>WAN 环境</strong>: 这些策略在 WAN 环境中可能不再适用，因为 WAN 的网络条件较差，可能需要不同的策略和优化手段。</li></ul></li></ol><ul><li><strong>Example 1</strong>: <strong>实时视频会议</strong>:<ul><li><strong>LAN</strong>: 在企业内部的局域网中，视频会议可以实现高质量的视频和音频流，因为网络延迟低且带宽充足。</li><li><strong>WAN</strong>: 当视频会议扩展到广域网时，需要考虑网络延迟和带宽限制，可能会导致视频质量下降或出现卡顿现象。需要使用更高效的视频压缩技术和自适应码率调整策略。</li></ul></li><li><strong>Example 2</strong>: <strong>文件同步应用</strong>:<ul><li><strong>LAN</strong>: 内部文件同步可以实现快速的实时同步。</li><li><strong>WAN</strong>: 在跨区域同步文件时，需要处理更大的延迟和带宽波动，采用增量同步和数据压缩等策略来提高性能。</li></ul></li></ul><h2 id="技巧13-了解协议是怎样工作的">技巧13:了解协议是怎样工作的</h2><ul><li>RFC是TCP/IP的官方规范</li></ul><h2 id="技巧14-不要把OSI七层参考模型太当回事">技巧14:不要把OSI七层参考模型太当回事</h2><ul><li>OSI和TCP/IP</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240822103343607.png" alt="image-20240822103343607"></p><h2 id="技巧15-理解TCP的写操作">技巧15:理解TCP的写操作</h2><ul><li>从应用程序的角度来看，最好把写操作当作是一项将数据从用户空间拷贝到内核发送缓冲区，然后就返回的操作。</li><li>如果发送端应用程序崩溃了，TCP会继续尝试着将数据传递给对等实体。</li></ul><h2 id="技巧16-理解TCP的有序释放操作">技巧16:理解TCP的有序释放操作</h2><ul><li><p>有序释放是在确保没有数据丢失的情况下拆除n连接的一个过程。</p></li><li><p>shutdown与close的区别</p><ul><li><strong><code>shutdown</code></strong>:<ul><li>用于部分关闭 socket（如停止发送或接收数据），允许对端继续操作，但不能再使用指定的方向进行通信。</li><li>并没有释放套接字及其资源</li><li>调用shutdown时，会影响到所有打开了那个套接字的进程。</li><li>FIN发送：用how =1来调用shutdown 时，不管其他进程是否打开了这个套接字，都可以保证对等实体会收到一个EOF。</li></ul></li><li><strong><code>close</code></strong><ul><li>用于完全关闭 socket，释放所有资源，断开连接，对端会收到连接关闭的通知。</li><li>释放套接字及其资源</li><li>调用close或closesocket，套接字的其他持有者仍然能够像什么事情都没有发生一样使用它。</li><li>调用close或closesocket就无法确保这一点，因为在套接字的引用计数减少到零之前，它都不会将FIN发送给对等实体。也就是说，所有进程关闭套接字后，它才将FIN发送给对等实体。</li></ul></li></ul><p><strong>总结：<code>shutdown</code> 是通过操作系统内核直接影响套接字的状态的。<code>close</code> 只是释放了当前进程的套接字描述符，并不会立即影响其他进程或线程的套接字描述符。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240822105203975.png" alt="image-20240822105203975"></p><p>Q：<strong>可以用 <code>shutdown</code> 释放资源吗？</strong></p><p>A：不可以，<code>shutdown</code> 专注于数据流控制，而不是资源管理。必须使用 <code>close</code> 函数释放资源。</p></li></ul><h2 id="技巧17-考虑用inetd来装载应用程序">技巧17:考虑用inetd来装载应用程序</h2><p><strong><code>inetd</code> 介绍</strong>:</p><ul><li><strong><code>inetd</code></strong>（Internet Daemon）是一个服务守护进程，负责监听指定的网络端口，并根据配置文件中的规则启动相应的服务程序处理请求。</li><li>通过配置文件 (<code>/etc/inetd.conf</code>)，<code>inetd</code> 可以决定哪些服务应该由哪些程序处理，并在接收到连接请求时启动相应的程序。</li></ul><p><strong>使用 <code>inetd</code> 的优点</strong>:</p><ol><li><strong>资源节省</strong>: <code>inetd</code> 只有在收到连接请求时才启动相应的服务程序，而不是让服务程序常驻内存。这样可以节省系统资源。</li><li><strong>简化管理</strong>: 通过集中管理配置文件，减少了对多个守护进程的管理负担。只需编辑 <code>inetd.conf</code> 配置文件即可添加或修改服务。</li><li><strong>灵活配置</strong>: 可以灵活配置哪些服务由 <code>inetd</code> 处理，并轻松调整服务程序的路径或参数。</li></ol><p><strong>举例说明</strong></p><p>假设你希望在系统上提供 FTP 和 Telnet 服务，但不希望这些服务程序一直运行，从而节省系统资源。可以使用 <code>inetd</code> 来管理这些服务。</p><ol><li><p><strong>安装和配置 <code>inetd</code></strong>:</p><ul><li><p>确保系统上安装了 <code>inetd</code>。在许多现代 Linux 系统上，<code>inetd</code> 被 <code>xinetd</code> 替代，你可以使用 <code>xinetd</code> 进行类似的配置。</p></li><li><p>编辑 <code>/etc/inetd.conf</code> 文件，添加以下配置来定义 FTP 和 Telnet 服务：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp     stream  tcp     nowait  root  /usr/sbin/<span class="keyword">in</span><span class="selector-class">.ftpd</span>   <span class="keyword">in</span><span class="selector-class">.ftpd</span></span><br><span class="line">telnet  stream  tcp     nowait  root  /usr/sbin/<span class="keyword">in</span><span class="selector-class">.telnetd</span> <span class="keyword">in</span>.telnetd</span><br></pre></td></tr></table></figure><ul><li><code>ftp</code>: 服务名。</li><li><code>stream</code>: 套接字类型（流式）。</li><li><code>tcp</code>: 使用的协议。</li><li><code>nowait</code>: 表示服务程序不会并发处理多个连接。</li><li><code>root</code>: 服务程序的用户身份。</li><li><code>/usr/sbin/in.ftpd</code>: 服务程序的路径。</li><li><code>in.ftpd</code>: 服务程序的名称。</li></ul></li></ul></li><li><p><strong>启动 <code>inetd</code></strong>:</p><ul><li>启动 <code>inetd</code> 守护进程（如果未运行）。通常，<code>inetd</code> 会在系统启动时自动启动。</li></ul></li><li><p><strong>测试配置</strong>:</p><ul><li>连接到指定的端口（如 FTP 的 21 端口或 Telnet 的 23 端口），<code>inetd</code> 会启动相应的服务程序来处理请求。</li></ul></li></ol><p><strong>示例操作</strong></p><p>假设我们在 <code>/etc/inetd.conf</code> 中配置了 Telnet 服务。连接到 Telnet 的 23 端口时，<code>inetd</code> 会启动 <code>in.telnetd</code> 程序来处理连接。</p><p><strong>启动 <code>inetd</code></strong>:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service inetd <span class="literal">start</span></span><br></pre></td></tr></table></figure><p><strong>连接 Telnet</strong>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">telnet localhost</span></span><br></pre></td></tr></table></figure><p>在连接到 Telnet 端口时，<code>inetd</code> 会自动启动 <code>in.telnetd</code> 程序，并处理该连</p><h2 id="技巧18-考虑用tcpmux为服务器“分配”知名端口">技巧18:考虑用tcpmux为服务器“分配”知名端口</h2><p><strong><code>tcpmux</code></strong> 用于在一个知名端口上复用多个服务。它允许多个不同的网络服务共享一个端口，通过接收服务请求并根据请求内容将连接转发到对应的服务程序，从而简化端口管理和配置。</p><p><strong><code>tcpmux</code> 介绍</strong></p><ul><li><strong><code>tcpmux</code></strong>（TCP Port Multiplexer）是一种协议，用于在单个端口上复用多个服务。它通过 TCP 端口复用允许多个服务共享一个知名端口（通常是 1-1023 端口范围内的端口）。</li><li><code>tcpmux</code> 协议使用一个预定义的端口（通常是端口 1）来接收请求，并根据请求内容决定将连接转发到哪个实际服务程序。</li></ul><p><strong><code>tcpmux</code> 的优点</strong></p><ol><li><strong>简化端口管理</strong>: 可以通过一个端口管理多个服务，减少对知名端口的占用。</li><li><strong>减少冲突</strong>: 减少服务程序之间的端口冲突，尤其是当系统上有多个服务需要运行时。</li><li><strong>提高安全性</strong>: 通过集中管理端口，可以简化防火墙配置，并对外提供统一的入口。</li></ol><p><strong>举例说明</strong></p><p>假设你有多个服务需要运行，如 FTP、Telnet 和 HTTP。你希望将它们集中在一个知名端口上，以简化管理和配置。可以使用 <code>tcpmux</code> 来实现这一点。</p><p><strong>1. 配置 <code>tcpmux</code></strong></p><p><strong>步骤 1: 安装和配置 <code>tcpmux</code></strong></p><ul><li>在现代系统上，<code>tcpmux</code> 可能不再广泛使用，或者其实现方式可能有所不同。如果使用 <code>tcpmux</code> 的传统实现，你可以在 <code>/etc/tcpmuxd.conf</code> 或类似的配置文件中设置服务。</li></ul><p><strong>步骤 2: 编辑配置文件</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 tcpmuxd.conf 文件中配置服务</span></span><br><span class="line">ftp     stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.ftpd   <span class="keyword">in</span>.ftpd</span><br><span class="line">telnet  stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.telnetd <span class="keyword">in</span>.telnetd</span><br><span class="line">http    stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.httpd   <span class="keyword">in</span>.httpd</span><br></pre></td></tr></table></figure><ul><li>上述配置将 FTP、Telnet 和 HTTP 服务与 <code>tcpmux</code> 绑定，并使用 <code>tcpmux</code> 端口（通常是端口 1）来复用这些服务。</li></ul><p><strong>步骤 3: 启动 <code>tcpmux</code></strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tcpmuxd <span class="literal">start</span></span><br></pre></td></tr></table></figure><p><strong>步骤 4: 测试 <code>tcpmux</code></strong></p><ul><li>连接到端口 1，并发送服务请求。例如，使用 telnet 连接到端口 1，发送相应的服务名称来选择所需的服务：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">telnet</span> localhost <span class="number">1</span></span><br></pre></td></tr></table></figure><p>补充·：<strong>Telnet</strong> 使用 <strong>Telnet 协议</strong>，这是一种基于 <strong>TCP</strong> 的应用层协议。它通过 TCP 的端口 23 进行通信，允许用户在远程计算机上进行交互式命令行会话。</p><p>在 <code>tcpmux</code> 接收到请求后，它会解析请求并将连接转发到正确的服务程序，如 FTP、Telnet 或 HTTP 服务。</p><p><strong>示例操作</strong></p><p>假设你配置了以下服务:</p><ul><li>FTP 通过端口 21</li><li>Telnet 通过端口 23</li><li>HTTP 通过端口 80</li></ul><p>你可以使用 <code>tcpmux</code> 监听端口 1，根据请求的内容将连接转发到相应的服务程序。</p><p><strong>简化配置</strong></p><p><strong>通过 <code>tcpmux</code> 管理的网络服务配置示例:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 tcpmux 管理多个服务</span></span><br><span class="line"><span class="number">1</span>   stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/tcpmuxd  tcpmuxd</span><br></pre></td></tr></table></figure><p><strong>在配置文件中定义服务:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置服务程序</span></span><br><span class="line">ftp     stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.ftpd   <span class="keyword">in</span>.ftpd</span><br><span class="line">telnet  stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.telnetd <span class="keyword">in</span>.telnetd</span><br><span class="line">http    stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.httpd   <span class="keyword">in</span>.httpd</span><br></pre></td></tr></table></figure><h2 id="技巧19-考虑使用两条TCP连接">技巧19:考虑使用两条TCP连接</h2><p><strong>使用两条 TCP 连接的好处</strong>:</p><ol><li><strong>分离控制和数据流</strong>: 在某些应用场景中，分离控制信息和数据传输可以提高通信的效率和可靠性。例如，一个连接专用于控制命令和管理操作，而另一个连接用于数据传输，这样可以减少数据和控制信息之间的干扰。</li><li><strong>提高性能</strong>: 通过将控制和数据流分开，应用程序可以更好地优化每条连接的性能。例如，控制连接可以保持较低的延迟，而数据连接可以处理大量数据传输，提高整体效率。</li><li><strong>增强可靠性</strong>: 使用两条连接可以提高系统的容错能力。如果一个连接出现问题，另一个连接仍然可以继续工作，减少服务中断的风险。</li></ol><p><strong>举例说明</strong></p><p><strong>1. 文件传输与控制命令</strong></p><p>在某些文件传输协议中，如 FTP（文件传输协议），使用两条 TCP 连接的设计是典型的例子：</p><ul><li><strong>控制连接</strong>: 用于发送命令和接收服务器的响应。通常使用端口 21。</li><li><strong>数据连接</strong>: 用于实际传输文件数据。通常在建立控制连接后动态分配端口。</li></ul><p><strong>示例操作</strong>:</p><ul><li><strong>FTP 控制连接</strong>: 客户端通过端口 21 连接到 FTP 服务器，发送命令如 <code>LIST</code>、<code>RETR</code>（取回文件）、<code>STOR</code>（存储文件），服务器响应这些命令。</li><li><strong>FTP 数据连接</strong>: 当客户端请求文件列表时，服务器在另一条数据连接上传输文件列表数据。数据连接在不同的端口上建立，用于传输实际的文件数据或目录列表。</li></ul><p><strong>2. 聊天应用程序</strong></p><p>在聊天应用程序中，可以使用两条 TCP 连接来分离聊天消息和控制信号：</p><ul><li><strong>聊天消息连接</strong>: 用于传输聊天消息内容，确保消息的高效传输。</li><li><strong>控制信号连接</strong>: 用于传输控制信号，如用户状态更新、连接管理等。</li></ul><p><strong>示例操作</strong>:</p><ul><li><strong>聊天消息连接</strong>: 客户端和服务器通过一个专用的连接传输用户的聊天消息。</li><li><strong>控制信号连接</strong>: 另一个连接处理用户登录、注销、状态更新等控制信息，确保这些操作不会干扰实际的聊天消息传输。</li></ul><h2 id="技巧20-使应用程序成为事件驱动的-1">技巧20:使应用程序成为事件驱动的(1)</h2><p><strong>高效资源使用</strong>: 事件驱动模型可以减少资源的消耗，通过在事件发生时处理任务而不是不断轮询或等待，这样可以提高应用程序的整体效率。</p><p><strong>更好的响应性</strong>: 应用程序可以即时响应事件（如网络请求、用户输入等），从而提供更快的用户体验。</p><p><strong>处理高并发</strong>: 事件驱动编程特别适合处理大量并发事件，通过异步处理和非阻塞 I/O 操作来支持大规模并发用户。</p><p><strong>简化设计</strong>: 通过将事件处理逻辑与业务逻辑分离，可以使程序设计更加清晰和可维护。</p><h2 id="技巧21-使应用程序成为事件驱动的-2">技巧21:使应用程序成为事件驱动的(2)</h2><p><strong>1. 异步 I/O 操作</strong></p><p>在事件驱动编程中，异步 I/O 操作是关键，允许程序在等待 I/O 操作完成的同时继续执行其他任务。</p><p><strong>示例</strong>:</p><ul><li><strong>Linux AIO</strong>: 使用 Linux 的异步 I/O 接口（如 <code>io_uring</code> 或 <code>libaio</code>）来进行非阻塞文件 I/O 操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">io_context_t</span> ctx;</span><br><span class="line">    io_setup(<span class="number">10</span>, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line"></span><br><span class="line">    io_prep_pread(&amp;cb, fd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    io_submit(ctx, <span class="number">1</span>, &amp;cb);</span><br><span class="line"></span><br><span class="line">    io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, events, nullptr);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用异步编程库</strong></p><p>现代 C++ 提供了多种异步编程库，如 Boost.Asio 和 C++20 的协程（coroutines），这些库和语言特性可以更简洁地实现事件驱动编程。</p><p><strong>示例</strong>:</p><ul><li><strong>Boost.Asio</strong>: 用于实现异步网络通信。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_accept</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Connection accepted!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    tcp::acceptor <span class="title function_">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">12345</span>))</span>;</span><br><span class="line">    tcp::socket <span class="title function_">socket</span><span class="params">(io_context)</span>;</span><br><span class="line"></span><br><span class="line">    acceptor.async_accept(socket, handle_accept);</span><br><span class="line">    io_context.run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧22-不要用TIME-WAIT暗杀来关闭一条连接">技巧22:不要用TIME-WAIT暗杀来关闭一条连接</h2><ul><li><p>通常只有一端——主动关闭的那一端会进入TIME-WAIT状态</p></li><li><p>使用TIME-WAIT状态主要由两个目的：</p><ol><li><p>维护连接状态，以防主动关闭连接的那段发送的最后一条ACK丢失后造成另一端重新发送FIN信号</p></li><li><p>为耗尽网络中所有此连接的“走失段”提供时间</p></li></ol></li><li><p>暗杀</p><p><strong>TIME-WAIT 暗杀</strong>是指通过不适当的方法关闭 TIME-WAIT 状态中的连接，可能会导致以下问题：</p><ol><li><strong>端口资源浪费</strong>: 在高负载的系统中，大量的 TIME-WAIT 状态连接可能会消耗系统的端口资源，导致端口耗尽问题。</li><li><strong>连接重用问题</strong>: 如果在 TIME-WAIT 状态期间重新使用相同的端口号，可能会导致数据包混淆，进而影响连接的稳定性和数据完整性。</li><li><strong>网络流量问题</strong>: 不正确的处理可能导致网络中的包丢失或重复，从而引发更多的网络流量问题和性能下降。</li></ol></li></ul><h2 id="技巧23-服务器应该设置SO-REUSERADDR选项">技巧23:服务器应该设置SO_REUSERADDR选项</h2><h2 id="技巧24-可能的话，使用一个大规模的写操作，而不是多个小规模的写操作">技巧24:可能的话，使用一个大规模的写操作，而不是多个小规模的写操作</h2><ul><li>上下文的切换耗时</li><li>Nagle算法影响</li></ul><h2 id="技巧25-理解如何使connect调用超时">技巧25:理解如何使connect调用超时</h2><p><strong><code>connect</code> 调用的超时</strong></p><p>在 TCP 网络编程中，<code>connect</code> 系统调用用于建立一个到远程主机的连接。然而，如果远程主机无法在合理的时间内响应，<code>connect</code> 调用可能会导致程序阻塞，直到连接建立或者超时。设置超时可以防止这种情况，并提高程序的可靠性和响应性。</p><p><strong>设置 <code>connect</code> 超时的步骤</strong></p><ol><li><strong>使用 <code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项</strong>: 这些选项可以设置接收和发送的超时时间，适用于 TCP 连接，但它们不会直接影响 <code>connect</code> 调用的超时。</li><li><strong>使用 <code>select</code> 或 <code>poll</code> 函数</strong>: 通过将套接字文件描述符传递给 <code>select</code> 或 <code>poll</code>，可以设置超时，帮助实现 <code>connect</code> 超时。</li><li><strong>使用 <code>fcntl</code> 函数设置非阻塞模式</strong>: 通过将套接字设置为非阻塞模式，可以使用非阻塞的 <code>connect</code> 调用，然后利用 <code>select</code> 或 <code>poll</code> 来等待连接的完成或超时。</li></ol><p><strong>补充：</strong></p><p><strong><code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项</strong> 是用于设置套接字的接收和发送操作的超时时间的选项。这些选项对 <code>connect</code> 调用的超时没有直接影响，但对于套接字在连接成功后如何处理接收和发送超时非常有用。</p><p><strong><code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项概述</strong></p><ul><li><strong><code>SO_RCVTIMEO</code></strong>: 设置接收操作的超时时间。</li><li><strong><code>SO_SNDTIMEO</code></strong>: 设置发送操作的超时时间。</li></ul><p>这两个选项通常用于控制套接字的接收和发送操作的超时，而不是 <code>connect</code> 调用本身。它们可以帮助处理由于网络问题导致的接收或发送延迟。</p><p><strong>示例代码</strong></p><p>以下示例演示了如何使用 <code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项来设置套接字的接收和发送超时时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_TIMEOUT 5  <span class="comment">// 接收超时时间（秒）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEND_TIMEOUT 5  <span class="comment">// 发送超时时间（秒）</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接收超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">recv_timeout</span>;</span></span><br><span class="line">    recv_timeout.tv_sec = RECV_TIMEOUT;</span><br><span class="line">    recv_timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;recv_timeout, <span class="keyword">sizeof</span>(recv_timeout)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_RCVTIMEO&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置发送超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">send_timeout</span>;</span></span><br><span class="line">    send_timeout.tv_sec = SEND_TIMEOUT;</span><br><span class="line">    send_timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;send_timeout, <span class="keyword">sizeof</span>(send_timeout)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_SNDTIMEO&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;server_addr.sin_addr);  <span class="comment">// example.com 的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接成功，尝试发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (send(sockfd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_received = recv(sockfd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_received &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[bytes_received] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received data:\n%s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧26-避免数据复制">技巧26:避免数据复制</h2><p><strong>避免数据复制的策略</strong></p><ol><li><p><strong>使用零拷贝技术</strong>:</p><ul><li>零拷贝是一种技术，旨在减少数据在内存中被复制的次数。操作系统和网络库提供了一些机制来实现零拷贝。</li><li><strong>示例</strong>: 使用 <code>sendfile()</code> 函数可以直接将文件的数据从内核缓冲区发送到网络连接中，而不需要将数据先复制到用户空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">e<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> src_fd = open(<span class="string">&quot;source_file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> dest_fd = <span class="comment">/* 目标套接字描述符 */</span>;</span><br><span class="line">    <span class="keyword">if</span> (src_fd &lt; <span class="number">0</span> || dest_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    fstat(src_fd, &amp;file_stat);</span><br><span class="line">    <span class="type">ssize_t</span> bytes_sent = sendfile(dest_fd, src_fd, &amp;offset, file_stat.st_size);</span><br><span class="line">    <span class="keyword">if</span> (bytes_sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendfile&quot;</span>);</span><br><span class="line">        close(src_fd);</span><br><span class="line">        close(dest_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(src_fd);</span><br><span class="line">    close(dest_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用内存映射 (Memory Mapping)</strong>:</p><ul><li>通过内存映射文件 (<code>mmap</code>) 将文件直接映射到进程的地址空间，避免了显式的读写操作。</li><li><strong>示例</strong>: 使用 <code>mmap</code> 映射文件并在内存中直接操作数据，减少了内存复制操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> file_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* file_data = mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_data == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作映射的内存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    munmap(file_data, file_size);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用共享内存</strong>:</p><ul><li>共享内存允许不同的进程访问同一块物理内存区域，从而避免了数据在进程之间的复制。</li><li><strong>示例</strong>: 使用 POSIX 共享内存 (<code>shm_open</code>) 或 System V 共享内存 (<code>shmget</code>) 来实现进程间的数据共享。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shm_fd = shm_open(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ftruncate(shm_fd, size);</span><br><span class="line">    <span class="type">void</span>* shm_ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        close(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作共享内存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    munmap(shm_ptr, size);</span><br><span class="line">    close(shm_fd);</span><br><span class="line">    shm_unlink(shm_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用高效的序列化和反序列化方法</strong>:</p><ul><li>避免不必要的数据转换，使用高效的序列化方法来减少数据复制。</li><li><strong>示例</strong>: 使用 Google 的 Protocol Buffers 或 FlatBuffers，这些库提供了高效的序列化机制。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Protocol Buffers 库示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_proto.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SerializeToString</span><span class="params">(<span class="type">const</span> your::proto::Message&amp; msg, <span class="built_in">std</span>::<span class="built_in">string</span>* output)</span> &#123;</span><br><span class="line">    msg.SerializeToString(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseFromString</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; input, your::proto::Message* msg)</span> &#123;</span><br><span class="line">    msg-&gt;ParseFromString(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p><strong>避免数据复制</strong> 通过以下几种方式来提升性能：</p><ul><li>使用零拷贝技术，如 <code>sendfile</code>。</li><li>使用内存映射，如 <code>mmap</code>。</li><li>使用共享内存来避免进程间的数据复制。</li><li>使用高效的序列化库来减少数据转换开销。</li></ul><p>这些技术有助于减少延迟和内存消耗，提高应用程序的性能。</p><h2 id="技巧27-使用前将结构sockaddr-in清零">技巧27:使用前将结构sockaddr_in清零</h2><p><strong>避免未定义行为</strong>:</p><ul><li><code>sockaddr_in</code> 结构体在未初始化时可能包含随机值，这些随机值可能会导致未定义的行为。</li><li>在函数如 <code>bind</code>、<code>connect</code> 或 <code>sendto</code> 中使用未初始化的结构体可能导致意外错误或不确定的结果。</li></ul><h2 id="技巧28-不要忘记字节的“性别”">技巧28:不要忘记字节的“性别”</h2><p><strong>技巧28: 不要忘记字节的“性别”</strong> 是网络编程中的一个重要注意事项，尤其是在处理数据的序列化和反序列化时。这个技巧强调了在网络编程中需要处理数据的字节顺序（字节序），并确保数据在不同系统之间的一致性。</p><h2 id="技巧29-不要将IP地址或端口号硬编入应用程序中">技巧29:不要将IP地址或端口号硬编入应用程序中</h2><h2 id="技巧30-理解已连接的UDP套接字">技巧30:理解已连接的UDP套接字</h2><p><strong>Q：UDP可以用connect函数操作吗？</strong></p><p>A：可以，目的就是为了简化编程。不影响UDP的无连接特性，UDP的无连接特性仍然存在，套接字仍然可以接收来自不同地址的数据。</p><p>使用connect</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>); <span class="comment">// 目标端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;server_addr.sin_addr); <span class="comment">// 目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, UDP!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (send(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目标地址和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.sin_family = AF_INET;</span><br><span class="line">    dest_addr.sin_port = htons(<span class="number">12345</span>); <span class="comment">// 目标端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;dest_addr.sin_addr); <span class="comment">// 目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, UDP!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(recv_addr);</span><br><span class="line">    <span class="type">ssize_t</span> recv_len = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;recv_addr, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (recv_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buffer[recv_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received message: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="技巧31-记住，并不是所有程序都是用C编写的">技巧31:记住，并不是所有程序都是用C编写的</h2><h2 id="技巧32-理解缓冲区长度带来的影响">技巧32:理解缓冲区长度带来的影响</h2><ul><li><strong>发送缓冲区长度</strong>:<ul><li><strong>网络拥塞</strong>: 如果发送缓冲区过小，可能会导致频繁的阻塞，尤其是在网络拥塞或高负载时。应用程序可能会因为缓冲区满而被阻塞，直到缓冲区有空间可用。</li><li><strong>吞吐量</strong>: 较大的发送缓冲区可以提高数据的吞吐量，减少由于等待缓冲区空间不足而导致的阻塞时间。尤其在高数据速率的应用中，合理设置发送缓冲区长度有助于提高性能。</li></ul></li><li><strong>接收缓冲区长度</strong>:<ul><li><strong>数据丢失</strong>: 如果接收缓冲区过小，可能会导致接收到的数据包被丢弃，尤其是在高数据速率的情况下。当接收缓冲区满时，新的数据包可能会被丢弃，导致数据丢失。</li><li><strong>延迟</strong>: 较大的接收缓冲区可以减少因缓冲区满而导致的丢包概率，从而减少数据丢失的情况。它还可以降低延迟，因为应用程序可以在接收缓冲区中存储更多的数据。</li></ul></li></ul><p><strong>[发送：小，阻塞。接收：小，丢包]</strong></p><ul><li>设置缓冲区大小<ul><li>可以使用 <code>setsockopt()</code> 函数来调整套接字的缓冲区大小。例如，设置发送缓冲区大小可以使用 <code>SO_SNDBUF</code> 选项，设置接收缓冲区大小可以使用 <code>SO_RCVBUF</code> 选项。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">65536</span>; <span class="comment">// 64KB</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_RCVBUF&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_SNDBUF&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer sizes set successfully.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧33-熟悉ping使用工具">技巧33:熟悉ping使用工具</h2><ul><li>ping没有使用TCP或UDP，因此没有相关的知名端口，使用ICMP</li></ul><h2 id="技巧34-学习使用tcpdump或类似的工具">技巧34:学习使用tcpdump或类似的工具</h2><p><code>tcpdump</code> 通过使用 <code>libpcap</code> 库来捕获网络上的数据包。<code>libpcap</code> 是一个提供跨平台的网络数据包捕获功能的库，支持多种操作系统。<code>tcpdump</code> 实际上是一个基于 <code>libpcap</code> 的命令行工具。</p><p><code>tcpdump</code> 的工作原理包括：</p><ol><li><strong>通过 <code>libpcap</code> 捕获网络数据包</strong>。</li><li><strong>使用过滤表达式选择性捕获数据包</strong>。</li><li><strong>解析和展示数据包的详细信息</strong>。</li><li><strong>支持将数据保存到文件中以供后续分析</strong>。</li></ol><h2 id="技巧35-学习使用traceroute">技巧35:学习使用traceroute</h2><ul><li>traceroute是诊断网络问题，学习网络路由以及探查网络拓扑的非常游泳的工具。</li></ul><h2 id="技巧36-学习使用ttcp">技巧36:学习使用ttcp</h2><p><code>ttcp</code> 是一个用于网络性能测试的工具，可以用来测量 TCP 和 UDP 网络连接的吞吐量和延迟。它通常用于评估网络带宽和性能，并测试网络在不同条件下的响应能力。以下是有关 <code>ttcp</code> 工具的一些详细信息和使用示例：</p><p><strong>1. <code>ttcp</code> 的功能</strong></p><ul><li><strong>性能测试</strong>：<code>ttcp</code> 可以用来测试网络带宽、吞吐量和延迟等性能指标。</li><li><strong>TCP/UDP 测试</strong>：它支持 TCP 和 UDP 协议的测试，能够分别测试这两种协议在网络中的表现。</li><li><strong>简单易用</strong>：<code>ttcp</code> 是一个简单的工具，适合快速测量网络性能和进行基本的网络测试。</li></ul><p><strong>2. <code>ttcp</code> 的工作原理</strong></p><ul><li><strong>客户端/服务器模式</strong>：<code>ttcp</code> 运行在客户端和服务器模式下，客户端发起数据传输请求，服务器接收数据并返回结果。</li><li><strong>数据传输</strong>：客户端生成一定量的数据并发送到服务器，服务器接收数据并计算吞吐量。</li><li><strong>性能评估</strong>：<code>ttcp</code> 根据传输的数据量和传输时间来计算网络性能指标，如吞吐量和延迟。</li></ul><p><strong>3. 使用示例</strong></p><p><strong>1. 安装 <code>ttcp</code></strong></p><p>在大多数 Linux 系统上，<code>ttcp</code> 可以通过软件包管理工具安装。例如，在 Debian 或 Ubuntu 上可以使用：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install ttcp</span><br></pre></td></tr></table></figure><p>在 Red Hat 或 CentOS 上可以使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> ttcp</span><br></pre></td></tr></table></figure><p><strong>2. 启动服务器</strong></p><p>首先，在目标机器上启动 <code>ttcp</code> 服务器进程：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ttcp -r</span></span><br></pre></td></tr></table></figure><p><strong>3. 启动客户端</strong></p><p>在源机器上，使用 <code>ttcp</code> 客户端来测试网络性能。假设服务器的 IP 地址是 <code>192.168.1.100</code>，可以使用以下命令进行 TCP 测试：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ttcp</span> -t -s <span class="number">192.168.1.100</span></span><br></pre></td></tr></table></figure><ul><li><code>-t</code>：表示进行 TCP 测试。</li><li><code>-s</code>：表示服务器的 IP 地址。</li></ul><p><strong>4. 解析结果</strong></p><p><code>ttcp</code> 会输出测试结果，包括传输的总数据量、传输时间、吞吐量等。例如，输出可能包括类似下面的内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sent</span> <span class="number">10000000</span> bytes in <span class="number">1</span>.<span class="number">5</span> seconds = <span class="number">6</span>.<span class="number">67</span> MB/sec</span><br></pre></td></tr></table></figure><p>这表示客户端在 1.5 秒内发送了 10,000,000 字节的数据，吞吐量为 6.67 MB/sec。</p><p><strong>4. 应用场景</strong></p><ul><li><strong>网络性能评估</strong>：用于评估网络连接的实际带宽和性能。</li><li><strong>故障排除</strong>：帮助诊断网络瓶颈和性能问题。</li><li><strong>比较测试</strong>：测试不同网络配置或硬件对性能的影响。</li></ul><h2 id="技巧37-学习使用lsof">技巧37:学习使用lsof</h2><p><strong><code>lsof</code> 的功能</strong>（List Open Files）</p><ul><li><strong>列出打开的文件</strong>：显示当前系统上所有被进程打开的文件，包括普通文件、目录、设备文件等。</li><li><strong>显示网络连接</strong>：提供当前系统上所有网络连接的信息，包括 TCP 和 UDP 连接。</li><li><strong>查看文件描述符</strong>：列出与文件描述符相关的详细信息，如文件句柄和设备。</li><li><strong>诊断工具</strong>：帮助查找占用文件或端口的进程，进行故障排除。</li></ul><p><strong>2. 常见用法</strong></p><p><strong>1. 列出所有打开的文件</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span></span><br></pre></td></tr></table></figure><p>此命令会列出当前系统上所有被打开的文件，包括网络连接、设备文件等。</p><p><strong>2. 查找特定文件的使用情况</strong></p><p>要查找特定文件被哪些进程打开：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /path/<span class="keyword">to</span>/<span class="built_in">file</span></span><br></pre></td></tr></table></figure><p>例如，查看 <code>/etc/passwd</code> 文件被哪些进程打开：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><strong>3. 查找某个进程打开的文件</strong></p><p>要列出特定进程（例如 PID 为 1234）打开的所有文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">Copy <span class="selector-tag">code</span></span><br><span class="line">lsof -<span class="selector-tag">p</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure><p><strong>4. 查找特定用户的文件</strong></p><p>要列出特定用户（例如用户 <code>john</code>）打开的所有文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof -u john</span></span><br></pre></td></tr></table></figure><p><strong>5. 查找特定端口的使用情况</strong></p><p>要查找特定端口（例如端口 80）被哪些进程占用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i :<span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>6. 列出所有网络连接</strong></p><p>要列出所有网络连接（包括 TCP 和 UDP）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -<span class="selector-tag">i</span></span><br></pre></td></tr></table></figure><p>可以结合 <code>-i</code> 选项的不同参数来进一步过滤，例如 <code>-i tcp</code> 或 <code>-i udp</code>。</p><p><strong>7. 查找某个命令打开的文件</strong></p><p>要查找正在运行的特定命令（例如 <code>nginx</code>）打开的文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof -c nginx</span></span><br></pre></td></tr></table></figure><p><strong>8. 列出被某个设备或文件系统占用的文件</strong></p><p>要列出挂载点（例如 <code>/mnt</code>）下所有打开的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof +D /mnt</span><br></pre></td></tr></table></figure><h2 id="技巧38-学习使用netstat">技巧38:学习使用netstat</h2><p><code>netstat</code>（Network Statistics）是一个用于显示网络连接、路由表、接口统计信息等网络相关数据的命令行工具。它可以帮助用户诊断网络问题、监控网络流量，并提供关于网络接口和连接状态的详细信息。</p><p><strong>1. <code>netstat</code> 的功能</strong></p><ul><li><strong>显示网络连接</strong>：列出系统上所有的网络连接，包括 TCP、UDP 连接。</li><li><strong>显示路由表</strong>：提供系统的路由表信息，包括网络路由的目的地、网关等。</li><li><strong>显示网络接口统计信息</strong>：提供每个网络接口的统计信息，如传输的字节数、接收的字节数等。</li><li><strong>显示监听的端口</strong>：列出正在监听的网络端口，帮助识别开放的端口和运行的服务。</li></ul><p><strong>2. 常见用法</strong></p><p><strong>1. 显示所有网络连接</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>此命令会列出所有活动的网络连接（包括 TCP 和 UDP）。</p><p><strong>2. 显示所有监听的端口</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -l</span></span><br></pre></td></tr></table></figure><p><code>-l</code> 选项显示正在监听的端口，帮助识别开放的服务端口。</p><p><strong>3. 显示 TCP 连接</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="keyword">at</span></span><br></pre></td></tr></table></figure><p><code>-t</code> 选项过滤出 TCP 连接。加上 <code>-a</code> 选项可以显示所有 TCP 连接。</p><p><strong>4. 显示 UDP 连接</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -au</span></span><br></pre></td></tr></table></figure><p><code>-u</code> 选项过滤出 UDP 连接。加上 <code>-a</code> 选项可以显示所有 UDP 连接。</p><p><strong>5. 显示路由表</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -r</span></span><br></pre></td></tr></table></figure><p><code>-r</code> 选项显示系统的路由表，帮助了解数据包的转发路径。</p><p><strong>6. 显示网络接口统计信息</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="selector-tag">i</span></span><br></pre></td></tr></table></figure><p><code>-i</code> 选项显示网络接口的统计信息，包括接收和发送的字节数、数据包数等。</p><p><strong>7. 显示进程信息</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><p><code>-p</code> 选项显示与每个连接相关的进程 ID 和名称，帮助识别哪个进程正在使用特定端口。</p><p><strong>8. 显示每秒数据统计</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -s</span></span><br></pre></td></tr></table></figure><p><code>-s</code> 选项显示每种协议的统计信息，包括错误、丢包等。</p><p><strong>3. 使用示例</strong></p><p><strong>1. 查找开放的端口</strong></p><p>要检查系统上哪些端口处于监听状态，可以使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -tuln</span></span><br></pre></td></tr></table></figure><ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-l</code>：只显示监听状态的端口。</li><li><code>-n</code>：以数字形式显示端口号和 IP 地址。</li></ul><p><strong>2. 查看进程和端口的关系</strong></p><p>要查看每个连接的进程信息，可以使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -tulnp</span></span><br></pre></td></tr></table></figure><ul><li><code>-p</code>：显示与连接相关的进程信息</li></ul><h2 id="技巧39-学习使用系统中的调用追踪工具-strace">技巧39:学习使用系统中的调用追踪工具(strace)</h2><h2 id="技巧40-构建并使用捕获ICMP报文的工具">技巧40:构建并使用捕获ICMP报文的工具</h2><h2 id="技巧41-读Stevens的书">技巧41:读Stevens的书</h2><h2 id="技巧42-阅读代码">技巧42:阅读代码</h2><h2 id="技巧43-访问RFC编辑者的页面">技巧43:访问RFC编辑者的页面</h2><h2 id="技巧44-经常访问新闻组">技巧44:经常访问新闻组</h2><p><strong>补充1：TCP的最大负载和最小负载的意义</strong></p><p>TCP（传输控制协议）的最大负载和最小负载是指TCP连接中可以传输的数据量的上限和下限。这些概念在TCP的性能调优和网络设计中具有重要意义。</p><p><strong>最大负载（Maximum Load）</strong></p><p>最大负载通常指的是TCP连接中可以传输的最大数据量，这主要与TCP的拥塞控制机制有关。TCP通过拥塞窗口（Congestion Window, CWND）来控制一次可以发送的数据量。拥塞窗口的大小会根据网络的拥塞程度动态调整。</p><p>意义：</p><ol><li><strong>网络利用率</strong>：最大负载决定了网络的最大吞吐量。通过调整拥塞窗口的大小，可以最大化网络的利用率，从而提高数据传输的效率。</li><li><strong>拥塞控制</strong>：最大负载是TCP拥塞控制机制的核心。通过动态调整拥塞窗口，TCP可以在网络拥塞时减少数据发送量，避免网络拥塞进一步加剧。</li><li><strong>性能优化</strong>：了解和调整最大负载可以帮助优化TCP连接的性能，特别是在高延迟或高带宽的网络环境中。</li></ol><p><strong>最小负载（Minimum Load）</strong></p><p>最小负载通常指的是TCP连接中可以传输的最小数据量，这主要与TCP的慢启动和超时重传机制有关。TCP在建立连接时会从较小的拥塞窗口开始，逐渐增加直到达到网络的拥塞窗口上限。</p><p>意义：</p><ol><li><strong>启动速度</strong>：最小负载决定了TCP连接的启动速度。较小的最小负载可以加快TCP连接的启动，从而减少连接建立的时间。</li><li><strong>超时重传</strong>：最小负载也与TCP的超时重传机制有关。在网络不稳定或丢包率较高的情况下，较小的最小负载可以减少重传的数据量，从而提高TCP的可靠性。</li><li><strong>资源利用</strong>：了解和调整最小负载可以帮助更好地利用网络资源，特别是在低带宽或高延迟的网络环境中。</li></ol><p><strong>总结</strong></p><p>TCP的最大负载和最小负载是TCP性能调优和网络设计中的重要参数。通过合理调整这些参数，可以提高TCP连接的性能、可靠性和网络资源的利用率。在实际应用中，需要根据具体的网络环境和应用需求来调整这些参数，以达到最佳的网络性能。</p><p><strong>补充2：linux创建1个socket内存开销多少</strong></p><p>文件系统inode + socket结构 是固定大小的，大约为1K。 理想情况下：每个socket占用的内存为<strong>2~3K</strong>。 以2K计算，内核空间实际可用内存约在800M，那么800M/2K = 400K. 粗略估计，Linux下，32位系统，能支持40万tcp并发连接差不多就到极限了。</p><p>*<em>补充3：int confd = accept(curfd, (sockaddr <em>)&amp;client_addr, &amp;client_len); 这个TCPSocket confd使用的端口号和curfd是一致的，那么客户端往这个ip+port上发送信息的时候怎么知道交给哪个描述符处理，说重点 举例说明</em></em></p><p>看这个例子你就理解啦</p><p>假设有一个服务器在 IP 地址 <code>192.168.1.10</code> 上监听端口 <code>8080</code>，并且客户端的 IP 地址是 <code>192.168.1.20</code>，客户端的端口号是 <code>12345</code>。</p><ol><li><strong>客户端连接</strong>:<ul><li>客户端使用其 IP 地址 <code>192.168.1.20</code> 和端口 <code>12345</code> 连接到服务器的 IP 地址 <code>192.168.1.10</code> 上的端口 <code>8080</code>。</li><li>服务器的监听套接字 <code>curfd</code> 接收到这个连接请求，并通过 <code>accept()</code> 创建一个新的套接字描述符 <code>confd</code>。</li></ul></li><li><strong>数据发送</strong>:<ul><li>客户端向 <code>192.168.1.10:8080</code> 发送数据包，数据包中包含目标 IP 地址和端口号 <code>192.168.1.10:8080</code>。</li><li>操作系统内核会使用这些信息将数据包路由到 <code>192.168.1.10</code> 上的监听套接字 <code>curfd</code>。</li></ul></li><li><strong>内核处理</strong>:<ul><li>内核根据客户端的 IP 地址和端口号（<code>192.168.1.20:12345</code>）和服务器的 IP 地址和端口号（<code>192.168.1.10:8080</code>）唯一标识连接。</li><li>内核知道这个连接对应于 <code>confd</code>，因为这是由 <code>accept()</code> 返回的专用描述符。</li></ul></li><li><strong>数据接收</strong>:<ul><li>数据到达服务器后，内核将数据包传递到正确的套接字描述符 <code>confd</code>，因为 <code>confd</code> 对应于客户端与服务器之间的唯一连接。</li></ul></li></ol><p>*<em>补充4：int confd = accept(curfd, (sockaddr <em>)&amp;client_addr, &amp;client_len);confd和curfd都是TCPSocket是吗？</em></em></p><p>是的，<code>confd</code> 和 <code>curfd</code> 都是 TCP 套接字（<code>TCPSocket</code>）。</p><p>[对Linux下socket限制的理解 - YZG - 博客园](<a href="https://www.cnblogs.com/yizhinantian/archive/2011/04/03/2004340.html#:~:text=%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Finode">https://www.cnblogs.com/yizhinantian/archive/2011/04/03/2004340.html#:~:text=文件系统inode</a> %2B socket结构 是固定大小的，大约为1K。,理想情况下：每个socket占用的内存为2~3K。 以2K计算，内核空间实际可用内存约在800M，那么800M%2F2K %3D 400K. 粗略估计，Linux下，32位系统，能支持40万tcp并发连接差不多就到极限了。)</p>]]></content>
    
    
    <summary type="html">TCP/IP高效编程</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Glibc-ptmalloc</title>
    <link href="https://penge666.github.io/posts/3707fe10.html"/>
    <id>https://penge666.github.io/posts/3707fe10.html</id>
    <published>2024-08-06T15:25:18.000Z</published>
    <updated>2024-08-06T15:45:14.397Z</updated>
    
    <content type="html"><![CDATA[<p>在Unix和类Unix系统中，glibc（GNU C Library）扮演着至关重要的角色。它作为系统调用和库函数的桥梁，使得程序员能够方便地利用底层系统资源。<code>ptmalloc</code> 是 <code>malloc</code> 在 GNU C Library（glibc）中的一个具体实现。</p><p><strong>32</strong> <strong>位模式下进程内存经典布局</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806233656259.png" alt="image-20240806233656259"></p><p>着重关注两个区：<strong>heap</strong>（堆区） <strong>memory mapping</strong>（内存映射区）</p><ul><li><p>brk函数其实就是在heap分配空间，在ptmalloc的设计中有start_brk和brk两个标志，他们两个的差值标记着堆区的大小。一开始这两个值是相同的，但是随着ptmalloc去调用brk函数，brk标记不断向高地址区域偏移，标记着heap堆区被分配出去了。</p></li><li><p>mmap函数则是在memory mapping区域分配空间，memory mapping区域除了我们常知道的映射动态库对象或者文件，其空间还可以被mmap映射至物理内存。</p></li></ul><h2 id="分配区">分配区</h2><p>在 Doug Lea 实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在 SMP 多线程环境下，对主分配区的锁的争用很激烈，严重影响了 malloc 的分配效率。<strong>于是 Wolfram Gloger 在 Doug Lea 的基础上改进使得Glibc 的 malloc 可以支持多线程，增加了非主分配区（non main arena）支持，主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</strong>【有点分段锁的味道】</p><p>每个进程只有一个主分配区，但可能存在多个非主分配区，ptmalloc 根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。**主分配区可以访问进程的 heap 区域和 mmap 映射区域，也就是说主分配区可以使用 sbrk 和 mmap向操作系统申请虚拟内存。而非主分配区只能访问进程的 mmap 映射区域，非主分配区每次使用 mmap()向操作系统“发”HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统默认为 64MB）大小的虚拟内存，**当用户向非主分配区请求分配内存时再切割成小块“零售”出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap()函数向操作系统申请虚拟内存。</p><p>主分配区可以访问 heap 区域，如果用户不调用 brk()或是 sbrk()函数，分配程序就可以保证分配到连续的虚拟地址空间，因为每个进程只有一个主分配区使用 sbrk()分配 heap 区域的虚拟内存。内核对 brk 的实现可以看着是 mmap 的一个精简版，相对高效一些。如果主分配区的内存是通过 mmap()向系统分配的，当 free 该内存时，主分配区会直接调用 munmap()将该内存归还给系统。</p><p>**当某一线程需要调用 malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。**在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。申请小块内存时会产生很多内存碎片，ptmalloc 在整理时也需要对分配区做加锁操作。每个加锁操作大概需要 5～10 个 cpu 指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致 malloc 性能下降。一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc在多线程竞争情况下性能远远落后于 tcmalloc。最新版的 ptmalloc 对锁进行了优化，加入了PER_THREAD 和 ATOMIC_FASTBINS 优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。</p><p><strong>代码角度理解</strong></p><p><strong>主分配区（Main Arena）</strong></p><p>主分配区是唯一的，它与进程的主线程相关联。主分配区使用进程的堆（heap）来分配内存，并且在进程启动时创建，始终存在。以下是主分配区的一些关键代码实现细节：</p><ol><li><p><strong><code>malloc_state</code> 结构体</strong>：</p><ul><li><p>这是主分配区的核心数据结构，包含了所有用于管理内存的字段，例如 <code>bins</code> 数组、<code>top</code> 指针（指向当前未分配的内存区域）、<code>last_remainder</code> 指针（指向最后一个分割的内存块）等。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    <span class="type">binmap_t</span> binmap;          <span class="comment">// 用于快速查找非空 bin 的位图</span></span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *last_remainder; <span class="comment">// 指向最后一个分割的内存块</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><p>主分配区通常是一个全局变量，例如在 <code>glibc</code> 中，主分配区可以通过 <code>main_arena</code> 变量访问。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> malloc_state main_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化</strong>：</p><ul><li><p>主分配区在进程启动时初始化，通常在 <code>ptmalloc</code> 的初始化函数中完成。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ptmalloc_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化主分配区</span></span><br><span class="line">    <span class="built_in">init_arena</span>(&amp;main_arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>从分配区（Thread Arena）</strong></p><p>从分配区是为每个线程独立创建的分配区，它允许线程独立地管理内存，从而减少锁竞争，提高并发性能。以下是从分配区的一些关键代码实现细节：</p><ol><li><p><strong>线程局部存储（Thread Local Storage, TLS）</strong>：</p><ul><li><p>每个线程可以通过线程局部存储（TLS）来访问自己的分配区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread malloc_state *thread_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>创建从分配区</strong>：</p><ul><li><p>当一个线程第一次调用 <code>malloc</code> 时，如果还没有分配区，<code>ptmalloc</code> 会为该线程创建一个新的从分配区。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> malloc_state *<span class="title">arena_get</span><span class="params">(mstate *ar_ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *a;</span><br><span class="line">    <span class="comment">// 尝试获取现有的分配区或创建新的分配区</span></span><br><span class="line">    a = <span class="built_in">get_free_list</span>(); <span class="comment">// 从空闲列表中获取分配区</span></span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        a = _int_new_arena(size); <span class="comment">// 创建新的分配区</span></span><br><span class="line">    &#125;</span><br><span class="line">    *ar_ptr = a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配和释放</strong>：</p><ul><li><p>当线程请求内存时，<code>ptmalloc</code> 会从相应的分配区中查找合适的内存块。如果找到合适的内存块，则将其从 <code>bins</code> 中移除并返回给调用者。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line">    <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="built_in">arena_get</span>(&amp;ar_ptr, size);</span><br><span class="line">    <span class="comment">// 从分配区中查找合适的内存块</span></span><br><span class="line">    victim = _int_malloc(ar_ptr, size);</span><br><span class="line">    <span class="keyword">if</span> (!victim) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些代码片段，可以看到主分配区和从分配区的基本结构和操作。</p><h2 id="关键数据结构">关键数据结构</h2><p>在 <code>ptmalloc</code> 内存分配器中，<code>unsorted bin</code>、<code>Fast Bins</code>、<code>top chunk</code>、<code>bins</code> 和 <code>mmaped chunk</code> 是用于管理内存块的关键数据结构。它们之间的关系和作用如下：</p><ol><li><code>unsorted bin</code></li></ol><p><code>unsorted bin</code> 是一个双向链表，用于临时存储最近释放的内存块。这些内存块在下次分配请求时会被重新整理并放入相应的 <code>bins</code> 中。</p><ol start="2"><li><code>Fast Bins</code></li></ol><p><code>Fast Bins</code> 是一个单链表数组，用于存储较小的空闲内存块（通常小于64或128字节）。<code>Fast Bins</code> 中的内存块不会被合并，这样可以快速地进行分配和释放。</p><ol start="3"><li><code>top chunk</code></li></ol><p><code>top chunk</code> 是分配区中未分配的内存区域。当 <code>bins</code> 中没有合适的内存块时，<code>ptmalloc</code> 会从 <code>top chunk</code> 中分割出所需的内存块。</p><ol start="4"><li><code>bins</code></li></ol><p><code>bins</code> 是一个双向链表数组，用于存储具有相同大小的空闲内存块。<code>bins</code> 分为 <code>small bins</code> 和 <code>large bins</code>，分别用于存储较小的和较大的内存块。</p><ol start="5"><li><code>mmaped chunk</code></li></ol><p><code>mmaped chunk</code> 是通过 <code>mmap</code> 系统调用分配的内存块。当请求的内存大小超过某个阈值时，<code>ptmalloc</code> 会使用 <code>mmap</code> 来分配内存，而不是从堆中分配。</p><p><strong>代码解读</strong></p><p>以下是一个简化的代码示例，展示了这些数据结构之间的关系和作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> prev_size;  <span class="comment">// 前一个内存块的大小</span></span><br><span class="line">    <span class="type">size_t</span> size;       <span class="comment">// 当前内存块的大小</span></span><br><span class="line">    malloc_chunk *fd;  <span class="comment">// 指向链表中下一个内存块</span></span><br><span class="line">    malloc_chunk *bk;  <span class="comment">// 指向链表中前一个内存块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *fastbinsY[NFASTBINS]; <span class="comment">// Fast Bins 数组</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *ar_ptr = <span class="built_in">get_arena</span>(); <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="type">size_t</span> nb = <span class="built_in">request2size</span>(size);     <span class="comment">// 将请求的大小转换为实际分配的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 Fast Bins 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt;= <span class="built_in">get_max_fast</span>()) &#123;</span><br><span class="line">        idx = <span class="built_in">fastbin_index</span>(nb);</span><br><span class="line">        fb = &amp;fastbinsY[idx];</span><br><span class="line">        victim = *fb;</span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 unsorted bin 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unsorted_chunks</span>(ar_ptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        victim = <span class="built_in">unsorted_chunks</span>(ar_ptr);</span><br><span class="line">        <span class="built_in">unsorted_chunks</span>(ar_ptr) = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (victim-&gt;size == nb) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 bins 中分配内存</span></span><br><span class="line">    idx = <span class="built_in">bin_index</span>(nb);</span><br><span class="line">    bin = <span class="built_in">bin_at</span>(ar_ptr, idx);</span><br><span class="line">    victim = <span class="built_in">first</span>(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin) &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(victim, bk, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 top chunk 中分配内存</span></span><br><span class="line">    victim = ar_ptr-&gt;top;</span><br><span class="line">    size = <span class="built_in">chunksize</span>(victim);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">        ar_ptr-&gt;top = remainder;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 mmap 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &amp; MMAP_THRESHOLD) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, nb, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>获取分配区</strong>：<ul><li><code>get_arena()</code> 函数获取当前线程的分配区。</li></ul></li><li><strong>Fast Bins</strong>：<ul><li>如果请求的大小小于 <code>get_max_fast()</code> 返回的值，尝试从 <code>Fast Bins</code> 中分配内存。</li><li><code>fastbin_index(nb)</code> 计算 <code>Fast Bins</code> 的索引，<code>fastbinsY[idx]</code> 获取相应的 <code>Fast Bin</code>。</li><li>如果找到合适的内存块，将其从 <code>Fast Bin</code> 中移除并返回。</li></ul></li><li><strong>unsorted bin</strong>：<ul><li>如果 <code>unsorted bin</code> 不为空，尝试从中分配内存。</li><li>如果找到合适大小的内存块，直接返回。</li></ul></li><li><strong>bins</strong>：<ul><li>计算请求大小的 <code>bin</code> 索引，尝试从相应的 <code>bin</code> 中分配内存。</li><li>如果找到合适的内存块，将其从 <code>bin</code> 中移除并返回。</li></ul></li><li><strong>top chunk</strong>：<ul><li>如果 <code>top chunk</code> 的大小足够，从 <code>top chunk</code> 中分割出所需的内存块，并更新 <code>top chunk</code> 的指针。</li></ul></li><li><strong>mmaped chunk</strong>：<ul><li>如果请求的大小超过某个阈值，使用 <code>mmap</code> 系统调用分配内存。</li></ul></li></ol><h2 id="分配释放策略">分配释放策略</h2><p><strong>ptmalloc 的分配策略</strong></p><ul><li>获取分配区锁，加锁成功则使用该分配区分配内存，否则就遍历分配区的环形链表。如果链表中没有空闲的，就开辟一个新的分配区，把其加入线程私有实例并且加入到环形链表。</li><li>将用户请求的字节向上对齐到bins中的最近字节。</li><li>如果小于64B就在fast bin中分配内存，如果大于再去判断是否小于512B，如果小于就去small bin中分配大小，如果大于就说明此时分配的是大内存。</li><li>首先会将fast bin中的chunk进行合并，然后链接至unsorted bin，再将其链接到相应的bin中。</li><li>然后去large bins中进行寻找，如果够用结束，不够下一步。</li><li>这个时候就需要判断top chunk是否够用，不够用下一步。</li><li>有两种选择，判断分配的字节大小是否大于等于mmap分配阈值，如果小于根据分配区去选择brk还是mmap去增加top chunk的大小；如果大于就直接调用mmap去映射。</li></ul><p><strong>ptmalloc 的释放策略</strong></p><ul><li>获取分配区的锁</li><li>判断free参数是否位nullptr，如果为nullptr则什么都不做</li><li>如果释放空间为mmaped chunk，直接使用munmap释放</li><li>如果size &lt; 64B且不和top chunk相邻，放入fast bin</li><li>判断前一个块是否空闲，空闲则合并</li><li>判断下一个是否空闲，空闲则合并放入unsorted bin，然后放入相应的bin中</li><li>判读合并后是否大于64kb，如果大于fast bin中chunk进行合并，放入unsorted bin，然后下一步。</li><li>判读top chunk是否大于128kb，如果大于就会归还给操作系统。注意：如果为非主分配区，就只会归还一部部分。</li></ul><p>学习自：glibc内存管理ptmalloc源代码分析</p>]]></content>
    
    
    <summary type="html">ptmalloc内存池</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>探索LRU算法</title>
    <link href="https://penge666.github.io/posts/e4a919c6.html"/>
    <id>https://penge666.github.io/posts/e4a919c6.html</id>
    <published>2024-08-05T03:02:01.000Z</published>
    <updated>2024-08-19T03:16:12.766Z</updated>
    
    <content type="html"><![CDATA[<p>开始之前，先上一道经典的面试题，LRU【🐕】</p><h2 id="热身">热身</h2><p><strong><a href="https://leetcode.cn/problems/lru-cache-lcci/">LRU 缓存</a></strong></p><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p><p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> <span class="built_in">LRUCache</span>( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key,value;</span><br><span class="line">    Node *pre,*next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k=<span class="number">0</span>,<span class="type">int</span> v=<span class="number">0</span>):<span class="built_in">key</span>(k),<span class="built_in">value</span>(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    Node* head;</span><br><span class="line">    map&lt;<span class="type">int</span>,Node*&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node *node)</span></span>&#123;</span><br><span class="line">        node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        node-&gt;pre=head;</span><br><span class="line">        node-&gt;next=head-&gt;next;</span><br><span class="line">        node-&gt;pre-&gt;next=node;</span><br><span class="line">        node-&gt;next-&gt;pre=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node=mp[key];</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        len=capacity;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        head=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        head-&gt;next=head;</span><br><span class="line">        head-&gt;pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node=<span class="built_in">getNode</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node=<span class="built_in">getNode</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            node-&gt;value=value;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* now=<span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">        mp[key]=now;</span><br><span class="line">        <span class="built_in">push_front</span>(now);</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&gt;len)&#123;</span><br><span class="line">            <span class="keyword">auto</span> last=head-&gt;pre;</span><br><span class="line">            mp.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(last);</span><br><span class="line">            <span class="keyword">delete</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="存在问题">存在问题</h2><p>学习自：<a href="https://blog.csdn.net/weixin_73077810/article/details/136197115">探索 LRU 算法的缺陷与解决方案</a></p><p>学习完了LRU算法，接下来看看是否存在什么问题呢？</p><p>传统的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><h3 id="预读失效">预读失效</h3><p>在 Linux 操作系统中，为了优化基于 Page Cache 的读缓存机制，提供了预读（read-ahead）机制。这个机制的工作原理可以通过以下例子来说明：</p><p>假设应用程序需要读取磁盘上文件 A 中 offset 为 0-3KB 的数据。由于磁盘的基本读写单位是块（通常为 4KB），操作系统会至少读取 0-4KB 范围内的内容，将其加载到内存中的一个 page 中。</p><p>然而，操作系统会基于空间局部性原则（即与当前访问的数据相邻的数据在未来有很大可能会被访问到），进一步优化读操作。为了提高后续读操作的效率，操作系统会预先将文件 A 的其他部分也加载到内存中，例如 offset [4KB,8KB)、[8KB,12KB)、以及 [12KB,16KB) 范围内的数据。这意味着操作系统会在内存中额外分配 3 个 page 来存储这些数据块，以便在应用程序需要访问这些范围的数据时，可以直接从内存中获取，而无需再次访问磁盘。</p><p>通过这种预读机制，操作系统能显著提高数据访问的效率，减少磁盘 I/O 的次数，提升整体性能。</p><p><strong>问题：</strong></p><p>预读失效会带来什么问题？</p><p>如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。</p><p>如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率 。</p><p><strong>Linux方案</strong></p><p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表和非活跃 LRU 链表；</p><p>有了这两个 LRU 链表后，预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。如果预读的页一直没有被访问，就会从 inactive list 移除，这样不会影响 active list 中的热点数据。active list 淘汰的数据就会被降级到 inactive list ，作为 inactive list 头部。</p><h3 id="缓冲污染">缓冲污染</h3><p>当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了。</p><p><strong>以 MySQL 举例子</strong></p><p>某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。</p><h2 id="LRU-K">LRU-K</h2><p>针对上述问题，之前在数据库实践专门针对这种情况使用另外的LRU-K算法。</p><p><strong>LRU-K 算法的核心</strong>是根据每个页面的最近 <code>K</code> 次访问记录来决定哪个页面应该被淘汰。访问次数越多，页面在缓存中存活的时间就越长。简单来说，LRU-K 提供了一种更精细的页面替换策略，与普通的 LRU 不同，它考虑了更深层次的访问历史。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/lru_k_replacer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，初始化替换器大小和K值</span></span><br><span class="line">LRUKReplacer::<span class="built_in">LRUKReplacer</span>(<span class="type">size_t</span> num_frames, <span class="type">size_t</span> k) : <span class="built_in">replacer_size_</span>(num_frames), <span class="built_in">k_</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱逐一个frame，选择最久未被访问的</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 先从历史队列(hist_)中选择可驱逐的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!hist_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : hist_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mp_[it]) &#123; <span class="comment">// 判断是否可以驱逐</span></span><br><span class="line">        <span class="type">frame_id_t</span> num = it;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置frame的访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        hist_.<span class="built_in">remove</span>(num); <span class="comment">// 从历史队列中移除</span></span><br><span class="line">        *frame_id = num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果历史队列中没有可驱逐的frame，则从当前缓存队列(cur_)中选择</span></span><br><span class="line">  <span class="keyword">if</span> (!cur_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : cur_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mp_[it]) &#123; <span class="comment">// 判断是否可以驱逐</span></span><br><span class="line">        <span class="type">frame_id_t</span> num = it;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置frame的访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        cur_.<span class="built_in">remove</span>(num); <span class="comment">// 从当前缓存队列中移除</span></span><br><span class="line">        *frame_id = num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有可驱逐的frame，则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一个frame的访问，更新其在LRU-K队列中的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 忽略无效的frame_id</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果frame是第一次被访问或者计数为0</span></span><br><span class="line">  <span class="keyword">if</span> (frame_num_.<span class="built_in">find</span>(frame_id) == frame_num_.<span class="built_in">end</span>() || frame_num_[frame_id] == <span class="number">0</span>) &#123;</span><br><span class="line">    frame_num_[frame_id]++; <span class="comment">// 增加访问计数</span></span><br><span class="line">    <span class="keyword">if</span> (frame_num_[frame_id] &gt;= k_) &#123;</span><br><span class="line">      cur_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 如果访问次数达到k，加入当前缓存队列</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hist_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 否则加入历史队列</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果frame已经被访问过</span></span><br><span class="line">    frame_num_[frame_id]++; <span class="comment">// 增加访问计数</span></span><br><span class="line">    <span class="keyword">if</span> (frame_num_[frame_id] &lt; k_) &#123;</span><br><span class="line">      <span class="comment">// 如果还未达到k次访问，保持在历史队列中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame_num_[frame_id] == k_) &#123;</span><br><span class="line">      hist_.<span class="built_in">remove</span>(frame_id); <span class="comment">// 从历史队列中移除</span></span><br><span class="line">      cur_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 加入当前缓存队列</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur_.<span class="built_in">remove</span>(frame_id); <span class="comment">// 从当前缓存队列中移除</span></span><br><span class="line">      cur_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 再次加入当前缓存队列，保持LRU顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个frame是否可以被驱逐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 忽略无效的frame_id</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  mp_[frame_id] = set_evictable; <span class="comment">// 设置可驱逐标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从替换器中移除一个frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 忽略无效的frame_id</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从历史队列中移除</span></span><br><span class="line">  <span class="keyword">if</span> (!hist_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : hist_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it == frame_id) &#123;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hist_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从当前缓存队列中移除</span></span><br><span class="line">  <span class="keyword">if</span> (!cur_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : cur_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it == frame_id) &#123;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前可驱逐的frame数量</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Size</span><span class="params">()</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 统计历史队列中的可驱逐frame数量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : hist_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_[i]) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 统计当前缓存队列中的可驱逐frame数量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : cur_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_[i]) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例场景</strong></p><p>假设 <code>k=2</code>，即我们在使用 LRU-2 算法，<code>num_frames=3</code>，即缓存最多可以存储3个页面。</p><ol><li><strong>访问顺序</strong>：<code>A, B, C, A, B, D, A</code></li><li><strong>过程说明</strong>：<ul><li>初始状态：缓存为空。</li><li><strong>访问A</strong>：将 <code>A</code> 添加到历史队列 <code>hist_</code>，因为 <code>A</code> 的访问次数为1。</li><li><strong>访问B</strong>：将 <code>B</code> 添加到历史队列 <code>hist_</code>，因为 <code>B</code> 的访问次数为1。</li><li><strong>访问C</strong>：将 <code>C</code> 添加到历史队列 <code>hist_</code>，因为 <code>C</code> 的访问次数为1。</li><li><strong>再次访问A</strong>：<code>A</code> 的访问次数增加到2，将 <code>A</code> 从历史队列 <code>hist_</code> 移动到当前缓存队列 <code>cur_</code>。</li><li><strong>再次访问B</strong>：<code>B</code> 的访问次数增加到2，将 <code>B</code> 从历史队列 <code>hist_</code> 移动到当前缓存队列 <code>cur_</code>。</li><li><strong>访问D</strong>：此时缓存已满（<code>cur_</code> 中有 <code>A</code> 和 <code>B</code>），需要驱逐一个页面。算法会先检查历史队列中的页面，发现 <code>C</code> 只被访问过1次，可以被驱逐。<code>C</code> 被移除，将 <code>D</code> 加入历史队列 <code>hist_</code>。</li><li><strong>再次访问A</strong>：<code>A</code> 的访问次数增加到3，仍然保持在当前缓存队列 <code>cur_</code> 中。</li></ul></li><li><strong>最终状态</strong>：<ul><li>历史队列 <code>hist_</code>：<code>D</code></li><li>当前缓存队列 <code>cur_</code>：<code>A, B</code></li></ul></li></ol><p>LRU-K 算法有效地平衡了频繁访问页面和较久未访问页面之间的替换策略，使得那些在较长时间内多次被访问的页面能够留在缓存中，而那些仅在短时间内频繁被访问的页面则容易被淘汰。</p><p><a href="https://blog.csdn.net/Sihang_Xie/article/details/128919122">【Caffeine缓存】Caffeine缓存淘汰算法Window-TinyLFU详解</a></p>]]></content>
    
    
    <summary type="html">LRU...算法</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Epoll经典问题</title>
    <link href="https://penge666.github.io/posts/8ff0cebc.html"/>
    <id>https://penge666.github.io/posts/8ff0cebc.html</id>
    <published>2024-07-28T13:23:30.000Z</published>
    <updated>2024-08-15T13:36:20.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习自：<a href="https://cloud.tencent.com/developer/article/1831360">十个问题理解Linux epoll工作原理</a> 并加上自己的心得</p><p>epoll 是 linux 特有的一个 I/O 事件通知机制。很久以来对 epoll 如何能够高效处理数以百万记的文件描述符很有兴趣。近期学习、研究了 epoll 源码，在这个过程中关于 epoll 数据结构和作者的实现思路产生出不少疑惑，在此总结为了 10 个问题并逐个加以解答和分析。本文基于的内核源码版本是<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Freleases%2Ftag%2Fv2.6.39&amp;source=article&amp;objectId=1831360"><strong>2.6.39 版本</strong></a> 。</p><h2 id="Question-1：是否所有的文件类型都可以被-epoll-监视？"><strong>Question 1：是否所有的文件类型都可以被 epoll 监视？</strong></h2><p>答案：不是。看下面这个实验代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    epfd = epoll_create(<span class="number">100</span>); <span class="comment">/* 创建epoll实例，预计监听100个fd */</span></span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">    <span class="type">int</span> nr_events, i;</span><br><span class="line">    events = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (!events) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开一个普通文本文件 */</span></span><br><span class="line">    <span class="type">int</span> target_fd = open (<span class="string">&quot;./11.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target_fd %d\n&quot;</span>, target_fd);</span><br><span class="line">    <span class="type">int</span> target_listen_type = EPOLLIN;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        events[i].data.fd = target_fd; <span class="comment">/* epoll调用返回后，返回给应用进程的fd号 */</span></span><br><span class="line">        events[i].events = target_listen_type; <span class="comment">/* 需要监听的事件类型 */</span></span><br><span class="line">        ret = epoll_ctl (epfd, EPOLL_CTL_ADD, target_fd, &amp;events[i]); <span class="comment">/* 注册fd到epoll实例上 */</span></span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ret %d, errno %d\n&quot;</span>, ret, errno);</span><br><span class="line">            perror (<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 应用进程阻塞在epoll上，超时时长置为-1表示一直等到有目标事件才会返回 */</span></span><br><span class="line">    nr_events = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr_events &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_events; i++) &#123;</span><br><span class="line">        <span class="comment">/* 打印出处于就绪状态的fd及其事件 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event=%d on fd=%d\n&quot;</span>, events[i].events, events[i].data.fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span> (events);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译、运行上面的代码，会打印出下列信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc epoll_test.<span class="property">c</span> -o epdemo</span><br><span class="line">./epdemo</span><br><span class="line">target_fd <span class="number">4</span></span><br><span class="line">ret -<span class="number">1</span>, errno <span class="number">1</span></span><br><span class="line"><span class="attr">epoll_ctl</span>: <span class="title class_">Operation</span> not permitted</span><br></pre></td></tr></table></figure><p>正常打开了&quot;txt&quot;文件 fd=4, 但调用 epoll_ctl 监视这个 fd 时却 ret=-1 失败了, 并且错误码为 1，错误信息为&quot;Operation not permitted&quot;。错误码指明这个 fd 不能够被 epoll 监视。</p><p><strong>那什么样的 fd 才可以被 epoll 监视呢？</strong></p><p>只有底层驱动实现了 file_operations 中 poll 函数的文件类型才可以被 epoll 监视！<strong>socket 类型的文件驱动是实现了 poll 函数的，因此才可以被 epoll 监视</strong>。struct file_operations 声明位置是在 include/linux/fs.h 中。</p><p><strong>补充：</strong></p><p>在 Linux 内核中，<code>epoll</code> 可以用来监视多种类型的文件描述符（文件、套接字、管道等），<strong>这需要底层的驱动实现了 <code>file_operations</code> 结构中的 <code>poll</code> 函数</strong>。下面详细说明这方面的区别以及 <code>epoll</code> 与 <code>file_operations</code> 的关系。</p><p><strong><code>file_operations</code> 结构体</strong></p><p><code>file_operations</code> 结构体定义了文件操作接口。它声明在 <code>include/linux/fs.h</code> 中，通常包括文件操作所需的一些函数指针，例如 <code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, <code>poll</code> 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>epoll</code> 与 <code>poll</code> 函数</strong></p><ul><li><p><strong><code>poll</code> 函数</strong>: 这是 <code>file_operations</code> 结构体中的一个函数指针。<code>poll</code> 函数用于检查文件描述符的状态，判断是否可以读写，或是否发生了某种事件。文件类型的驱动实现了这个函数，<code>epoll</code> 可以用来监视这些文件描述符的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>epoll</code> 监视</strong>: <code>epoll</code> 通过调用底层驱动的 <code>poll</code> 函数来检测文件描述符的状态变化。如果底层驱动实现了 <code>poll</code> 函数，<code>epoll</code> 就可以监视这个文件描述符。</p></li></ul><p><strong>普通文件与套接字的区别</strong></p><ul><li><strong>普通文件</strong>:<ul><li><strong>文件系统接口</strong>: 普通文件的 <code>file_operations</code> 实现通常包括 <code>read</code>, <code>write</code>, <code>llseek</code> 等基本操作。</li><li><strong><code>poll</code> 函数</strong>: 普通文件的 <code>poll</code> 实现会根据文件的状态（是否可以读写）来返回相应的事件。</li></ul></li><li><strong>套接字</strong>:<ul><li><strong>网络接口</strong>: 套接字的 <code>file_operations</code> 实现包括网络相关的操作，比如 <code>recv</code>, <code>send</code> 等。</li><li><strong><code>poll</code> 函数</strong>: 套接字的 <code>poll</code> 函数会根据网络事件（如数据可读、连接关闭等）返回相应的事件。</li></ul></li></ul><h2 id="Question-2：ep-wq-的作用是什么？"><strong>Question 2：ep-&gt;wq 的作用是什么？</strong></h2><p><strong>答案：wq 是一个等待队列，用来保存对某一个 epoll 实例调用 epoll_wait()的所有进程。</strong></p><p>一个进程调用 epoll_wait()后，如果当前还没有任何事件发生，需要让当前进程挂起等待（放到 ep-&gt;wq 里）；当 epoll 实例监视的文件上有事件发生后，需要唤醒 ep-&gt;wq 上的进程去继续执行用户态的业务逻辑。之所以要用一个等待队列来维护关注这个 epoll 的进程，是因为有时候调用 epoll_wait()的不只一个进程，当多个进程都在关注同一个 epoll 实例时，休眠的进程们通过这个等待队列就可以逐个被唤醒了。</p><p><strong>多个进程关注同一个 epoll 实例，那么有事件发生后先唤醒谁？后唤醒谁？还是一起全唤醒？这涉及到一个称为“惊群效应”的问题。</strong></p><h2 id="Question-3：什么是-epoll-惊群？"><strong>Question 3：什么是 epoll 惊群？</strong></h2><p>答案：多个进程等待在 ep-&gt;wq 上，事件触发后所有进程都被唤醒，但只有其中 1 个进程能够成功继续执行的现象。其他被白白唤起的进程等于做了无用功，可能会造成系统负载过高的问题。下面这段代码能够直观感受什么是 epoll 惊群：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 10</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_and_bind</span> <span class="params">(<span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(port));</span><br><span class="line">    bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">make_socket_non_blocking</span> <span class="params">(<span class="type">int</span> sfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags, s;</span><br><span class="line"></span><br><span class="line">    flags = fcntl (sfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror (<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    s = fcntl (sfd, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror (<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd, s;</span><br><span class="line">    <span class="type">int</span> efd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">    sfd = create_and_bind(<span class="string">&quot;8001&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">    s = make_socket_non_blocking (sfd);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">    s = listen(sfd, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror (<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(MAXEVENTS);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.data.fd = sfd;</span><br><span class="line">    <span class="comment">//event.events = EPOLLIN | EPOLLET;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span> event);</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; PROCESS_NUM; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The event loop */</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> n, i;</span><br><span class="line">                n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process %d return from epoll_wait!\n&quot;</span>, getpid());</span><br><span class="line">             <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp; EPOLLIN)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */</span></span><br><span class="line">                        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                        close (events[i].data.fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* We have a notification on the listening socket, which means one or more incoming connections. */</span></span><br><span class="line">                        <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                        <span class="type">socklen_t</span> in_len;</span><br><span class="line">                        <span class="type">int</span> infd;</span><br><span class="line">                        <span class="type">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">                        in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">                        infd = accept(sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">                        <span class="keyword">if</span> (infd == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;process %d accept failed!\n&quot;</span>, getpid());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d accept successed!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Make the incoming socket non-blocking and add it to the list of fds to monitor. */</span></span><br><span class="line">                        close(infd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">free</span> (events);</span><br><span class="line">    close (sfd);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将服务端的监听 socket fd 加入到 epoll_wait 的监视集合中，这样当有客户端想要建立连接，就会事件触发 epoll_wait 返回。此时如果 10 个进程同时在 epoll_wait 同一个 epoll 实例就出现了惊群效应。所有 10 个进程都被唤起，但只有一个能成功 accept。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212514596.png" alt="image-20240815212514596"></p><p>为了解决 epoll 惊群，内核后续的高版本又提供了 EPOLLEXCLUSIVE 选项和 SO_REUSEPORT 选项，<strong>我个人理解两种解决方案思路上的不同点在于：EPOLLEXCLUSIVE 是在唤起进程阶段起作用，只唤起排在队列最前面的 1 个进程；而 SO_REUSEPORT 是在分配连接时起作用，相当于每个进程自己都有一个独立的 epoll 实例，内核来决策把连接分配给哪个 epoll。</strong></p><h2 id="Question-4：ep-poll-wait-的作用是什么？"><strong>Question 4：ep-&gt;poll_wait 的作用是什么？</strong></h2><p><strong>答案：ep-&gt;poll_wait 是 epoll 实例中另一个等待队列。当被监视的文件是一个 epoll 类型时，需要用这个等待队列来处理递归唤醒。</strong></p><p>在阅读内核代码过程中，ep-&gt;wq 还算挺好理解，但我发现伴随着 ep-&gt;wq 唤醒， 还有一个 ep-&gt;poll_wait 的唤醒过程。比如下面这段代码，在 eventpoll.c 中出现了很多次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !<span class="title function_">ep_is_linked</span>(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="title function_">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">            <span class="title function_">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">atomic_long_inc</span>(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="title function_">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br></pre></td></tr></table></figure><p>查阅很多资料后才搞明白其实 epoll 也是一种文件类型，其底层驱动也<strong>实现了 file_operations 中的 poll 函数</strong>，因此一个 epoll 类型的 fd 可以被其他 epoll 实例监视。而 epoll 类型的 fd 只会有“读就绪”的事件。当 epoll 所监视的非 epoll 类型文件有“读就绪”事件时，当前 epoll 也会进入“读就绪”状态。</p><p>因此如果一个 epoll 实例监视了另一个 epoll 就会出现递归。举个例子，如图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212524313.png" alt="image-20240815212524313"></p><ol><li>epollfd1 监视了 2 个“非 epoll”类型的 fd</li><li>epollfd2 监视了 epollfd1 和 2 个“非 epoll”类型的 fd</li></ol><p>如果 epollfd1 所监视的 2 个 fd 中有可读事件触发，fd 的 ep_poll_callback 回调函数会触发将 fd 放到 epollfd1 的 rdllist 中。此时 epollfd1 本身的可读事件也会触发，就需要从 epollfd1 的 poll_wait 等待队列中找到 epollfd2，调用 epollfd1 的 ep_poll_callback(将 epollfd1 放到 epollfd2 的 rdllist 中)。<strong>因此 ep-&gt;poll_wait 是用来处理 epoll 间嵌套监视的情况的。</strong></p><h2 id="Question-5：ep-rdllist-的作用是什么？"><strong>Question 5：ep-&gt;rdllist 的作用是什么？</strong></h2><p>答案：epoll 实例中包含就绪事件的 fd 组成的链表。</p><p>通过扫描 ep-&gt;rdllist 链表，内核可以轻松获取当前有事件触发的 fd。而不是像 select()/poll() 那样全量扫描所有被监视的 fd，再从中找出有事件就绪的。因此可以说这一点决定了 epoll 的性能是远高于 select/poll 的。</p><p>看到这里你可能又产生了一个小小的疑问：<strong>为什么 epoll 中事件就绪的 fd 会“主动”跑到 rdllist 中去，而不用全量扫描就能找到它们呢？</strong> 这是因为每当调用 epoll_ctl 新增一个被监视的 fd 时，都会注册一下这个 fd 的回调函数 ep_poll_callback， 当网卡收到数据包会触发一个中断，中断处理函数再回调 ep_poll_callback 将这个 fd 所属的“epitem”添加至 epoll 实例中的 rdllist 中。</p><h2 id="Question-6：ep-ovflist-的作用是什么？"><strong>Question 6：ep-&gt;ovflist 的作用是什么？</strong></h2><p><strong><code>ep-&gt;ovflist</code> 是 <code>epoll</code> 的溢出列表，用于在 <code>epoll</code> 的事件队列满载时存放多余的待处理事件，确保即使在高并发场景下，所有触发的事件都不会丢失，而是有序处理。</strong></p><p>答案：在 rdllist 被占用时，用来在不持有 ep-&gt;lock 的情况下收集有就绪事件的 fd。</p><p>当 epoll 上已经有了一些就绪事件的时候，内核需要扫描 rdllist 将就绪的 fd 返回给用户态。这一步通过 ep_scan_ready_list 函数来实现。其中 sproc 是一个回调函数(也就是 ep_send_events_proc 函数)，来处理数据从内核态到用户态的复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for the scan code, to call f_op-&gt;poll(). Also allows for O(NumReady) performance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ep</span>: Pointer to the epoll private data structure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sproc</span>: Pointer to the scan callback.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@priv</span>: Private opaque data passed to the <span class="doctag">@sproc</span> callback.</span></span><br><span class="line"><span class="comment"> * Returns: The same integer error code returned by the <span class="doctag">@sproc</span> callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> int <span class="title function_">ep_scan_ready_list</span>(struct eventpoll *ep,</span><br><span class="line">                  int (*sproc)(struct eventpoll *,</span><br><span class="line">                       struct list_head *, <span class="keyword">void</span> *),</span><br><span class="line">                  <span class="keyword">void</span> *priv)</span><br></pre></td></tr></table></figure><p>由于 rdllist 链表业务非常繁忙（epoll 增加监视文件、修改监视文件、有事件触发…等情况都需要操作 rdllist)，所以在复制数据到用户空间时，加了一个 ep-&gt;mtx 互斥锁来保护 epoll 自身数据结构线程安全，此时其他执行流程里有争抢 ep-&gt;mtx 的操作都会因命中 ep-&gt;mtx 进入休眠。</p><p>但加锁期间很可能有新事件源源不断地产生，进而调用 ep_poll_callback(ep_poll_callback 不用争抢 ep-&gt;mtx 所以不会休眠)，新触发的事件需要一个地方来收集，不然就丢事件了。这个用来临时收集新事件的链表就是 ovflist。我的理解是：引入 ovflist 后新产生的事件就不用因为想向 rdllist 里写而去和 ep_send_events_proc 争抢自旋锁(ep-&gt;lock), 同时 ep_send_events_proc 也可以放心大胆地在无锁(不持有 ep-&gt;lock)的情况下修改 rdllist。</p><p>看代码时会发现，还有一个 txlist 链表，这个链表用来最后向用户态复制数据，rdllist 要先把自己的数据全部转移到 txlist，然后 rdllist 自己被清空。ep_send_events_proc 遍历 txlist 处理向用户空间复制，复制成功后如果是水平触发(LT)还要把这个事件还回 rdllist，等待下一次 epoll_wait 来获取它。</p><p>ovflist 上的 fd 会合入 rdllist 上等待下一次扫描；如果 txlist 上的 fd 没有处理完，最后也会合入 rdllist。这 3 个链表的关系是这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212534725.png" alt="image-20240815212534725"></p><h2 id="Question-7：epitem-pwqlist-队列的作用是什么？"><strong>Question 7：epitem-&gt;pwqlist 队列的作用是什么？</strong></h2><p><strong><code>epitem-&gt;pwqlist</code> 队列用于跟踪和管理 <code>epitem</code> 关联的等待队列，以便在监视的文件描述符上事件触发时，能够正确地将等待的进程唤醒并将事件添加到 <code>epoll</code> 的就绪队列中。</strong></p><p>答案：用来保存这个 epitem 的 poll 等待队列。</p><p>首先介绍下什么是 epitem。epitem 是 epoll 中很重要的一种数据结构， 是红黑树和 rdllist 的基本组成元素。需要监听的文件和事件信息，都被包装在 epitem 结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;  <span class="comment">// 用于加入红黑树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink; <span class="comment">// 用于加入rdllist</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd; <span class="comment">// 包含被监视文件的文件指针和fd信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist; <span class="comment">// poll等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep; <span class="comment">// 所属的epoll实例</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;  <span class="comment">// 关注的事件</span></span><br><span class="line">    <span class="comment">/* 其他成员省略 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回忆一下上文说到，每当用户调用 epoll_ctl()新增一个监视文件，都要给这个文件注册一个回调函数 ep_poll_callback, 当网卡收到数据后软中断会调用这个 ep_poll_callback 把这个 epitem 加入到 ep-&gt;rdllist 中。</p><p><strong>pwdlist 就是跟 ep_poll_callback 注册相关的</strong>。</p><p>当调用 epoll_ctl()新增一个监视文件后，内核会为这个 epitem 创建一个 eppoll_entry 对象，通过 eppoll_entry-&gt;wait_queue_t-&gt;wait_queue_func_t 来设置 ep_poll_callback。pwdlist 为什么要做成一个队列呢，直接设置成 eppoll_entry 对象不就行了吗？实际上不同文件类型实现 file_operations-&gt;poll 用到等待队列数量可能不同。虽然大多数都是 1 个，但也有例外。比如“scullpipe”类型的文件就用到了 2 个等待队列。</p><p>pwqlist、epitem、fd、epoll_entry、ep_poll_callback 间的关系是这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212540347.png" alt="image-20240815212540347"></p><h2 id="Question-8：epmutex、ep-mtx、ep-lock-3-把锁的区别是？"><strong>Question 8：epmutex、ep-&gt;mtx、ep-&gt;lock 3 把锁的区别是？</strong></h2><p>答案：锁的粒度和使用目的不同。</p><ol><li>epmutex 是一个全局互斥锁，epoll 中一共只有 3 个地方用到这把锁。分别是 ep_free() 销毁一个 epoll 实例时、eventpoll_release_file() 清理从 epoll 中已经关闭的文件时、epoll_ctl() 时避免 epoll 间嵌套调用时形成死锁。我的理解是 epmutex 的锁粒度最大，用来处理跨 epoll 实例级别的同步操作。</li><li>ep-&gt;mtx 是一个 epoll 内部的互斥锁，在 ep_scan_ready_list() 扫描就绪列表、eventpoll_release_file() 中执行 ep_remove()删除一个被监视文件、ep_loop_check_proc()检查 epoll 是否有循环嵌套或过深嵌套、还有 epoll_ctl() 操作被监视文件增删改等处有使用。可以看出上述的函数里都会涉及对 epoll 实例中 rdllist 或红黑树的访问，因此我的理解是 ep-&gt;mtx 是一个 epoll 实例内的互斥锁，用来保护 epoll 实例内部的数据结构的线程安全。</li><li>ep-&gt;lock 是一个 epoll 实例内部的自旋锁，用来保护 ep-&gt;rdllist 的线程安全。自旋锁的特点是得不到锁时不会引起进程休眠，所以在 ep_poll_callback 中只能使用 ep-&gt;lock，否则就会丢事件。</li></ol><h2 id="Question-9：epoll-使用红黑树的目的是什么？"><strong>Question 9：epoll 使用红黑树的目的是什么？</strong></h2><p>答案：用来维护一个 epoll 实例中所有的 epitem。</p><p>用户态调用 epoll_ctl()来操作 epoll 的监视文件时，需要增、删、改、查等动作有着比较高的效率。尤其是当 epoll 监视的文件数量达到百万级的时候，选用不同的数据结构带来的效率差异可能非常大。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212550835.png" alt="image-20240815212550835"></p><p>从时间(增、删、改、查、按序遍历)、空间(存储空间大小、扩展性)等方面考量，红黑树都是非常优秀的数据结构(当然这以红黑树比较高的实现复杂度作为代价)。epoll 红黑树中的 epitem 是按什么顺序组织的。阅读代码可以发现是先比较 2 个文件指针的地址大小，如果相同再比较文件 fd 的大小。</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare RB tree keys */</span></span><br><span class="line"><span class="keyword">static</span> inline int <span class="title function_">ep_cmp_ffd</span>(<span class="params">struct epoll_filefd *p1, struct epoll_filefd *p2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1-&gt;file &gt; p2-&gt;file ? +<span class="number">1</span> : (p1-&gt;file &lt; p2-&gt;file ? -<span class="number">1</span> : p1-&gt;fd - p2-&gt;fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll、epitem、和红黑树间的组织关系是这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212555333.png" alt="image-20240815212555333"></p><h2 id="Question-10：什么是水平触发、边缘触发？"><strong>Question 10：什么是水平触发、边缘触发？</strong></h2><p>答案：水平触发(LT)和边缘触发(ET)是 epoll_wait 的 2 种工作模式。水平触发：关注点是数据（读操作缓冲区不为空，写操作缓冲区不为满），epoll_wait 总会返回就绪。LT 是 epoll 的默认工作模式。</p><p>边缘触发：关注点是变化，只有监视的文件上有数据变化发生（读操作关注有数据写进缓冲区，写操作关注数据从缓冲区取走），epoll_wait 才会返回。</p><p>看一个<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fcheerfuldustin%2Ftest_epoll_lt_and_et&amp;source=article&amp;objectId=1831360"><strong>实验</strong></a> ,直观感受下 2 种模式的区别, 客户端都是输入“abcdefgh” 8 个字符，服务端每次接收 2 个字符。</p><p>水平触发时，客户端输入 8 个字符触发了一次读就绪事件，由于被监视文件上还有数据可读故一直返回读就绪，服务端 4 次循环每次都能取到 2 个字符，直到 8 个字符全部读完。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212602516.png" alt="image-20240815212602516"></p><p>边缘触发时，客户端同样输入 8 个字符但服务端一次循环读到 2 个字符后这个读就绪事件就没有了。等客户端再输入一个字符串后，服务端关注到了数据的“变化”继续从缓冲区读接下来的 2 个字符“c”和”d”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212608947.png" alt="image-20240815212608947"></p><h4 id="小结"><strong>小结</strong></h4><p>本文通过 10 个问题，其实也是从 10 个不同的视角去观察 epoll 这间宏伟的殿堂。至此也基本介绍完了 epoll 从监视事件，到内部数据结构组织、事件处理，最后到 epoll_wait 返回的整体工作过程。最后附上一张 epoll 相关数据结构间的关系图，在学习 epoll 过程中它曾解答了我心中不少的疑惑，我愿称之为灯塔~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212620217.png" alt="image-20240815212620217"></p><p>补充：<a href="https://cloud.tencent.com/developer/article/2420478">20种不同并发模型示例，带你深入理解并发模型</a></p><p><strong>参考资料</strong></p><ol><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Ffd3kyt.github.io%2Fposts%2Fimplementation-of-epoll%2F&amp;source=article&amp;objectId=1831360"><strong>Implementation of Epoll</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Flatest%2Fcore-api%2Frbtree.html&amp;source=article&amp;objectId=1831360"><strong>Red-black Trees (rbtree) in Linux</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F9162712%2Fwhat-is-the-purpose-of-epolls-edge-triggered-option&amp;source=article&amp;objectId=1831360"><strong>What is the purpose of epoll’s edge triggered option?</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Ficoty.github.io%2F2019%2F06%2F03%2Fepoll-source%2F&amp;source=article&amp;objectId=1831360"><strong>epoll 源码分析(基于 linux-5.1.4)</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F81610605e623&amp;source=article&amp;objectId=1831360"><strong>epoll 实现原理</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.programmersought.com%2Farticle%2F73753380894%2F&amp;source=article&amp;objectId=1831360"><strong>epoll (2) source code analysis</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fblog.csdn.net%2Fwallwind%2Farticle%2Fdetails%2F8981641&amp;source=article&amp;objectId=1831360"><strong>epoll 的内核实现</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fprogramming.vip%2Fdocs%2Flinux-kernel-notes-epoll-implementation-principle.html&amp;source=article&amp;objectId=1831360"><strong>Linux Kernel Notes: epoll Implementation Principle</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fpureage.info%2F2015%2F12%2F22%2Fthundering-herd.html&amp;source=article&amp;objectId=1831360"><strong>accept 与 epoll 惊群</strong></a></li></ol>]]></content>
    
    
    <summary type="html">Epoll经典十问</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>动态库搜索路径</title>
    <link href="https://penge666.github.io/posts/7c160fcc.html"/>
    <id>https://penge666.github.io/posts/7c160fcc.html</id>
    <published>2024-07-25T09:10:51.000Z</published>
    <updated>2024-08-24T08:26:51.484Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：之前在503的时候经常因为动态库找不到而烦恼，今天这篇文章就对其查找顺序简单梳理下 ~~~</p><p>在 Linux 系统中，指定动态库搜索路径有多种方法，以下是五种常用的方法及它们的优先级顺序（从高到低）</p><p>针对一个程序想知道使用 <code>ldd</code> 命令来查看一个可执行文件或共享库的依赖库，并检查这些库是否能够正确加载。</p><h2 id="动态库路径">动态库路径</h2><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">✘ ⚙ penge@penge-virtual-machine  ~/Desktop/test  ldd ./main</span><br><span class="line">       linux-vdso.so.1 (0x00007ffc160f8000)</span><br><span class="line">       libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f4855d57000)</span><br><span class="line">       libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f4855d32000)</span><br><span class="line">       libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4855d0f000)</span><br><span class="line">       libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4855b1d000)</span><br><span class="line">       libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f48559ce000)</span><br><span class="line">       /lib64/ld-linux-x86-64.so.2 (0x00007f4855fe6000)</span><br></pre></td></tr></table></figure><p>这些动态库的信息在**<code>.dynamic</code> 段**。</p><p><strong>在程序启动时指定（<code>LD_PRELOAD</code> 环境变量）</strong></p><ul><li>优先级最高。使用 <code>LD_PRELOAD</code> 可以强制程序优先加载指定的动态库，而不是使用程序默认链接的库。这对于调试或替换特定库非常有用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=/path/to/custom/library.so ./your_program</span><br></pre></td></tr></table></figure><p><strong>在程序启动时指定（<code>LD_LIBRARY_PATH</code> 环境变量）</strong></p><ul><li><code>LD_LIBRARY_PATH</code> 环境变量指定了动态链接器在运行时应该优先搜索的动态库路径。它覆盖默认路径，但低于 <code>LD_PRELOAD</code> 的优先级。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/custom/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./your_program</span><br></pre></td></tr></table></figure><p>【特别注意】：</p><p><strong><code>LD_LIBRARY_PATH</code> 的设置只对当前 shell 会话以及从这个 shell 启动的子进程有效</strong>。如果你在一个新的终端或 shell 会话中，需要重新设置 <code>LD_LIBRARY_PATH</code>，或者将其设置到用户的环境配置文件中（如 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code>）以使其永久生效。</p><blockquote><p><strong>.bashrc文件介绍</strong></p></blockquote><p>.bashrc，属于一种系统隐藏文件，.bashrc就是这个终端里面指令运行的<strong>配置脚本</strong>。</p><p>当我们要配置.bashrc时，可以通过 nano 或者 vi / vim指令对.bashrc进行编辑，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br><span class="line">vim ~/.bashrc</span><br><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure><p>对bashrc做出任何的修改，都<strong>将会在下一次启动终端时候生效</strong>。如果希望<strong>立即生效</strong>，可以执行source指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>在链接时指定（<code>-rpath</code> 编译选项）</strong></p><ul><li><code>-rpath</code> 是在编译时指定的选项，用于指定程序在运行时搜索动态库的路径。<code>-rpath</code> 的优先级高于默认路径和 <code>/etc/ld.so.conf</code> 配置的路径，但低于 <code>LD_LIBRARY_PATH</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -Wl,-rpath,/path/to/custom/libs</span><br></pre></td></tr></table></figure><p><strong>在系统配置中指定（<code>/etc/ld.so.conf</code> 和 <code>/etc/ld.so.conf.d/</code>）</strong></p><ul><li>通过修改 <code>/etc/ld.so.conf</code> 文件或在 <code>/etc/ld.so.conf.d/</code> 目录中添加配置文件，可以指定系统全局的动态库搜索路径。<strong>需要在修改配置后运行 <code>ldconfig</code> 命令来更新缓存。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/path/to/custom/libs&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/ld.so.conf.d/custom.conf</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><ol><li><p><strong>默认搜索路径</strong></p><ul><li><p>如果没有通过上述方法指定，系统会按照默认路径来搜索动态库，通常包括 <code>/lib</code>, <code>/usr/lib</code>, <code>/lib64</code>, <code>/usr/lib64</code> 等目录。</p></li><li><p>直接运行程序即可，系统会根据默认路径加载动态库。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./your_program</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>/etc/ld.so.conf</strong></p></blockquote><p><code>/etc/ld.so.conf</code> 是系统全局配置文件，通常位于 <code>/etc/</code> 目录下。它由系统管理员或安装包的脚本配置，用来为所有用户和进程设置额外的动态库搜索路径。</p><p>文件的内容是由每行一个路径组成的列表，每个路径代表一个要添加到动态链接器搜索路径中的目录。路径可以是绝对路径，也可以是包含变量的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib</span><br><span class="line">/opt/custom/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br></pre></td></tr></table></figure><p>上面的示例将 <code>/usr/local/lib</code>、<code>/opt/custom/lib</code> 和 <code>/usr/lib/x86_64-linux-gnu</code> 添加到系统的动态库搜索路径中。</p><p><strong>包含其他配置文件</strong></p><p><code>/etc/ld.so.conf</code> 文件还可以包含对其他配置文件的引用，这通常通过 <code>include</code> 关键字实现。这允许将不同的路径配置分离到多个文件中，便于管理。</p><p><strong>示例</strong>：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span>.<span class="keyword">d</span><span class="comment">/*.conf</span></span><br></pre></td></tr></table></figure><p>这行配置会将 <code>/etc/ld.so.conf.d/</code> 目录下所有以 <code>.conf</code> 结尾的文件中的路径添加到动态链接器的搜索路径中。</p><p><strong>补充：</strong></p><p>动态链接库的大致过程介绍</p><p><strong>1.ELF 文件与 <a href="http://ld.so">ld.so</a> 的启动</strong></p><p>用户执行一个使用动态库的程序时，内核通过解析 ELF 文件的 Program Header 表来找到并启动 <code>ld.so</code> 动态链接器。</p><p>使用 <code>readelf</code> 工具查看 ELF 文件中的 Program Header</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l /bin/ls</span><br></pre></td></tr></table></figure><p>在输出中，可以看到包含动态段的入口，如 <code>.interp</code> 段，该段指定了动态链接器的位置（如 <code>/lib64/ld-linux-x86-64.so.2</code>）。</p><p><strong>2.动态库的查找过程</strong></p><p>去.dymaic查看所需的动态库！</p><p><code>ld.so</code> 在加载可执行文件后，会根据多种方式查找所依赖的动态库，具体顺序如下：</p><ul><li><strong><code>LD_PRELOAD</code></strong>: 优先加载由 <code>LD_PRELOAD</code> 环境变量指定的库。</li><li><strong><code>LD_LIBRARY_PATH</code></strong>: 然后查找由 <code>LD_LIBRARY_PATH</code> 环境变量指定的路径。</li><li><strong><code>rpath</code> 和 <code>runpath</code></strong>: ELF 文件中指定的库搜索路径。</li><li><strong><code>/etc/ld.so.conf</code> 和 <code>ld.so.cache</code></strong>: 全局配置的库路径。</li><li><strong>默认路径</strong>: 系统默认的 <code>/lib</code>、<code>/usr/lib</code> 等路径。</li></ul><p><strong>3. 符号解析与重定位</strong></p><p><code>ld.so</code> 在加载库后，负责解析这些库中的符号（如函数和全局变量），并进行重定位，使得程序可以正确调用库中的函数或访问库中的数据。</p><ul><li><strong>符号表</strong>：<code>ld.so</code> 从 ELF 文件中的 <code>.dynsym</code> 段加载符号表，并根据符号名在所有加载的库中查找对应的符号地址。</li><li><strong>重定位</strong>：对于未确定的地址（符号位置），<code>ld.so</code> 根据实际加载库的内存地址对其进行重定位。</li></ul><p><strong>例子</strong>：使用 GDB 查看符号表和重定位条目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb /usr/bin/curl</span><br><span class="line">(gdb) info <span class="built_in">functions</span>  <span class="comment"># 查看所有函数符号</span></span><br><span class="line">(gdb) info variables  <span class="comment"># 查看所有变量符号</span></span><br></pre></td></tr></table></figure><p><strong>4. 延迟绑定（Lazy Binding）</strong></p><p>为了提升性能，<code>ld.so</code> 采用延迟绑定机制，只有在函数首次调用时才进行符号解析。这种方式减少了程序启动时的开销。</p><ul><li><strong>PLT（Procedure Linkage Table）</strong>：用于实现延迟绑定的表，每次函数调用时，先跳转到 PLT 表中的入口，该入口再调用动态链接器解析函数的实际地址。</li><li><strong>GOT（Global Offset Table）</strong>：保存已解析的函数地址，当再次调用时，直接从 GOT 中获取函数地址，避免重复解析。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d -j .plt /usr/bin/curl</span><br></pre></td></tr></table></figure><p><strong>objdump命令</strong>是用查看目标文件或者可执行的目标文件的构成的gcc工具。</p><p><strong>补充：linux程序启动</strong></p><p>Linux操作系统下应用程序的启动过程和Win32有类似之处，在 Linux 下应用程序加载和执行的具体步骤如下。</p><p>第1步:用户在 linux命令终端中输入运行程序的命令，然后按回车键。</p><p>第2步:首先接管的是 exec系统调用，它会为应用程序的运行准备一些环境变量等，并且为运行的命令找到相应的解释器。</p><p>第3步:通常应用程序的解释器就是ld (loader/加载器)，ld接管控制权后首先需要读入这个可执行程序的文件的一部分，包括文件头及共享对象(so，对应于Windows下的动态链接库）区等。然后检查这个可执行文件所依赖的共享对象so（这些信息都在可执行文件中)，并且在 LD_LIBRARY_PATH和系统默认库文件夹的位置查找这些库是否存在。如果不存在，则报告错误并退出执行。</p><p>第4步:针对每一个依赖的库，ld需要首先读入这个so的一部分文件头和相关信息。然后递归查找该共享对象所依赖的其他共享对象，直到最底层。在这个过程中，ld 会在内部维护一个数据结构用来记录所有这些共享对象之间的相互依赖关系。最终，ld会确认所有的该可执行程序直接或间接依赖的so都存在。</p><p>第5步:ld会把所有依赖的so映射到该程序的进程空间的虚拟内存中(只是映射，并不是把全部 so文件的内容读入内存)。显然，每一个共享对象在该进程的虚拟内存空间中占据不同的连续区域。它们的“基地址”各不相同，从而其内部的一些用绝对地址表示的符号需要做出相应的修改。这个过程称为“relocation过程”。</p><p>第6步:初始化应用程序的全局变量，对于全局对象自动调用构造函数。第7步:进入main函数开始执行。</p><h2 id="优化动态库">优化动态库</h2><h3 id="减少动态链接库的数量">减少动态链接库的数量</h3><p>减少动态链接库的数量是提高程序启动性能的一个重要原则，是构造大型应用程序时需要考虑的首要问题。例如<strong>微软的Office 套件程序启动时只需要两个动态链接库</strong>。根据实践经验，如果一个应用程序启动时需要加载的动态链接库达到数十个，则把这些动态库的数量减少到10个以内，至少可以提高启动性能达15%。在性能优化工程实践中，减少应用程序启动时需要加载的动态链接库数量可以通过如下两种方法来实现。</p><p>1.修改代码</p><p>2.合并动态库</p><p>把功能相近或者依赖关系密切的动态库合并成一个库。我认为是减少读盘次数</p><h3 id="减小动态链接库尺寸">减小动态链接库尺寸</h3><p>使用 <code>strip</code> 命令:</p><ul><li><p><code>strip</code> 命令可以从目标文件或者可执行文件中<strong>删除符号表信息</strong>,从而减小文件大小。</p></li><li><p>示例命令:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strip -s libfoo.so</span><br></pre></td></tr></table></figure></li><li><p>这将从 <code>libfoo.so</code> 动态库中删除符号表信息,从而缩小文件大小。</p></li></ul><p>原理</p><ol><li>可执行程序在链接时,只需要使用动态库中的符号信息,而不需要完整的符号表信息。</li><li>当可执行程序在运行时,需要动态加载动态库并解析其中的符号信息。即使动态库中没有完整的符号表信息,但仍然可以正确解析所需的符号。</li></ol><p>所以通常情况下,使用 <code>strip -s</code> 命令删除动态库中的符号表信息,不会影响该动态库的正常使用。这种方式可以有效地减小动态库的文件大小,而不会影响应用程序的正常运行。</p>]]></content>
    
    
    <summary type="html">动态库搜索路径</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议学习</title>
    <link href="https://penge666.github.io/posts/61c8c4f5.html"/>
    <id>https://penge666.github.io/posts/61c8c4f5.html</id>
    <published>2024-07-22T09:01:48.000Z</published>
    <updated>2024-07-22T09:34:54.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、QUIC-简介"><strong>1、QUIC 简介</strong></h3><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171232702.png" alt="image-20240722171232702"></p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h3 id="2、QUIC-实现原理"><strong>2、QUIC 实现原理</strong></h3><h4 id="2-1、数据格式"><strong>2.1、数据格式</strong></h4><p>一个 QUIC 数据包的格式如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171314750.png" alt="image-20240722171314750"></p><p>由 header 和 data 两部分组成。</p><p>header 是明文的，包含 4 个字段：Flags、Connection ID、QUIC Version、Packet Number；</p><p>data 是加密的，可以包含 1 个或多个 frame，每个 frame 又分为 type 和 payload，其中 payload 就是应用数据；</p><p>数据帧有很多类型：Stream、ACK、Padding、Window_Update、Blocked 等，这里重点介绍下用于传输应用数据的 Stream 帧。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171320083.png" alt="image-20240722171320083"></p><p><strong>Frame Type：</strong> 帧类型，占用 1 个字节</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171324906.png" alt="image-20240722171324906"></p><p>（1）Bit7：必须设置为 1，表示 Stream 帧</p><p>（2）Bit6：如果设置为 1，表示发送端在这个 stream 上已经结束发送数据，流将处于半关闭状态</p><p>（3）Bit5：如果设置为 1，表示 Stream 头中包含 Data length 字段</p><p>（4）Bit432：表示 offset 的长度。000 表示 0 字节，001 表示 2 字节，010 表示 3 字节，以此类推</p><p>（5）Bit10：表示 Stream ID 的长度。00 表示 1 字节，01 表示 2 字节，10 表示 3 字节，11 表示 4 字节</p><p><strong>Stream ID：</strong> 流 ID，用于标识数据包所属的流。后面的流量控制和多路复用会涉及到</p><p>**Offset：**偏移量，表示该数据包在整个数据中的偏移量，用于数据排序。</p><p><strong>Data Length：</strong> 数据长度，占用 2 个字节，表示实际应用数据的长度</p><p><strong>Data：</strong> 实际的应用数据</p><h4 id="2-2、建立连接"><strong>2.2、建立连接</strong></h4><p>先分析下 HTTPS 的握手过程，包含 TCP 握手和 TLS 握手，TCP 握手：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171428707.png" alt="image-20240722171428707"></p><p>从图中可以看出，TCP 握手需要 2 个 RTT。</p><p>TLS 握手：密钥协商（1.3 版本）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171450629.png" alt="image-20240722171450629"></p><p>从图中可以看出，TLS 握手需要 1 个 RTT，也就是 1 次 RTT 就把通信密钥协商好了，这是怎么做到的？</p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）服务器：生成随机数 b，计算 B=b*G%P，将 B 发送给客户端，也就是 Server Hello 消息</p><p>（3）客户端：使用 ECDH 算法生成通信密钥 KEY = a * B = a * b * G%P</p><p>（4）服务器：使用 ECDH 算法生成通信密钥 KEY = b * A = b * a * G%P</p><p>所以，这里的关键就是 ECDH 算法，a 和 b 是客户端和服务器的私钥，是不公开的，而其他参数是公开的。ECDH 算法有个非常重要的特征：即使知道 A、G、P，通过 A = a*G%P 公式也是无法推到出 a 的，保证了私钥的安全性。</p><p>综上所述，HTTPS 建立连接需要 3 个 RTT，由于 QUIC 的握手是基于 TLS1.3 实现的，所以首次建立连接时也是需要 1 次 RTT，那 QUIC 是如何做到 0-RTT 握手的呢？</p><h5 id="2-2-1、0-RTT-握手"><strong>2.2.1、0-RTT 握手</strong></h5><p>其实原理很简单：客户端缓存了 ServerConfig（B=b*G%P），下次建连直接使用缓存数据计算通信密钥：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171543971.png" alt="image-20240722171543971"></p><p>（1）客户端：生成随机数 c，选择公开的大数 G 和 P，计算 A=c*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算通信密钥 KEY = c <em>B =  c * b</em>G%P，加密发送应用数据</p><p>（3）服务器：根据 Client Hello 消息计算通信密钥 KEY = b * A = b * c*G%P</p><p>也就是说，客户端不需要经过握手就可以发送应用数据，这就是 0-RTT 握手。再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数（A1=a * G%P，A2=c * G%P，…），一旦服务器的随机数 b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。</p><p>为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性</p><h5 id="2-2-2、前向安全"><strong>2.2.2、前向安全</strong></h5><p>前向安全：是指用来产生会话密钥的长期密钥泄露出去，不会泄漏以前的通讯内容。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171728670.png" alt="image-20240722171728670"></p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算初始密钥 initKey = a<em>B = a</em>b*G%P，加密发送应用数据 1</p><p>（3）服务器：根据 Client Hello 消息计算初始密钥 initKey = b<em>A = b</em>a*G%P</p><p>（4）服务器：生成随机数 c，计算 C=c*G%P，使用 initKey 加密 C，发送给客户端，也就是 Server Hello 消息</p><p>（5）客户端：使用 initKey 解码获取 C，计算会话密钥 sessionKey = a<em>C = a</em>c*G%P，加密发送应用数据 2</p><p>（6）服务器：计算会话密钥 sessionKey = c<em>A = c</em>a*G%P，解密获取应用数据 2</p><p>客户端缓存的 ServerConfig 是服务器静态配置的，是可以长期使用的。客户端通过 ServerConfig 实现 0-RTT 握手，使用会话密钥 sessionKey 保证通信数据的前向安全。</p><p><strong>详细解释：</strong></p><p>为了让前向安全的过程更加通俗易懂，我们可以将它与一个简单的比喻结合起来。这种机制可以确保即使某个时刻的密钥泄露，也不会影响之前的通信安全。我们可以将这个过程想象成两个朋友（客户端和服务器）在通信时进行的秘密交换：</p><ol><li><p><strong>客户端生成随机数a，选择公开的大数G和P，计算A=a*G%P，并将A和G发送给服务器，这相当于Client Hello消息</strong>：</p><p>想象两个朋友A（客户端）和B（服务器）想要交换秘密信息。A生成了一个随机数a，并选择了一个共同使用的公开的“大数”G和P。A计算了一个值A=a*G%P，并将这个值A和大数G发送给B。这就像A告诉B：“这是我的公开信息。”</p></li><li><p><strong>客户端使用缓存的ServerConfig计算初始密钥initKey=aB=ab*G%P，并加密发送应用数据1</strong>：</p><p>A使用之前存储的服务器配置信息（ServerConfig）计算一个初始密钥initKey=a*B，其中B是服务器的公开信息。然后，A使用这个初始密钥来加密一些信息，并将其发送给B。</p></li><li><p><strong>服务器根据Client Hello消息计算初始密钥initKey=bA=ba*G%P</strong>：</p><p>B收到A的公开信息后，也生成了一个随机数b。B使用这个随机数和A发送的公开信息计算了同样的初始密钥initKey=b*A。这样，A和B现在都有了一个相同的初始密钥。</p></li><li><p><strong>服务器生成随机数c，计算C=c*G%P，使用initKey加密C，发送给客户端，即Server Hello消息</strong>：</p><p>B生成另一个随机数c，并计算一个新的值C=c*G%P。B使用之前计算的初始密钥initKey加密这个新值C，然后将加密后的C发送给A。这就像B告诉A：“这是我生成的新秘密信息，但你需要用我们的初始密钥来解密它。”</p></li><li><p><strong>客户端使用initKey解码获取C，计算会话密钥sessionKey=aC=ac*G%P，并加密发送应用数据2</strong>：</p><p>A使用初始密钥解密B发送的C，然后计算一个新的会话密钥sessionKey=a*C。A使用这个会话密钥来加密新的信息，并将其发送给B。</p></li><li><p><strong>服务器计算会话密钥sessionKey=cA=ca*G%P，解密获取应用数据2</strong>：</p><p>B也使用C和A发送的公开信息计算同样的会话密钥sessionKey=c*A。然后，B使用这个会话密钥来解密A发送的加密信息。</p></li></ol><p>通过这个过程，客户端和服务器能够在不暴露各自秘密的情况下生成相同的会话密钥，从而确保通信的前向安全。这意味着即使未来某个密钥被泄露，也不会影响之前的通信内容的安全性。</p><h4 id="2-3、可靠传输"><strong>2.3、可靠传输</strong></h4><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171841278.png" alt="image-20240722171841278"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN = 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN=4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN=2）和重传的数据包（PKN=4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171905289.png" alt="image-20240722171905289"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h4 id="2-4、流量控制"><strong>2.4、流量控制</strong></h4><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171922763.png" alt="image-20240722171922763"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171935952.png" alt="image-20240722171935952"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171947478.png" alt="image-20240722171947478"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 = 60</p><h4 id="2-5、拥塞控制"><strong>2.5、拥塞控制</strong></h4><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd = min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h5 id="2-5-1、慢启动"><strong>2.5.1、慢启动</strong></h5><p>初始拥塞窗口大小 cwnd=1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS = 1500（MTU）- 20（IP 首部）- 8（UDP 首部） = 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets <span class="operator">=</span> <span class="number">2000</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;= ssthresh</strong> 时，使用拥塞避免算法</li></ul><h5 id="2-5-2、拥塞避免"><strong>2.5.2、拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1/cwnd</p><p>假设现在的 cwnd=8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h5 id="2-5-3、拥塞发生"><strong>2.5.3、拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = 1</li></ul><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd = cwnd / 2</li><li>ssthresh = cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h5 id="2-5-4、快速恢复"><strong>2.5.4、快速恢复</strong></h5><p>快速恢复算法：cwnd = ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><h5 id="2-5-5、常见算法"><strong>2.5.5、常见算法</strong></h5><ul><li>New Reno：基于丢包检测</li><li>CUBIC：基于丢包检测</li><li>BBR：基于网络带宽</li></ul><p>和 TCP 不同的是，QUIC 是在用户空间实现的拥塞控制，可以非常灵活的设置，甚至可以为每一个请求都设置一种拥塞控制算法。</p><h4 id="2-6、多路复用"><strong>2.6、多路复用</strong></h4><p>多路复用是 HTTP/2 的主要特性之一。</p><p>概念：单条 TCP 连接上可以同时发送多个 HTTP 请求，解决了 HTTP1.1 中单个连接 1 次只能发送 1 个请求的性能瓶颈。<strong>HTTP/2 能实现多路复用的根本原因是采用了二进制帧格式的数据结构</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172100507.png" alt="image-20240722172100507"></p><ul><li>Length：表示 Payload 的长度</li><li>Type：表示帧类型</li><li>Flags：帧标识</li><li>Stream ID：数据帧所属的流</li><li>Payload：应用数据，长度由 Length 字段指定</li></ul><p>一个请求就对应一条流，通过 Stream ID 就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID 分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172118432.png" alt="image-20240722172118432"></p><p>虽然在 HTTP 应用层，可以同时发送多个请求，但是在 TCP 传输层，仍然只有 1 个滑动窗口来发送这些数据包，考虑下面的情形：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172132726.png" alt="image-20240722172132726"></p><p>客户端发送的 5 个数据包（56789）服务器都收到了，并且回应了 5 个 ACK，但是第 5 个数据包的 ACK 丢失了，导致客户端的发送窗口无法向前移动，也就无法发送新的数据，这就是 TCP 层的队头阻塞问题。</p><p>HTTP/2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞。那 QUIC 是如何解决 TCP 层的队头阻塞问题的呢？其实很简单，HTTP/2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口**，那如果给每个请求流都分配一个独立的滑动窗口**，是不是就可以解决这个问题了？</p><p>QUIC 就是这么做的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172143472.png" alt="image-20240722172143472"></p><p>A 请求流上的丢包不会影响 B 请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然 QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC 声明的无队头阻塞的多路复用。</p><h4 id="2-7、连接迁移"><strong>2.7、连接迁移</strong></h4><p>连接迁移：<strong>当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信</strong>，对于 TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源 IP、源端口、目的 IP、目的端口，只要其中 1 个发生变化，就需要重新建立连接。但 QUIC 的连接是基于 64 位的 Connection ID，网络切换并不会影响 Connection ID 的变化，连接在逻辑上仍然是通的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172203987.png" alt="image-20240722172203987"></p><p>假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为 IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID 字段可以判断这 4 个包是来自于同一个客户端。QUIC 能实现连接迁移的根本原因是底层使用 UDP 协议就是面向无连接的。</p><p>补充：<strong>Connection ID</strong>：每个QUIC连接都有一个唯一的Connection ID。当客户端和服务器建立连接时，它们交换并存储彼此的Connection ID！</p><h3 id="3、QUIC-小结"><strong>3、QUIC 小结</strong></h3><p>本文尽量用通俗易懂的语言介绍了 QUIC 协议实现原理，目的是让大家对 QUIC 有一个基本的了解，当然，这只是 QUIC 协议的冰山一角，更详细具体的内部实现还需要深入研究标准文档和源码，如果文中有描述不对的地方，欢迎批评指正，多多交流</p><p>本文学习自:<a href="https://zhuanlan.zhihu.com/p/405387352">QUIC 协议详解</a></p>]]></content>
    
    
    <summary type="html">QUIC 协议详解</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-多级反馈队列</title>
    <link href="https://penge666.github.io/posts/40ab952d.html"/>
    <id>https://penge666.github.io/posts/40ab952d.html</id>
    <published>2024-07-18T14:04:26.000Z</published>
    <updated>2024-08-06T14:22:29.359Z</updated>
    
    <content type="html"><![CDATA[<p>进程调度有一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。</p><blockquote><p><strong>提示：从历史中学习</strong></p><p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。</p></blockquote><h2 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h2><p>MLFQ 中有许多独立的<code>队列</code>（queue），每个队列有不同的<code>优先级</code>（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是<strong>优先执行较高优先级</strong>的工作（即在<strong>较高级队列</strong>中的工作）。对于同一个队列中的任务，采用<code>轮转调度</code>。</p><p><code>MLFQ</code>中工作优先级并不是固定的，而是会根据进程的行为<code>动态调整优先级</code>。例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是<strong>交互型进程</strong>的可能行为，MLFQ 因此会让它保持<strong>高优先级</strong>。相反，如果一个工作<strong>长时间地占用</strong> CPU，MLFQ 会<strong>降低其优先级</strong>。</p><p>MLFQ 的两条基本规则:</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</li><li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B 。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806222225344.png" alt="image-20240806222225344"></p><h2 id="尝试-1：如何改变优先级"><a href="#尝试-1：如何改变优先级" class="headerlink" title="尝试 1：如何改变优先级"></a>尝试 1：如何改变优先级</h2><p>我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有<strong>运行时间很短</strong>、<strong>频繁放弃 CPU</strong> 的<code>交互型工作</code>，也有需要<strong>很多 CPU 时间</strong>、<strong>响应时间却不重要</strong>的长时间<code>计算密集型工作</code>。下面是我们第一次尝试优先级调整算法。</p><ul><li><strong>规则 3</strong> ：工作进入系统时，放在最高优先级（最上层队列）。</li><li><strong>规则 4a</strong>：工作用完整个时间片后，降低其优先级（移入下一个队列）。</li><li><strong>规则 4b</strong>：如果工作在其时间片以内主动释放 CPU，则优先级不变。</li></ul><h3 id="实例-1：单个长工作"><a href="#实例-1：单个长工作" class="headerlink" title="实例 1：单个长工作"></a>实例 1：单个长工作</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221138198.png" alt="image-20240806221138198"></p><p>从这个例子可以看出，该工作首先进入最高优先级（Q2）。执行一个 10ms 的时间片后，调度程序将工作的优先级减 1，因此进入 Q1。在 Q1 执行一个时间片后，最终降低优先级进入系统的最低优先级（Q0），并一直留在那里。</p><h3 id="实例-2：加入一个短工作"><a href="#实例-2：加入一个短工作" class="headerlink" title="实例 2：加入一个短工作"></a>实例 2：加入一个短工作</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221310794.png" alt="image-20240806221310794"></p><p>B 在 T=100 时到达</p><p>如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，<strong>MLFQ 近似于 SJF</strong>(最短任务优先)。</p><h3 id="实例-3：如果有-I-O-呢"><a href="#实例-3：如果有-I-O-呢" class="headerlink" title="实例 3：如果有 I/O 呢"></a>实例 3：如果有 I/O 呢</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221321021.png" alt="image-20240806221321021"></p><p>交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O 操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交互型工作快速运行</p><h3 id="当前-MLFQ-的一些问题"><a href="#当前-MLFQ-的一些问题" class="headerlink" title="当前 MLFQ 的一些问题"></a>当前 MLFQ 的一些问题</h3><ol><li>饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。</li><li>愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。</li><li>一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间需要作为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。因为优先级一旦下降就无法提升</li></ol><h2 id="尝试-2：提升优先级"><a href="#尝试-2：提升优先级" class="headerlink" title="尝试 2：提升优先级"></a>尝试 2：提升优先级</h2><p>为解决[1]饥饿问题</p><ul><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221329792.png" alt="image-20240806221329792"></p><ol><li><strong>左边没有优先级提升</strong>，长工作在两个短工作到达后被饿死。</li><li><strong>右边每 50ms 就有一次优先级提升</strong>（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 50ms 就被提升到最高优先级，从而定期获得执行。</li></ol><p>添加时间段 S 导致了明显的问题：S 的值应该如何设置？德高望重的系统研究员 John Ousterhout 曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。</p><h2 id="尝试-3：更好的计时方式"><a href="#尝试-3：更好的计时方式" class="headerlink" title="尝试 3：更好的计时方式"></a>尝试 3：更好的计时方式</h2><p>为解决[2]愚弄调度程序问题</p><p>起因是规则 4a 和 4b 不合理，调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。</p><p>重写规则 4：</p><ul><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221337806.png" alt="image-20240806221337806"></p><p>没有<strong>规则 4</strong>的保护时，进程可以在每个时间片结束前发起一次 I/O 操作，从而垄断 CPU 时间。有了这样的保护后，不论进程的 I/O 行为如何，都会慢慢地降低优先级，因而无法获得超过公平的 CPU 时间比例。同时由于<strong>规则 5</strong>的存在，原来的交互性进程还是可以在之后提升优先级。</p><h2 id="MLFQ-调优及其他问题"><a href="#MLFQ-调优及其他问题" class="headerlink" title="MLFQ 调优及其他问题"></a>MLFQ 调优及其他问题</h2><p>关于 MLFQ 调度算法还有一些问题。其中一个大问题是<strong>如何配置</strong>一个调度程序，例如：</p><ol><li>配置多少队列？</li><li>每一层队列的时间片配置多大？</li><li>为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</li></ol><p>这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221345717.png" alt="image-20240806221345717"></p><p>例如，大多数的 MLFQ 变体都支持不同队列可变的时间片长度。<strong>高优先级队列通常只有较短的时间片</strong>（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，<strong>低优先级队列</strong>中更多的是 CPU 密集型工作，配置<strong>更长的时间片</strong>会取得更好的效果。图 8.7 展示了一个例子，两个长工作在高优先级队列执行 10ms，中间队列执行 20ms，最后在最低优先级队列执行 40ms。</p><p><code>Solaris</code> 的 MLFQ 实现（<code>时分调度类 TS</code>）很容易配置。它提供了<code>一组表</code>来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级。管理员可以通过这些表，让调度程序的行为方式不同。该表默认有 60 层队列，时间片长度从 20ms（最高优先级），到几百 ms（最低优先级），每一秒左右提升一次进程的优先级。</p><p>其他一些 MLFQ 调度程序没用表，甚至没用本章中讲到的规则，有些采用数学公式来调整优先级。例如，<code>FreeBSD</code> 调度程序（4.3 版本），会基于当前进程使用了多少 CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升，但与这里描述方式不同。阅读 Epema 的论文，他漂亮地概括了这种使用量衰减（decay-usage）算法及其特征</p><p>最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的<code>建议</code>（advice），比如通过命令行工具 <code>nice</code>，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看 man 手册。</p><blockquote><p><strong>提示：尽可能多地使用建议</strong></p><p>操作系统很少知道什么策略对系统中的单个进程和每个进程算是好的，因此提供接口并允许用户或管理员给操作系统一些提示（hint）常常很有用。我们通常称之为建议（advice），因为操作系统不一定要关注它，但是可能会将建议考虑在内，以便做出更好的决定。这种用户建议的方式在操作系统中的各个领域经常十分有用，包括调度程序（通过 nice）、内存管理（madvise），以及文件系统（通知预取和缓存[P+95]）</p></blockquote><h2 id="MLFQ：小结"><a href="#MLFQ：小结" class="headerlink" title="MLFQ：小结"></a>MLFQ：小结</h2><p>本章介绍了一种调度方式，名为<code>多级反馈队列</code>（MLFQ）。</p><p>本章包含了一组优化的 MLFQ 规则。为了方便查阅，我们重新列在这里。</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</li><li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</li><li><strong>规则 3</strong>：工作进入系统时，放在最高优先级（最上层队列）。</li><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul><p>MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ 可以同时满足各种工作的需求：<strong>对于短时间运行的交互型工作，获得类似于 SJF/STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前</strong>。因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括<code>类 BSD UNIX 系统</code>、<code>Solaris</code>以及 <code>Windows NT</code> 和其后的 <code>Window 系列操作系统</code>。</p><p>最后，关于抢占式问题总结：</p><ol><li><strong>先来先服务（First-Come, First-Served, FCFS）</strong>：<ul><li>通常是非抢占式的。进程一旦获得CPU，就会一直运行直到完成或阻塞。</li></ul></li><li><strong>短作业优先（Shortest Job First, SJF）</strong>：<ul><li>可以是抢占式的，也可以是非抢占式的。抢占式的SJF称为最短剩余时间优先（Shortest Remaining Time First, SRTF），它会在新到达的进程比当前运行进程的剩余时间更短时抢占CPU。</li></ul></li><li><strong>时间片轮转（Round Robin, RR）</strong>：<ul><li>是抢占式的。每个进程被分配一个固定的时间片，当时间片用完时，当前进程被抢占，CPU分配给队列中的下一个进程。</li></ul></li><li><strong>多级反馈队列（Multilevel Feedback Queue, MFQ）</strong>：<ul><li>是抢占式的。进程可以在不同优先级的队列之间移动，高优先级的队列中的进程可以抢占低优先级队列中的进程。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">OS-多级反馈队列MLFQ</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT6.081-Lab1&amp;&amp;2</title>
    <link href="https://penge666.github.io/posts/c952f7a6.html"/>
    <id>https://penge666.github.io/posts/c952f7a6.html</id>
    <published>2024-07-16T12:08:55.000Z</published>
    <updated>2024-08-06T14:52:22.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前阅读过Linux0.11的源码，但是还是觉得远远还不够，随后入坑了这门mit6.s081. 享受lab带来的快乐~</p><h3 id="环境配置">环境配置</h3><p>网页：<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">https://pdos.csail.mit.edu/6.828/2021/tools.html</a></p><p>先说环境，笔者直接在VMWare上的Ubuntu22.04上实验的，废话少说，开干~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure><p>直接克隆即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ <span class="built_in">ls</span></span><br><span class="line">conf            gradelib.py  LICENSE   mkfs    user</span><br><span class="line">grade-lab-util  kernel       Makefile  README</span><br><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ git checkout util</span><br><span class="line">Already on <span class="string">&#x27;util&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/util&#x27;</span>.</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  make clean</span><br><span class="line"><span class="built_in">rm</span> -f *.tex *.dvi *.idx *.aux *.<span class="built_in">log</span> *.ind *.ilg \</span><br><span class="line">*/*.o */*.d */*.asm */*.sym \</span><br><span class="line">user/initcode user/initcode.out kernel/kernel fs.img \</span><br><span class="line">mkfs/mkfs .gdbinit \</span><br><span class="line">        user/usys.S \</span><br><span class="line">user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_alarmtest  user/_call user/_bttest \</span><br><span class="line">ph barrier</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  make      </span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/kalloc.o kernel/kalloc.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/string.o kernel/string.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/main.o kernel/main.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/vm.o kernel/vm.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/proc.o kernel/proc.c</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/swtch.o kernel/swtch.S</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/trampoline.o kernel/trampoline.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/trap.o kernel/trap.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/syscall.o kernel/syscall.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sysproc.o kernel/sysproc.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/bio.o kernel/bio.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/fs.o kernel/fs.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/log.o kernel/log.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sleeplock.o kernel/sleeplock.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/file.o kernel/file.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/pipe.o kernel/pipe.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/exec.o kernel/exec.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sysfile.o kernel/sysfile.c</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/kernelvec.o kernel/kernelvec.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/plic.o kernel/plic.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/virtio_disk.o kernel/virtio_disk.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/start.o kernel/start.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/console.o kernel/console.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/printf.o kernel/printf.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/uart.o kernel/uart.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/spinlock.o kernel/spinlock.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -march=rv64g -nostdinc -I. -Ikernel -c user/initcode.S -o user/initcode.o</span><br><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -N -e start -Ttext 0 -o user/initcode.out user/initcode.o</span><br><span class="line">riscv64-linux-gnu-objcopy -S -O binary user/initcode.out user/initcode</span><br><span class="line">riscv64-linux-gnu-objdump -S user/initcode.o &gt; user/initcode.asm</span><br><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -T kernel/kernel.ld -o kernel/kernel kernel/entry.o kernel/kalloc.o kernel/string.o kernel/main.o kernel/vm.o kernel/proc.o kernel/swtch.o kernel/trampoline.o kernel/trap.o kernel/syscall.o kernel/sysproc.o kernel/bio.o kernel/fs.o kernel/log.o kernel/sleeplock.o kernel/file.o kernel/pipe.o kernel/exec.o kernel/sysfile.o kernel/kernelvec.o kernel/plic.o kernel/virtio_disk.o kernel/start.o kernel/console.o kernel/printf.o kernel/uart.o kernel/spinlock.o</span><br><span class="line">riscv64-linux-gnu-objdump -S kernel/kernel &gt; kernel/kernel.asm</span><br><span class="line">riscv64-linux-gnu-objdump -t kernel/kernel | sed <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27;</span> &gt; kernel/kernel.sym</span><br></pre></td></tr></table></figure><p>离谱的操作</p><p><code>ctrl + p </code>可以查看当前进程</p><p><code>ctrl-a  x</code>可以退出sh（是按住ctrl还有a，松开手，再按下x，然后回车）</p><p>※ Note：退出 <code>ctrl + a 放开后，再按下x</code></p><h3 id="调试">调试</h3><p>这个方式有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch kernel/kernel</span><br><span class="line">（gdb）<span class="built_in">set</span> architecture riscv:rv64</span><br><span class="line">(gdb)target remote localhost:25000</span><br></pre></td></tr></table></figure><p>因此使用<code>riscv-unknown-elf-gdb</code>这条命令~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805213407210.png" alt="image-20240805213407210"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ sudo vim .gdbinit</span><br></pre></td></tr></table></figure><p>将画红框的内容加入到<code>.gdbinit</code>隐藏文件。</p><blockquote><p><strong>调试的话</strong></p></blockquote><p>一个终端开启调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  sudo make qemu-gdb</span><br><span class="line"> *** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br></pre></td></tr></table></figure><p>一个终端远程连接即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  riscv64-unknown-elf-gdb kernel/kernel</span><br><span class="line">GNU gdb (GDB) 13.1</span><br><span class="line">(gdb) target remote localhost:25000</span><br><span class="line">Remote debugging using localhost:25000</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) b main</span><br><span class="line">Note: breakpoint 1 also <span class="built_in">set</span> at pc 0x8000032e.</span><br><span class="line">Breakpoint 2 at 0x8000032e: file kernel/main.c, line 13.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at kernel/main.c:1</span><br></pre></td></tr></table></figure><p>然后就可用快乐的调试了~</p><p>Note：由于这个实验是多线程的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> CPUS</span><br><span class="line">CPUS := 1</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LAB)</span>,fs)</span><br><span class="line">CPUS := 1</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>为了调试方便，就先将这个设置成1了。</p><ul><li><a href="https://blog.csdn.net/yihuajack/article/details/116571913">xv6 2020版使用gdb调试debug的方法</a></li><li><a href="https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/">优雅的调试—在vscode上完美调试xv6（完结</a></li><li><a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">MIT 6.S081 xv6调试不完全指北</a></li><li><a href="https://github.com/monifeng/6.s081/blob/main/MIT6.s081%20gdb%E8%B0%83%E8%AF%95.md">mit6.s081 GDB调试</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># b <span class="comment">//设置断点（breakpoint）</span></span></span><br><span class="line"><span class="meta"># c <span class="comment">//继续运行（Continue）--到断点处就会停止</span></span></span><br><span class="line"><span class="meta"># n <span class="comment">//单步调试 </span></span></span><br><span class="line"><span class="meta"># p <span class="comment">//打印变量内容</span></span></span><br><span class="line"><span class="meta"># si <span class="comment">//断点定位</span></span></span><br><span class="line"><span class="meta"># display/i $pc <span class="comment">//每次停止时，都可以显示下一条指令的反汇编</span></span></span><br><span class="line"><span class="meta"># layout asm <span class="comment">//可以显示当前的汇编指令</span></span></span><br><span class="line"><span class="meta"># display /3i $pc <span class="comment">//如果您希望在单步执行程序时自动显示下3条指令,可以使用display命令</span></span></span><br><span class="line"><span class="meta"># p *path@6 <span class="comment">//这里是打印path指向的内容，打印长度为6（如果不写@6那么只能打印一个char）</span></span></span><br></pre></td></tr></table></figure><p><strong>闲话</strong>：闲着看看项目行数</p><p>统计当前目录下的所有文件行数： wc -l *</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  <span class="built_in">wc</span> -l *</span><br><span class="line"></span><br><span class="line">      4 answers-traps.txt</span><br><span class="line"><span class="built_in">wc</span>: conf: Is a directory</span><br><span class="line">      0 conf</span><br><span class="line">   3418 fs.img</span><br><span class="line">     70 grade-lab-traps</span><br><span class="line">    611 gradelib.py</span><br><span class="line"><span class="built_in">wc</span>: kernel: Is a directory</span><br><span class="line">      0 kernel</span><br><span class="line">     24 LICENSE</span><br><span class="line">    410 Makefile</span><br><span class="line"><span class="built_in">wc</span>: mkfs: Is a directory</span><br><span class="line">      0 mkfs</span><br><span class="line"><span class="built_in">wc</span>: __pycache__: Is a directory</span><br><span class="line">      0 __pycache__</span><br><span class="line">     47 README</span><br><span class="line"><span class="built_in">wc</span>: user: Is a directory</span><br><span class="line">      0 user</span><br><span class="line">     62 xv6.out</span><br><span class="line">   4646 total</span><br></pre></td></tr></table></figure><p>当前目录以及子目录的所有文件行数： find  . * | xargs wc -l</p><h2 id="Lab1">Lab1</h2><p>lab1就是简单的linux下编程，了解命令的含义编程即可。</p><h3 id="Boot-xv6-easy">Boot xv6 (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><p>这个就不截图了，能跑起了就好啦~</p><h3 id="sleep-easy">sleep (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><blockquote><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p></blockquote><p>简单来讲就是实现一个睡眠的程序，需要自己写在 <code>user/sleep.c</code> 里，一定要读一读实验手册里的hints，非常有用并且涉及到一些细节问题！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;args wrong!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> num = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">sleep</span>(num);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><ul><li>考虑输入为空或其他</li><li>将字符串转换为int类型</li><li>头文件的引用</li></ul><h3 id="pingpong-easy">pingpong (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><p>这个也不是很难</p><p><strong>实验要求</strong></p><blockquote><p>Write a program that uses UNIX system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p></blockquote><p>大义就是：用两个管道接收父子进程的数据，父进程发送一个byte，然后子进程接收后打印，然后子进程发送父进程一个byte，最后父进程打印输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> q[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(p),<span class="built_in">pipe</span>(q);</span><br><span class="line">    <span class="comment">// child </span></span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buff_child[<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// === child  first stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(p[WRITE]);</span><br><span class="line">        <span class="built_in">read</span>(p[READ],buff_child,<span class="number">6</span>);</span><br><span class="line">        <span class="type">int</span> child_pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,child_pid);</span><br><span class="line">        <span class="built_in">close</span>(p[READ]);</span><br><span class="line">        <span class="comment">// === second stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(q[READ]);</span><br><span class="line">        <span class="built_in">write</span>(q[WRITE], <span class="string">&quot;father\n&quot;</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="built_in">close</span>(q[WRITE]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> buff_fa[<span class="number">6</span>];</span><br><span class="line">        <span class="comment">// ===fa  first stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(p[READ]);</span><br><span class="line">        <span class="built_in">write</span>(p[WRITE], <span class="string">&quot;child\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">close</span>(p[WRITE]);</span><br><span class="line">        <span class="comment">// === second stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(q[WRITE]);</span><br><span class="line">        <span class="built_in">read</span>(q[READ],buff_fa,<span class="number">7</span>);</span><br><span class="line">        <span class="type">int</span> fa_pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,fa_pid);</span><br><span class="line">        <span class="built_in">close</span>(q[READ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="primes-moderate-hard">primes (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">hard</a>)</h3><p><strong>实验要求</strong></p><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p></blockquote><p>用管道编写一个筛选质数的筛选器，可以参考超链接和下图：</p><p>目标是使用pipe和fork来设置管道。第一个进程将数字2到35输入到管道中。对于每个素数，您将安排创建一个进程，该进程通过一个管道从左边的邻居读取数据，并通过另一个管道向右边的邻居写入数据。由于 xv6的文件描述符和进程数量有限，因此第一个进程可以停留在35个。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805214744151.png" alt="image-20240805214744151"></p><p><strong>思路</strong></p><p>因为稍微有一点复杂，建议理一理思路后再动手。</p><p>每次将符合要求的全部传入管道中，第一个传的一定是素数，直接打印，然后将其他符合要求的再次传入管道并传给子进程。我自己的方法是递归处理，并没有完全利用到多进程的性能，如果有改进的办法，可以提出来讨论一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL (int*)0</span></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个管道</span></span><br><span class="line">    <span class="type">int</span> pipe_fa[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(pipe_fa);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> main_pid=fork();</span><br><span class="line">    <span class="comment">// 子线程</span></span><br><span class="line">    <span class="keyword">if</span>(main_pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[WRITE]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 定义子线程</span></span><br><span class="line">            <span class="type">int</span> pipe_child[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">pipe</span>(pipe_child); </span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num;</span><br><span class="line">            <span class="type">int</span> res_read = <span class="built_in">read</span>(pipe_fa[READ],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            <span class="keyword">if</span>(res_read==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            ans[cnt++]=num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,num);</span><br><span class="line">            <span class="comment">// printf(&quot;debug:answer generate%d\n&quot;,num);</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> res_read_ = <span class="built_in">read</span>(pipe_fa[READ],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                <span class="comment">// printf(&quot;debug:read num:%d res_read_:%d\n&quot;,num,res_read_);</span></span><br><span class="line">                <span class="keyword">if</span>(res_read_==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num%ans[cnt<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="built_in">write</span>(pipe_child[WRITE],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(pipe_child[WRITE]);</span><br><span class="line">            <span class="comment">// printf(&quot;debug:finish %d\n&quot;,num);</span></span><br><span class="line">            <span class="comment">// 循环迭代</span></span><br><span class="line">            <span class="type">int</span> pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 子线程</span></span><br><span class="line">                pipe_fa[READ] = <span class="built_in">dup</span>(pipe_child[READ]);</span><br><span class="line">                <span class="built_in">close</span>(pipe_child[READ]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 父线程</span></span><br><span class="line">                <span class="built_in">close</span>(pipe_child[READ]);</span><br><span class="line">                <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[READ]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">write</span>(pipe_fa[WRITE],&amp;i,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[WRITE]);</span><br><span class="line">        <span class="comment">// printf(&quot;debug:main input[2~35]\n&quot;);</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);       <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;cnt;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;,ans[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805214107322.png" alt="image-20240805214107322"></p><h2 id="Lab2">Lab2</h2><h3 id="System-call-tracing-moderate">System call tracing (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)</h3><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>在这个作业中，您将添加一个系统调用跟踪特性，它可以帮助您调试以后的实验室。您将创建一个新的跟踪系统调用来控制跟踪。它应该采用一个参数，一个整数“掩码”，其位指定哪个系统调用跟踪。例如，为了跟踪 fork 系统调用，程序调用 trace (1 &lt; &lt; SYS _ fork) ，其中 SYS _ fork 是 kernel/syscall.h 中的系统调用号。如果在掩码中设置了系统调用的编号，则必须修改 xv6内核，以便在每个系统调用即将返回时输出一行。这一行应该包含进程 id、系统调用的名称和返回值; 您不需要打印系统调用参数。跟踪系统调用应该能够跟踪调用它的进程及其随后分支的任何子进程，但不应影响其他进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ trace 2147483647 grep hello README</span><br><span class="line">4: syscall trace -&gt; 0</span><br><span class="line">4: syscall <span class="built_in">exec</span> -&gt; 3</span><br><span class="line">4: syscall open -&gt; 3</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">4: syscall close -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408</span><br><span class="line">408: syscall fork -&gt; 409</span><br><span class="line">409: syscall fork -&gt; 410</span><br><span class="line">410: syscall fork -&gt; 411</span><br><span class="line">409: syscall fork -&gt; 412</span><br><span class="line">410: syscall fork -&gt; 413</span><br><span class="line">409: syscall fork -&gt; 414</span><br><span class="line">411: syscall fork -&gt; 415</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先聊下添加系统调用的步骤：</p><p>添加系统调用主要有以下几步：</p><ul><li>在user/user.h中添加系统调用函数的定义。</li><li>在user/usys.pl中添加入口，这个文件将会在make后生成user/usys.S文件，在该汇编文件中，每个函数就只有三行，将系统调用号通过li(load imm)存入a7寄存器，之后使用ecall进入内核态，最后返回。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exit</span><br></pre></td></tr></table></figure><ul><li><p>在kernel/syscall.h中定义系统调用号。</p></li><li><p>在kernel/syscall.c的syscalls函数指针数组中添加对应的函数。在syscall函数中，先读取trapframe-&gt;a7获取系统调用号，之后根据该系统调用号查找syscalls数组中的对应的处理函数并调用。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805235021773.png" alt="image-20240805235021773"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">initlock</span>(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)<span class="built_in">PGROUNDUP</span>((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    <span class="built_in">kfree</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kfree</code> 函数的主要功能是将一个内存页标记为空闲，并将其添加到空闲内存链表中。它首先检查传入的地址是否有效，然后填充内存页以捕获悬空引用，最后将内存页添加到空闲链表中，并确保操作是线程安全的。这样可以确保内存页在后续的内存分配中可以被重新使用。</p><p>整个详细流程可见：</p><ul><li><p><a href="https://juejin.cn/user/2392979529797981/posts">[mit6.s081] 笔记 Lab2: System calls | 系统调用</a></p></li><li><p><a href="https://blog.csdn.net/ahundredmile/article/details/125512247">6.S081 Lab00 xv6启动过程（从代码出发，了解操作系统启动过程）</a></p></li><li><p><a href="https://leenjewel.github.io/blog/2015/11/11/%5B%28xue-xi-xv6%29%5D-nei-he-gai-lan/">【学习Xv6】 内核概览</a></p></li><li><p><a href="https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#25-lab-2-system-calls">MIT 6.S081 Lecture Notes</a></p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805234706950.png" alt="image-20240805234706950"></p>]]></content>
    
    
    <summary type="html">XV6-热身环节</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>32位的int和32位的float，谁能表示的数多</title>
    <link href="https://penge666.github.io/posts/7b5b2d72.html"/>
    <id>https://penge666.github.io/posts/7b5b2d72.html</id>
    <published>2024-07-15T11:58:22.000Z</published>
    <updated>2024-08-06T14:59:44.768Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://www.cnblogs.com/any91/p/14784786.html">同样是占32个坑，凭啥你float就比int的范围更大？</a></h1><p>原文出处：<a href="https://zhuanlan.zhihu.com/p/84453627?from_voters_page=true">https://zhuanlan.zhihu.com/p/84453627?from_voters_page=true</a></p><p>ok，这里先说明一下，假设是在32位的机器上，int是32位。而float使用的是IEEE 754标准的单精度浮点数格式也是占用32位。</p><p>这时候float和int都是占用32位，占用同样的空间，但float范围是更大的，那我们为啥还要int呢？为啥不节省空间，只用float？我们来一探究竟！他们在计算机的大脑里是如何记忆的？</p><p><strong>ok，这里先说明一下，假设是在32位的机器上，int是32位。而float使用的是IEEE 754标准的单精度浮点数格式也是占用32位。</strong></p><p>这时候float和int都是占用32位，占用同样的空间，但float范围是更大的，那我们为啥还要int呢？为啥不节省空间，只用float？我们来一探究竟！他们在计算机的大脑里是如何记忆的？</p><h2 id="1、int对32个坑是如何使用的？">1、int对32个坑是如何使用的？</h2><p>int类型的使用方法，大多学过计算机的，应该都是非常清楚的。二进制存储即可。</p><p><strong>例1：请写出165(10进制)使用32位int型存储在计算机中的形式。</strong></p><p>10进制转换为2进制，我个人喜欢先转为16进制，再写成2进制。</p><p>如下： 16510⇒10×16+5×1⇒A516⇒10100101</p><p>那么165在32位int型中是这样存储的（中间的0，我省略了）：</p><p><img src="https://pic4.zhimg.com/80/v2-d275288a53e69f37d8d1a1e4842da7cb_720w.webp" alt="img"></p><p>165在计算机中的int存储</p><p>非常简单明了，好理解。把10进制转换2进制，直接存进去就ok，前面空位补0。</p><p><strong>例2：请写出-165(10进制)使用32位int型存储在计算机中的形式。</strong></p><p>这是一个负数，按照惯例int型首位为符号位。0表示在正数，1表示负数。</p><p>如下： −16510⇒−(10×16+5×1)⇒100⋅⋅⋅10100101</p><p>但在计算机中，负数存储的是补码，不是原码。</p><p>他们之间按照如下转换：</p><p><strong>原码：1000 0000 1010 0101</strong></p><p><strong>反码：1111 1111 0101 1010</strong> （除了符号位，其它取反）</p><p><strong>补码：1111 1111 0101 1011</strong> （在反码的基础上加1即可）</p><p>那么-165在32位int型中是这样存储的（中间的1，我省略了）：</p><p><img src="https://pic2.zhimg.com/80/v2-d08661c3d813990cdcff8a7e728be789_720w.webp" alt="img"></p><p>-165在计算机中的int存储</p><p>比正数复杂了一点，但是还是可以很容易算出来的。</p><p>问题来了？为啥负数要用补码？这不是挑事吗？原码不好吗？</p><p><img src="https://pic4.zhimg.com/80/v2-6972d84f8d2fb7e050c16bf77b3743f7_720w.webp" alt="img"></p><p>原因之一在于，我们计算： 165+(−165)=0 ，在计算机中存储的是二进制，</p><p>如果使用原码进行计算，需要单独把符号位拿出来，再做减法运算，而把符号位区分出来是需要额外的硬件电路支撑的，这很不方便。</p><p>如果使用补码，如下所示（这里按照16位进行举例）：</p><p>0000 0000 1010 0101 + 1111 1111 0101 1011=0000 0000 0000 0000；</p><p>使用补码参与运算后，无需再管符号位，可以让符号位直接参与运算。这就是使用补码的最大的好处。到这里大家有没有发现，int型的这种存储方案是没有考虑小数的，所以这是整型的。关于int型的存储，不再赘述，整体来说还是清晰明了的一种方案。</p><hr><h2 id="2、float对32个坑是如何使用的？">2、float对32个坑是如何使用的？</h2><p>同样也是占用32个坑，float型的范围比int就大很多，而且还能表示小数，那么它到底是如何利用这32个坑的呢？</p><p><strong>例3：请写出165.25(10进制)使用float型存储在计算机中的形式。</strong></p><p>同样我们还是先转换为2进制：165.2510⇒ <strong>1010 0101 . 0100</strong></p><p>那么如何把上面的二进制小数存到32个坑里呢？</p><p>在填坑之前，我们先要规范二进制小数的表示形式，就和我们的科学计数法一样的道理。</p><p>（就像 123.6 要写成 1.236×102 这个样子，把所有的小数换成统一的格式）</p><p>IEEE754标准做了这样的规定：当尾数(小数)不为0时，<strong>尾数域的最高有效位为1</strong>，这称为浮点数的规格化。</p><p>例如： 10100101.0100⇒1.01001010100×27</p><p>规格化后的二进制小数，有了统一的规格，可以发现这样规格化之后，我们只需要存储一个尾数（即小数部分，整数部分恒为1）和指数部分。</p><p>IEEE754标准把float型的32个坑做了如下划分：</p><p><img src="https://pic3.zhimg.com/80/v2-ab70e3260e17f51f27b53bb45cca0a7a_720w.webp" alt="img"></p><p>其中包含了1位符号位S，8位阶码E和23位尾数M。</p><p>1.01001010100×27 ，要存储这个二进制小数；</p><p>首先符号位S，<strong>0</strong>表示正数，<strong>1</strong>表示负数。<strong>S=0</strong>；</p><p>再写出尾数M，即：<strong>M=0100 1010 1000 0000 0000 000</strong>；</p><p>然后算出阶码E，这里指数为：<strong>e=7=0000 0111</strong>，根据标准要求，E=e+127；</p><p>即：<strong>E=7+127=134=1000 0110</strong>；</p><p>那么把这三个数都填进坑里，就ok啦。</p><p><img src="https://pic2.zhimg.com/80/v2-5a112a8353f2050f65eae389780a5579_720w.webp" alt="img"></p><p>165.25在计算机中的float储存</p><p>这个计算过程稍微复杂点，但也还可以手算出来。</p><p><img src="https://pic3.zhimg.com/80/v2-34f77d9cdabf5cf49b28d2c78a3a812a_720w.webp" alt="img"></p><p>但是问题又来了：</p><p>1、浮点数的表示范围有多大？</p><p>2、为什么要用指数加上127，才是阶码E，而不是直接用指数存进去？</p><p>3、这个过程可以看出float有效位是尾数M加1也就是24位，阶码E只是我们规范科学计数法记录指数的，但int有效位是32位，float实际有效位比int少，那么在相互转换的过程中会出现什么问题？</p><p>我依次解释这3个问题：</p><p><strong>1、浮点数的表示范围有多大？</strong></p><p><img src="https://pic4.zhimg.com/80/v2-c357fa1691ded5da725e94d29bfad20f_720w.webp" alt="img"></p><p>float型定义的正无穷大</p><p><img src="https://pic2.zhimg.com/80/v2-6a52c35f1cb54f1d56993818a127b95d_720w.webp" alt="img"></p><p>float型定义的负无穷大</p><p>可以得出当<strong>E= 1111 1111</strong>时，指数为255-127=128，但这并不是表示这个数是： 1×2128 ，在IEEE754把这种情况定义为无穷大，此时尾数必须全部为0，不能有其他值，否则就认为无效数字。</p><p>那么除了无穷大这个特殊的、人为定义的情况，float型能表示的最大的正整数是多少？最小的负整数是多少？当<strong>E= 1111 1111</strong>时，是IEEE754定义的特殊值即为无穷大，那么除此之外的最大值就是：<strong>E= 1111 1110</strong>，M也取最大值，即得到如下结果：</p><p><img src="https://pic4.zhimg.com/80/v2-5954a5358cec9a68e62eed2b8f98f433_720w.webp" alt="img"></p><p>float型能存储的最大正整数</p><p>此时阶码E为254，指数即为e=254-127=127。这个数即为：</p><p>1.11111111111111111111111×2127 ；</p><p>对于尾数我们可以换一个写法：</p><p><strong>1.1111 1111 1111 1111 1111 111=10-0.0000 0000 0000 0000 0000 001</strong></p><p>这样尾数可以写成： 2−2−23 ；</p><p>那么float能够表示的最大正整数就是： (2−2−23)×2127 ，即为 2128−2104 。</p><p>那么float能够表示的最小负整数就是： 2104−2128 。</p><p><strong>2、为什么要用指数加上127，才是阶码E，而不是直接用指数存进去？</strong></p><p>这就很容易说明了，我们举个例子：</p><p><strong>例4：请写出0.75(10进制)使用float型存储在计算机中的形式。</strong></p><p>写成二进制：0.7510=0.11 。再写成规划化的计数法： 1.1×2−1 ；</p><p>发现问题了没有？这次的指数是个负数啦，而我们希望存储到机器里的阶码永远都是正值，因为我们不希望再浪费一个坑去保存阶码的正负号，于是乎，干脆把指数加上127，而指数能取到的最小值就是-127，这样就可以保证阶码<strong>E</strong>永远都是正数啦，我们就不用再考虑指数正负号的问题了。</p><p><strong>E=-1+127=126=0111 1110；</strong></p><p><strong>M=1000 0000 0000 0000 0000 000；</strong></p><p><img src="https://pic3.zhimg.com/80/v2-c6bb9c6bfd42cf2bfc7b805214ce8bfe_720w.webp" alt="img"></p><p>0.75在计算机中的float储存</p><p><strong>3、这个过程可以看出float有效位是尾数M加1也就是24位，阶码E只是我们用于规范科学计数法记录指数的，但int有效位是32位，float实际有效位比int少，那么在相互转换的过程中会出现什么问题？</strong></p><p>通过问题1知道，float型的表示范围是比int大很多的，但有效位确实只有24位。既然float范围大，那么所有的int型都是可以转换为float型的，这是不会产生溢出报错的。但因为int型有效位是32位，是比float型的24位大的，是有可能发生舍入的，即当一个int型数字，转成float型后，可能就不再是原本数字了，损失了一定的精度。</p><p>例如2进制int型正数：<strong>0111 1111 1111 1111 1111 1111 1111 1111</strong>；</p><p>写成科学计数法即为： 1.11111111111111111111111111111111×230</p><p>小数点后面有30个1，但是我们知道float种尾数M只有23个坑。</p><p>则转化为float型后，阶码<strong>E=30+127=157=1001 1101</strong></p><p><img src="https://pic2.zhimg.com/80/v2-b77b9dbf319006623f273cfc1542c485_720w.webp" alt="img"></p><p>可以发现，我们对原int型中存储的数字只保留了小数点后23个1，而后面7个，直接忽视了，这就是发生了舍入。</p>]]></content>
    
    
    <summary type="html">32位的int和32位的float，谁能表示的数多</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核:OOM-killer打分机制</title>
    <link href="https://penge666.github.io/posts/1f41a9c6.html"/>
    <id>https://penge666.github.io/posts/1f41a9c6.html</id>
    <published>2024-07-14T15:53:57.000Z</published>
    <updated>2024-08-08T15:56:29.507Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 内核中的 OOM (Out-Of-Memory) 机制是当系统内存耗尽时，用来杀死某些进程以释放内存的机制。为了决定应该杀死哪个进程，内核使用了一套复杂的打分系统，这个过程称为 OOM 打分机制。</p><h2 id="基本概述">基本概述</h2><h3 id="OOM-机制的触发">OOM 机制的触发</h3><p>当系统内存耗尽，无法满足进程分配内存的需求时，内核会触发 OOM 杀手（OOM Killer）。OOM 杀手会选中一个进程并终止它，以释放内存。整个过程大致分为以下几个步骤：</p><ol><li><strong>检测内存不足</strong>：当系统内存不足且无法通过释放缓存、回收页面等方式缓解时，触发 OOM 机制。</li><li><strong>选择目标进程</strong>：通过打分机制选定一个进程作为目标。</li><li><strong>杀死目标进程</strong>：终止目标进程并释放其占用的内存资源。</li></ol><h3 id="OOM-打分机制">OOM 打分机制</h3><p>内核通过为每个进程打分来决定哪个进程应被杀死。打分机制主要依据进程对系统资源的占用情况，打分越高，越有可能被杀死。打分过程涉及多个因素：</p><ol><li><strong>进程的内存占用</strong>：占用内存越多的进程，得分越高。这是最重要的因素。<ul><li>通过 <code>mm-&gt;total_vm</code> (虚拟内存总量) 计算，值越大，打分越高。</li></ul></li><li><strong>进程的优先级 (nice 值)</strong>：进程的优先级也影响得分。优先级越低（nice 值越高），得分越低。<ul><li>通过进程的 <code>oom_score_adj</code> 进一步调整。用户可以通过 <code>/proc/[pid]/oom_score_adj</code> 来手动调节这个值，使某些进程更容易或更不容易被杀。</li></ul></li><li><strong>进程年龄</strong>：某些情况下，运行时间越长的进程得分越低，内核倾向于保留长期运行的服务进程。</li><li><strong>子进程数</strong>：如果进程有大量子进程，意味着它可能是一个服务进程，内核可能降低它的得分。</li><li><strong>CAP_SYS_ADMIN 权限</strong>：具有此权限的进程通常得分较低，除非没有其他选择，因为这些进程通常是系统管理进程。</li><li><strong>用户调整</strong>：用户可以通过调整 <code>oom_score_adj</code> 或者 <code>oom_adj</code>（旧版本）来影响某个进程的 OOM 分数。这些值允许用户通过 <code>/proc/[pid]/oom_score_adj</code> 对某个进程的 OOM 得分进行加权。</li></ol><h3 id="具体打分公式">具体打分公式</h3><p>在 Linux 3.8 及更高版本中，内核使用了一个计算公式来评估进程的 OOM 分数：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cCopy</span> codepoints = mm-&gt;</span><span class="function"><span class="title">total_vm</span> + (mm-&gt;</span><span class="function"><span class="title">hiwater_rss</span> - mm-&gt;</span>rss);</span><br><span class="line"><span class="function"><span class="title">points</span> += mm-&gt;</span>hiwater_rss * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="title">points</span> += mm-&gt;</span>rss;</span><br><span class="line"><span class="function"><span class="title">points</span> += task_struct-&gt;</span>oom_score_adj;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>total_vm</code> 是进程的虚拟内存总量。</li><li><code>hiwater_rss</code> 是进程历史上消耗内存的最高点。</li><li><code>rss</code> 是当前实际驻留在内存中的页数。</li><li><code>oom_score_adj</code> 是用户自定义的调整值。</li></ul><h3 id="OOM-优先级与保护机制">OOM 优先级与保护机制</h3><ul><li><strong>oom_score</strong>: 每个进程的 OOM 分数可以在 <code>/proc/[pid]/oom_score</code> 中查看。分数越高，进程越有可能被杀死。</li><li><strong>oom_adj 和 oom_score_adj</strong>：用户和管理员可以通过 <code>/proc/[pid]/oom_adj</code> 或 <code>/proc/[pid]/oom_score_adj</code> 文件调整进程的 OOM 优先级。例如，将 <code>oom_score_adj</code> 设置为 <code>-1000</code> 可以保护进程不被 OOM 杀手杀死，而设置为 <code>1000</code> 会让它优先被杀。</li></ul><h3 id="OOM-杀手的执行">OOM 杀手的执行</h3><p>一旦 OOM 打分完成，内核会选择得分最高的进程进行杀死。杀死进程时，会发送 <code>SIGKILL</code> 信号给目标进程，强制终止它。杀死目标进程后，内核会重新评估系统内存，如果仍然不足，可能继续杀死其他进程，直到内存压力缓解。</p><h3 id="具体的系统配置">具体的系统配置</h3><p>管理员可以通过 <code>/proc/sys/vm/oom_kill_allocating_task</code> 来配置是否优先杀死当前触发 OOM 的进程。此外，还可以通过 <code>/proc/sys/vm/panic_on_oom</code> 配置系统在 OOM 时是否直接崩溃而不是杀死进程。</p><h2 id="源码">源码</h2><h3 id="1-OOM-Killer-触发机制">1. OOM Killer 触发机制</h3><p>当系统内存耗尽且无法回收更多内存时，OOM Killer 会被触发。这个过程通常发生在内存管理的页面分配过程中，如果内核无法满足内存分配请求且所有回收机制（如文件系统缓存回收、页面交换等）均失败，就会调用 OOM Killer。</p><p>代码位置：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux 内核 进程内存管理代码</span></span><br><span class="line"><span class="comment">// 文件：mm/page_alloc.c</span></span><br><span class="line"><span class="keyword">if</span> (should_alloc_retry(gfp_mask, <span class="keyword">order</span>, <span class="keyword">ac</span>))</span><br><span class="line">    goto retry;</span><br><span class="line">...</span><br><span class="line">out_of_memory(gfp_mask, <span class="keyword">order</span>, <span class="keyword">ac</span>);</span><br></pre></td></tr></table></figure><h3 id="2-out-of-memory-函数">2. <code>out_of_memory()</code> 函数</h3><p><code>out_of_memory()</code> 是 OOM Killer 的入口函数，它决定是否需要触发 OOM Killer，以及后续的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">out_of_memory</span><span class="params">(<span class="keyword">struct</span> zonelist *zonelist, <span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">int</span> *ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!oom_killer_disabled &amp;&amp; !<span class="built_in">mutex_trylock</span>(&amp;oom_lock))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前系统状态，如果已经在 OOM 处理中，返回</span></span><br><span class="line">    <span class="keyword">if</span> (oom_killer_disabled)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择要杀死的进程</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p = <span class="built_in">select_bad_process</span>();</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行杀死操作</span></span><br><span class="line">    <span class="built_in">oom_kill_process</span>(p, <span class="string">&quot;Out of memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择被杀进程：select-bad-process">3. 选择被杀进程：<code>select_bad_process()</code></h3><p><code>select_bad_process()</code> 函数会遍历系统中的所有进程，并为每个进程计算一个 OOM 分数，根据分数决定哪个进程应该被杀死。分数越高的进程越可能被杀死。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">select_bad_process</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *tsk, *selected = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> points = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each_process(tsk) &#123;</span><br><span class="line">        <span class="comment">// 检查进程是否可杀</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_oom_unkillable</span>(tsk))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 OOM 分数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> totalpoints = <span class="built_in">oom_badness</span>(tsk, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择得分最高的进程</span></span><br><span class="line">        <span class="keyword">if</span> (totalpoints &gt; points) &#123;</span><br><span class="line">            selected = tsk;</span><br><span class="line">            points = totalpoints;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算-OOM-分数：oom-badness">4. 计算 OOM 分数：<code>oom_badness()</code></h3><p><code>oom_badness()</code> 函数根据多个因素计算进程的 OOM 分数，包括内存占用、优先级、进程年龄等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">oom_badness</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="keyword">struct</span> mem_cgroup *mem, <span class="type">const</span> <span class="type">nodemask_t</span> *nodemask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> points = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存占用分数</span></span><br><span class="line">    points += p-&gt;mm-&gt;total_vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑优先级调整</span></span><br><span class="line">    points += p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程是一个长期运行的服务，降低其分数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">has_capability_noaudit</span>(p, CAP_SYS_ADMIN))</span><br><span class="line">        points /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-杀死进程：oom-kill-process">5. 杀死进程：<code>oom_kill_process()</code></h3><p><code>oom_kill_process()</code> 函数负责最终的杀死操作。它向选中的进程发送 <code>SIGKILL</code> 信号，强制终止该进程。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line">void <span class="built_in">oom_kill_process</span>(struct task_struct *p, const char *message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pr_err</span>(&quot;%s: Kill process %d (%s) score %lu or sacrifice child\n&quot;,</span><br><span class="line">           message, <span class="built_in">task_pid_nr</span>(p), <span class="selector-tag">p</span>-&gt;comm, <span class="selector-tag">p</span>-&gt;signal-&gt;oom_score_adj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 SIGKILL 信号</span></span><br><span class="line">    <span class="built_in">do_send_sig_info</span>(SIGKILL, SEND_SIG_FORCED, p, true);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 OOM 锁</span></span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;oom_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-相关数据结构">6. 相关数据结构</h3><p><code>task_struct</code> 是进程的核心数据结构，<code>mm_struct</code> 则用于描述进程的内存使用情况。<code>oom_score_adj</code> 则是用户可以调整的一个参数，用于影响进程的 OOM 打分。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">task_struct</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">mm_struct</span> *mm;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">signal_struct</span> *signal;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">mm_struct</span> &#123;</span><br><span class="line">    unsigned long total_vm;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">signal_struct</span> &#123;</span><br><span class="line">    int oom_score_adj;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>Linux 内核中的 OOM Killer 是一个复杂但高效的机制，用于在系统内存耗尽时自动释放内存资源。通过 <code>out_of_memory()</code> 函数触发，选择打分最高的进程并执行杀死操作，以保持系统的稳定性。用户还可以通过调整 <code>oom_score_adj</code> 等参数影响 OOM Killer 的行为。</p><p><a href="http://blog.chinaunix.net/uid-20671208-id-4440249.html">kernel 3.10代码分析–Out Of Memory(OOM)处理流程</a></p>]]></content>
    
    
    <summary type="html">OOM-killer打分机制</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈分段,分页的理解</title>
    <link href="https://penge666.github.io/posts/40df8a20.html"/>
    <id>https://penge666.github.io/posts/40df8a20.html</id>
    <published>2024-07-14T12:19:31.000Z</published>
    <updated>2024-08-07T03:55:07.269Z</updated>
    
    <content type="html"><![CDATA[<p>一道很经典的OS面试题~</p><p>我们知道<strong>操作系统本质就是虚拟化</strong>：</p><ol><li><strong>CPU虚拟化</strong>：操作系统允许多个程序共享CPU资源，通过时间分片（time-slicing）或多任务处理（multitasking）技术，使得每个程序都认为自己独占CPU。</li><li><strong>内存虚拟化</strong>：操作系统通过虚拟内存管理技术（如分页和分段），为每个程序提供一个连续的地址空间，即使物理内存是分散的。这样，程序可以使用比实际物理内存更大的地址空间。</li><li><strong>存储虚拟化</strong>：操作系统通过文件系统接口，将物理存储设备（如硬盘或SSD）抽象为文件和目录，使得用户和应用程序可以方便地存储和检索数据，而不需要关心底层的物理存储细节。</li><li><strong>I/O设备虚拟化</strong>：操作系统通过设备驱动程序，将物理I/O设备（如键盘、鼠标、显示器、网络接口等）抽象为统一的接口，使得应用程序可以方便地与这些设备交互。</li><li><strong>网络虚拟化</strong>：现代操作系统还支持网络虚拟化技术，如虚拟网络接口和网络命名空间，使得多个网络配置可以在同一物理网络上共存，而不会相互干扰。</li></ol><p>接下来聊聊内存虚拟化。</p><h2 id="物理寻址">物理寻址</h2><p>​    在早期的计算机中，要运行一个程序，会把这些程序全都装入内存，程序都是直接运行在内存上的，也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。那当程序同时运行多个程序时，操作系统是如何为这些程序分配内存的呢？下面通过实例来说明当时的内存分配方法：</p><p>某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806202253933.png" alt="image-20240806202253933"></p><p><strong>问题1：进程地址空间不隔离</strong>。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。</p><p><strong>问题2：内存使用效率低</strong>。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p><p><strong>问题3：程序运行的地址不确定</strong>。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。</p><h2 id="分段">分段</h2><p>为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。<strong>按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</strong></p><p>​      当创建一个进程时，操作系统会为该进程分配一个4GB大小的虚拟进程地址空间。之所以是4GB，是因为在32位的操作系统中，一个指针长度是4字节，而4字节指针的寻址能力是从0x00000000~0xFFFFFFFF，最大值0xFFFFFFFF表示的即为4GB大小的容量。与虚拟地址空间相对的，还有一个物理地址空间，这个地址空间对应的是真实的物理内存。如果你的计算机上安装了512M大小的内存，那么这个物理地址空间表示的范围是0x00000000~0x1FFFFFFF。当操作系统做虚拟地址到物理地址映射时，只能映射到这一范围，操作系统也只会映射到这一范围。当进程创建时，每个进程都会有一个自己的4GB虚拟地址空间。要注意的是这个4GB的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的地址隔离。那是不是这4GB的虚拟地址空间应用程序可以随意使用呢？很遗憾，在Windows系统下，这个虚拟地址空间被分成了4部分：NULL指针区、用户区、64KB禁入区、内核区。应用程序能使用的只是用户区而已，大约2GB左右(最大可以调整到3GB)。内核区为2GB，内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享，但应用程序是不能直接访问的。</p><p>​     <strong>人们之所以要创建一个虚拟地址空间，目的是为了解决进程地址空间隔离的问题。但程序要想执行，必须运行在真实的内存上，所以，必须在虚拟地址与物理地址间建立一种映射关系。这样，通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值。人们想到了一种分段(Sagmentation)的方法，它的思想是在虚拟地址空间和物理地址空间之间做一一映射。比如说虚拟地址空间中某个10M大小的空间映射到物理地址空间中某个10M大小的空间。这种思想理解起来并不难，操作系统保证不同进程的地址空间被映射到物理地址空间中不同的区域上，这样每个进程最终访问到的</strong></p><p>​      物理地址空间都是彼此分开的。通过这种方式，就实现了进程间的地址隔离。还是以实例说明，假设有两个进程A和B，进程A所需内存大小为10M，其虚拟地址空间分布在0x00000000到0x00A00000，进程B所需内存为100M，其虚拟地址空间分布为0x00000000到0x06400000。那么按照分段的映射方法，进程A在物理内存上映射区域为0x00100000到0x00B00000，，进程B在物理内存上映射区域为0x00C00000到0x07000000。于是进程A和进程B分别被映射到了不同的内存区间，彼此互不重叠，实现了地址隔离。从应用程序的角度看来，进程A的地址空间就是分布在0x00000000到0x00A00000，在做开发时，开发人员只需访问这段区间上的地址即可。应用程序并不关心进程A究竟被映射到物理内存的那块区域上了，所以程序的运行地址也就是相当于说是确定的了。 图二显示的是分段方式的内存映射方法。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806202355700.png" alt="image-20240806202355700"></p><p>这种分段的映射方法虽然解决了上述中的问题一和问题三，但并没能解决问题二，即内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序，这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。实际上，程序的运行有局部性特点，在某个时间段内，程序只是访问程序的一小部分数据，也就是说，程序的大部分数据在一个时间段内都不会被用到。基于这种情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页(Paging)。</p><h2 id="分页">分页</h2><p>分页的基本方法是，将地址空间分成许多的页。每页的大小由CPU决定，然后由操作系统选择页的大小。目前Inter系列的CPU支持4KB或4MB的页大小，而PC上目前都选择使用4KB。按这种选择，4GB虚拟地址空间共可以分成1048576个页，512M的物理内存可以分为131072个页。显然虚拟空间的页数要比物理空间的页数多得多。</p><p>​      在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分<strong>页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</strong></p><p>​     下面通过介绍一个<strong>可执行文件的装载过程来说明分页机制的实现方法</strong>。一个可执行文件(PE文件)其实就是一些编译链接好的数据和指令的集合，它也会被分成很多页，在PE文件执行的过程中，它往内存中装载的单位就是页。当一个PE文件被执行时，操作系统会先为该程序创建一个4GB的进程虚拟地址空间。前面介绍过，虚拟地址空间只是一个中间层而已，它的功能是利用一种映射机制将虚拟地址空间映射到物理地址空间，所以，创建4GB虚拟地址空间其实并不是要真的创建空间，只是要创建那种映射机制所需要的数据结构而已，这种数据结构就是页目和页表。</p><p>​      当创建完虚拟地址空间所需要的数据结构后，进程开始读取PE文件的第一页。在PE文件的第一页包含了PE文件头和段表等信息，进程根据文件头和段表等信息，将PE文件中所有的段一一映射到虚拟地址空间中相应的页(PE文件中的段的长度都是页长的整数倍)。这时PE文件的真正指令和数据还没有被装入内存中，操作系统只是根据PE文件的头部等信息建立了PE文件和进程虚拟地址空间中页的映射关系而已。当CPU要访问程序中用到的某个虚拟地址时，当CPU发现该地址并没有相相关联的物理地址时，CPU认为该虚拟地址所在的页面是个空页面，CPU会认为这是个页错误(Page Fault)，CPU也就知道了操作系统还未给该PE页面分配内存，CPU会将控制权交还给操作系统。操作系统于是为该PE页面在物理空间中分配一个页面，然后再将这个物理页面与虚拟空间中的虚拟页面映射起来，然后将控制权再还给进程，进程从刚才发生页错误的位置重新开始执行。由于此时已为PE文件的那个页面分配了内存，所以就不会发生页错误了。随着程序的执行，页错误会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。</p><p>​       分页方法的核心思想就是当可执行文件执行到第x页时，就为第x页分配一个内存页y，然后再将这个内存页添加到进程虚拟地址空间的映射表中,这个映射表就相当于一个y=f(x)函数。应用程序通过这个映射表就可以访问到x页关联的y页了。</p><p>补充：<a href="https://www.zhihu.com/question/50796850/answer/522734117">怎样通俗的理解操作系统中内存管理分页和分段？</a></p><p>来看个问题~</p><ul><li><a href="https://www.cnblogs.com/Ethan-Code/p/16627754.html">在4G主存机器申请8G内存会发生什么</a></li></ul>]]></content>
    
    
    <summary type="html">OS-分段/分页</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL学习笔记</title>
    <link href="https://penge666.github.io/posts/26565af3.html"/>
    <id>https://penge666.github.io/posts/26565af3.html</id>
    <published>2024-07-13T09:05:35.000Z</published>
    <updated>2024-07-13T13:34:22.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>为什么叫allocator空间配置器，而不叫内存配置器？<br>因为空间不一定是内存，也可能是磁盘或其他辅助存储介质。可以写一个allocator，直接向硬盘取空间。</p><p>不过，实际上，我们最常用的就是用于配置内存。</p><h2 id="空间配置器的标准接口">空间配置器的标准接口</h2><p>allocator标准接口：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line">    一个嵌套的（nested）<span class="keyword">class</span> template。<span class="keyword">class</span> rebind&lt;U&gt; 拥有唯一成员other, 那是一个typedef, 代表allocator&lt;U&gt;.</span><br><span class="line">allocator::allocator()</span><br><span class="line">    <span class="keyword">default</span> <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&amp;)</span><br><span class="line">    copy <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">template</span>&lt;<span class="title">class</span> <span class="title">U</span>&gt; <span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line">    泛化的copy <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">allocator</span>:</span>:~allocator()</span><br><span class="line">    <span class="keyword">default</span> <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">pointer</span> <span class="title">allocator</span>:</span>:address(reference x) <span class="keyword">const</span></span><br><span class="line">    返回某个对象的地址. 算式a.address(x)等同于&amp;x</span><br><span class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></span><br><span class="line">    返回某个<span class="keyword">const</span>对象的地址. 算式a.address(x)等同于&amp;x</span><br><span class="line">pointer allocator::allocate(size_type n, <span class="keyword">const</span> void* = <span class="number">0</span>)</span><br><span class="line">    配置空间, 足以存储n个T对象. 第二参数是个提示. 实现上可能会利用它来增进区域性(locality), 或完全忽略之</span><br><span class="line">void allocator::deallocate(pointer p, size_type n)</span><br><span class="line">    归还先前配置的空间</span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span></span><br><span class="line">    返回可成功配置的最大量</span><br><span class="line">void allocator::construct(pointer p, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">    等同于 new ((<span class="keyword">const</span> void*)p) T(x)</span><br><span class="line">void allocator::destroy(pointer p)</span><br><span class="line">    等同于p-&gt;~T()</span><br></pre></td></tr></table></figure><h2 id="两种空间配置器">两种空间配置器</h2><p><a href="http://www.rrsd.com/software_development/stl/stl/index.html">SGI STL</a>有2个种空间配置器：<br>1）std::allocator，符合STL标准，但很少使用，也不建议使用。因为只是把::operator new和::operator delete做了一层薄薄封装，效率差。<br>2）std::alloc，SGI特殊空间配置器，将配置器分为两级，兼顾了效率与内存碎片问题，效率高。推荐使用。</p><p>下面主要讲的也是std::alloc。</p><h3 id="空间配置器的职责">空间配置器的职责</h3><p>通常，我们习惯用new、delete对C++ 内存配置进行申请、释放操作。比如，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;...&#125;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure><p>其中，new操作内含2阶段操作：<br>1）调用::operator new配置内存。<br>2）调用Foo::Foo()构造对象。</p><p>delete操作也内含2阶操作：<br>1）调用Foo::~Foo()析构对象；<br>2）调用::operator delete释放内存；</p><p>而STL的allocator（空间配置器）把这两阶段操作分开了。其中，内存配置（申请）由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由全局::construct()负责，对象析构由全局::destroy()负责。</p><h2 id="配置器allocator文件说明">配置器allocator文件说明</h2><p>STL标准规定，配置器定义于<code>&lt;memory&gt;</code>，而SGI <code>&lt;memory&gt;</code>内含3个与配置器相关的文件：<br>1）&lt;stl_construct.h&gt; 定义了全局函数construct(), destroy(), 负责对象的构造和析构。隶属于STL标准规范。<br>2）&lt;stl_alloc.h&gt; 定义了一、二级配置器，彼此合作。配置器名为alloc。<br>3）&lt;stl_uninitialized.h&gt; 定义一些全局函数，用来填充（fill）或复制（copy）大块内存数据。都属于STL标准规范：</p><ul><li>un_initialized_copy()</li><li>un_initialized_fill()</li><li>un_initialized_fill_n()<br>3个函数不属于配置器范畴，但与对象初值设置有关。对于容器的大规模元素初值设置很有帮助。这些函数对于效率都有面面俱到的考虑，最差情况下会调用construct()。最佳情况则会使用C标准函数memmove()直接进行内存数据的移动。</li></ul><h2 id="构造和析构工具：construct-destroy">构造和析构工具：construct, destroy</h2><p>全局函数<strong>construct(), destroy()在已配置内存的基础上，用于对象的构造和析构</strong>。<br>因此，construct()需要原生内存（native memory）地址和要构造对象类型，可能包含初值（列表）用于构造对象作为参数。<br>destroy有两种形式：1）析构单个对象，提供对象指针即可；2）析构迭代器区间所有对象，提供迭代器区间[first, last)。</p><p>注意：如果是原始类型区间，如char* [start, end)，则不需要析构，因为没有构建对象。</p><p>可以得到construct和destroy的模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stl_construct.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _Construct(T1* p) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="type">void</span>*) p) <span class="built_in">T</span>(); <span class="comment">// placement new; 调用T::T()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value); <span class="comment">// placement new; 调用T1::T1(value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第一个版本, 接受一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">       pointer-&gt;~<span class="built_in">T</span>(); <span class="comment">// 调用dtor ~T()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第二个版本, 接受两个迭代器. 次函数设法找出元素的数值型别,</span></span><br><span class="line"><span class="comment">// 进而利用__type_traits&lt;&gt;求取最适当措施</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">       __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型别(value type)是否有trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) &#123;</span><br><span class="line">       <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor  trivial_destructor;</span><br><span class="line">       __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型别(value type)有non-trivial destructor, 则派送(dispatch)到这里</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last,  __false_type) &#123;</span><br><span class="line">       <span class="keyword">for</span> (; first &lt; last; ++first)</span><br><span class="line">              <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型别(value type)有trivial destructor, 则派送(dispatch)到这里</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last,  __true_type) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy() 第二版针对迭代器为char*和wchar_t*的特化版</span></span><br><span class="line"><span class="comment">// 原生指针区间不需要析构, 因为没有对象, 类似地，还有int*, long*, float*, double*，这里省略</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>代码中一组__destroy()是辅助实现destroy()的，编译器会在编译期根据萃取出参数的类型（value type）。接着萃取出trivial_destructor特性，判断是否支持trivial_destructor（平凡的析构函数，说明没有申请动态内存），如果支持（特性为__true_type），就不需要专门调用析构函数；如果不支持（特性为__false_type），就需要针对迭代器区间每个元素，逐个调用析构函数。<br>如果迭代器区间包含元素较多，这能节省不少时间。</p><h2 id="空间配置与释放，std-alloc">空间配置与释放，std::alloc</h2><p><strong>std::alloc 负责内存的配置和释放</strong>。对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责，SGI对此设计哲学：</p><ul><li>向system heap要求空间。</li><li>考虑多线程（multi-threads）状态。</li><li>考虑内存不足时的应变措施。</li><li>考虑过多“小型区块”可能造成的内存碎片（fragment）问题。</li></ul><p>本文为控制问题复杂度，以下讨论及源码，皆排除多线程。</p><p>C++的内存配置基本操作::operator new()，内存释放基本操作 ::operator delete()。这2全局函数相当于C的malloc()和free()。SGI正是以malloc()和free()完成内存的配置与释放的，但SGI STL的std::alloc不能使用operator new/delete，因为new/delete会直接构造/析构对象，而这不符合std::alloc职责。</p><p><strong>std::alloc设计基本思想</strong><br>为避免小型区块可能造成的内存碎片问题，SGI STL设计了双层级配置器：<br>1）第一级配置器，直接使用malloc(), free()；<br>2）第二级配置器，视情况采用不同策略：<br>当配置区块 &gt; 128bytes时，视为“足够大”，便调用第一级配置器；<br>当配置区块 &lt;= 128bytes时，视为“过小”，交给memory pool（内存池）来管理，不再求助于第一级配置器。</p><p>设计可以只开放第一级配置器，可以同时开启。取决于__USE_MALLOC是否被定义（SGI STL并未定义__USE_MALLOC）。</p><p>SGI STL的两级配置器：__malloc_alloc_template是第一级配置器，__default_alloc_template是第二级配置器。alloc不接受任何template型别参数。并且，SGI还在此基础上，用simple_alloc包装了一个接口，对用户屏蔽内部细节，使之符合STL规格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stl_alloc.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部4个成员函数都是单纯的转发调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123; <span class="comment">// simple_alloc包装第一级配置器和第二级配置器, 用户传入模板参数给Alloc即可</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">// 配置n个单位T类型对象的原始空间</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T*)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     <span class="comment">// 配置1个单位T类型对象的原始空间</span></span><br><span class="line">              <span class="keyword">return</span> (T*)Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p, <span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">// 释放n个单位T类型对象的原始空间</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p)</span> </span>&#123; <span class="comment">// 释放1个单位T类型对象的原始空间</span></span><br><span class="line">              Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了转发调用，simple_alloc包装配置器还将接口的配置单位，由byte转换成了元素的大小（sizeof(T)）。SGI STL容器全部使用这个simple_alloc接口。<br>例如，vector的专属空间配置器data_allocator，就是simple_alloc&lt;value_type, Alloc&gt;，当然Alloc取决于我们传入vector的配置器类型（一级或二级），缺省是std::alloc。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">// 使用缺省alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">       <span class="comment">// 专属空间配置器, 每次配置一个元素大小</span></span><br><span class="line">       <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (...)</span><br><span class="line">                     data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一级配置器：-malloc-alloc-template">第一级配置器：__malloc_alloc_template</h2><ol><li>allocate() 直接使用malloc(), deallocate() 直接使用free()；</li><li>模拟C++的set_new_handler()以处理内存不足的状况。</li></ol><p>set_new_handler只有针对placement new申请内存时，才有效；用malloc申请时，无效。需要借助malloc返回值为空，进行申请内存失败判断。</p><p><strong>如何选择使用哪个配置器？</strong><br>定义或取消宏__USE_MALLOC，就能决定alloc的实际类型（一级配置器 or 二级配置器）。SGI STL并未定义__USE_MALLOC，因此SGI默认使用的二级配置器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc single_client_alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt; single_client_alloc;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="一级配置器实现">一级配置器实现</h3><p>用malloc(), free(), realloc()等C函数执行实际的内存配置、释放、重新配置，并模拟实现类似于C++ new-handler异常处理机制。不能直接使用new-handler机制，因为并没有用::operator new配置内存，而是用的malloc。</p><p><strong>C++ new handler机制是什么？</strong><br>指你可以要求系统在内存配置需求无法被满足时，调用一个你指定的函数，来进行异常处理。i.e. 一旦::operator new无法完成任务，在抛出std::bad_alloc异常前，会先调用由客户端指定的处理例程。 (见<a href="https://www.cnblogs.com/fortunely/p/15682123.html">《Effective C++》条款49</a>）</p><p><strong>谁负责注册、设计“内存不足处理例程”？</strong><br>设计“内存不足处理例程”是客户端的责任，注册“内存不足处理例程”也是客户端的责任。也就是，客户负责调用set_malloc_handler()注册内存不足处理例程，并定义传入实参（内存不足如何处理）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stl_alloc.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一级配置器</span></span><br><span class="line"><span class="comment">// 用于异常处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __THROW_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span> defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)</span></span><br><span class="line"><span class="meta">#    <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __THROW_BAD_ALLOC fprintf(stderr, <span class="string">&quot;out of memory\n&quot;</span>); exit(1)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span> <span class="comment">/* Standard conforming out-of-memory handling */</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __THROW_BAD_ALLOC throw std::bad_alloc()</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc-based allocator 通常比default alloc速度慢</span></span><br><span class="line"><span class="comment">// 一般而言是thread-safe, 并且对空间的运用比较高效(efficient)</span></span><br><span class="line"><span class="comment">// 以下是第一级配置</span></span><br><span class="line"><span class="comment">// 注意， 无&quot;template型别参数&quot;. 至于&quot;非型别参数&quot;inst, 则完全没派上用场</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// 以下都是函数指针, 所代表的函数将用来处理内存不足的情况</span></span><br><span class="line">       <span class="comment">// oom: out of memory.</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;            <span class="comment">// 模拟C++ placement new, 不断尝试配置内存, 调用客户注册的处理例程或抛出异常</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*, <span class="type">size_t</span>)</span></span>;    <span class="comment">// 模拟C++ placement new, 不断尝试重新配置内存, 调用客户注册的处理例程或抛出异常</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>; <span class="comment">// 保存客户注册的 内存不足处理例程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">              <span class="type">void</span> *result = <span class="built_in">malloc</span>(n); <span class="comment">// 第一级配置器直接使用malloc()</span></span><br><span class="line">              <span class="comment">// 以下无法满足需求时, 改用oom_malloc()</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> <span class="comment">/*n*/</span>)</span> </span>&#123;</span><br><span class="line">              <span class="built_in">free</span>(p); <span class="comment">// 第一级配置器直接使用free()</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">              <span class="type">void</span> *result = <span class="built_in">realloc</span>(p, new_sz); <span class="comment">// 第一级配置器直接使用realloc()</span></span><br><span class="line">              <span class="comment">// 以下无法满足需求时, 改用oom_realloc()</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下仿真C++的set_new_handler(). 换句话说， 你可以通过它指定自己的out-of-memory handler</span></span><br><span class="line">       <span class="comment">// 注册 内存不足处理例程</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(*set_malloc_handler(<span class="type">void</span>(*f)()))</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="built_in">void</span>(*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">              __malloc_alloc_oom_handler = f;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"><span class="comment">// 初值0, 有待客户端设定</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span></span><br><span class="line"><span class="function"><span class="title">void</span><span class="params">(*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">void</span>(*my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (; ;) &#123; <span class="comment">// 循环尝试配置内存</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)(); <span class="comment">// 调用客户注册的处理例程, 企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);     <span class="comment">// 再次尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span>* p, <span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">void</span>(*my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (; ;) &#123; <span class="comment">// 循环不断尝试释放、配置 ...</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; <span class="comment">// 如果客户没有设置my_malloc_handler, 就抛出异常</span></span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)();    <span class="comment">// 调用客户注册的处理例程, 企图释放内存</span></span><br><span class="line">        result = <span class="built_in">reallocate</span>(p, n); <span class="comment">// 尝试重新配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意, 以下直接将参数inst指定为0</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure><h2 id="第二级配置器：-default-alloc-template">第二级配置器：__default_alloc_template</h2><p>与第一级配置器区别：为避免太多小额区块造成内存碎片，多了一些机制。</p><p>SGI第二级配置做法：如果区块够大，&gt; 128bytes，移交给第一级配置器处理；当区块 &lt; 128bytes，则以内存池（memory pool）管理。<br>这种方法称为<strong>次配置（sub-allocation）</strong>：每次配置一大块内存，并维护对应自由链表（free-list）。下次再有相同大小内存需求时，就直接从free-lists中取出。如果客户端归还小额区块，就由配置器回收到free-lists中。<br>简而言之，二级配置器负责内存配置、回收，会根据区块大小，选择自行配置，还是移交给一级配置器处理。</p><p>因此，可以知道二级配置器多了自由链表和内存池两个机制，专门为处理 &lt;= 128bytes的内存申请而生。</p><h3 id="自由链表-free-lists">自由链表 free-lists</h3><p>二级配置器的核心之一就是free-lists（自由链表），每个free-list代表一类空闲区块，大小从8，16，24，…，到128 （bytes），共16个。16个free-list的头结点，用一个数组free_list[16]表示，下文称之为槽位。每个槽位指向的区块是一个链表，而该区块就是链表的第一个空闲块。</p><p>free-list的精髓就是联合体obj：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free-lists节点结构</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">    <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>一般情况下，我们用next* 和 data的struct来描述链表节点，而obj用obj*的union，这是为什么？</strong><br>因为这样可以节省维护链表的指针空间。一个区块，在分配给客户端之前，首部大小为obj那部分可以看作一个指针free_list_link，用来串成链表；而分配给客户端之后，这部分无需当做指针，可以被客户按需使用；待客户归还区块时，首部大小为obj那部分又会被当做指针，用来串成链表，加入free list。<br>free_list_link所指向的内存区块大小，由链表头结点，即槽位所在free_list[]中的索引决定。而归还时，调用者会记录区块大小。因此，obj不需要额外存储区块大小。</p><p><strong>为什么free-list区块最小尺寸是8byte，而不是4byte？</strong><br>因为64位系统上，指针尺寸8byte；32位系统上，指针尺寸4byte。为了兼容32位、64位系统，取较大值8。</p><p>下图是以96byte区块为例，描述free-lists结构：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212536617.png" alt="image-20240713212536617"></p><h3 id="default-alloc-template-的数据结构">__default_alloc_template 的数据结构</h3><p>SGI STL中，__default_alloc_template 的数据结构签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二级配置器的部分实现内容</span></span><br><span class="line"><span class="keyword">enum</span> &#123; __ALIGN = <span class="number">8</span> &#125;; <span class="comment">// 小型区块上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123; __MAX_BYTES = <span class="number">128</span> &#125;; <span class="comment">// 小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123; __NFREELTISTS = __MAX_BYTES / __ALIGN &#125;; <span class="comment">// free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是第二级配置器</span></span><br><span class="line"><span class="comment">// 注意, 无&quot;template型别参数&quot;, 且第二参数完全没派上用场</span></span><br><span class="line"><span class="comment">// 第一参数用于多线程环境. 本书不讨论多线程环境</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// ROUND_UP() 将bytes上调至8的倍数</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// free-lists节点结构</span></span><br><span class="line">       <span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">              <span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">              <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">// 16个free-lists</span></span><br><span class="line">       <span class="type">static</span> obj* <span class="keyword">volatile</span> free_list[__NFREELTISTS];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下函数根据区块大小, 决定使用第n号free-lists. n从1起算</span></span><br><span class="line">       <span class="comment">// 根据要申请的内存空间大小(bytes), 找到free list中不小于bytes的区块, 返回其位于free_list[]的编号</span></span><br><span class="line">       <span class="comment">// e.g. 1) bytes = 96, return = (96 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line">       <span class="comment">// 2) bytes = 95, return = (95 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line">       <span class="comment">// 3) bytes = 97, return = (97 + 8 - 1) / 8 - 1 = 12</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">       <span class="comment">// 配置一大块空间, 可容纳nobjs个大小为&quot;size&quot;的区块</span></span><br><span class="line">       <span class="comment">// 如果配置nobjs个区块有所不便, nobjs可能会降低</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Chunk allocation state</span></span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* start_free; <span class="comment">// 内存池起始位置. 只在chunk_alloc()中变化</span></span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* end_free;   <span class="comment">// 内存池结束位置. 只在chunk_alloc()中变化</span></span><br><span class="line">       <span class="type">static</span> <span class="type">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后*/</span> &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>  <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p , <span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后*/</span> &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">reallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于free-lists，有两个重要操作：<br>1）ROUND_UP() 将参数bytes上调至8的倍数，确保所有操作都是8byte对齐；<br>2）FREELIST_INDEX() 根据参数bytes，在free_list[]中找到合适的槽位：确保区块大小 &gt;= bytes。</p><h3 id="ROUND-UP-向上调对齐">ROUND_UP() 向上调对齐</h3><p>ROUND_UP()实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ROUND_UP() 将bytes上调至8的倍数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (((bytes)+__ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FREELIST-INDEX-找合适槽位">FREELIST_INDEX() 找合适槽位</h3><p>FREELIST_INDEX()实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下函数根据区块大小, 决定使用第n号free-lists. </span></span><br><span class="line"><span class="comment">// 根据要申请的内存空间大小(bytes), 找到free list中不小于bytes的区块, 返回其位于free_list[]的编号</span></span><br><span class="line"><span class="comment">// e.g. 1) bytes = 96, return = (96 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line"><span class="comment">// 2) bytes = 95, return = (95 + 8 - 1) / 8 - 1 = 11</span></span><br><span class="line"><span class="comment">// 3) bytes = 97, return = (97 + 8 - 1) / 8 - 1 = 12</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (((bytes)+__ALIGN - <span class="number">1</span>) / __ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocate-空间配置">allocate() 空间配置</h3><p>作为一个配置器，最核心的功能莫过于分配内存、回收内存。allocate()负责分配内存，deallocate()负责回收内存。</p><p>利用allocate()申请n bytes内存流程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212756541.png" alt="image-20240713212756541"></p><p>有3个关键点：<br>1）申请内存空间n &gt; 128bytes时，交给一级配置器处理。而一级配置器的__malloc_alloc_template&lt;&gt;::allocate()在前面已讲过，这里不再遨述。<br>2）n &lt;= 128bytes，在free_list[]数组会找一个适当的区块链表free list，并且该free list有可用空间时，需要将free list链表的第一个空闲数据块交给客户，而自身的指针也同样需要更新。<br>3）在2）的基础上，free list并没有可用空间时，就会调用refill()重新填充该free list。这部分放到下面的refill()函数部分讲解，而内部涉及到memory pool（内存池）的部分，放到下面memory pool部分专门讲解。</p><p><strong>什么时候表示free list有空闲区块？</strong><br>free_list[i]（i=0,1,…15）的free_list_link所指向的下一个链表节点如果非空（非0），代表有空闲区块。而二级指针my_free_list指向free_list[i]（某个槽位）。</p><p>针对情形2），当free list由空闲区块时，拔出第一个空闲区块给客户</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212745601.png" alt="image-20240713212745601"></p><p>二级配置器的allocate()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n must be &gt; 0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">       obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">       obj* result;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// &gt;128, 调用第一级配置器</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123;</span><br><span class="line">              <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n)); <span class="comment">// malloc_alloc即一级配置器 __malloc_alloc_template&lt;0&gt;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">       my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">       result = *my_free_list;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 没找到可用的free list, 准备重新填充free list</span></span><br><span class="line">              <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n)); <span class="comment">/* 后面详述 */</span></span><br><span class="line">              <span class="keyword">return</span> r;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调整free list</span></span><br><span class="line">       *my_free_list = result-&gt;free_list_link;</span><br><span class="line">       <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deallocate-空间释放">deallocate() 空间释放</h3><p>空间释放与空间配置的逆过程，由deallocate()处理，负责回收分配出去的内存空间。总的原则是谁配置的空间，由谁来负责回收。</p><p>不过，与allocate()分配空间不同，deallocate()只有2个关键点，因为不存在内存空间不够的情况。<br>2个关键点：<br>1）回收的空间 n &gt; 128byte时，交给第一级配置器处理；<br>2）n &lt;= 128bytes时，找到适当的free list，然后调整free list，将回收空间加入其中。</p><p>二级配置器回收空间流程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713212729258.png" alt="image-20240713212729258"></p><p>二级配置器回收空间结构变化示意图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713213107576.png" alt="image-20240713213107576"></p><p>二级配置器deallocate()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 不可以是0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>  <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p , <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">       obj* q = (obj*)p;</span><br><span class="line">       obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// &gt; 128调用第一级配置器</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123;</span><br><span class="line">              malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找对应free list</span></span><br><span class="line">       my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">       <span class="comment">// 调整free list, 回收区块</span></span><br><span class="line">       q-&gt;free_list_link = *my_free_list;</span><br><span class="line">       *my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当 归还空间大小 &lt;= 128时，deallocate并没有将空间归还给系统，而是交给了free list，方便下次申请。这样可以有效避免内存碎片问题。</p><h3 id="refill-重新填充free-list">refill() 重新填充free list</h3><p>在allocate()中，当发现合适的free list中并没有可用的空闲块时，就会调用refill()为free list重新填充空闲空间。新空间由chunk_alloc()完成，默认取自内存池。</p><p>refill() 默认向chunk_alloc()申请nobjs=20个大小为n（假定n已经调整为8倍数）的（连续）内存空间，当然实际成功申请到多少个，需要根据实际情况决定，可通过nobjs传出值判断。可以肯定的是，如果有返回值（没有出现异常终止程序），那么至少会有一个大小为n的对象。<br>refill()会得到一个连续空间，而把第一个大小n的对象返回给客户；至于剩余的空间，在按尺寸n找到合适的free list后，将剩余空间按链表形式加入free list。</p><p>refill() 重新填充free list流程：<br><img src="https://img2022.cnblogs.com/blog/741401/202205/741401-20220504190104782-1277915042.png" alt="img"></p><p>refill()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个大小为n的对象, 并且有时候会为适当的free list增加节点</span></span><br><span class="line"><span class="comment">// 假设n已经适当上调至8的倍数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">       <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用chunk_alloc(), 尝试取得nobjs个区块作为free list的新节点</span></span><br><span class="line">       <span class="comment">// 注意参数nobjs是pass by reference</span></span><br><span class="line">       <span class="type">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n, nobjs); <span class="comment">// 下节详述</span></span><br><span class="line">       obj* <span class="keyword">volatile</span> *my_free_list; <span class="comment">// 2级指针, 指向free list链表头结点, 也位于free_list[]槽位上</span></span><br><span class="line">       obj* result;</span><br><span class="line">       obj *current_obj, *next_obj;</span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果只获得一个区块, 这个区块就分配给调用者, free list无新节点</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 否则准备调整free list, 纳入新节点</span></span><br><span class="line">       my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下在chunk空间内建立free list</span></span><br><span class="line">       result = (obj*)chunk; <span class="comment">// 首部这一块准备返回给客户端</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下引导free list指向新配置的空间(取自内存池)</span></span><br><span class="line">       *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以下在chunk剩余空间(除去返回给客户的首部)上, 将free list的各节点串起来</span></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">1</span>; ; ++i) &#123; <span class="comment">// 从1开始, 因为第0个将返回给客户端</span></span><br><span class="line">              current_obj = next_obj;</span><br><span class="line">              next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br><span class="line">              <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">                     current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                     current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memory-pool-内存池">memory pool 内存池</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713213157224.png" alt="image-20240713213157224"></p><p>chunk_alloc()源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设size已经适当上调至8的倍数</span></span><br><span class="line"><span class="comment">// 注意参数nobjs是pass by reference</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>  &amp;nobjs) &#123;</span><br><span class="line">       <span class="type">char</span>* result;</span><br><span class="line">       <span class="type">size_t</span> total_bytes = size * nobjs;         <span class="comment">// 要申请的内存总量</span></span><br><span class="line">       <span class="type">size_t</span> bytes_left = end_free - start_free; <span class="comment">// 内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">              <span class="comment">// 内存池剩余空间完全满足需求量, 从内存池直接分配所需量 start_free ~ start_free + total_bytes</span></span><br><span class="line">              result = start_free;</span><br><span class="line">              start_free += total_bytes; <span class="comment">// 从内存池取出内存后, 移动内存池起始位置</span></span><br><span class="line">              <span class="keyword">return</span> (result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">              <span class="comment">// 内存池剩余空间不能完全满足需求量, 但足够供应一个(含)以上的区块</span></span><br><span class="line">              nobjs = bytes_left / size;  <span class="comment">// 先分配能满足的块数</span></span><br><span class="line">              total_bytes = size * nobjs; <span class="comment">// 从内存池实际能分配的总量</span></span><br><span class="line">              result = start_free;</span><br><span class="line">              start_free += total_bytes;</span><br><span class="line">              <span class="keyword">return</span> (result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 内存池剩余空间连一个区块的大小都无法提供, 就需要向OS重新申请(malloc)内存</span></span><br><span class="line">              <span class="comment">// 默认申请 2倍所需量, heap_size 用来调整申请的内存量.</span></span><br><span class="line">              <span class="comment">// 注意: 为内存池申请空间, 分配空间时, 需要确保对齐(8byte对齐)</span></span><br><span class="line">              <span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>); <span class="comment">// &gt;&gt; 4 &lt;=&gt; /16</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 先试着让内存池的残余零头还有利用价值, 因为不够申请的一个区块大小(size),</span></span><br><span class="line">              <span class="comment">// 因此内存池剩余空间肯定 &lt; 128bytes, 可以加入某个区块</span></span><br><span class="line">              <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="comment">// 内存池还有一些零头, 先分配给恰当的free list, 以备其他客户向free list申请空间</span></span><br><span class="line">                     <span class="comment">// 首先寻找适当的free list</span></span><br><span class="line">                     obj* <span class="keyword">volatile</span> *my_free_list = free_list +  <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 将内存池残余空间插入到free list槽位对应链表</span></span><br><span class="line">                     <span class="comment">// 调整free list, 将内存池中的残余空间编入</span></span><br><span class="line">                     ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">                     *my_free_list = (obj*)start_free;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 向OS heap申请新空间, 用来补充内存池. 此时内存池已经为空, 残余空间已经交给free list.</span></span><br><span class="line">              start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123; <span class="comment">// OS heap空间不足, malloc()失败后异常处理</span></span><br><span class="line">                     <span class="type">int</span> i;</span><br><span class="line">                     obj* <span class="keyword">volatile</span> * my_free_list, *p;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 试着检查我们手上拥有的东西, 这不会造成伤害. 我们不打算尝试配置较小的区块,</span></span><br><span class="line">                     <span class="comment">// 因为那在多进程(multi-process)机器上容易导致灾难</span></span><br><span class="line">                     <span class="comment">// 以下搜寻适当的free list</span></span><br><span class="line">                     <span class="comment">// 所谓适当是指&quot;尚有未用区块, 且区块够大&quot;之free list</span></span><br><span class="line">                     <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                           my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">                           p = *my_free_list;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (<span class="number">0</span> != p) &#123; <span class="comment">// free list内尚有未用区块</span></span><br><span class="line">                                  <span class="comment">// 调整free list以释放出未用区块</span></span><br><span class="line">                                  *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                                  start_free = (<span class="type">char</span>*)p;</span><br><span class="line">                                  end_free = start_free + i;</span><br><span class="line">                                         </span><br><span class="line">                                  <span class="comment">// 此时内存池已经有足够大区块. 递归调用自己, 为了修正nobjs</span></span><br><span class="line">                                  <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">                                  <span class="comment">// 注意, 内存池任何残余零头终将被编入适当的free-list中备用</span></span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     end_free = <span class="number">0</span>; <span class="comment">// 如果出现意外(到处都没内存可用)</span></span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 调用第一级配置器, 看看out-of-memory机制是否能尽点力</span></span><br><span class="line">                     start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">                     <span class="comment">// 这会导致抛出异常(exception), 或内存不足的情况获得改善</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              heap_size += bytes_to_get;            <span class="comment">// 向OS成功申请到内存, 就扩大heap size</span></span><br><span class="line">              end_free = start_free + bytes_to_get; <span class="comment">// 更新内存池end_free边界</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 此时内存池有足够空间, 递归调用自己, 为了修正nobjs</span></span><br><span class="line">              <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240713213309191.png" alt="image-20240713213309191"></p><p>本文转载自：<a href="https://www.cnblogs.com/fortunely/p/16219743.html">https://www.cnblogs.com/fortunely/p/16219743.html</a></p>]]></content>
    
    
    <summary type="html">STL空间配置器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp位运算函数-__builtin_</title>
    <link href="https://penge666.github.io/posts/bcd9e906.html"/>
    <id>https://penge666.github.io/posts/bcd9e906.html</id>
    <published>2024-07-12T01:42:39.000Z</published>
    <updated>2024-08-22T01:45:30.353Z</updated>
    
    <content type="html"><![CDATA[<p><code>__builtin_</code> 系列函数是 GCC 提供的一些内置函数，旨在优化位运算和其他低级操作。这些函数通常直接映射到底层硬件指令，使得某些操作更为高效。以下是一些常用的位运算相关的 <code>__builtin_</code> 函数及其示例：</p><ol><li><strong><code>__builtin_popcount</code> / <code>__builtin_popcountl</code> / <code>__builtin_popcountll</code></strong></li></ol><ul><li><p><strong>功能</strong>: 计算整数的二进制表示中 <code>1</code> 的个数（即汉明重量）。</p></li><li><p><strong>示例</strong>: 假设我们需要统计一个整数的二进制表示中有多少个 <code>1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0b110110</span>; <span class="comment">// 二进制表示：110110</span></span><br><span class="line">    <span class="type">int</span> count = __builtin_popcount(x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of 1s in &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Number</span> of <span class="number">1</span>s in <span class="number">54</span> is: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>解释: <code>110110</code> 中有四个 <code>1</code>。</p></li></ul><ol start="2"><li><strong><code>__builtin_ctz</code> / <code>__builtin_ctzl</code> / <code>__builtin_ctzll</code></strong></li></ol><ul><li><p><strong>功能</strong>: 计算整数二进制表示下从右往左数连续 <code>0</code> 的个数（Count Trailing Zeros）。</p></li><li><p><strong>示例</strong>: 找出一个整数尾部连续 <code>0</code> 的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0b1001000</span>; <span class="comment">// 二进制表示：1001000</span></span><br><span class="line">    <span class="type">int</span> trailing_zeros = __builtin_ctz(x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of trailing zeros in &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; trailing_zeros &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Number</span> of trailing zeros in <span class="number">72</span> is: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>解释: <code>1001000</code> 尾部有三个 <code>0</code>。</p></li></ul><ol start="3"><li><strong><code>__builtin_clz</code> / <code>__builtin_clzl</code> / <code>__builtin_clzll</code></strong></li></ol><ul><li><p><strong>功能</strong>: 计算整数二进制表示下从左往右数的前导 <code>0</code> 的个数（Count Leading Zeros）。</p></li><li><p><strong>示例</strong>: 找出一个整数前导连续 <code>0</code> 的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0b00001000</span>; <span class="comment">// 二进制表示：00001000</span></span><br><span class="line">    <span class="type">int</span> leading_zeros = __builtin_clz(x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of leading zeros in &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; leading_zeros &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Number of leading zeros in <span class="number">8</span> is: <span class="number">28</span></span><br></pre></td></tr></table></figure><p>解释: 对于 32 位整数，<code>00001000</code> 前导有 28 个 <code>0</code>。</p></li></ul><ol start="4"><li><strong><code>__builtin_parity</code> / <code>__builtin_parityl</code> / <code>__builtin_parityll</code></strong></li></ol><ul><li><p><strong>功能</strong>: 计算整数二进制表示中 <code>1</code> 的个数的奇偶性。如果 <code>1</code> 的个数是奇数，返回 <code>1</code>；否则返回 <code>0</code>。</p></li><li><p><strong>示例</strong>: 检查整数的奇偶性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0b1011</span>; <span class="comment">// 二进制表示：1011</span></span><br><span class="line">    <span class="type">int</span> parity = __builtin_parity(x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parity of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; parity &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Parity</span> of <span class="number">11</span> is: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>解释: <code>1011</code> 中有三个 <code>1</code>，为奇数，故返回 <code>1</code>。</p></li></ul><ol start="5"><li><strong><code>__builtin_bswap16</code> / <code>__builtin_bswap32</code> / <code>__builtin_bswap64</code></strong></li></ol><ul><li><p><strong>功能</strong>: 交换字节顺序，用于大小端转换。</p></li><li><p><strong>示例</strong>: 将 <code>32</code> 位整数的字节顺序进行交换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">uint32_t</span> swapped = __builtin_bswap32(x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original: 0x&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; x &lt;&lt; <span class="string">&quot;, Swapped: 0x&quot;</span> &lt;&lt; swapped &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:c</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Original</span>: <span class="number">0</span>x12345678, Swapped: <span class="number">0</span>x78563412</span><br></pre></td></tr></table></figure><p>解释: <code>0x12345678</code> 经过字节顺序交换变为 <code>0x78563412</code>。</p></li></ul><ol start="6"><li><strong><code>__builtin_ffs</code> / <code>__builtin_ffsl</code> / <code>__builtin_ffsll</code></strong></li></ol><ul><li><p><strong>功能</strong>: 找到整数中最低位 <code>1</code> 的位置，返回从 <code>1</code> 开始的位置索引，如果没有找到则返回 <code>0</code>。</p></li><li><p><strong>示例</strong>: 找到整数中最低位 <code>1</code> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0b101000</span>; <span class="comment">// 二进制表示：101000</span></span><br><span class="line">    <span class="type">int</span> position = __builtin_ffs(x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First set bit in &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is at position: &quot;</span> &lt;&lt; position &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">First <span class="keyword">set</span> bit <span class="keyword">in</span> <span class="number">40</span> <span class="keyword">is</span> <span class="keyword">at</span> position: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>解释: <code>101000</code> 中最低位的 <code>1</code> 在第 <code>4</code> 位。</p></li></ul><p><strong>总结</strong></p><p><code>__builtin_</code> 系列函数是 C++ 中非常高效的位运算工具，能显著提高特定操作的性能。通过这些示例，我们可以看到它们在各种实际应用场景中的效果</p>]]></content>
    
    
    <summary type="html">Cpp位运算函数-__builtin_</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>互斥锁、读写锁、自旋锁</title>
    <link href="https://penge666.github.io/posts/39f9f1ca.html"/>
    <id>https://penge666.github.io/posts/39f9f1ca.html</id>
    <published>2024-07-02T04:00:20.000Z</published>
    <updated>2024-08-25T13:08:44.783Z</updated>
    
    <content type="html"><![CDATA[<p>鹰击长空鲸霸海，不试怎知龙与邱！</p><h2 id="1-前言">1.前言</h2><p>本文介绍锁与临界资源与原子操作的的使用场景。</p><h2 id="2-临界资源">2.临界资源</h2><h3 id="2-1-什么是临界资源">2.1 什么是临界资源</h3><p>临界资源就是被多个线程/进程共享，但在某一时刻只能被一个线程/进程所使用的资源。   下文以一个经典案例(多线程同时进行i++)介绍三种锁，以及cpu指令集支持的原子操作和CAS。</p><p>主线程启动后创建十个线程，并将主线程中的count变量当作参数传入子线程中，也就是说十个线程同时操作一个共享资源count，子线程执行10w次count++ 操作，主线程每隔两秒打印一次count的值。下面来看看加锁与不加锁的区别。</p><h3 id="2-2-多线程操作临界资源且不加锁">2.2 多线程操作临界资源且不加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们预期count最终是达到100w，为什么在不加锁的时候没有达到预期效果？很明显，count++不是原子操作</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120141957.png" alt="image-20240702120141957"></p><h3 id="2-3-i-不是原子操作-i-对应三条汇编指令">2.3 i++不是原子操作,i++对应三条汇编指令</h3><p>如果i++是原子操作，那么必然会累加到100w，那么i++到底对应着那几步呢？</p><p>下面以idx++举例，idx的值是存储在内存里面，首先从内存MOV到eax寄存器里面，然后通过寄存器进行自增，最后再从eax写回到内存中。在编译器不做任何优化的情况下，idx++就对应这三个步骤。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120158334.png" alt="image-20240702120158334"></p><p>在大多数情况下，程序是这样执行的</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120209782.png" alt="image-20240702120209782"></p><p>但是也会存在下面这两种情况。线程1首先将idx的值读到了寄存器，然后cpu执行线程2，线程2执行完三步骤后，又回到线程1，线程1接着执行剩下的两步。有人可能会想，两个线程不都执行完了吗？有什么不同？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120226769.png" alt="image-20240702120226769"></p><p>首先，在线程1让出后，线程1的上下文(比如这里的eax)，是存储到线程1里面的，线程1恢复后，又将上下文load回去。这里就涉及到yield和resume了，详细介绍看纯c协程框架NtyCo实现与原理的第二节与第三节。 理解了上下文的切换后，就容易理解了，有没有发现，两次++操作，最终会漏加。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120244473.png" alt="image-20240702120244473"></p><p>所以在多线程中，操作临界资源时，那么这个临界资源是原子的，那么就不用加锁，要么就必须加锁，否在就会出现上述问题！</p><p>那么所谓加锁是什么意思？就是将这三条汇编指令变成一个原子操作，只要有一个线程lock加锁了，别的线程就不能执行进来，直到加锁的线程解锁，别的线程才能加锁。那么这三条汇编指令就是原子的了。下面将介绍3中锁以及2个原子操作。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120256216.png" alt="image-20240702120256216"></p><h3 id="2-4-多线程操作临界资源且加互斥锁">2.4 多线程操作临界资源且加互斥锁</h3><p>下面来看看两种加锁方式，这两种都可以跑了100w，但是这两种加锁的粒度是不一样的，在这个程序中，谁是临界资源？是pcount，而不是while，所以第二种加锁虽然可以跑通，但是它加锁的粒度太大了，就本程序而言，第二种加锁方式这和单线程跑有什么区别？所以我们要对临界资源加锁,不是临界资源的不加锁，掌控好锁的粒度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确加锁</span></span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    (*pcount)++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误加锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">    (*pcount)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到加锁之后，成功达到我们的预期</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120337410.png" alt="image-20240702120337410"></p><h3 id="2-5-多线程操作临界资源且加读写锁">2.5 多线程操作临界资源且加读写锁</h3><p>读写锁，顾名思义，读临界资源的时候加读锁，写临界资源的时候加写锁。适用于读多写少的场景。</p><p>A线程加了读锁，B线程可以继续加读锁，但是不能加写锁。 A线程加了写锁，B线程不能加读锁，也不能加写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120405727.png" alt="image-20240702120405727"></p><h3 id="2-6-多线程操作临界资源且加自旋锁">2.6 多线程操作临界资源且加自旋锁</h3><p>spinlock与mutex一样，mutex在哪里加锁，spinlock就在哪加锁，使用方法是一样的，但是其内部行为不一样。那么mutex和spinlock的区别在哪呢？</p><p>互斥锁在获取不到锁时，会进入休眠，等待释放时被唤醒。会让出CPU。 自旋锁在获取不到锁时，一直等待，在等待过程种不会有进程，线程切换。只会一直等，死等。</p><p>互斥锁与自旋锁的使用场景下文介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_spin_lock</span>(&amp;spinlock);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_spin_unlock</span>(&amp;spinlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;spinlock, PTHREAD_PROCESS_SHARED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120430596.png" alt="image-20240702120430596"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120437972.png" alt="image-20240702120437972"></p><p>补充：<strong>自旋锁会不会死锁</strong>？</p><p>给出我的观点：是锁就会有死锁问题！</p><p><strong>嵌套自旋锁导致的死锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock);  <span class="comment">// 第一次获取锁</span></span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock);  <span class="comment">// 再次尝试获取同一个锁，会导致死锁</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock);</span><br><span class="line">    spin_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环依赖导致的死锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock1, lock2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_A</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock1);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock2);  <span class="comment">// 线程A等待lock2</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock2);</span><br><span class="line">    spin_unlock(&amp;lock1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_B</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock2);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock1);  <span class="comment">// 线程B等待lock1</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock1);</span><br><span class="line">    spin_unlock(&amp;lock2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，线程A持有lock1并等待获取lock2，而线程B持有lock2并等待获取lock1，这种情况会导致两个线程都无法继续执行，从而导致死锁。</p><p><strong>总结</strong></p><p>自旋锁本身并不会直接导致死锁，但在特定的使用场景下，如果代码设计不合理，可能会出现死锁。为了避免死锁，开发者应该：</p><ul><li>避免嵌套使用同一个自旋锁。</li><li>设计时避免循环依赖关系，确保获取锁的顺序一致。</li><li>考虑使用其他同步机制，如互斥锁（mutex）或读写锁（rwlock），这些锁可以避免自旋锁的一些问题，特别是在锁持有时间较长的情况下。</li></ul><h3 id="2-7-原子操作">2.7 原子操作</h3><p>我们发现加锁，都是将i++对应的汇编的三个步骤，变成原子性。那么我们有没有办法直接将i++对应的汇编指令，变成一条指令？可以，我们使用xaddl这条指令。</p><p>Intel X86指令集提供了指令前缀lock⽤于锁定前端串⾏总线FSB，保证了指令执⾏时不会收到其他处理器的⼲扰。</p><p>所谓原子操作，它不是某条具体的指令，它是CPU支持的指令集，都是原子操作。比如说CAS，CAS是原子操作的一种，而不能说原子操作就是CAS。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">xaddl -----&gt; Inc</span><br><span class="line">xaddl：第二个参数加第一个参数，并把值存储到第一个参数里</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;lock; xaddl %2, %1;&quot;</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;=a&quot;</span> (old)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;m&quot;</span> (*value), <span class="string">&quot;a&quot;</span> (add)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(pcount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmpxchg-----&gt; CAS CAS：Compare And Swap，先比较，再赋值，翻译成代码就是下面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a==b)&#123;<span class="comment">//Compare</span></span><br><span class="line">a=c;<span class="comment">//Swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPU的指令集支持了先比较后赋值的指令，叫cmpxchg。正因为CPU执行了这个指令，它才是原子操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Perform atomic &#x27;compare and swap&#x27; operation on the pointer.</span></span><br><span class="line"><span class="comment">//  The pointer is compared to &#x27;cmp&#x27; argument and if they are</span></span><br><span class="line"><span class="comment">//  equal, its value is set to &#x27;val&#x27;. Old value of the pointer is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T *<span class="title">cas</span> <span class="params">(T *cmp_, T *val_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T *old;</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;lock; cmpxchg %2, %3&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;=a&quot;</span> (old), <span class="string">&quot;=m&quot;</span> (ptr)</span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;r&quot;</span> (val_), <span class="string">&quot;m&quot;</span> (ptr), <span class="string">&quot;0&quot;</span> (cmp_)</span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-三种锁的api介绍">3.三种锁的api介绍</h2><h3 id="3-1-互斥锁-mutex">3.1 互斥锁 mutex</h3><p>【互斥锁也会自选一会，超过时间的时候OS才会将线程阻塞起来！】</p><p>有两个特殊的api，pthread_mutex_trylock 尝试加锁，如果没有获取到锁则返回，而不是休眠。pthread_mutex_timedlock 等待一段时间，超时了还没获取倒锁则返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mutex handling.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__mutexattr)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try locking a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/* Wait until lock becomes available, or specified time passes. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_timedlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__restrict __mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">    __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-读写锁-rdlock">3.2 读写锁 rdlock</h3><p>读写锁适用于多读少写的情况，否则还是用互斥锁。</p><p>A线程加了读锁，B线程可以继续加读锁，但是不能加写锁。 A线程加了写锁，B线程不能加读锁，也不能加写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling read-write locks.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize read-write lock RWLOCK using attributes ATTR, or use</span></span><br><span class="line"><span class="comment">   the default values if later is NULL.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">__attr)</span> __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy read-write lock RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire read lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire read lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">  __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire read lock for RWLOCK or return after specfied time.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_timedrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">       __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire write lock for RWLOCK or return after specfied time.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_timedwrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">       __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-自旋锁-spinlock">3.3 自旋锁 spinlock</h3><p>自旋锁最大的特点是，获取不到锁就一直等待，即使CPU时间片用完了也不会发生切换，死等。而上面两种锁不一样，获取不到就会休眠，让出CPU时间片，切换到其他线程或进程执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions to handle spinlocks.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can</span></span><br><span class="line"><span class="comment">   be shared between different processes.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_init</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock, <span class="type">int</span> __pshared)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy the spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_destroy</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait until spinlock LOCK is retrieved.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_lock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to lock spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_trylock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_unlock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-递归锁">3.4 递归锁</h3><p>递归锁（Recursive Lock）也称为可重入<a href="https://so.csdn.net/so/search?q=%E4%BA%92%E6%96%A5%E9%94%81&amp;spm=1001.2101.3001.7020">互斥锁</a>（reentrant mutex），是互斥锁的一种，<strong>同一线程对其多次加锁不会产生死锁</strong>。递归锁会使用引用计数机制，以便可以从同一线程多次加锁、解锁，当加锁、解锁次数相等时，锁才可以被其他线程获取。</p><p>递归锁（Reentrant Lock）在C++中的实现和应用场景，主要是为了处理递归函数或在同一线程中多次进入临界区的情况。递归锁可以避免因多次获取同一个锁而导致的死锁问题。</p><p><strong>递归锁的用途</strong></p><ol><li><strong>递归函数中的同步</strong>：<ul><li>当一个递归函数需要同步时，使用普通的互斥锁会导致在递归调用时锁无法再次获取，从而导致死锁。递归锁允许同一个线程多次获取锁，因此在递归函数中非常有用。</li></ul></li><li><strong>复杂逻辑中的多次加锁</strong>：<ul><li>在某些复杂的逻辑中，同一个线程可能需要多次进入临界区。使用递归锁可以避免由于多次加锁而导致的死锁问题。</li></ul></li><li><strong>代码重用和模块化</strong>：<ul><li>当函数A调用函数B，而函数B又需要同步时，且函数A已经持有锁，这种情况下使用递归锁可以使代码更加模块化，减少代码耦合。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义递归锁</span></span><br><span class="line">std::recursive_mutex recMutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取递归锁</span></span><br><span class="line">    recMutex.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock acquired by thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; with count &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用自身</span></span><br><span class="line">    <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放递归锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock released by thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; with count &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    recMutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(recursiveFunction, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-三种锁的使用场景">4.三种锁的使用场景</h2><p>比如说读一个文件，就使用mutex。而如果是简单的加加减减操作，就是用spinlock。如果系统提供了原子操作的接口，对于i++这种操作来说，用原子操作更合适。</p><p>spinlock：临界资源操作简单/没有发生系统调用/持续时间较短（<strong>自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，等待时消耗cpu资源较多，自旋锁一般用于多核的服务器</strong>。）</p><p>mutex：临界资源操作复杂/发生系统调用/持续时间比较长</p><ul><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li><li>临界区竞争非常激烈</li><li>单核处理器</li></ul><p>补充：</p><p><strong>案例1：单核处理器上的自旋锁讲述</strong></p><p>在单核处理器上，虽然同时只有一个进程在执行，但通过操作系统的调度，多个进程仍然可以并发地运行。比如，进程A正在执行，并且持有自旋锁，这时操作系统决定切换到进程B。</p><ol><li><strong>进程A持有自旋锁</strong>：进程A获取了自旋锁，并正在执行某些操作。</li><li><strong>上下文切换</strong>：操作系统决定切换到进程B，因为进程A的时间片用完了，或者操作系统认为进程B需要运行。</li><li><strong>进程B尝试获取自旋锁</strong>：进程B开始运行，并试图获取同一个自旋锁。因为锁被进程A持有，进程B会进入自旋等待状态，不断地检查锁的状态。</li><li><strong>再次切换到进程A</strong>：操作系统可能再次切换回进程A，进程A继续运行并最终释放自旋锁。</li><li><strong>进程B获取自旋锁</strong>：一旦进程A释放锁，操作系统可能会切换回进程B，进程B就可以成功获取锁并继续执行。</li></ol><p><strong>案例2：多核处理器上的自旋锁讲述</strong></p><p><strong>初始状态</strong>：</p><ul><li>共享资源初始状态为未被锁定。</li><li>自旋锁初始状态为未被持有。</li></ul><p><strong>进程A尝试获取锁</strong>：</p><ul><li>进程A运行在CPU核1上，它试图获取自旋锁来访问共享资源。</li><li>自旋锁目前未被持有，因此进程A成功获取锁，并进入临界区开始访问共享资源。</li></ul><p><strong>进程B尝试获取锁</strong>：</p><ul><li>在进程A持有锁的同时，进程B在CPU核2上运行，也试图获取同一个自旋锁。</li><li>由于锁已被进程A持有，进程B进入自旋等待状态，在CPU核2上不断循环检查锁的状态。</li></ul><p><strong>进程A释放锁</strong>：</p><ul><li>进程A完成对共享资源的访问，释放自旋锁。</li><li>锁的状态变为未被持有。</li></ul><p><strong>进程B获取锁</strong>：</p><ul><li><p>进程B在自旋等待中检测到锁已被释放，立即获取自旋锁。</p></li><li><p>进程B进入临界区开始访问共享资源。</p><p>【因为始终只有一把自旋锁】</p></li></ul><p>原子操作：使用场景很小，必须需要CPU的指令集支持才行。（原子操作适用于简单的加减等数学运算，属于粒度最小的操作。比如往链表里增加一个结点，可以做出原子操作吗？不行，因为CPU指令集没有同时多个赋值的指令。cas 多线程同时竞争的时候效率并不会特别高，如果互斥锁和自旋锁能满足要求了尽量不要用cas）</p><h2 id="5-原子操作的接口">5.原子操作的接口</h2><p>对于gcc、g++编译器来讲，它们提供了⼀组API来做原⼦操作：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_add </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_sub </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_or </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_and </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_xor </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_nand </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"></span><br><span class="line">bool __sync_bool_compare_and_swap (<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">oldval </span><span class="keyword">type</span> <span class="type">newval, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_val_compare_and_swap </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">oldval </span><span class="keyword">type</span> <span class="type">newval, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_lock_test_and_set </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line">void __sync_lock_release (<span class="keyword">type</span> <span class="type">*ptr, </span>...)</span><br></pre></td></tr></table></figure><p>详细⽂档⻅：<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins">https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins</a></p><h2 id="补充">补充</h2><h3 id="Q：悲观锁和乐观锁的使用场景">Q：悲观锁和乐观锁的使用场景</h3><p>悲观锁和乐观锁是并发控制的两种策略，它们在不同的场景下有不同的应用。</p><blockquote><ol><li><strong>悲观锁</strong></li></ol></blockquote><p><strong>概念</strong>:<br>悲观锁假设数据在多线程环境下非常容易发生冲突，因此在数据访问前会锁定资源，确保其他线程不能访问或修改数据，直到当前操作完成。悲观锁一般通过数据库锁机制或操作系统锁机制实现。</p><p><strong>应用场景</strong>:</p><ul><li><strong>高并发环境下频繁写操作</strong>：在高并发的系统中，如果对数据的写操作非常频繁，发生冲突的概率很高，此时使用悲观锁可以有效避免数据的不一致性。<ul><li><strong>示例</strong>: 银行系统中的转账操作。当一个用户正在转账时，需要锁定账户信息，防止其他用户同时对同一账户进行操作，导致数据错误。</li></ul></li><li><strong>长事务</strong>：在需要长时间持有锁的事务中，使用悲观锁可以确保数据在整个事务过程中不被其他事务修改。<ul><li><strong>示例</strong>: ERP 系统中，处理订单或库存时需要确保数据的一致性和完整性，因此会在整个事务期间锁定相关资源。</li></ul></li><li><strong>强一致性要求</strong>：如果业务场景对数据一致性要求极高，任何时候都不能容忍数据不一致，悲观锁是更好的选择。<ul><li><strong>示例</strong>: 在交易撮合系统中，为了确保每个交易的唯一性和准确性，可能会对关键数据使用悲观锁。</li></ul></li></ul><blockquote><p>2.<strong>乐观锁</strong></p></blockquote><p><strong>概念</strong>:<br>乐观锁假设数据冲突较少，因此不会锁定资源，而是允许多个线程同时操作。乐观锁在提交数据时，会检查是否发生冲突，如果有冲突则回滚并重试。乐观锁通常通过版本号机制或时间戳机制实现。</p><p><strong>应用场景</strong>:</p><ul><li><strong>读多写少的场景</strong>：在读操作远多于写操作的系统中，数据冲突的概率较低，使用乐观锁可以提高并发性能，因为它不会对数据加锁，减少了系统开销。<ul><li><strong>示例</strong>: 电子商务系统中的商品浏览功能。大量用户同时浏览商品时，使用乐观锁可以提高系统的并发性，因为读取操作不需要加锁。</li></ul></li><li><strong>短事务</strong>：在处理短时间的事务时，乐观锁的性能优势更加明显，因为数据冲突的概率更低，且回滚和重试的代价不高。<ul><li><strong>示例</strong>: 社交网络的用户信息更新。大部分情况下，用户的更新操作是快速完成的，而且冲突的概率较低，因此乐观锁更合适。</li></ul></li><li><strong>低冲突场景</strong>：在业务逻辑中，大多数操作对同一数据的冲突很少发生，乐观锁允许多个线程并发操作，提高了系统的吞吐量。<ul><li><strong>示例</strong>: 在线编辑文档的协作系统。多个用户同时编辑不同部分时，乐观锁允许大家并行操作，只有在最终保存时才进行冲突检测。</li></ul></li></ul><blockquote><p><strong>总结</strong></p></blockquote><ul><li><strong>悲观锁</strong>：适用于高并发写操作场景、长事务、以及对数据一致性要求极高的场景。其优点是能有效避免冲突，但缺点是可能导致性能瓶颈和死锁问题。</li><li><strong>乐观锁</strong>：适用于读多写少、短事务、和低冲突的场景。其优点是高并发性能好，但缺点是在高冲突场景下可能导致大量重试和性能下降。</li></ul><p>在实际开发中，选择哪种锁策略应根据业务场景的特点和需求来决定。</p><p>学习自：<a href="https://blog.csdn.net/qq_42956653/article/details/126141284">互斥锁、读写锁、自旋锁，以及原子操作指令xaddl、cmpxchg的使用场景剖析</a></p>]]></content>
    
    
    <summary type="html">锁向无敌</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://penge666.github.io/posts/735e5788.html"/>
    <id>https://penge666.github.io/posts/735e5788.html</id>
    <published>2024-07-01T14:51:48.000Z</published>
    <updated>2024-07-08T02:46:35.698Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序、插入排序、选择排序、计数排序、堆排序、快速排序、归并排序</p><p><strong>基本概念</strong></p><p>排序算法的稳定性：如果待排序的序列中存在相同键值的元素，排序前后的相对顺序保持不变。【相同的元素不交换位置】</p><p><strong>最坏时间复杂度、最好时间复杂度和平均时间复杂度.</strong></p><p><strong><code>最坏时间复杂度</code></strong><br>最坏情况下的时间复杂度称最坏时间复杂度，一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。</p><p><strong><code>平均时间复杂度</code></strong><br>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间，设每种情况的出现的概率为pi,平均时间复杂度则为sum(pi*f(n)) 。</p><p><strong><code>最好时间复杂度</code></strong><br>最理想情况下的时间复杂度称最好时间复杂度。</p><h2 id="冒泡排序">冒泡排序</h2><p>【分组插入排序】</p><p>思路分析：</p><p>①比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>②对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p><p>③针对所有的元素重复以上的步骤，除了最后一个。</p><p>④持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>过程动态图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/BubbleSort.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：冒泡排序算法最坏的情况和平均复杂度是O(n^2)，最好时间复杂度为O(n)，空间复杂度为O(1)，排序算法稳定。</p><h2 id="直接插入排序">直接插入排序</h2><p>思路分析：</p><p>①在长度为N的数组，将数组中第i  [1~（N-1) ] 个元素，插入到数组 [0~i] 适当的位置上。</p><p>②在排序的过程中当前元素之前的数组元素已经是有序的了。</p><p>③在插入的过程中，有序的数组元素，需要向右移动为更小的元素腾出空间，直到为当前元素找到合适的位置。</p><p>过程动态图展示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/insert_sort.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="keyword">for</span> (j; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; temp) &#123;</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：时间复杂度平均为O(n^2)，最坏为O(n^2)，最好为O(n)，空间复杂度为O(1)，排序算法稳定。</p><h2 id="希尔排序">希尔排序</h2><p><strong>基本思想</strong></p><p>希尔排序的核心思想是先将数组分割成若干个子序列，然后对每个子序列进行插入排序。随着算法的进行，子序列之间的间隔（gap）逐渐减小，直到最后变为1，此时整个数组变为一个子序列行最后一次插入排序。</p><p><strong>希尔排序的过程</strong></p><ol><li>选择一个初始的间隔序列（通常为数组长度的一半）。</li><li>对于每个间隔 gap，将数组分割成若干个子序列。</li><li>对每个子序列进行插入排序。</li><li>减少间隔，重复步骤2和3，直到间隔为1。</li></ol><p><strong>举例说明</strong></p><p>假设我们有一个长度为 8 的数组 [8, 4, 1, 3, 2, 7, 6, 5]，按照希尔排序的步骤进行排序：</p><ol><li>初始间隔 gap = 4：<ul><li>子序列1：[8, 2]</li><li>子序列2：[4, 7]</li><li>子序列3：[1, 6]</li><li>子序列4：[3, 5]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 2：<ul><li>子序列1：[2, 1, 6, 5]</li><li>子序列2：[8, 4, 3, 7]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 1：<ul><li>整个数组进行一次插入排序。</li></ul></li></ol><p>通过这个例子，可以看到希尔排序如何逐步减少间隔并进行排序。</p><p>假设我们有一个长度为 8 的数组 [8, 4, 1, 3, 2, 7, 6, 5]，按照希尔排序的步骤进行排序：</p><ol><li>初始间隔 gap = 4：<ul><li>子序列1：[8, 2]</li><li>子序列2：[4, 7]</li><li>子序列3：[1, 6]</li><li>子序列4：[3, 5]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 2：<ul><li>子序列1：[2, 1, 6, 5]</li><li>子序列2：[8, 4, 3, 7]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 1：<ul><li>整个数组进行一次插入排序。</li></ul></li></ol><p>通过这个例子，可以看到希尔排序如何逐步减少间隔并进行排序。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">int</span> gap = n;</span><br><span class="line"><span class="keyword">while</span>(gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap/<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//控制分组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; n-gap;i++)<span class="comment">//注意边界条件，避免越界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = a[end+gap];</span><br><span class="line"><span class="keyword">while</span>(end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[end] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">a[end+gap] = a[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[end+gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【✳】<strong>时间复杂度分析</strong></p><p>希尔排序的时间复杂度分析涉及到以下几个方面：</p><p><strong>1. 间隔序列的选择</strong></p><p>希尔排序的效率很大程度上取决于所选择的间隔序列。常见的间隔序列有：</p><ul><li>希尔序列：间隔序列为 { n/2, n/4, …, 1 }。</li><li>Hibbard 序列：间隔序列为 { 1, 3, 7, …, 2^k - 1 }。</li><li>Knuth 序列：间隔序列为 { 1, 4, 13, 40, …, (3^k - 1) / 2 }。</li></ul><p>不同的间隔序列会影响排序的时间复杂度。这里我们以希尔序列为例进行分析。</p><p><strong>2. 插入排序的时间复杂度</strong></p><p>对于一个长度为 h 的子序列，插入排序的时间复杂度为 O(h^2)。</p><p><strong>3. 总时间复杂度</strong></p><p><strong>计算方式</strong></p><p>假设数组长度为 n，间隔序列为 { n/2, n/4, …, 1 }。在每个间隔 gap 下进行插入排序的时间复杂度可以近似看作 O(n)。</p><p>具体分析如下：</p><ul><li>当 gap = n/2 时，进行 n/2 次插入排序，每次插入排序的时间复杂度为 O((n/2)^2) = O(n^2/4)。</li><li>当 gap = n/4 时，进行 n/4 次插入排序，每次插入排序的时间复杂度为 O((n/4)^2) = O(n^2/16)。</li><li>依次类推，直到 gap = 1。</li></ul><p>由于每次 gap 变为原来的一半，总的时间复杂度可以表示为：<br>T(n) = O(n^2/4) + O(n^2/16) + … + O(1)</p><p>这实际上是一个几何级数，求和结果为：<br>T(n) = O(n^2 * (1/4 + 1/16 + … + 1/n^2))</p><p>因为这个和趋近于 O(n log^2 n)，所以希尔排序的平均时间复杂度为 O(n log^2 n)。</p><p><strong>总结</strong></p><p>时间复杂度可以在 O(n^(1.3)) 到 O(n^2) 之间。</p><p><strong>常见的间隔序列及其时间复杂度</strong></p><ol><li>希尔序列（Shell Sequence）：间隔序列为 {n/2, n/4, …, 1}。<ul><li>时间复杂度：O(n^2)</li></ul></li><li>Hibbard 序列：间隔序列为 {1, 3, 7, …, 2^k - 1}。<ul><li>时间复杂度：O(n^(3/2))</li></ul></li><li>Knuth 序列：间隔序列为 {1, 4, 13, 40, …, (3^k - 1) / 2}。<ul><li>时间复杂度：O(n^(3/2))</li></ul></li><li>Sedgewick 序列：间隔序列为 {1, 5, 19, 41, 109, …}。<ul><li>时间复杂度：O(n^(4/3))</li></ul></li><li>Pratt 序列：间隔序列为 {1, 2, 3, 4, 6, 8, 9, …}，即2的幂和3的幂的所有组合。<ul><li>时间复杂度：O(n log^2 n)</li></ul></li></ol><p><strong>时间复杂度计算示例：Hibbard 序列</strong></p><p>假设我们使用 Hibbard 序列，间隔序列为 {1, 3, 7, …, 2^k - 1}。</p><p><strong>分析步骤</strong></p><ol><li>间隔序列长度：对于一个长度为 n 的数组，最大间隔 k 满足 2^k - 1 ≈ n，即 k ≈ log_2 n。</li><li>每个间隔下的复杂度：在每个间隔 h 下，插入排序的复杂度为 O(n / h * h) = O(n)。</li><li>总复杂度：对于每个间隔 h，我们需要进行 k 次插入排序。由于 k ≈ log_2 n，总复杂度为 O(n log_2 n)。</li></ol><p>然而，由于 Hibbard 序列的实际排序效果，实验结果表明其平均时间复杂度更接近于 O(n^(3/2))。</p><p><strong>总结</strong></p><p>希尔排序的时间复杂度范围很广，具体取决于所使用的间隔序列。一般来说，时间复杂度可以在 O(n^(1.3)) 到 O(n^2) 之间变化。对于大多数实际应用，使用优化的间隔序列（如 Sedgewick 序列或 Pratt 序列）可以得到较好的时间复杂度，接近 O(n log^2 n)。</p><p><strong>参考公式</strong></p><ul><li>希尔序列：O(n^2)</li><li>Hibbard 序列：O(n^(3/2))</li><li>Knuth 序列：O(n^(3/2))</li><li>Sedgewick 序列：O(n^(4/3))</li><li>Pratt 序列：O(n log^2 n)</li></ul><p><strong>为什么说希尔排序不稳定！</strong></p><p>举个例子来说明这个问题：</p><p>假设有以下数组：<code>[3, 3, 1, 2, 2]</code>。</p><ol><li>初始数组： <code>[3, 3, 1, 2, 2]</code></li><li>选择一个跨度（gap），例如2： 对于跨度为2的子序列，我们有两个子序列：<code>[3, 1, 2]</code>和<code>[3, 2]</code>。</li><li>对每个子序列进行插入排序：<ul><li>对子序列<code>[3, 1, 2]</code>，排序后为<code>[1, 2, 3]</code>。</li><li>对子序列<code>[3, 2]</code>，排序后为<code>[2, 3]</code>。</li></ul></li><li>合并结果： <code>[1, 2, 2, 3, 3]</code></li></ol><p>在这个例子中，原数组中两个相同的“2”的相对顺序在排序后改变了。原本位于数组后半部分的“2”被移到了前半部分，而前半部分的“2”则保持在后半部分，这说明了希尔排序的不稳定性。</p><h2 id="选择排序">选择排序</h2><p>**思路分析：**第一趟从n个元素的数据序列中选出关键字最小/大的元素并放在最前/后位置，下一趟从n-1个元素中选出最小/大的元素并放在最前/后位置。以此类推，经过n-1趟完成排序。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/select_sort.gif" alt=""></p><p>代码实现（此处代码对直接排序进行了有优化，遍历一次同时选出最大的和最小的，最大的放在最右边，最小的放在最左边，排序范围缩减）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">size_t</span> left = <span class="number">0</span>,right = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> min = left,max = left;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = left;i &lt;= right;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt; a[min])</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[min],a[left]);</span><br><span class="line"><span class="keyword">if</span>(max == left) <span class="comment">//最大值在最左边</span></span><br><span class="line">max = min;</span><br><span class="line"><span class="built_in">swap</span>(a[max],a[right]);</span><br><span class="line">--right;</span><br><span class="line">++left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**直接选择排序的最好时间复杂度号最坏时间复杂度都是O(n^2)，因为即使数组一开始就是正序的，也需要将两重循环进行完，平均时间复杂度也是O(n^2)，最好的时间复杂度为O(n^2)，空间复杂度为O(1)，因为不占用多余的空间。直接选择排序是一种原地排序并且不稳定的排序算法，优点是实现简单，占用空间小，缺点是效率低，时间复杂度高，对于大规模的数据耗时较长。</p><p><strong>为什么说选择排序不稳定</strong>！</p><p>举个例子来说明选择排序的不稳定性：</p><p>假设有以下数组：<code>[4, 2, 3, 2, 1]</code>。</p><ol><li>初始数组： <code>[4, 2, 3, 2, 1]</code></li><li>第一轮选择最小元素：<ul><li>当前数组：<code>[4, 2, 3, 2, 1]</code></li><li>最小元素是1，将其与第一个元素4交换：</li><li>交换后数组：<code>[1, 2, 3, 2, 4]</code></li></ul></li><li>第二轮选择最小元素：<ul><li>当前数组：<code>[1, 2, 3, 2, 4]</code></li><li>最小元素是2，将其与第二个元素2交换（没有实际变化）：</li><li>交换后数组：<code>[1, 2, 3, 2, 4]</code></li></ul></li><li>第三轮选择最小元素：<ul><li>当前数组：<code>[1, 2, 3, 2, 4]</code></li><li>最小元素是2，将其与第三个元素3交换：</li><li>交换后数组：<code>[1, 2, 2, 3, 4]</code></li></ul></li></ol><p>在这个例子中，原数组中两个相同的“2”的相对顺序在排序后改变了。原本位于数组第二个位置的“2”在排序后移动到了数组第三个位置，而原本在第四个位置的“2”则保持在第四个位置，这说明了选择排序的不稳定性。</p><h2 id="堆排序">堆排序</h2><p><strong>思路分析：</strong></p><p>①将长度为n的待排序的数组进行堆有序化构造成一个大顶堆</p><p>②将根节点与尾节点交换并输出此时的尾节点</p><p>③将剩余的n -1个节点重新进行堆有序化</p><p>④重复步骤2，步骤3直至构造成一个有序序列</p><p>（升序构建小堆，降序构建大堆）</p><p><strong>过程动态图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/AdjustDown.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> root,<span class="type">size_t</span> n)</span><span class="comment">//向下调整算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> parent = root;</span><br><span class="line"><span class="type">size_t</span> child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//下标为0的为第一个孩子，所以parent*2+1为下标为左孩子</span></span><br><span class="line"><span class="keyword">while</span>(child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span> &lt; n &amp;&amp; a[child+<span class="number">1</span>] &gt; a[child])</span><br><span class="line">&#123;</span><br><span class="line">++child;<span class="comment">//让child指向较大的那个孩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[child],a[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span><span class="comment">//升序，建大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//从第一个非叶子节点开始，做向下调整，调整完第一个元素为最大元素</span></span><br><span class="line"><span class="keyword">for</span>(i = (n<span class="number">-2</span>)/<span class="number">2</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(a,i,n);</span><br><span class="line">&#125;<span class="comment">//大堆建成</span></span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="comment">//交换第一个元素和最后一个元素，然后把交换后的第一个元素往下调整，再成大堆</span></span><br><span class="line"><span class="comment">//--end，即是缩小范围，每次把最大的换到end的位置</span></span><br><span class="line"><span class="keyword">for</span>(end = n<span class="number">-1</span>;end &gt;= <span class="number">0</span>;--end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[end],a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a,<span class="number">0</span>,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：堆排序的最好和最差情况时间复杂度都为O(nlog2n)，平均时间复杂度为O(nlog2n)，空间复杂度为O(1)，排序算法不稳定，无需使用多余的空间帮助排序。优点是占用空间较小，时间复杂度较低，缺点是实现较为复杂，并且当待排序序列发生改动时，哪怕是特别小的改动，都需要调整整个堆来维护堆的性质，维护开销较大。</p><p>时间复杂度</p><p><strong>构建堆的时间复杂度</strong></p><ul><li><strong>自底向上的堆化过程</strong>：在堆排序中，首先要将无序数组构建成一个最大堆。这一过程的时间复杂度为 O(n)。</li></ul><p><strong>排序过程的时间复杂度</strong></p><ul><li><strong>删除最大元素并重建堆</strong>：将最大堆的根节点（最大值）与最后一个节点交换，然后对剩余的 n−1个元素重新进行堆化。每次堆化的时间复杂度为 O(log⁡n)，因为堆化操作的高度最多为 log⁡2n</li></ul><p>这个过程需要进行 n−1 次，因此排序部分的总时间复杂度为：O(nlog2n)</p><p><strong>补充下建堆的过程</strong></p><p><strong>建堆步骤</strong></p><p>堆的性质要求每个节点的值都不小于（最大堆）或不大于（最小堆）其子节点的值。建堆的过程自底向上进行，因为这样可以确保在调整某个节点时，它的子节点已经是堆。</p><p><strong>详细步骤</strong></p><ol><li><strong>选择从最后一个非叶子节点开始</strong>：因为叶子节点本身已经是一个堆，所以我们只需要调整非叶子节点。最后一个非叶子节点的索引是 ⌊n/2⌋−1，其中 n 是数组的长度。</li><li><strong>自底向上调整堆</strong>：从最后一个非叶子节点开始，依次向前遍历每个节点，执行 <code>heapify</code> 操作以确保每个节点都满足堆的性质。</li></ol><p><strong><code>heapify</code> 操作</strong></p><p><code>heapify</code> 是调整堆的核心操作，确保以某个节点为根的子树满足堆的性质。</p><p><strong>伪代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;       <span class="comment">// 初始化 largest 为根节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于 largest</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 largest 不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]); <span class="comment">// 交换根节点和最大值节点</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);   <span class="comment">// 递归地调整受影响的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建堆的完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始自底向上调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    <span class="built_in">buildMaxHeap</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个一个地从堆中取出元素，并调整剩余的堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将当前堆的根节点（最大值）与堆的最后一个元素交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整剩余的堆，使其重新满足最大堆的性质</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>假设我们有一个数组[4,10,3,5,1]，建堆过程如下：</p><ol><li>初始数组：[4,10,3,5,1]</li><li>从最后一个非叶子节点 i=1 开始堆化：<ul><li>当前节点是 10，左子节点是 5，右子节点是 1，没有变化。</li></ul></li><li>处理根节点 i=0<ul><li>当前节点是 4，左子节点是 10，右子节点是 3。由于 10 最大，将 4 和 10 交换，得到 [][10, 4, 3, 5, 1][10,4,3,5,1]。</li><li>调整后的子树根节点是 4，它没有子节点需要调整。</li></ul></li></ol><p>结果是 [][10, 4, 3, 5, 1][10,4,3,5,1]，这个数组已经是最大堆。</p><h2 id="快速排序">快速排序</h2><p>本质上快速排序把数据划分成几份，所以快速排序通过选取一个关键数据，再根据它的大小，把原数组分成两个子数组：第一个数组里的数都比这个主元数据小或等于，而另一个数组里的数都比这个主元数据要大或等于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于交换两个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// i指向小于pivot的最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回pivot的正确位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序递归函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 获取分区点</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);  <span class="comment">// 排序左边部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 排序右边部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector版本的/手撕快排版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> i=left<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> j=right+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp=nums[left+<span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">while</span>(nums[++i]&lt;tmp) ;</span><br><span class="line"><span class="keyword">while</span>(nums[--j]&gt;tmp) ;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quickSort</span>(nums,left,j);</span><br><span class="line"><span class="built_in">quickSort</span>(nums,j+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortFun</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line"><span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">sortFun</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> resi:num) cout&lt;&lt;resi&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组中第 K 大的数</strong>：可以用快排实现，也可以用优先队列实现。</p><p>举例：</p><p>假设我们有数组 <code>arr = &#123;10, 7, 8, 9, 1, 5&#125;</code>，我们调用 <code>partition(arr, 0, 5)</code>。</p><ul><li>初始状态：<code>pivot = 5</code>，<code>i = -1</code>。</li><li>遍历数组：<ul><li><code>j = 0</code>，<code>arr[j] = 10</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 1</code>，<code>arr[j] = 7</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 2</code>，<code>arr[j] = 8</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 3</code>，<code>arr[j] = 9</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 4</code>，<code>arr[j] = 1</code>，小于 <code>pivot</code>，交换 <code>arr[0]</code> 和 <code>arr[4]</code>，<code>i = 0</code>。</li></ul></li><li>交换基准元素：<ul><li>将 <code>arr[1]</code> 和 <code>arr[5]</code> 交换，得到 <code>arr = &#123;1, 5, 8, 9, 10, 7&#125;</code>。</li></ul></li><li>返回值：<ul><li>返回 <code>i + 1 = 1</code>。</li></ul></li></ul><p>通过上述步骤，我们将数组划分为两部分：<code>&#123;1&#125;</code> 和 <code>&#123;8, 9, 10, 7&#125;</code>，其中基准元素 <code>5</code> 位于正确的位置。</p><p><strong>总结</strong>：平均时间复杂度为O(nlog2n)，最坏时间复杂度为O(n^2)，空间复杂度为O(nlog2n），排序算法不稳定。</p><p><strong>补充</strong>：</p><ul><li><p><strong>选择的枢轴（pivot）不理想</strong>：如果每次选择的枢轴总是数组中的最大或最小元素，快速排序将退化为最坏情况。例如，对于一个已经有序的数组，如果每次选择第一个元素或最后一个元素作为枢轴，快速排序会产生极度不平衡的划分，导致最坏时间复杂度 O(n^2)。</p><p>举个例子，假设我们总是选择第一个元素作为枢轴：</p><ul><li>对于一个已经有序的数组 <code>[1, 2, 3, 4, 5]</code>，第一次选择 1 作为枢轴，将数组划分为 <code>[]</code> 和 <code>[2, 3, 4, 5]</code>。</li><li>接下来，选择 2 作为枢轴，将数组划分为 <code>[]</code> 和 <code>[3, 4, 5]</code>。</li><li>继续下去，每次的划分都会导致一个子数组为空，另一个子数组包含剩余的所有元素。</li></ul><p>这样，每次递归调用都会减少一个元素，导致总体时间复杂度变为 O(n^2)。</p></li><li><p><strong>重复元素很多</strong>：当数组中有很多重复元素时，特别是所有元素都相同时，如果选择的枢轴总是那些重复的元素，快速排序也会退化。例如，对于一个全是相同元素的数组 <code>[5, 5, 5, 5, 5]</code>，如果选择枢轴为 5，每次划分后的两个子数组大小不变，这会导致快速排序退化为最坏时间复杂度。</p></li></ul><p>为了避免快速排序退化为 O(n^2)，常用的改进方法包括：</p><ul><li><strong>随机选择枢轴</strong>：在每次划分时随机选择一个元素作为枢轴，这样可以大大减少出现最坏情况的概率。</li><li><strong>三数取中法（Median of Three）</strong>：选择第一个元素、中间元素和最后一个元素的中位数作为枢轴。</li><li><strong>混合排序算法</strong>：当数组大小较小时，切换到插入排序等其他高效的排序算法，因为在小数组上，插入排序的性能通常优于快速排序。</li></ul><h2 id="归并排序">归并排序</h2><p><strong>思路分析：</strong></p><p>当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样<strong>递归下去，合并上来</strong>就是归并排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> *a, <span class="type">int</span> left, <span class="type">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">_MergeSort(a, left, mid);</span><br><span class="line">_MergeSort(a, mid+<span class="number">1</span>, right);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[right-left+<span class="number">1</span>];<span class="comment">//开辟同原数组大小的辅助空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = left;<span class="comment">//左区间的开头</span></span><br><span class="line"><span class="type">int</span> begin2 = mid+<span class="number">1</span>;<span class="comment">//右区间的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;<span class="comment">//辅助空间的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(begin1 &lt;= mid &amp;&amp; begin2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[begin1] &lt; a[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将余下的直接放入辅助空间</span></span><br><span class="line"><span class="keyword">while</span>(begin1 &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(begin2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tmp数组的值全部拷贝到a数组里面</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[left+i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;<span class="comment">//释放自己申请的空间</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line">_MergeSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手撕版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergefun</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"><span class="type">int</span> i=l;</span><br><span class="line"><span class="type">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(nums[i++]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp.<span class="built_in">push_back</span>(nums[i++]);</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) tmp.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tmp.<span class="built_in">size</span>();i++) nums[i+l]=tmp[i];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(nums,l,mid);</span><br><span class="line"><span class="built_in">mergeSort</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">mergefun</span>(nums,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortFun</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(nums,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">SortFun</span>(nums);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：平均和最坏、最好时间复杂度为O(nlog2n)，空间复杂度O(n)，排序算法稳定。</p><p>一个经典问题：数组中的逆序对（hard）</p><ul><li>[<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a>](<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/</a>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSort</span>(nums, tmp, left, mid) + <span class="built_in">mergeSort</span>(nums, tmp, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || tmp[i] &lt;= tmp[j]) &#123;</span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(nums, tmp, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240701233431874.png" alt="image-20240701233431874"></p><p>参考资料：</p><p><a href="https://blog.csdn.net/ypt523/article/details/80462873">排序算法（七大经典排序算法）</a></p><p><a href="https://segmentfault.com/a/1190000021638663#item-7-27">https://segmentfault.com/a/1190000021638663#item-7-27</a></p>]]></content>
    
    
    <summary type="html">七大经典排序算法</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>伙伴算法和slab算法</title>
    <link href="https://penge666.github.io/posts/f26278ad.html"/>
    <id>https://penge666.github.io/posts/f26278ad.html</id>
    <published>2024-06-30T09:36:48.000Z</published>
    <updated>2024-08-21T15:16:17.857Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中，用来管理物理内存页面的<strong>伙伴系统</strong>，以及负责分配比页更小的内存对象的<strong>SLAB分配器</strong>了。</p><p>待填坑<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2MzU3Mjc3Ng==&amp;action=getalbum&amp;album_id=2559805446807928833&amp;scene=173&amp;from_msgid=&amp;from_itemidx=&amp;count=3&amp;nolastread=1&amp;scene=21#wechat_redirect">slab内存池</a></p><blockquote><p><strong>内存池的管理，关心的指标</strong></p></blockquote><p>1.<strong>内存利用率</strong></p><ul><li><strong>内存碎片</strong>：内存池设计要尽量减少内存碎片。内存碎片会导致内存池中无法充分利用可用内存，影响内存利用率。</li><li><strong>占用空间</strong>：内存池的设计应尽量减少由于元数据（如块头信息、管理信息）导致的额外内存占用，使更多内存用于实际的对象存储。</li></ul><ol start="2"><li><strong>分配和释放的效率</strong></li></ol><ul><li><strong>分配速度</strong>：内存池的一个主要优点就是能够快速分配内存。因此，分配操作的时间复杂度需要非常低，通常是 O(1)。</li><li><strong>释放速度</strong>：释放内存也应尽可能高效，避免复杂的内存管理操作。释放后的内存块应能立即重新分配。</li></ul><ol start="3"><li><strong>内存池的大小和扩展性</strong></li></ol><ul><li><strong>初始大小</strong>：内存池的初始大小需要根据预期使用情况进行合理设定，既不能过大浪费内存，也不能过小频繁扩容。</li><li><strong>扩展策略</strong>：内存池在达到容量上限时，是否能够动态扩展，以及扩展的策略（例如每次扩展的大小）如何设计，会直接影响到系统的性能和内存使用。</li></ul><ol start="4"><li><strong>并发性</strong></li></ol><ul><li><strong>多线程支持</strong>：在多线程环境下使用内存池时，需要考虑对并发访问的支持。要设计线程安全的分配和释放机制，以避免竞争条件和死锁等问题。</li><li><strong>锁的粒度</strong>：如果使用锁来保护内存池，锁的粒度越小，可能的并发性越高，但实现复杂度也会增加。</li></ul><ol start="5"><li><strong>回收策略</strong></li></ol><ul><li><strong>内存池回收</strong>：当分配的对象不再使用时，如何将内存块回收到内存池中，或者如何防止内存池膨胀过大是设计中的一个重要问题。</li><li><strong>空闲内存管理</strong>：空闲的内存块应该如何组织，以便能快速找到合适大小的内存块进行分配（如空闲链表、位图等管理方式）。</li></ul><ol start="6"><li><strong>内存池的生命周期管理</strong></li></ol><ul><li><strong>生命周期</strong>：内存池本身的创建和销毁时机需要合理管理，避免内存泄漏或过早销毁带来的问题。</li><li><strong>内存池重置</strong>：有时需要在某些场景下重置内存池以释放内存，如何高效地重置或清空内存池也是需要考虑的。</li></ul><ol start="7"><li><strong>适配性和灵活性</strong></li></ol><ul><li><strong>内存块大小的适配性</strong>：内存池应该能够适应不同大小的分配请求，或者至少支持常用大小的分配。可以设计多级内存池来处理不同的内存块大小需求。</li><li><strong>灵活性</strong>：内存池应该能够在不同场景下灵活配置和使用，比如支持不同类型的对象分配、不同的内存分配策略等。</li></ul><ol start="8"><li><strong>内存安全</strong></li></ol><ul><li><strong>越界访问防护</strong>：内存池设计中需要考虑如何防止和检测越界访问的情况，以避免潜在的内存安全问题。</li><li><strong>非法释放检测</strong>：如果内存块已经释放或者从未分配过，系统应该能够检测到并防止非法的释放操作。</li></ul><ol start="9"><li><strong>调试和监控能力</strong></li></ol><ul><li><strong>内存统计信息</strong>：设计时应考虑如何提供内存池的使用统计信息（如已使用块数、空闲块数等）来辅助调试和性能优化。</li><li><strong>日志和报警机制</strong>：对于内存池中的异常情况（如内存泄漏、内存不足），应有相应的日志记录和报警机制，以便及时处理问题。</li></ul><ol start="10"><li><strong>内存池的可移植性</strong></li></ol><ul><li><strong>平台依赖性</strong>：设计的内存池应尽量减少对特定平台或操作系统的依赖，以提高代码的可移植性和复用性。</li></ul><p>关注以上这些关键指标，可以帮助你设计一个高效、可靠、可扩展的内存池管理系统，满足各种复杂的应用需求。</p>]]></content>
    
    
    <summary type="html">Linux内存管理-伙伴算法和slab算法</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用户态和内核态</title>
    <link href="https://penge666.github.io/posts/6407ef8f.html"/>
    <id>https://penge666.github.io/posts/6407ef8f.html</id>
    <published>2024-06-30T08:30:03.000Z</published>
    <updated>2024-06-30T09:05:20.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户态和内核态概述">用户态和内核态概述</h2><p><strong>简单来说内核态就是操作系统运行线程，用户态就是线程执行用户自己的程序。</strong></p><p><strong>用户态</strong>：</p><ul><li>不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</li></ul><p><strong>内核态</strong>：</p><ul><li><p>系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行。</p></li><li><p>内核态可以使用计算机所有的硬件资源。</p></li></ul><blockquote><p><strong>为什么要区分用户态和内核态？</strong></p></blockquote><p><strong>1. 安全性</strong></p><ul><li><strong>保护系统资源</strong>：内核态拥有对所有硬件和系统资源的完全控制权。通过区分用户态和内核态，可以防止用户程序直接访问和修改系统关键数据结构和硬件资源。</li><li><strong>防止恶意行为</strong>：如果没有用户态和内核态的区分，恶意程序可能会直接操作硬件或篡改系统内核，从而危害整个系统的安全。</li></ul><p><strong>2. 稳定性</strong></p><ul><li><strong>防止错误传播</strong>：用户态程序运行在受限环境中，不能直接访问硬件和其他进程的内存。即使用户程序发生崩溃或错误，也不会直接影响到系统内核和其他程序的运行。</li><li><strong>隔离故障</strong>：通过用户态和内核态的隔离，可以确保一个程序的错误不会影响到整个系统的稳定性。</li></ul><p><strong>3. 控制和管理</strong></p><ul><li><strong>资源管理</strong>：操作系统需要对系统资源（如CPU、内存、I/O设备等）进行统一管理和调度。通过内核态，可以实现对资源的有效控制和分配。</li><li><strong>系统调用接口</strong>：通过系统调用接口，用户程序可以请求内核服务，但这些请求是受控的。内核可以检查和验证这些请求，确保其合法性和安全性。</li></ul><p><strong>4. 提高效率</strong></p><ul><li><strong>中断处理</strong>：许多硬件中断（如定时器中断、I/O中断）需要立即响应。这些中断处理程序运行在内核态，可以快速地访问和操作硬件。</li><li><strong>直接硬件访问</strong>：内核态允许直接操作硬件设备，而不需要经过额外的抽象层，从而提高了操作的效率。</li></ul><h2 id="CPU-指令集权限">CPU 指令集权限</h2><p>指令集是 C P U 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 C P U 指令，而非常非常多的 C P U 指令 在一起，可以组成一个、甚至多个集合，指令的集合叫 C P U 指令集。</p><p>同时 C P U 指令集 有权限分级，大家试想，C P U 指令集 可以直接操作硬件的，要是因为指令操作的不规范`，造成的错误会影响整个计算机系统的。好比你写程序，因为对硬件操作不熟悉，导致操作系统内核、及其他所有正在运行的程序，都可能会因为操作失误而受到不可挽回的错误，最后只能重启计算机才行。</p><p>而对于硬件的操作是非常复杂的，参数众多，出问题的几率相当大，必须谨慎的进行操作，对开发人员来说是个艰巨的任务，还会增加负担，同时开发人员在这方面也不被信任，所以操作系统内核直接屏蔽开发人员对硬件操作的可能，都不让你碰到这些 C P U 指令集。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164319388.png" alt="image-20240630164319388"></p><p>针对上面的需求，硬件设备商直接提供硬件级别的支持，做法就是对 C P U 指令集设置了权限，不同级别权限能使用的 C P U 指令集 是有限的，以 Intel C P U 为例，Inter把 CPU 指令集 操作的权限由高到低划为4级：</p><ul><li>ring 0</li><li>ring 1</li><li>ring 2</li><li>ring 3</li></ul><p>其中 ring 0 权限最高，可以使用所有 C P U 指令集，ring 3 权限最低，仅能使用常规 C P U 指令集，不能使用操作硬件资源的 C P U 指令集，比如 I O 读写、网卡访问、申请内存都不行，Linux系统仅采用ring 0 和 ring 3 这2个权限。</p><p><strong>高情商</strong></p><p><strong>ring 0被叫做内核态，完全在操作系统内核中运行</strong></p><p><strong>ring 3被叫做用户态，在应用程序中运行</strong></p><p><strong>低情商</strong></p><p>执行内核空间的代码，具有ring 0保护级别，有对硬件的所有操作权限，可以执行所有C P U 指令集，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机。</p><p>在用户模式下，具有ring 3保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的。</p><h2 id="用户态与内核态的空间">用户态与内核态的空间</h2><p>在内存资源上的使用，操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」，以Linux32位操作系统为例，它的寻址空间范围是 4G（2的32次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 1G（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 3G（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164611780.png" alt="image-20240630164611780"></p><ul><li>用户态：只能操作 0-3G 范围的低位虚拟空间地址</li><li>内核态：0-4G 范围的虚拟空间地址都可以操作，尤其是对 3-4G 范围的高位虚拟空间地址必须由内核态去操作</li><li>补充：3G-4G 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。每个进程的 4G 虚拟空间地址，高位 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用，换句话说就是， 高位 1G 的内核空间是被所有进程共享的！</li></ul><p><strong>最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用</strong></p><h2 id="用户态与内核态的栗子">用户态与内核态的栗子</h2><p><strong>用户态：应用程序请求读取文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>系统调用：从用户态到内核态</strong></p><ul><li>当应用程序调用 <code>open()</code>, <code>read()</code> 和 <code>close()</code> 函数时，这些函数实际上是对内核提供的系统调用的封装。</li><li>例如，当 <code>read()</code> 被调用时，用户程序会发出一个系统调用陷入（trap）指令，触发从用户态到内核态的切换。<ul><li><code>read</code> 函数会执行一个系统调用指令（通常是 <code>syscall</code> 或 <code>int 0x80</code>），这是一种特殊的 CPU 指令，用于<strong>从用户态切换到内核态</strong>。</li><li>系统调用指令会引发一个陷入（trap），这是一种同步的中断，触发 CPU 切换到内核态，并跳转到内核中的系统调用处理入口。</li></ul></li></ul><p><strong>内核态：操作系统处理请求</strong></p><ul><li><p>内核接管控制权，进入内核态。CPU 跳转到内核的系统调用处理程序，根据系统调用号（每个系统调用都有一个唯一的编号，<code>read</code> 对应的编号通常是 0）找到相应的内核函数（sys_read）。内核中的文件系统代码开始执行，处理文件读取请求。</p></li><li><p>内核验证文件描述符，检查访问权限，然后执行实际的文件读取操作，将数据从磁盘读取到内核缓冲区。</p></li></ul><p><strong>从内核态返回用户态</strong></p><ul><li>文件读取操作完成后，内核将读取的数据复制到用户提供的缓冲区（<code>buffer</code>）。</li><li>内核返回结果，控制权交还给用户程序【通过 <code>iret</code> 或 <code>sysret</code> 指令返回用户态】，此时切换回用户态。</li></ul><p><strong>用户态：处理读取的数据</strong></p><ul><li>用户程序继续执行，处理从文件中读取的数据（如 <code>printf()</code> 打印数据）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户态：        应用程序（用户代码）      -&gt;      内核态： 操作系统（系统调用处理）</span><br><span class="line">  <span class="built_in">read</span>(fd, buffer, count)      系统调用陷入</span><br><span class="line">                                --&gt; 保存用户态上下文</span><br><span class="line">                                --&gt; 跳转到内核系统调用处理入口</span><br><span class="line">                                --&gt; 验证参数</span><br><span class="line">                                --&gt; 查找文件对象</span><br><span class="line">                                --&gt; 执行文件读取操作</span><br><span class="line">                                --&gt; 将数据复制到用户缓冲区</span><br><span class="line">                                --&gt; 设置返回值</span><br><span class="line">                                --&gt; 恢复用户态上下文</span><br><span class="line">                                --&gt; 返回用户态，继续执行用户程序</span><br></pre></td></tr></table></figure><h2 id="用户态与内核态的切换">用户态与内核态的切换</h2><ul><li><strong>保留用户态现场（上下文、寄存器、用户栈等）</strong></li><li><strong>复制用户态参数，用户栈切到内核栈，进入内核态</strong></li><li><strong>额外的检查（因为内核代码对用户不信任）</strong></li><li><strong>执行内核态代码</strong></li><li><strong>复制内核态代码执行结果，回到用户态</strong></li><li><strong>恢复用户态现场（上下文、寄存器、用户栈等）</strong></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164810614.png" alt="image-20240630164810614"></p><p>从上图我们可以看出来通过系统调用将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。</p><p>库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。</p><p>Shell顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，它是一种特殊的应用程序，俗称命令行。Shell也是可编程的，它有标准的Shell语法，符合其语法的文本叫Shell脚本，很多人都会用Shell脚本实现一些常用的功能，可以提高工作效率。</p><p>最后来说说，什么情况会导致用户态到内核态切换</p><p><strong>系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断，也可以称为软中断</strong>。</p><p><strong>异常：当 C P U 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常</strong>。</p><p><strong>中断：当 C P U 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 C P U 发出相应的中断信号，这时 C P U 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。</strong></p><p>扩展自：<a href="https://blog.csdn.net/u014571143/article/details/129660010">「操作系统」什么是用户态和内核态？为什么要区分</a></p>]]></content>
    
    
    <summary type="html">一文说懂用户态内核态</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程线程协程</title>
    <link href="https://penge666.github.io/posts/68a40dd3.html"/>
    <id>https://penge666.github.io/posts/68a40dd3.html</id>
    <published>2024-06-29T07:30:57.000Z</published>
    <updated>2024-06-30T08:18:49.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程">进程</h2><p>计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><blockquote><p><strong>补充：细聊PCB</strong></p></blockquote><p>在Linux中，PCB结构为task_struct;</p><p>task_struct是Linux内核的一种数据结构，它会被装载到RAM里并且包含进程的信息，每个进程都把它的信息放在task_struct这个数据结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">　　　表示进程的当前状态:</span></span><br><span class="line"><span class="comment">    TASK_RUNNING:正在运行或在就绪队列run-queue中准备运行的进程，实际参与进程调度。</span></span><br><span class="line"><span class="comment">    TASK_INTERRUPTIBLE:处于等待队列中的进程，待资源有效时唤醒，也可由其它进程通过信号(signal)或定时中断唤醒后进入就绪队列run-queue。</span></span><br><span class="line"><span class="comment">    TASK_UNINTERRUPTIBLE:处于等待队列中的进程，待资源有效时唤醒，不可由其它进程通过信号(signal)或定时中断唤醒。</span></span><br><span class="line"><span class="comment">    TASK_ZOMBIE:表示进程结束但尚未消亡的一种状态(僵死状态)。此时，进程已经结束运行且释放大部分资源，但尚未释放进程控制块。</span></span><br><span class="line"><span class="comment">    TASK_STOPPED:进程被暂停，通过其它进程的信号才能唤醒。导致这种状态的原因有二，或者是对收到SIGSTOP、SIGSTP、SIGTTIN或SIGTTOU信号的反应，或者是受其它进程的ptrace系统调用的控制而暂时将CPU交给控制进程。</span></span><br><span class="line"><span class="comment">    TASK_SWAPPING: 进程页面被交换出内存的进程。</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;　　<span class="comment">//进程标志，与管理有关,在调用fork()时给出</span></span><br><span class="line">    <span class="type">int</span> sigpending;　　　　　<span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">mm_segment_t</span> addr_limit; 　　<span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span></span><br><span class="line">    <span class="comment">/*用户线程空间地址: 0..0xBFFFFFFF。</span></span><br><span class="line"><span class="comment">       内核线程空间地址: 0..0xFFFFFFFF     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">exec_domain</span> *exec_domain;　　<span class="comment">//进程执行域</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> need_resched;　　　　　<span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ptrace;</span><br><span class="line">    <span class="type">int</span> lock_depth;　　<span class="comment">//锁深度</span></span><br><span class="line">    <span class="type">long</span> counter;　　　<span class="comment">//进程的基本时间片,在轮转法调度时表示进程当前还可运行多久，在进程开始运行是被赋为priority的值，以后每隔一个tick(时钟中断)递减1，减到0时引起新一轮调 度。重新调度将从run_queue队列选出counter值最大的就绪进程并给予CPU使用权，因此counter起到了进程的动态优先级的作用</span></span><br><span class="line">    <span class="type">long</span> nice;　　　　 <span class="comment">//静态优先级</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> policy;　　<span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR,分时进程:SCHED_OTHER</span></span><br><span class="line"><span class="comment">//在Linux 中, 采用按需分页的策略解决进程的内存需求。task_struct的数据成员mm 指向关于存储管理的mm_struct结构。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm;　　<span class="comment">//进程内存管理信息</span></span><br><span class="line">    <span class="type">int</span> has_cpu, processor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpus_allowed;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> run_list;　　<span class="comment">//指向运行队列的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sleep_time; 　　<span class="comment">//进程的睡眠时间</span></span><br><span class="line">    <span class="comment">//用于将系统中所有的进程连成一个双向循环链表,其根是init_task</span></span><br><span class="line">    <span class="comment">//在Linux 中所有进程(以PCB 的形式)组成一个双向链表,next_task和prev_task是链表的前后向指针</span></span><br><span class="line">　 <span class="keyword">struct</span> <span class="title class_">task_struct</span> *next_task, *prev_task;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *active_mm;  <span class="comment">//active_mm 指向活动地址空间。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linux_binfmt</span> *binfmt;　　<span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">    <span class="type">int</span> exit_code, exit_signal;</span><br><span class="line">    <span class="type">int</span> pdeath_signal;　　　　<span class="comment">//父进程终止是向子进程发送的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> personality;</span><br><span class="line">    <span class="type">int</span> dumpable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> did_exec:<span class="number">1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid; 　　<span class="comment">//进程标识符,用来代表一个进程</span></span><br><span class="line">    <span class="type">pid_t</span> pgrp;　 <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">    <span class="type">pid_t</span> tty_old_pgrp;  　　<span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">    <span class="type">pid_t</span> session;　　　　　　<span class="comment">//进程的会话标识</span></span><br><span class="line">    <span class="type">pid_t</span> tgid;</span><br><span class="line">    <span class="type">int</span> leader;　　　　　　　　<span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">    &lt;br&gt;　　<span class="comment">//指向最原始的进程任务指针，父进程任务指针，子进程任务指针，新兄弟进程任务指针，旧兄弟进程任务指针。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> thread_group;　　 <span class="comment">//线程链表</span></span><br><span class="line">    &lt;br&gt;　　<span class="comment">//用于将进程链入HASH表,系统进程除了链入双向链表外，还被加入到hash表中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *pidhash_next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> **pidhash_pprev;   </span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait_chldexit; 　　<span class="comment">//供wait4()使用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semaphore</span> *vfork_sem;　　　　 <span class="comment">//供vfork()使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_priority;　　　　　　<span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line">   &lt;br&gt;　　 <span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies,系统根据it_real_value</span></span><br><span class="line">    <span class="comment">//设置定时器的第一个终止时间.在定时器到期时，向进程发送SIGALRM信号，同时根据</span></span><br><span class="line">    <span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span></span><br><span class="line">    <span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送信号SIGPROF，并根据it_prof_incr重置时间.</span></span><br><span class="line">    <span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span></span><br><span class="line">    <span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据it_virt_incr重置初值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_incr, it_prof_incr, it_virt_incr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timer_list</span> real_timer;　　<span class="comment">//指向实时定时器的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tms</span> times; 　　　　　　　  <span class="comment">//记录进程消耗的时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time;　　　　<span class="comment">//进程创建的时间</span></span><br><span class="line">    <span class="type">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];<span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">    <span class="comment">//内存缺页和交换信息:</span></span><br><span class="line">    <span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copyon　Write页和匿名页）和主缺页数（从映射文件或交换</span></span><br><span class="line">    <span class="comment">//设备读入的页面数）；nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span></span><br><span class="line">    <span class="comment">//cmin_flt, cmaj_flt,cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span></span><br><span class="line">    <span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">    <span class="type">int</span> swappable:<span class="number">1</span>; 　　<span class="comment">//表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">    <span class="comment">//进程认证信息</span></span><br><span class="line">    <span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid，euid，egid为有效uid,gid</span></span><br><span class="line">    <span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件系统的访问权限时使用他们。</span></span><br><span class="line">    <span class="comment">//suid，sgid为备份uid,gid</span></span><br><span class="line">    <span class="type">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">    <span class="type">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">    <span class="type">int</span> ngroups;　　　　　<span class="comment">//记录进程在多少个用户组中</span></span><br><span class="line">    <span class="type">gid_t</span> groups[NGROUPS];　　<span class="comment">//记录进程所在的组</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;<span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span></span><br><span class="line">    <span class="type">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;　　<span class="comment">//代表进程所属的用户</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> rlim[RLIM_NLIMITS]; 　　<span class="comment">//与进程相关的资源限制信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math; 　　<span class="comment">//是否使用FPU</span></span><br><span class="line">    <span class="type">char</span> comm[<span class="number">16</span>]; 　　　　<span class="comment">//进程正在运行的可执行文件名</span></span><br><span class="line">     <span class="comment">//文件系统信息</span></span><br><span class="line">    <span class="type">int</span> link_count;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tty_struct</span> *tty;　　<span class="comment">//进程所在的控制终端，如果不需要控制终端，则该指针为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> locks;     <span class="comment">/* How many file locks are being held */</span></span><br><span class="line">    <span class="comment">//进程间通信信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sem_undo</span> *semundo;　　<span class="comment">//进程在信号量上的所有undo操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sem_queue</span> *semsleeping;　　<span class="comment">//当进程因为信号量操作而挂起时，他在该队列中记录等待的操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_struct</span> thread;　　　<span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs; 　　　　<span class="comment">//文件系统信息，fs保存了进程本身与VFS（虚拟文件系统）的关系信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *files;　<span class="comment">//打开文件信息</span></span><br><span class="line">     <span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">spinlock_t</span> sigmask_lock; <span class="comment">/* Protects signal and blocked */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">signal_struct</span> *sig;　<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked;　　　　　　<span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigpending</span> pending; <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;</span><br><span class="line">    <span class="type">size_t</span> sas_ss_size;</span><br><span class="line">    <span class="built_in">int</span> (*notifier)(<span class="type">void</span> *priv);</span><br><span class="line">    <span class="type">void</span> *notifier_data;</span><br><span class="line">    <span class="type">sigset_t</span> *notifier_mask;</span><br><span class="line">    <span class="comment">/* Thread group tracking */</span></span><br><span class="line">    u32 parent_exec_id;</span><br><span class="line">    u32 self_exec_id;</span><br><span class="line">    <span class="type">spinlock_t</span> alloc_lock;   <span class="comment">//用于申请空间时用的自旋锁。自旋锁的主要功能是临界区保护</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>进程标识信息</strong>：<ul><li><strong>进程ID（Process ID, PID）</strong>：唯一标识一个进程的标识符。</li><li><strong>父进程ID</strong>：创建当前进程的父进程的ID。</li></ul></li><li><strong>处理器状态信息</strong>：<ul><li><strong>程序计数器（Program Counter, PC）</strong>：指示下一条将要执行的指令的地址。</li><li><strong>CPU寄存器的内容</strong>：包括通用寄存器、浮点寄存器、状态寄存器等，保存进程的执行状态。</li><li><strong>进程状态</strong>：如运行、就绪、阻塞等状态。</li></ul></li><li><strong>内存管理信息</strong>：<ul><li><strong>基地址和限长寄存器</strong>：用于定义进程的地址空间范围。</li><li><strong>页表或段表</strong>：用于虚拟内存管理，映射虚拟地址到物理地址。</li></ul></li><li><strong>调度和状态信息</strong>：<ul><li><strong>进程优先级</strong>：用于进程调度。</li><li><strong>调度队列指针</strong>：指向进程在调度队列中的位置，用于进程调度。</li><li><strong>其他调度参数</strong>：如时间片长度、剩余时间等。</li></ul></li><li><strong>进程间通信信息</strong>：<ul><li><strong>信号量、消息队列</strong>：用于进程间通信和同步。</li><li><strong>管道和共享内存</strong>：用于进程间数据传输。</li></ul></li><li><strong>I/O状态信息</strong>：<ul><li><strong>打开的文件列表</strong>：进程当前打开的所有文件的列表。</li><li><strong>I/O设备信息</strong>：如进程使用的I/O设备、设备状态等。</li></ul></li><li><strong>汇总信息</strong>：<ul><li><strong>CPU使用时间</strong>：进程使用的CPU时间。</li><li><strong>内存使用量</strong>：进程使用的内存量。</li><li><strong>其他资源使用信息</strong>：如I/O操作次数等。</li></ul></li></ol><h2 id="线程">线程</h2><p>随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p><blockquote><p><strong>补充：进程切换流程</strong></p></blockquote><p>这里我举个例子说明进程A切换到进程B的例子：</p><ol><li><strong>保存进程A的上下文</strong>：<ul><li>将进程A的程序计数器、通用寄存器、状态寄存器等保存到进程A的PCB中。</li><li>保存进程A的页表基地址、段表基地址到PCB中。</li><li>保存进程A的文件描述符表、信号处理信息等。</li></ul></li><li><strong>更新进程A的状态</strong>：<ul><li>将进程A的状态从“运行”改为“就绪”或“阻塞”。</li></ul></li><li><strong>调度器选择进程B</strong>：<ul><li>调度器根据调度算法选择进程B。</li><li>将进程B的状态从“就绪”改为“运行”。</li></ul></li><li><strong>加载进程B的上下文</strong>：<ul><li>从进程B的PCB中恢复程序计数器、通用寄存器、状态寄存器等内容。</li><li>设置页表基地址和段表基地址为进程B的地址空间。</li><li>恢复进程B的文件描述符表、信号处理信息等。</li></ul></li><li><strong>切换到进程B并执行</strong>：<ul><li>更新程序计数器为进程B的下一条指令地址。</li><li>CPU开始执行进程B的代码。</li></ul></li></ol><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p>为了理解线程和线程在内存的布局，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">进程A</span><br><span class="line">├── 进程控制块（PCB）</span><br><span class="line">│   ├── 进程ID（PID）</span><br><span class="line">│   ├── 进程状态</span><br><span class="line">│   ├── 调度信息</span><br><span class="line">│   └── 其他元数据</span><br><span class="line">├── 内存空间</span><br><span class="line">│   ├── 代码段</span><br><span class="line">│   ├── 数据段</span><br><span class="line">│   ├── 堆</span><br><span class="line">│   └── 共享资源</span><br><span class="line">│       ├── 文件描述符</span><br><span class="line">│       └── 信号处理信息</span><br><span class="line">├── 线程1</span><br><span class="line">│   ├── 线程控制块（TCB）</span><br><span class="line">│   │   ├── 线程ID（TID）</span><br><span class="line">│   │   ├── 线程状态</span><br><span class="line">│   │   ├── 寄存器内容</span><br><span class="line">│   │   └── 程序计数器</span><br><span class="line">│   ├── 独立栈</span><br><span class="line">│   └── 共享资源（与进程共享）</span><br><span class="line">├── 线程2</span><br><span class="line">│   ├── 线程控制块（TCB）</span><br><span class="line">│   │   ├── 线程ID（TID）</span><br><span class="line">│   │   ├── 线程状态</span><br><span class="line">│   │   ├── 寄存器内容</span><br><span class="line">│   │   └── 程序计数器</span><br><span class="line">│   ├── 独立栈</span><br><span class="line">│   └── 共享资源（与进程共享）</span><br></pre></td></tr></table></figure><p><strong>线程（Thread）</strong></p><ul><li><strong>线程控制块（TCB）</strong>：保存线程的元数据，如线程ID、状态、寄存器内容、程序计数器等。</li><li><strong>独立栈</strong>：每个线程都有自己的栈，用于存储局部变量和函数调用信息。</li><li><strong>共享资源</strong>：与进程内其他线程共享代码段、数据段、堆和文件描述符等资源。</li></ul><p><strong>因此，我们就知道线程上下文切换比进程上下文切换要快</strong>。</p><p>原因：</p><ol><li><strong>资源共享</strong>：<ul><li><strong>线程</strong>：线程共享同一进程的内存地址空间、文件描述符和其他资源，只需要切换寄存器和程序计数器等上下文信息。</li><li><strong>进程</strong>：进程切换需要切换整个内存地址空间，包括页表和其他资源，涉及更多的状态保存和恢复。</li></ul></li><li><strong>缓存效率</strong>：<ul><li><strong>线程</strong>：由于线程共享同一进程的内存空间，切换时不会导致缓存（如CPU缓存和TLB）的显著失效，提高了缓存命中率。</li><li><strong>进程</strong>：进程切换通常会导致缓存失效，需要重新加载缓存数据，增加了额外的开销。</li></ul></li><li><strong>模式切换</strong>：<ul><li><strong>线程</strong>：线程切换通常在用户态完成，不涉及内核态和用户态的频繁切换。</li><li><strong>进程</strong>：进程切换需要在内核态和用户态之间切换，涉及更多的特权级别改变和指令开销。</li></ul></li></ol><p><strong>总结</strong></p><p>简单来说：进程切换需要切换整个地址空间，包括页表切换和缓存刷新等，还需要保存进程的上下文信息，包括 CPU 寄存器状态和栈指针。但是，同一进程内的线程共享内存地址空间，只需要切换上下文。</p><h3 id="任务调度">任务调度</h3><p>在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。</p><p>上述过程中，任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。</p><p>这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。多任务运行过程的示意图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629160358544.png" alt="image-20240629160358544"></p><h3 id="多线程与多核">多线程与多核</h3><p>上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？</p><p>其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。</p><p>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。<br>内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</p><p>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629162446104.png" alt="image-20240629162446104"></p><p>超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。【超线程技术通过在每个物理核心上模拟多个逻辑处理器，使得核心能够同时处理多个线程，最大化资源利用，提高并行处理能力和整体性能。】</p><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。</p><h4 id="一对一模型">一对一模型</h4><p>对于一对一模型来说，一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果CPU没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。</p><p>但一对一模型也有两个缺点：</p><ol><li>许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163102594.png" alt="image-20240629163102594"></p><h4 id="多对一模型">多对一模型</h4><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。因此相对一对一模型，多对一模型的线程上下文切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。</p><p>但多对一模型也有两个缺点：</p><ol><li>如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；</li><li>在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163124909.png" alt="image-20240629163124909"></p><h4 id="多对多模型">多对多模型</h4><p>多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。由线程库负责在可用的可调度实体上调度用户线程，这使得线程的上下文切换非常快，因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。</p><p>多对多模型的优点有：</p><ol><li>一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；</li><li>多对多模型对用户线程的数量没有限制；</li><li>在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163145410.png" alt="image-20240629163145410"></p><h3 id="线程的生命周期">线程的生命周期</h3><p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。</p><p>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及macOS等流行的操作系统。</p><p>我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163308718.png" alt="image-20240629163308718"></p><p><strong>线程与进程的区别</strong></p><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li><li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li><li><strong>稳定性方面</strong>：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li><li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</li><li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</li></ul><h2 id="协程">协程</h2><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163537069.png" alt="image-20240629163537069"></p><h3 id="协程的目的">协程的目的</h3><p>在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p><p>对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。</p><p>而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。</p><h3 id="协程的特点">协程的特点</h3><ol><li><strong>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</strong></li><li><strong>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</strong></li><li><strong>由于在同一个线程上，因此可以避免竞争关系而使用锁。</strong></li><li><strong>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</strong></li></ol><h3 id="协程的原理">协程的原理</h3><p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由<code>coroutine</code>负责调度的线程称为<code>Fiber</code>。比如Golang里的 go关键字其实就是负责开启一个<code>Fiber</code>，让<code>func</code>逻辑跑在上面。</p><p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。<br>因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。</p><p><strong>协程与线程比较</strong></p><table><thead><tr><th>比较项</th><th style="text-align:center">线程</th><th style="text-align:center">协程</th></tr></thead><tbody><tr><td>占用资源</td><td style="text-align:center">初始单位为1MB,固定不可变</td><td style="text-align:center">初始一般为 2KB，可随需要而增大</td></tr><tr><td>调度所属</td><td style="text-align:center">由 OS 的内核完成</td><td style="text-align:center">由用户完成</td></tr><tr><td>切换开销</td><td style="text-align:center">涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td><td style="text-align:center">只有三个寄存器的值修改 - PC / SP / DX.</td></tr><tr><td>性能问题</td><td style="text-align:center">资源占用太高，频繁创建销毁会带来严重的性能问题</td><td style="text-align:center">资源占用小,不会带来严重的性能问题</td></tr><tr><td>数据同步</td><td style="text-align:center">需要用锁等机制确保数据的一直性和可见性</td><td style="text-align:center">不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td></tr></tbody></table><p><strong>线程</strong>：适合CPU密集型任务，利用多核并行计算能力，适合需要高并发的场景，但有较高的资源占用和上下文切换开销。</p><p><strong>协程</strong>：适合I/O密集型任务，通过非阻塞I/O和协作调度提高效率，轻量级且避免复杂的同步问题，但无法利用多核并行计算。</p><p>部分学习自：[<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">一文读懂什么是进程、线程、协程</a>](<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">https://www.cnblogs.com/Survivalist/p/11527949.html</a>)</p>]]></content>
    
    
    <summary type="html">理解进程、线程与协程：高效并发编程的关键</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>DNS协议解析</title>
    <link href="https://penge666.github.io/posts/2eaa30e5.html"/>
    <id>https://penge666.github.io/posts/2eaa30e5.html</id>
    <published>2024-06-28T09:17:34.000Z</published>
    <updated>2024-08-24T10:36:49.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-0-demo">0.0 demo</h2><p>使用tcpdump观察DNS通信过程</p><ol><li><strong>捕获 DNS 流量</strong></li></ol><p>要捕获所有 DNS 流量（通常在端口 53 上运行），你可以在终端中使用以下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> tcpdump -i eth0 port <span class="number">53</span> -n</span><br></pre></td></tr></table></figure><ul><li><code>-i eth0</code>: 指定网络接口，这里假设你使用的是 <code>eth0</code> 接口。你可以使用 <code>ifconfig</code> 或 <code>ip a</code> 来查看你的网络接口名称，并替换为对应的接口名。</li><li><code>port 53</code>: 过滤出 DNS 流量，DNS 默认使用 UDP 和 TCP 协议的 53 端口。</li><li><code>-n</code>: 禁用主机名解析，以避免将 IP 地址解析为主机名，这样输出会更快。</li></ul><ol start="2"><li><strong>查看具体的 DNS 查询和响应</strong></li></ol><p>运行上面的命令后，tcpdump 将显示所有通过端口 53 的流量。示例输出可能如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">17</span>:<span class="number">45</span>:<span class="number">12</span>.<span class="number">345678</span> IP <span class="number">192.168.1.2</span>.<span class="number">12345</span> &gt; <span class="number">8.8.8.8</span>.<span class="number">53</span>: <span class="number">1234</span>+ A? www.example.com. (<span class="number">28</span>)</span><br><span class="line"><span class="attribute">17</span>:<span class="number">45</span>:<span class="number">12</span>.<span class="number">456789</span> IP <span class="number">8.8.8.8</span>.<span class="number">53</span> &gt; <span class="number">192.168.1.2</span>.<span class="number">12345</span>: <span class="number">1234</span> <span class="number">1</span>/<span class="number">0</span>/<span class="number">0</span> A <span class="number">93.184.216.34</span> (<span class="number">44</span>)</span><br></pre></td></tr></table></figure><ul><li>第一行表示从 <code>192.168.1.2</code>（本地机器的 IP 地址）发出的 DNS 查询，目标是 <code>8.8.8.8</code>（Google 公共 DNS 服务器），查询的是 <code>www.example.com</code> 的 A 记录（IPv4 地址）。</li><li>第二行表示从 <code>8.8.8.8</code> 返回的响应，<code>www.example.com</code> 的 IP 地址为 <code>93.184.216.34</code>。</li></ul><ol start="3"><li><strong>进一步分析</strong></li></ol><p>你还可以捕获并保存这些数据以便日后分析。例如，使用以下命令将捕获的数据保存到文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> tcpdump -i eth0 port <span class="number">53</span> -n -w dns_capture.pcap</span><br></pre></td></tr></table></figure><ul><li><code>-w dns_capture.pcap</code>: 将捕获的数据保存到 <code>dns_capture.pcap</code> 文件中，这个文件可以使用 Wireshark 等工具进行详细分析。</li></ul><ol start="4"><li><strong>过滤特定的 DNS 查询</strong></li></ol><p>如果你只想查看某个特定域名的查询，可以使用如下命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i eth0 port <span class="number">53</span> -n <span class="string">| grep &quot;</span>www.example.com<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>这样你只会看到与 <code>www.example.com</code> 相关的 DNS 查询和响应。</p><h2 id="0-前言"><strong>0. 前言</strong></h2><p>为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171832226.png" alt="image-20240630171832226"></p><h2 id="1-什么是-DNS-协议"><strong>1. 什么是 DNS 协议</strong></h2><p>在学习 DNS 协议之前，我们先区分一下域名和 IP 地址这个两个概念：</p><ul><li><strong>IP 地址</strong>：一长串能够唯一地标记网络上的计算机的数字</li><li><strong>域名</strong>：又称网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）比如 <code>www.baidu.com</code></li></ul><blockquote><p>不知道有没有同学会混淆域名和<strong>网址</strong>的概念，可以这样理解，网址里面含有域名。举个例子：<code>www.gitee.com/veal98</code> 就是一个网址，而 <code>www.gitee.com</code> 就是域名</p></blockquote><p>由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并<strong>通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射</strong>，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析。</p><blockquote><p>DNS 协议可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。但<strong>大多数情况下 DNS 都使用 UDP 进行传输</strong>。</p></blockquote><h2 id="2-域名详解"><strong>2. 域名详解</strong></h2><p>❓ 那么域名由谁来规定和管理呢？不能是随便写吧？</p><p>全世界域名的最高管理机构，是一个叫做 ICANN （Internet Corporation for Assigned Names and Numbers）的组织，总部在美国加州。<strong>ICANN 负责管理全世界域名系统的运作</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171852966.png" alt="image-20240630171852966"></p><p>域名其实是具有一定的层次结构的，从上到下依次为：<strong>根域名</strong>、<strong>顶级域名</strong>（top level domain，TLD）、<strong>二级域名</strong>、（三级域名）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171904380.png" alt="image-20240630171904380"></p><h3 id="①-顶级域名"><strong>① 顶级域名</strong></h3><p>先来讲讲<strong>顶级域名</strong>（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<code>www.baidu.com</code> 的顶级域名就是 <code>.com</code>。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。截至 2015 年 7 月，顶级域名共有 1058 个，它们大致可以分成两类：</p><ul><li>一类是<strong>通用顶级域名</strong>（gTLD），比如<code>.com</code>、<code>.net</code>、<code>.edu</code>、<code>.org</code>、<code>.xxx</code>等等，共有 700 多个。</li><li>另一类是<strong>国家顶级域名</strong>（ccTLD），代表不同的国家和地区，比如<code>.cn</code>（中国）、<code>.io</code>（英属印度洋领地）、<code>.cc</code>（ 科科斯群岛）、<code>.tv</code>（图瓦卢）等，共有 300 多个。</li></ul><p>当然，ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个<strong>托管商</strong>，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，<code>.cn</code> 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 <code>.cn</code> 域名的各种政策。</p><h3 id="②-二级域名"><strong>② 二级域名</strong></h3><p>而<strong>二级域名</strong>(Second Level Domain,SLD) 在通用顶级域名或国家顶级域名之下具有不同的意义：</p><ul><li>通用顶级域名下的二级域名：一般是指域名注册人选择使用的网上名称，如 <code>yahoo.com</code>（商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如 <code>baidu.com</code>）</li><li>国家顶级域名下的二级域名：一般是指类似于通用顶级域名的表示注册人类别和功能的标志。例如，在 <code>.com.cn</code> 域名结构中，<code>.com</code> 此时是置于国家顶级域名 <code>.cn</code> 下的二级域名，表示中国的商业性组织，以此类推。</li></ul><p><strong>三级域名</strong>是形如 <code>www.baidu.com</code> 的域名，可以当做是二级域名的子域名，特征为域名包含两个 <code>.</code>。对于域名所有者/使用者而言，三级域名都是二级域名的附属物而无需单独费用。<strong>三级域名甚至不能称为域名，一般称之为域名下的 “二级目录”</strong>。</p><h3 id="③-根域名"><strong>③ 根域名</strong></h3><p>❓ 那么<strong>根域名</strong>在哪里呢？在层次结构中根域名不是最顶级的吗？域名中怎么没有看见它？</p><p>由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<code>www.xxx.com</code> 被写成 <code>www.xxx.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171917340.png" alt="image-20240630171917340"></p><p>理论上，<strong>所有域名的查询都必须先查询根域名</strong>，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，<strong>ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171933731.png" alt="image-20240630171933731"></p><p>比如，我要访问<code>abc.xyz</code>，也必须先去询问根域名列表，它会告诉我 <code>.xyz</code> 域名由 CentralNic 公司托管。根域名列表还记载，<code>.google</code>由谷歌公司托管，<code>.apple</code>由苹果公司托管等等。</p><p>由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。</p><h2 id="3-域名服务器详解"><strong>3. 域名服务器详解</strong></h2><p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。一个域名服务器所负责管里的分层叫作 <strong>区 (ZONE)</strong>。域名的每层都设有一个域名服务器：</p><ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器</li></ul><p>下面这幅图就很直观了：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171945529.png" alt="image-20240630171945529"></p><p>除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，即<strong>本地域名服务器</strong>。下面我们分别讲解这四种服务器都是用来干什么的</p><h3 id="①-根域名服务器"><strong>① 根域名服务器</strong></h3><p>上面我们提到，ICANN 维护着一张根域名列表，里面记载着顶级域名和对应的托管商，其实根域名列表的正式名称是 <strong>DNS 根区</strong>（DNS root zone），保存 DNS 根区文件的服务器，就叫做 <strong>DNS 根域名服务器</strong>（root name server）。根域名服务器<strong>保存所有的顶级域名服务器的地址</strong></p><p>由于早期的 DNS 查询结果是一个 512 字节的 UDP 数据包。这个包最多可以容纳 13 个服务器的地址，因此就规定全世界有 13 个根域名服务器，编号从 <code>a.root-servers.net</code> 一直到 <code>m.root-servers.net</code>。其中 10 台设置在美国，另外各有一台设置于荷兰、瑞典和日本。</p><p>前面我们说过，理论上<strong>所有域名的查询都必须先查询根域名</strong>，所以一般来说所有的域名服务器都会注册一份根域名服务器的 IP 地址的缓存，用于在必要的时候向其发送请求。</p><h3 id="②-顶级域名服务器"><strong>② 顶级域名服务器</strong></h3><p>按照根域名服务器管理顶级域名的逻辑，顶级域名服务器显然就是用来<strong>管理注册在该顶级域名下的所有二级域名</strong>的，<strong>记录这些二级域名的 IP 地址</strong>。</p><h3 id="③-权限域名服务器"><strong>③ 权限域名服务器</strong></h3><p>按照上面的逻辑，权限域名服务器应该是管理注册在二级域名下的所有三/四级域名的，但其实不是这样，如果一个二级域名或者一个三/四级域名对应一个域名服务器，则域名服务器数量会很多，我们需要使用<strong>划分区</strong>的办法来解决这个问题。那么权限域名服务器就是负责管理一个“<strong>区</strong>”的域名服务器。</p><p>❓ 什么是区？怎样划分区呢？</p><p>区和域其实是不同的，区可以有多种不同的划分方法。以百度为例，我们假设有 <code>fanyi.baidu.com</code>、<code>ai.baidu.com</code>、<code>tieba.baidu.com</code> 这三个三级域名。我们可以这样分区，<code>fanyi.baidu.com</code> 和 <code>tieba.baidu.com</code> 放在 <code>baidu.com</code> 权限域名服务器，<code>ai.baidu.com</code> 放在 <code>ai.baidu.com</code> 权限域名服务器中。并且 <code>baidu.com</code> 权限域名服务器和 <code>ai.baidu.com</code> 权限域名服务器是<strong>同等地位</strong>的，而具体怎么分区是百度公司根据域名多少、访问多少等情况去自己规定的。</p><p>画个图直观理解一下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171957318.png" alt="image-20240630171957318"></p><h3 id="④-本地域名服务器"><strong>④ 本地域名服务器</strong></h3><p>除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，就是<strong>本地域名服务器</strong>（也被称为<strong>权威域名服务器</strong>）。本地域名服务器是电脑解析时的<strong>默认</strong>域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器。常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172008191.png" alt="image-20240630172008191"></p><p>每个因特网服务提供者或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。<strong>当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</strong>。<strong>本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询</strong>。</p><p>那么具体本地域名服务器是如何向上级域名服务器转发查询请求的呢？</p><h2 id="4-DNS-查询方式"><strong>4. DNS 查询方式</strong></h2><p>具体 DNS 查询的方式有两种：</p><ul><li>递归查询</li><li>迭代查询</li></ul><p>所谓迭代就是，如果请求的接收者不知道所请求的内容，那么<strong>接收者将扮演请求者</strong>，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。</p><p>通俗点来说，在递归查询中，如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案；而迭代查询则是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。</p><p>一般来说，<strong>域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大</strong>。通过下面这两个图就能很好的理解了</p><p>1）递归查询：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172020763.png" alt="image-20240630172020763"></p><p>2）迭代查询：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172030301.png" alt="image-20240630172030301"></p><h2 id="5-域名缓存"><strong>5. 域名缓存</strong></h2><p>上面讲解的是域名服务器之间的 DNS 查询请求过程，但实际上，每个时刻都有无数网民要上网，那每次都去访问本地域名服务器去获取 IP 地址显然是不实际的。解决方法就是<strong>使用缓存保存域名和 IP 地址的映射</strong>。</p><p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p><p>1）<strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</p><p>2）<strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172049327.png" alt="image-20240630172049327"></p><p>Windows 系统默认开启 DNS 缓存服务，服务名是 <code>DNSClient</code>，可以缓存一些常用的域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172100462.png" alt="image-20240630172100462"></p><p>使用命令 <code>ipconfig/displaydns</code> 可以查看电脑中缓存的域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172113442.png" alt="image-20240630172113442"></p><p>⭐ 在浏览器中进行访问的时候，会优先查询浏览器缓存，如果未命中则继续查询操作系统缓存，最后再查询本地域名服务器，然后本地域名服务器会递归的查找域名记录，最后返回结果。<strong>主机和本地域名服务器之间的查询方式是递归查询</strong>，也就是说主机请求本地域名服务器，那么本地域名服务器作为请求的接收者一定要给主机想要的答案。</p><h2 id="6-完整域名解析过程"><strong>6. 完整域名解析过程</strong></h2><p>OK，将我们上面所说的域名服务器之间的 DNS 查询请求过程和域名缓存结合起来，就是一个完整的 DNS 协议进行域名解析的过程。这里我们以正向解析为例（域名解析成 IP 地址）：</p><p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p><p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p><p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p><p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p><ul><li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li><li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul><p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p><p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p><p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p><p>配合下图直观理解：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172124777.png" alt="image-20240630172124777"></p><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/351059293">超详细 DNS 协议解析</a></p>]]></content>
    
    
    <summary type="html">超详细DNS协议解析</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
