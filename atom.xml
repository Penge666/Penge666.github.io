<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-07-02T06:55:29.180Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互斥锁、读写锁、自旋锁</title>
    <link href="https://penge666.github.io/posts/39f9f1ca.html"/>
    <id>https://penge666.github.io/posts/39f9f1ca.html</id>
    <published>2024-07-02T04:00:20.000Z</published>
    <updated>2024-07-02T06:55:29.180Z</updated>
    
    <content type="html"><![CDATA[<p>鹰击长空鲸霸海，不试怎知龙与邱！</p><h2 id="1-前言">1.前言</h2><p>本文介绍锁与临界资源与原子操作的的使用场景。</p><h2 id="2-临界资源">2.临界资源</h2><h3 id="2-1-什么是临界资源">2.1 什么是临界资源</h3><p>临界资源就是被多个线程/进程共享，但在某一时刻只能被一个线程/进程所使用的资源。   下文以一个经典案例(多线程同时进行i++)介绍三种锁，以及cpu指令集支持的原子操作和CAS。</p><p>主线程启动后创建十个线程，并将主线程中的count变量当作参数传入子线程中，也就是说十个线程同时操作一个共享资源count，子线程执行10w次count++ 操作，主线程每隔两秒打印一次count的值。下面来看看加锁与不加锁的区别。</p><h3 id="2-2-多线程操作临界资源且不加锁">2.2 多线程操作临界资源且不加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们预期count最终是达到100w，为什么在不加锁的时候没有达到预期效果？很明显，count++不是原子操作</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120141957.png" alt="image-20240702120141957"></p><h3 id="2-3-i-不是原子操作-i-对应三条汇编指令">2.3 i++不是原子操作,i++对应三条汇编指令</h3><p>如果i++是原子操作，那么必然会累加到100w，那么i++到底对应着那几步呢？</p><p>下面以idx++举例，idx的值是存储在内存里面，首先从内存MOV到eax寄存器里面，然后通过寄存器进行自增，最后再从eax写回到内存中。在编译器不做任何优化的情况下，idx++就对应这三个步骤。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120158334.png" alt="image-20240702120158334"></p><p>在大多数情况下，程序是这样执行的</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120209782.png" alt="image-20240702120209782"></p><p>但是也会存在下面这两种情况。线程1首先将idx的值读到了寄存器，然后cpu执行线程2，线程2执行完三步骤后，又回到线程1，线程1接着执行剩下的两步。有人可能会想，两个线程不都执行完了吗？有什么不同？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120226769.png" alt="image-20240702120226769"></p><p>首先，在线程1让出后，线程1的上下文(比如这里的eax)，是存储到线程1里面的，线程1恢复后，又将上下文load回去。这里就涉及到yield和resume了，详细介绍看纯c协程框架NtyCo实现与原理的第二节与第三节。 理解了上下文的切换后，就容易理解了，有没有发现，两次++操作，最终会漏加。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120244473.png" alt="image-20240702120244473"></p><p>所以在多线程中，操作临界资源时，那么这个临界资源是原子的，那么就不用加锁，要么就必须加锁，否在就会出现上述问题！</p><p>那么所谓加锁是什么意思？就是将这三条汇编指令变成一个原子操作，只要有一个线程lock加锁了，别的线程就不能执行进来，直到加锁的线程解锁，别的线程才能加锁。那么这三条汇编指令就是原子的了。下面将介绍3中锁以及2个原子操作。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120256216.png" alt="image-20240702120256216"></p><h3 id="2-4-多线程操作临界资源且加互斥锁">2.4 多线程操作临界资源且加互斥锁</h3><p>下面来看看两种加锁方式，这两种都可以跑了100w，但是这两种加锁的粒度是不一样的，在这个程序中，谁是临界资源？是pcount，而不是while，所以第二种加锁虽然可以跑通，但是它加锁的粒度太大了，就本程序而言，第二种加锁方式这和单线程跑有什么区别？所以我们要对临界资源加锁,不是临界资源的不加锁，掌控好锁的粒度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确加锁</span></span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    (*pcount)++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误加锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">    (*pcount)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到加锁之后，成功达到我们的预期</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120337410.png" alt="image-20240702120337410"></p><h3 id="2-5-多线程操作临界资源且加读写锁">2.5 多线程操作临界资源且加读写锁</h3><p>读写锁，顾名思义，读临界资源的时候加读锁，写临界资源的时候加写锁。适用于读多写少的场景。</p><p>A线程加了读锁，B线程可以继续加读锁，但是不能加写锁。 A线程加了写锁，B线程不能加读锁，也不能加写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120405727.png" alt="image-20240702120405727"></p><h3 id="2-6-多线程操作临界资源且加自旋锁">2.6 多线程操作临界资源且加自旋锁</h3><p>spinlock与mutex一样，mutex在哪里加锁，spinlock就在哪加锁，使用方法是一样的，但是其内部行为不一样。那么mutex和spinlock的区别在哪呢？</p><p>互斥锁在获取不到锁时，会进入休眠，等待释放时被唤醒。会让出CPU。 自旋锁在获取不到锁时，一直等待，在等待过程种不会有进程，线程切换。只会一直等，死等。</p><p>互斥锁与自旋锁的使用场景下文介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_spin_lock</span>(&amp;spinlock);</span><br><span class="line">        (*pcount)++;</span><br><span class="line">        <span class="built_in">pthread_spin_unlock</span>(&amp;spinlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;spinlock, PTHREAD_PROCESS_SHARED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120430596.png" alt="image-20240702120430596"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240702120437972.png" alt="image-20240702120437972"></p><p>补充：<strong>自旋锁会不会死锁</strong>？</p><p>给出我的观点：是锁就会有死锁问题！</p><p><strong>嵌套自旋锁导致的死锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock);  <span class="comment">// 第一次获取锁</span></span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock);  <span class="comment">// 再次尝试获取同一个锁，会导致死锁</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock);</span><br><span class="line">    spin_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环依赖导致的死锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock1, lock2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_A</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock1);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock2);  <span class="comment">// 线程A等待lock2</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock2);</span><br><span class="line">    spin_unlock(&amp;lock1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_B</span><span class="params">()</span> &#123;</span><br><span class="line">    spin_lock(&amp;lock2);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    spin_lock(&amp;lock1);  <span class="comment">// 线程B等待lock1</span></span><br><span class="line">    <span class="comment">// ... do some more work ...</span></span><br><span class="line">    spin_unlock(&amp;lock1);</span><br><span class="line">    spin_unlock(&amp;lock2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，线程A持有lock1并等待获取lock2，而线程B持有lock2并等待获取lock1，这种情况会导致两个线程都无法继续执行，从而导致死锁。</p><p><strong>总结</strong></p><p>自旋锁本身并不会直接导致死锁，但在特定的使用场景下，如果代码设计不合理，可能会出现死锁。为了避免死锁，开发者应该：</p><ul><li>避免嵌套使用同一个自旋锁。</li><li>设计时避免循环依赖关系，确保获取锁的顺序一致。</li><li>考虑使用其他同步机制，如互斥锁（mutex）或读写锁（rwlock），这些锁可以避免自旋锁的一些问题，特别是在锁持有时间较长的情况下。</li></ul><h3 id="2-7-原子操作">2.7 原子操作</h3><p>我们发现加锁，都是将i++对应的汇编的三个步骤，变成原子性。那么我们有没有办法直接将i++对应的汇编指令，变成一条指令？可以，我们使用xaddl这条指令。</p><p>Intel X86指令集提供了指令前缀lock⽤于锁定前端串⾏总线FSB，保证了指令执⾏时不会收到其他处理器的⼲扰。</p><p>所谓原子操作，它不是某条具体的指令，它是CPU支持的指令集，都是原子操作。比如说CAS，CAS是原子操作的一种，而不能说原子操作就是CAS。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">xaddl -----&gt; Inc</span><br><span class="line">xaddl：第二个参数加第一个参数，并把值存储到第一个参数里</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 68725 on 2022/8/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE     10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;lock; xaddl %2, %1;&quot;</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;=a&quot;</span> (old)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;m&quot;</span> (*value), <span class="string">&quot;a&quot;</span> (add)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//callback</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">func</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *pcount = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(pcount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> th_id[THREAD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;th_id[i], <span class="literal">NULL</span>, func, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count --&gt; %d\n&quot;</span>, count);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmpxchg-----&gt; CAS CAS：Compare And Swap，先比较，再赋值，翻译成代码就是下面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a==b)&#123;<span class="comment">//Compare</span></span><br><span class="line">a=c;<span class="comment">//Swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPU的指令集支持了先比较后赋值的指令，叫cmpxchg。正因为CPU执行了这个指令，它才是原子操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Perform atomic &#x27;compare and swap&#x27; operation on the pointer.</span></span><br><span class="line"><span class="comment">//  The pointer is compared to &#x27;cmp&#x27; argument and if they are</span></span><br><span class="line"><span class="comment">//  equal, its value is set to &#x27;val&#x27;. Old value of the pointer is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T *<span class="title">cas</span> <span class="params">(T *cmp_, T *val_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T *old;</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;lock; cmpxchg %2, %3&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;=a&quot;</span> (old), <span class="string">&quot;=m&quot;</span> (ptr)</span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;r&quot;</span> (val_), <span class="string">&quot;m&quot;</span> (ptr), <span class="string">&quot;0&quot;</span> (cmp_)</span></span></span><br><span class="line"><span class="params"><span class="function">: <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-三种锁的api介绍">3.三种锁的api介绍</h2><h3 id="3-1-互斥锁-mutex">3.1 互斥锁 mutex</h3><p>有两个特殊的api，pthread_mutex_trylock 尝试加锁，如果没有获取到锁则返回，而不是休眠。pthread_mutex_timedlock 等待一段时间，超时了还没获取倒锁则返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mutex handling.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__mutexattr)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try locking a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/* Wait until lock becomes available, or specified time passes. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_timedlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__restrict __mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">    __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-读写锁-rdlock">3.2 读写锁 rdlock</h3><p>读写锁适用于多读少写的情况，否则还是用互斥锁。</p><p>A线程加了读锁，B线程可以继续加读锁，但是不能加写锁。 A线程加了写锁，B线程不能加读锁，也不能加写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling read-write locks.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize read-write lock RWLOCK using attributes ATTR, or use</span></span><br><span class="line"><span class="comment">   the default values if later is NULL.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">__attr)</span> __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy read-write lock RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire read lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire read lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">  __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire read lock for RWLOCK or return after specfied time.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_timedrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">       __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire write lock for RWLOCK or return after specfied time.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_timedwrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict</span></span></span><br><span class="line"><span class="params"><span class="function">       __abstime)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock RWLOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-自旋锁-spinlock">3.3 自旋锁 spinlock</h3><p>自旋锁最大的特点是，获取不到锁就一直等待，即使CPU时间片用完了也不会发生切换，死等。而上面两种锁不一样，获取不到就会休眠，让出CPU时间片，切换到其他线程或进程执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions to handle spinlocks.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can</span></span><br><span class="line"><span class="comment">   be shared between different processes.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_init</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock, <span class="type">int</span> __pshared)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy the spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_destroy</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait until spinlock LOCK is retrieved.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_lock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to lock spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_trylock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release spinlock LOCK.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">pthread_spin_unlock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *__lock)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4-三种锁的使用场景">4.三种锁的使用场景</h2><p>比如说读一个文件，就使用mutex。而如果是简单的加加减减操作，就是用spinlock。如果系统提供了原子操作的接口，对于i++这种操作来说，用原子操作更合适。</p><p>spinlock：临界资源操作简单/没有发生系统调用/持续时间较短（<strong>自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，等待时消耗cpu资源较多，自旋锁一般用于多核的服务器</strong>。）</p><p>mutex：临界资源操作复杂/发生系统调用/持续时间比较长</p><ul><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li><li>临界区竞争非常激烈</li><li>单核处理器</li></ul><p>补充：</p><p><strong>案例1：单核处理器上的自旋锁讲述</strong></p><p>在单核处理器上，虽然同时只有一个进程在执行，但通过操作系统的调度，多个进程仍然可以并发地运行。比如，进程A正在执行，并且持有自旋锁，这时操作系统决定切换到进程B。</p><ol><li><strong>进程A持有自旋锁</strong>：进程A获取了自旋锁，并正在执行某些操作。</li><li><strong>上下文切换</strong>：操作系统决定切换到进程B，因为进程A的时间片用完了，或者操作系统认为进程B需要运行。</li><li><strong>进程B尝试获取自旋锁</strong>：进程B开始运行，并试图获取同一个自旋锁。因为锁被进程A持有，进程B会进入自旋等待状态，不断地检查锁的状态。</li><li><strong>再次切换到进程A</strong>：操作系统可能再次切换回进程A，进程A继续运行并最终释放自旋锁。</li><li><strong>进程B获取自旋锁</strong>：一旦进程A释放锁，操作系统可能会切换回进程B，进程B就可以成功获取锁并继续执行。</li></ol><p><strong>案例2：多核处理器上的自旋锁讲述</strong></p><p><strong>初始状态</strong>：</p><ul><li>共享资源初始状态为未被锁定。</li><li>自旋锁初始状态为未被持有。</li></ul><p><strong>进程A尝试获取锁</strong>：</p><ul><li>进程A运行在CPU核1上，它试图获取自旋锁来访问共享资源。</li><li>自旋锁目前未被持有，因此进程A成功获取锁，并进入临界区开始访问共享资源。</li></ul><p><strong>进程B尝试获取锁</strong>：</p><ul><li>在进程A持有锁的同时，进程B在CPU核2上运行，也试图获取同一个自旋锁。</li><li>由于锁已被进程A持有，进程B进入自旋等待状态，在CPU核2上不断循环检查锁的状态。</li></ul><p><strong>进程A释放锁</strong>：</p><ul><li>进程A完成对共享资源的访问，释放自旋锁。</li><li>锁的状态变为未被持有。</li></ul><p><strong>进程B获取锁</strong>：</p><ul><li><p>进程B在自旋等待中检测到锁已被释放，立即获取自旋锁。</p></li><li><p>进程B进入临界区开始访问共享资源。</p><p>【因为始终只有一把自旋锁】</p></li></ul><p>原子操作：使用场景很小，必须需要CPU的指令集支持才行。（原子操作适用于简单的加减等数学运算，属于粒度最小的操作。比如往链表里增加一个结点，可以做出原子操作吗？不行，因为CPU指令集没有同时多个赋值的指令。cas 多线程同时竞争的时候效率并不会特别高，如果互斥锁和自旋锁能满足要求了尽量不要用cas）</p><h2 id="5-原子操作的接口">5.原子操作的接口</h2><p>对于gcc、g++编译器来讲，它们提供了⼀组API来做原⼦操作：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_add </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_sub </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_or </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_and </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_xor </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_fetch_and_nand </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line"></span><br><span class="line">bool __sync_bool_compare_and_swap (<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">oldval </span><span class="keyword">type</span> <span class="type">newval, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_val_compare_and_swap </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">oldval </span><span class="keyword">type</span> <span class="type">newval, </span>...)</span><br><span class="line"><span class="keyword">type</span> <span class="type">__sync_lock_test_and_set </span>(<span class="keyword">type</span> <span class="type">*ptr, </span><span class="keyword">type</span> <span class="type">value, </span>...)</span><br><span class="line">void __sync_lock_release (<span class="keyword">type</span> <span class="type">*ptr, </span>...)</span><br></pre></td></tr></table></figure><p>详细⽂档⻅：<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins">https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins</a></p><p>详细⽂档⻅：<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins">https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html#AtomicBuiltins</a></p><p>学习自：<a href="https://blog.csdn.net/qq_42956653/article/details/126141284">互斥锁、读写锁、自旋锁，以及原子操作指令xaddl、cmpxchg的使用场景剖析</a></p>]]></content>
    
    
    <summary type="html">锁向无敌</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://penge666.github.io/posts/735e5788.html"/>
    <id>https://penge666.github.io/posts/735e5788.html</id>
    <published>2024-07-01T14:51:48.000Z</published>
    <updated>2024-07-01T16:35:03.749Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序、插入排序、选择排序、计数排序、堆排序、快速排序、归并排序</p><p><strong>基本概念</strong></p><p>排序算法的稳定性：如果待排序的序列中存在相同键值的元素，排序前后的相对顺序保持不变。【相同的元素不交换位置】</p><p><strong>最坏时间复杂度、最好时间复杂度和平均时间复杂度.</strong></p><p><strong><code>最坏时间复杂度</code></strong><br>最坏情况下的时间复杂度称最坏时间复杂度，一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。</p><p><strong><code>平均时间复杂度</code></strong><br>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间，设每种情况的出现的概率为pi,平均时间复杂度则为sum(pi*f(n)) 。</p><p><strong><code>最好时间复杂度</code></strong><br>最理想情况下的时间复杂度称最好时间复杂度。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>【分组插入排序】</p><p>思路分析：</p><p>①比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>②对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p><p>③针对所有的元素重复以上的步骤，除了最后一个。</p><p>④持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>过程动态图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/BubbleSort.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：冒泡排序算法最坏的情况和平均复杂度是O(n^2)，最好时间复杂度为O(n)，空间复杂度为O(1)，排序算法稳定。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>思路分析：</p><p>①在长度为N的数组，将数组中第i  [1~（N-1) ] 个元素，插入到数组 [0~i] 适当的位置上。</p><p>②在排序的过程中当前元素之前的数组元素已经是有序的了。</p><p>③在插入的过程中，有序的数组元素，需要向右移动为更小的元素腾出空间，直到为当前元素找到合适的位置。</p><p>过程动态图展示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/insert_sort.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> temp = nums[i];</span><br><span class="line"><span class="keyword">for</span> (j; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; temp) &#123;</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：时间复杂度平均为O(n^2)，最坏为O(n^2)，最好为O(n)，空间复杂度为O(1)，排序算法稳定。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>基本思想</strong></p><p>希尔排序的核心思想是先将数组分割成若干个子序列，然后对每个子序列进行插入排序。随着算法的进行，子序列之间的间隔（gap）逐渐减小，直到最后变为1，此时整个数组变为一个子序列行最后一次插入排序。</p><p><strong>希尔排序的过程</strong></p><ol><li>选择一个初始的间隔序列（通常为数组长度的一半）。</li><li>对于每个间隔 gap，将数组分割成若干个子序列。</li><li>对每个子序列进行插入排序。</li><li>减少间隔，重复步骤2和3，直到间隔为1。</li></ol><p><strong>举例说明</strong></p><p>假设我们有一个长度为 8 的数组 [8, 4, 1, 3, 2, 7, 6, 5]，按照希尔排序的步骤进行排序：</p><ol><li>初始间隔 gap = 4：<ul><li>子序列1：[8, 2]</li><li>子序列2：[4, 7]</li><li>子序列3：[1, 6]</li><li>子序列4：[3, 5]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 2：<ul><li>子序列1：[2, 1, 6, 5]</li><li>子序列2：[8, 4, 3, 7]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 1：<ul><li>整个数组进行一次插入排序。</li></ul></li></ol><p>通过这个例子，可以看到希尔排序如何逐步减少间隔并进行排序。</p><p>假设我们有一个长度为 8 的数组 [8, 4, 1, 3, 2, 7, 6, 5]，按照希尔排序的步骤进行排序：</p><ol><li>初始间隔 gap = 4：<ul><li>子序列1：[8, 2]</li><li>子序列2：[4, 7]</li><li>子序列3：[1, 6]</li><li>子序列4：[3, 5]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 2：<ul><li>子序列1：[2, 1, 6, 5]</li><li>子序列2：[8, 4, 3, 7]</li><li>对每个子序列进行插入排序。</li></ul></li><li>间隔 gap = 1：<ul><li>整个数组进行一次插入排序。</li></ul></li></ol><p>通过这个例子，可以看到希尔排序如何逐步减少间隔并进行排序。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">int</span> gap = n;</span><br><span class="line"><span class="keyword">while</span>(gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap/<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//控制分组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; n-gap;i++)<span class="comment">//注意边界条件，避免越界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = a[end+gap];</span><br><span class="line"><span class="keyword">while</span>(end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[end] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">a[end+gap] = a[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[end+gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【✳】<strong>时间复杂度分析</strong></p><p>希尔排序的时间复杂度分析涉及到以下几个方面：</p><p><strong>1. 间隔序列的选择</strong></p><p>希尔排序的效率很大程度上取决于所选择的间隔序列。常见的间隔序列有：</p><ul><li>希尔序列：间隔序列为 { n/2, n/4, …, 1 }。</li><li>Hibbard 序列：间隔序列为 { 1, 3, 7, …, 2^k - 1 }。</li><li>Knuth 序列：间隔序列为 { 1, 4, 13, 40, …, (3^k - 1) / 2 }。</li></ul><p>不同的间隔序列会影响排序的时间复杂度。这里我们以希尔序列为例进行分析。</p><p><strong>2. 插入排序的时间复杂度</strong></p><p>对于一个长度为 h 的子序列，插入排序的时间复杂度为 O(h^2)。</p><p><strong>3. 总时间复杂度</strong></p><p><strong>计算方式</strong></p><p>假设数组长度为 n，间隔序列为 { n/2, n/4, …, 1 }。在每个间隔 gap 下进行插入排序的时间复杂度可以近似看作 O(n)。</p><p>具体分析如下：</p><ul><li>当 gap = n/2 时，进行 n/2 次插入排序，每次插入排序的时间复杂度为 O((n/2)^2) = O(n^2/4)。</li><li>当 gap = n/4 时，进行 n/4 次插入排序，每次插入排序的时间复杂度为 O((n/4)^2) = O(n^2/16)。</li><li>依次类推，直到 gap = 1。</li></ul><p>由于每次 gap 变为原来的一半，总的时间复杂度可以表示为：<br>T(n) = O(n^2/4) + O(n^2/16) + … + O(1)</p><p>这实际上是一个几何级数，求和结果为：<br>T(n) = O(n^2 * (1/4 + 1/16 + … + 1/n^2))</p><p>因为这个和趋近于 O(n log^2 n)，所以希尔排序的平均时间复杂度为 O(n log^2 n)。</p><p><strong>总结</strong></p><p>时间复杂度可以在 O(n^(1.3)) 到 O(n^2) 之间。</p><p><strong>常见的间隔序列及其时间复杂度</strong></p><ol><li>希尔序列（Shell Sequence）：间隔序列为 {n/2, n/4, …, 1}。<ul><li>时间复杂度：O(n^2)</li></ul></li><li>Hibbard 序列：间隔序列为 {1, 3, 7, …, 2^k - 1}。<ul><li>时间复杂度：O(n^(3/2))</li></ul></li><li>Knuth 序列：间隔序列为 {1, 4, 13, 40, …, (3^k - 1) / 2}。<ul><li>时间复杂度：O(n^(3/2))</li></ul></li><li>Sedgewick 序列：间隔序列为 {1, 5, 19, 41, 109, …}。<ul><li>时间复杂度：O(n^(4/3))</li></ul></li><li>Pratt 序列：间隔序列为 {1, 2, 3, 4, 6, 8, 9, …}，即2的幂和3的幂的所有组合。<ul><li>时间复杂度：O(n log^2 n)</li></ul></li></ol><p><strong>时间复杂度计算示例：Hibbard 序列</strong></p><p>假设我们使用 Hibbard 序列，间隔序列为 {1, 3, 7, …, 2^k - 1}。</p><p><strong>分析步骤</strong></p><ol><li>间隔序列长度：对于一个长度为 n 的数组，最大间隔 k 满足 2^k - 1 ≈ n，即 k ≈ log_2 n。</li><li>每个间隔下的复杂度：在每个间隔 h 下，插入排序的复杂度为 O(n / h * h) = O(n)。</li><li>总复杂度：对于每个间隔 h，我们需要进行 k 次插入排序。由于 k ≈ log_2 n，总复杂度为 O(n log_2 n)。</li></ol><p>然而，由于 Hibbard 序列的实际排序效果，实验结果表明其平均时间复杂度更接近于 O(n^(3/2))。</p><p><strong>总结</strong></p><p>希尔排序的时间复杂度范围很广，具体取决于所使用的间隔序列。一般来说，时间复杂度可以在 O(n^(1.3)) 到 O(n^2) 之间变化。对于大多数实际应用，使用优化的间隔序列（如 Sedgewick 序列或 Pratt 序列）可以得到较好的时间复杂度，接近 O(n log^2 n)。</p><p><strong>参考公式</strong></p><ul><li>希尔序列：O(n^2)</li><li>Hibbard 序列：O(n^(3/2))</li><li>Knuth 序列：O(n^(3/2))</li><li>Sedgewick 序列：O(n^(4/3))</li><li>Pratt 序列：O(n log^2 n)</li></ul><p><strong>为什么说希尔排序不稳定！</strong></p><p>举个例子来说明这个问题：</p><p>假设有以下数组：<code>[3, 3, 1, 2, 2]</code>。</p><ol><li>初始数组： <code>[3, 3, 1, 2, 2]</code></li><li>选择一个跨度（gap），例如2： 对于跨度为2的子序列，我们有两个子序列：<code>[3, 1, 2]</code>和<code>[3, 2]</code>。</li><li>对每个子序列进行插入排序：<ul><li>对子序列<code>[3, 1, 2]</code>，排序后为<code>[1, 2, 3]</code>。</li><li>对子序列<code>[3, 2]</code>，排序后为<code>[2, 3]</code>。</li></ul></li><li>合并结果： <code>[1, 2, 2, 3, 3]</code></li></ol><p>在这个例子中，原数组中两个相同的“2”的相对顺序在排序后改变了。原本位于数组后半部分的“2”被移到了前半部分，而前半部分的“2”则保持在后半部分，这说明了希尔排序的不稳定性。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>思路分析：</strong>第一趟从n个元素的数据序列中选出关键字最小/大的元素并放在最前/后位置，下一趟从n-1个元素中选出最小/大的元素并放在最前/后位置。以此类推，经过n-1趟完成排序。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/select_sort.gif" alt=""></p><p>代码实现（此处代码对直接排序进行了有优化，遍历一次同时选出最大的和最小的，最大的放在最右边，最小的放在最左边，排序范围缩减）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">size_t</span> left = <span class="number">0</span>,right = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> min = left,max = left;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = left;i &lt;= right;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt; a[min])</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[min],a[left]);</span><br><span class="line"><span class="keyword">if</span>(max == left) <span class="comment">//最大值在最左边</span></span><br><span class="line">max = min;</span><br><span class="line"><span class="built_in">swap</span>(a[max],a[right]);</span><br><span class="line">--right;</span><br><span class="line">++left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>直接选择排序的最好时间复杂度号最坏时间复杂度都是O(n^2)，因为即使数组一开始就是正序的，也需要将两重循环进行完，平均时间复杂度也是O(n^2)，最好的时间复杂度为O(n^2)，空间复杂度为O(1)，因为不占用多余的空间。直接选择排序是一种原地排序并且不稳定的排序算法，优点是实现简单，占用空间小，缺点是效率低，时间复杂度高，对于大规模的数据耗时较长。</p><p><strong>为什么说选择排序不稳定</strong>！</p><p>举个例子来说明选择排序的不稳定性：</p><p>假设有以下数组：<code>[4, 2, 3, 2, 1]</code>。</p><ol><li>初始数组： <code>[4, 2, 3, 2, 1]</code></li><li>第一轮选择最小元素：<ul><li>当前数组：<code>[4, 2, 3, 2, 1]</code></li><li>最小元素是1，将其与第一个元素4交换：</li><li>交换后数组：<code>[1, 2, 3, 2, 4]</code></li></ul></li><li>第二轮选择最小元素：<ul><li>当前数组：<code>[1, 2, 3, 2, 4]</code></li><li>最小元素是2，将其与第二个元素2交换（没有实际变化）：</li><li>交换后数组：<code>[1, 2, 3, 2, 4]</code></li></ul></li><li>第三轮选择最小元素：<ul><li>当前数组：<code>[1, 2, 3, 2, 4]</code></li><li>最小元素是2，将其与第三个元素3交换：</li><li>交换后数组：<code>[1, 2, 2, 3, 4]</code></li></ul></li></ol><p>在这个例子中，原数组中两个相同的“2”的相对顺序在排序后改变了。原本位于数组第二个位置的“2”在排序后移动到了数组第三个位置，而原本在第四个位置的“2”则保持在第四个位置，这说明了选择排序的不稳定性。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>思路分析：</strong></p><p>①将长度为n的待排序的数组进行堆有序化构造成一个大顶堆</p><p>②将根节点与尾节点交换并输出此时的尾节点</p><p>③将剩余的n -1个节点重新进行堆有序化</p><p>④重复步骤2，步骤3直至构造成一个有序序列</p><p>（升序构建小堆，降序构建大堆）</p><p><strong>过程动态图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/AdjustDown.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> root,<span class="type">size_t</span> n)</span><span class="comment">//向下调整算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> parent = root;</span><br><span class="line"><span class="type">size_t</span> child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//下标为0的为第一个孩子，所以parent*2+1为下标为左孩子</span></span><br><span class="line"><span class="keyword">while</span>(child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span> &lt; n &amp;&amp; a[child+<span class="number">1</span>] &gt; a[child])</span><br><span class="line">&#123;</span><br><span class="line">++child;<span class="comment">//让child指向较大的那个孩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[child],a[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">size_t</span> n)</span><span class="comment">//升序，建大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//从第一个非叶子节点开始，做向下调整，调整完第一个元素为最大元素</span></span><br><span class="line"><span class="keyword">for</span>(i = (n<span class="number">-2</span>)/<span class="number">2</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(a,i,n);</span><br><span class="line">&#125;<span class="comment">//大堆建成</span></span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="comment">//交换第一个元素和最后一个元素，然后把交换后的第一个元素往下调整，再成大堆</span></span><br><span class="line"><span class="comment">//--end，即是缩小范围，每次把最大的换到end的位置</span></span><br><span class="line"><span class="keyword">for</span>(end = n<span class="number">-1</span>;end &gt;= <span class="number">0</span>;--end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[end],a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a,<span class="number">0</span>,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：堆排序的最好和最差情况时间复杂度都为O(nlog2n)，平均时间复杂度为O(nlog2n)，空间复杂度为O(1)，排序算法不稳定，无需使用多余的空间帮助排序。优点是占用空间较小，时间复杂度较低，缺点是实现较为复杂，并且当待排序序列发生改动时，哪怕是特别小的改动，都需要调整整个堆来维护堆的性质，维护开销较大。</p><p>时间复杂度</p><p><strong>构建堆的时间复杂度</strong></p><ul><li><strong>自底向上的堆化过程</strong>：在堆排序中，首先要将无序数组构建成一个最大堆。这一过程的时间复杂度为 O(n)。</li></ul><p><strong>排序过程的时间复杂度</strong></p><ul><li><p><strong>删除最大元素并重建堆</strong>：将最大堆的根节点（最大值）与最后一个节点交换，然后对剩余的 n−1个元素重新进行堆化。每次堆化的时间复杂度为 O(log⁡n)，因为堆化操作的高度最多为 log⁡2n</p><p>这个过程需要进行 n−1 次，因此排序部分的总时间复杂度为：O(nlog2n)</p></li></ul><p><strong>补充下建堆的过程</strong></p><p><strong>建堆步骤</strong></p><p>堆的性质要求每个节点的值都不小于（最大堆）或不大于（最小堆）其子节点的值。建堆的过程自底向上进行，因为这样可以确保在调整某个节点时，它的子节点已经是堆。</p><p><strong>详细步骤</strong></p><ol><li><strong>选择从最后一个非叶子节点开始</strong>：因为叶子节点本身已经是一个堆，所以我们只需要调整非叶子节点。最后一个非叶子节点的索引是 ⌊n/2⌋−1，其中 n 是数组的长度。</li><li><strong>自底向上调整堆</strong>：从最后一个非叶子节点开始，依次向前遍历每个节点，执行 <code>heapify</code> 操作以确保每个节点都满足堆的性质。</li></ol><p><strong><code>heapify</code> 操作</strong></p><p><code>heapify</code> 是调整堆的核心操作，确保以某个节点为根的子树满足堆的性质。</p><p><strong>伪代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;       <span class="comment">// 初始化 largest 为根节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于 largest</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 largest 不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]); <span class="comment">// 交换根节点和最大值节点</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);   <span class="comment">// 递归地调整受影响的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建堆的完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始自底向上调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    <span class="built_in">buildMaxHeap</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个一个地从堆中取出元素，并调整剩余的堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将当前堆的根节点（最大值）与堆的最后一个元素交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整剩余的堆，使其重新满足最大堆的性质</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>假设我们有一个数组[4,10,3,5,1]，建堆过程如下：</p><ol><li>初始数组：[4,10,3,5,1]</li><li>从最后一个非叶子节点 i=1 开始堆化：<ul><li>当前节点是 10，左子节点是 5，右子节点是 1，没有变化。</li></ul></li><li>处理根节点 i=0<ul><li>当前节点是 4，左子节点是 10，右子节点是 3。由于 10 最大，将 4 和 10 交换，得到 [][10, 4, 3, 5, 1][10,4,3,5,1]。</li><li>调整后的子树根节点是 4，它没有子节点需要调整。</li></ul></li></ol><p>结果是 [][10, 4, 3, 5, 1][10,4,3,5,1]，这个数组已经是最大堆。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>本质上快速排序把数据划分成几份，所以快速排序通过选取一个关键数据，再根据它的大小，把原数组分成两个子数组：第一个数组里的数都比这个主元数据小或等于，而另一个数组里的数都比这个主元数据要大或等于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于交换两个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// i指向小于pivot的最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回pivot的正确位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序递归函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 获取分区点</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);  <span class="comment">// 排序左边部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 排序右边部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><p>假设我们有数组 <code>arr = &#123;10, 7, 8, 9, 1, 5&#125;</code>，我们调用 <code>partition(arr, 0, 5)</code>。</p><ul><li>初始状态：<code>pivot = 5</code>，<code>i = -1</code>。</li><li>遍历数组：<ul><li><code>j = 0</code>，<code>arr[j] = 10</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 1</code>，<code>arr[j] = 7</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 2</code>，<code>arr[j] = 8</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 3</code>，<code>arr[j] = 9</code>，大于 <code>pivot</code>，不交换，<code>i</code> 仍为 <code>-1</code>。</li><li><code>j = 4</code>，<code>arr[j] = 1</code>，小于 <code>pivot</code>，交换 <code>arr[0]</code> 和 <code>arr[4]</code>，<code>i = 0</code>。</li></ul></li><li>交换基准元素：<ul><li>将 <code>arr[1]</code> 和 <code>arr[5]</code> 交换，得到 <code>arr = &#123;1, 5, 8, 9, 10, 7&#125;</code>。</li></ul></li><li>返回值：<ul><li>返回 <code>i + 1 = 1</code>。</li></ul></li></ul><p>通过上述步骤，我们将数组划分为两部分：<code>&#123;1&#125;</code> 和 <code>&#123;8, 9, 10, 7&#125;</code>，其中基准元素 <code>5</code> 位于正确的位置。</p><p><strong>总结</strong>：平均时间复杂度为O(nlog2n)，最坏时间复杂度为O(n^2)，空间复杂度为O(nlog2n），排序算法不稳定。</p><p><strong>补充</strong>：</p><ul><li><p><strong>选择的枢轴（pivot）不理想</strong>：如果每次选择的枢轴总是数组中的最大或最小元素，快速排序将退化为最坏情况。例如，对于一个已经有序的数组，如果每次选择第一个元素或最后一个元素作为枢轴，快速排序会产生极度不平衡的划分，导致最坏时间复杂度 O(n^2)。</p><p>举个例子，假设我们总是选择第一个元素作为枢轴：</p><ul><li>对于一个已经有序的数组 <code>[1, 2, 3, 4, 5]</code>，第一次选择 1 作为枢轴，将数组划分为 <code>[]</code> 和 <code>[2, 3, 4, 5]</code>。</li><li>接下来，选择 2 作为枢轴，将数组划分为 <code>[]</code> 和 <code>[3, 4, 5]</code>。</li><li>继续下去，每次的划分都会导致一个子数组为空，另一个子数组包含剩余的所有元素。</li></ul><p>这样，每次递归调用都会减少一个元素，导致总体时间复杂度变为 O(n^2)。</p></li><li><p><strong>重复元素很多</strong>：当数组中有很多重复元素时，特别是所有元素都相同时，如果选择的枢轴总是那些重复的元素，快速排序也会退化。例如，对于一个全是相同元素的数组 <code>[5, 5, 5, 5, 5]</code>，如果选择枢轴为 5，每次划分后的两个子数组大小不变，这会导致快速排序退化为最坏时间复杂度。</p></li></ul><p>为了避免快速排序退化为 O(n^2)，常用的改进方法包括：</p><ul><li><strong>随机选择枢轴</strong>：在每次划分时随机选择一个元素作为枢轴，这样可以大大减少出现最坏情况的概率。</li><li><strong>三数取中法（Median of Three）</strong>：选择第一个元素、中间元素和最后一个元素的中位数作为枢轴。</li><li><strong>混合排序算法</strong>：当数组大小较小时，切换到插入排序等其他高效的排序算法，因为在小数组上，插入排序的性能通常优于快速排序。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>思路分析：</strong></p><p>当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样<strong>递归下去，合并上来</strong>就是归并排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> *a, <span class="type">int</span> left, <span class="type">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">_MergeSort(a, left, mid);</span><br><span class="line">_MergeSort(a, mid+<span class="number">1</span>, right);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[right-left+<span class="number">1</span>];<span class="comment">//开辟同原数组大小的辅助空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = left;<span class="comment">//左区间的开头</span></span><br><span class="line"><span class="type">int</span> begin2 = mid+<span class="number">1</span>;<span class="comment">//右区间的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;<span class="comment">//辅助空间的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(begin1 &lt;= mid &amp;&amp; begin2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[begin1] &lt; a[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将余下的直接放入辅助空间</span></span><br><span class="line"><span class="keyword">while</span>(begin1 &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(begin2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tmp数组的值全部拷贝到a数组里面</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[left+i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;<span class="comment">//释放自己申请的空间</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line">_MergeSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：平均和最坏、最好时间复杂度为O(nlog2n)，空间复杂度O(n)，排序算法稳定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240701233431874.png" alt="image-20240701233431874"></p><p>参考资料：</p><p><a href="https://blog.csdn.net/ypt523/article/details/80462873">排序算法（七大经典排序算法）</a></p><p><a href="https://segmentfault.com/a/1190000021638663#item-7-27">https://segmentfault.com/a/1190000021638663#item-7-27</a></p>]]></content>
    
    
    <summary type="html">七大经典排序算法</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>伙伴算法和slab算法</title>
    <link href="https://penge666.github.io/posts/f26278ad.html"/>
    <id>https://penge666.github.io/posts/f26278ad.html</id>
    <published>2024-06-30T09:36:48.000Z</published>
    <updated>2024-07-02T02:49:04.146Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中，用来管理物理内存页面的<strong>伙伴系统</strong>，以及负责分配比页更小的内存对象的<strong>SLAB分配器</strong>了。</p>]]></content>
    
    
    <summary type="html">Linux内存管理-伙伴算法和slab算法</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用户态和内核态</title>
    <link href="https://penge666.github.io/posts/6407ef8f.html"/>
    <id>https://penge666.github.io/posts/6407ef8f.html</id>
    <published>2024-06-30T08:30:03.000Z</published>
    <updated>2024-06-30T09:05:20.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户态和内核态概述">用户态和内核态概述</h2><p><strong>简单来说内核态就是操作系统运行线程，用户态就是线程执行用户自己的程序。</strong></p><p><strong>用户态</strong>：</p><ul><li>不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</li></ul><p><strong>内核态</strong>：</p><ul><li><p>系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行。</p></li><li><p>内核态可以使用计算机所有的硬件资源。</p></li></ul><blockquote><p><strong>为什么要区分用户态和内核态？</strong></p></blockquote><p><strong>1. 安全性</strong></p><ul><li><strong>保护系统资源</strong>：内核态拥有对所有硬件和系统资源的完全控制权。通过区分用户态和内核态，可以防止用户程序直接访问和修改系统关键数据结构和硬件资源。</li><li><strong>防止恶意行为</strong>：如果没有用户态和内核态的区分，恶意程序可能会直接操作硬件或篡改系统内核，从而危害整个系统的安全。</li></ul><p><strong>2. 稳定性</strong></p><ul><li><strong>防止错误传播</strong>：用户态程序运行在受限环境中，不能直接访问硬件和其他进程的内存。即使用户程序发生崩溃或错误，也不会直接影响到系统内核和其他程序的运行。</li><li><strong>隔离故障</strong>：通过用户态和内核态的隔离，可以确保一个程序的错误不会影响到整个系统的稳定性。</li></ul><p><strong>3. 控制和管理</strong></p><ul><li><strong>资源管理</strong>：操作系统需要对系统资源（如CPU、内存、I/O设备等）进行统一管理和调度。通过内核态，可以实现对资源的有效控制和分配。</li><li><strong>系统调用接口</strong>：通过系统调用接口，用户程序可以请求内核服务，但这些请求是受控的。内核可以检查和验证这些请求，确保其合法性和安全性。</li></ul><p><strong>4. 提高效率</strong></p><ul><li><strong>中断处理</strong>：许多硬件中断（如定时器中断、I/O中断）需要立即响应。这些中断处理程序运行在内核态，可以快速地访问和操作硬件。</li><li><strong>直接硬件访问</strong>：内核态允许直接操作硬件设备，而不需要经过额外的抽象层，从而提高了操作的效率。</li></ul><h2 id="CPU-指令集权限">CPU 指令集权限</h2><p>指令集是 C P U 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 C P U 指令，而非常非常多的 C P U 指令 在一起，可以组成一个、甚至多个集合，指令的集合叫 C P U 指令集。</p><p>同时 C P U 指令集 有权限分级，大家试想，C P U 指令集 可以直接操作硬件的，要是因为指令操作的不规范`，造成的错误会影响整个计算机系统的。好比你写程序，因为对硬件操作不熟悉，导致操作系统内核、及其他所有正在运行的程序，都可能会因为操作失误而受到不可挽回的错误，最后只能重启计算机才行。</p><p>而对于硬件的操作是非常复杂的，参数众多，出问题的几率相当大，必须谨慎的进行操作，对开发人员来说是个艰巨的任务，还会增加负担，同时开发人员在这方面也不被信任，所以操作系统内核直接屏蔽开发人员对硬件操作的可能，都不让你碰到这些 C P U 指令集。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164319388.png" alt="image-20240630164319388"></p><p>针对上面的需求，硬件设备商直接提供硬件级别的支持，做法就是对 C P U 指令集设置了权限，不同级别权限能使用的 C P U 指令集 是有限的，以 Intel C P U 为例，Inter把 CPU 指令集 操作的权限由高到低划为4级：</p><ul><li>ring 0</li><li>ring 1</li><li>ring 2</li><li>ring 3</li></ul><p>其中 ring 0 权限最高，可以使用所有 C P U 指令集，ring 3 权限最低，仅能使用常规 C P U 指令集，不能使用操作硬件资源的 C P U 指令集，比如 I O 读写、网卡访问、申请内存都不行，Linux系统仅采用ring 0 和 ring 3 这2个权限。</p><p><strong>高情商</strong></p><p><strong>ring 0被叫做内核态，完全在操作系统内核中运行</strong></p><p><strong>ring 3被叫做用户态，在应用程序中运行</strong></p><p><strong>低情商</strong></p><p>执行内核空间的代码，具有ring 0保护级别，有对硬件的所有操作权限，可以执行所有C P U 指令集，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机。</p><p>在用户模式下，具有ring 3保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的。</p><h2 id="用户态与内核态的空间">用户态与内核态的空间</h2><p>在内存资源上的使用，操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」，以Linux32位操作系统为例，它的寻址空间范围是 4G（2的32次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 1G（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 3G（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164611780.png" alt="image-20240630164611780"></p><ul><li>用户态：只能操作 0-3G 范围的低位虚拟空间地址</li><li>内核态：0-4G 范围的虚拟空间地址都可以操作，尤其是对 3-4G 范围的高位虚拟空间地址必须由内核态去操作</li><li>补充：3G-4G 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。每个进程的 4G 虚拟空间地址，高位 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用，换句话说就是， 高位 1G 的内核空间是被所有进程共享的！</li></ul><p><strong>最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用</strong></p><h2 id="用户态与内核态的栗子">用户态与内核态的栗子</h2><p><strong>用户态：应用程序请求读取文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>系统调用：从用户态到内核态</strong></p><ul><li>当应用程序调用 <code>open()</code>, <code>read()</code> 和 <code>close()</code> 函数时，这些函数实际上是对内核提供的系统调用的封装。</li><li>例如，当 <code>read()</code> 被调用时，用户程序会发出一个系统调用陷入（trap）指令，触发从用户态到内核态的切换。<ul><li><code>read</code> 函数会执行一个系统调用指令（通常是 <code>syscall</code> 或 <code>int 0x80</code>），这是一种特殊的 CPU 指令，用于<strong>从用户态切换到内核态</strong>。</li><li>系统调用指令会引发一个陷入（trap），这是一种同步的中断，触发 CPU 切换到内核态，并跳转到内核中的系统调用处理入口。</li></ul></li></ul><p><strong>内核态：操作系统处理请求</strong></p><ul><li><p>内核接管控制权，进入内核态。CPU 跳转到内核的系统调用处理程序，根据系统调用号（每个系统调用都有一个唯一的编号，<code>read</code> 对应的编号通常是 0）找到相应的内核函数（sys_read）。内核中的文件系统代码开始执行，处理文件读取请求。</p></li><li><p>内核验证文件描述符，检查访问权限，然后执行实际的文件读取操作，将数据从磁盘读取到内核缓冲区。</p></li></ul><p><strong>从内核态返回用户态</strong></p><ul><li>文件读取操作完成后，内核将读取的数据复制到用户提供的缓冲区（<code>buffer</code>）。</li><li>内核返回结果，控制权交还给用户程序【通过 <code>iret</code> 或 <code>sysret</code> 指令返回用户态】，此时切换回用户态。</li></ul><p><strong>用户态：处理读取的数据</strong></p><ul><li>用户程序继续执行，处理从文件中读取的数据（如 <code>printf()</code> 打印数据）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户态：        应用程序（用户代码）      -&gt;      内核态： 操作系统（系统调用处理）</span><br><span class="line">  <span class="built_in">read</span>(fd, buffer, count)      系统调用陷入</span><br><span class="line">                                --&gt; 保存用户态上下文</span><br><span class="line">                                --&gt; 跳转到内核系统调用处理入口</span><br><span class="line">                                --&gt; 验证参数</span><br><span class="line">                                --&gt; 查找文件对象</span><br><span class="line">                                --&gt; 执行文件读取操作</span><br><span class="line">                                --&gt; 将数据复制到用户缓冲区</span><br><span class="line">                                --&gt; 设置返回值</span><br><span class="line">                                --&gt; 恢复用户态上下文</span><br><span class="line">                                --&gt; 返回用户态，继续执行用户程序</span><br></pre></td></tr></table></figure><h2 id="用户态与内核态的切换">用户态与内核态的切换</h2><ul><li><strong>保留用户态现场（上下文、寄存器、用户栈等）</strong></li><li><strong>复制用户态参数，用户栈切到内核栈，进入内核态</strong></li><li><strong>额外的检查（因为内核代码对用户不信任）</strong></li><li><strong>执行内核态代码</strong></li><li><strong>复制内核态代码执行结果，回到用户态</strong></li><li><strong>恢复用户态现场（上下文、寄存器、用户栈等）</strong></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630164810614.png" alt="image-20240630164810614"></p><p>从上图我们可以看出来通过系统调用将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。</p><p>库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。</p><p>Shell顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，它是一种特殊的应用程序，俗称命令行。Shell也是可编程的，它有标准的Shell语法，符合其语法的文本叫Shell脚本，很多人都会用Shell脚本实现一些常用的功能，可以提高工作效率。</p><p>最后来说说，什么情况会导致用户态到内核态切换</p><p><strong>系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断，也可以称为软中断</strong>。</p><p><strong>异常：当 C P U 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常</strong>。</p><p><strong>中断：当 C P U 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 C P U 发出相应的中断信号，这时 C P U 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。</strong></p><p>扩展自：<a href="https://blog.csdn.net/u014571143/article/details/129660010">「操作系统」什么是用户态和内核态？为什么要区分</a></p>]]></content>
    
    
    <summary type="html">一文说懂用户态内核态</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程线程协程</title>
    <link href="https://penge666.github.io/posts/68a40dd3.html"/>
    <id>https://penge666.github.io/posts/68a40dd3.html</id>
    <published>2024-06-29T07:30:57.000Z</published>
    <updated>2024-06-30T08:18:49.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程">进程</h2><p>计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><blockquote><p><strong>补充：细聊PCB</strong></p></blockquote><p>在Linux中，PCB结构为task_struct;</p><p>task_struct是Linux内核的一种数据结构，它会被装载到RAM里并且包含进程的信息，每个进程都把它的信息放在task_struct这个数据结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">　　　表示进程的当前状态:</span></span><br><span class="line"><span class="comment">    TASK_RUNNING:正在运行或在就绪队列run-queue中准备运行的进程，实际参与进程调度。</span></span><br><span class="line"><span class="comment">    TASK_INTERRUPTIBLE:处于等待队列中的进程，待资源有效时唤醒，也可由其它进程通过信号(signal)或定时中断唤醒后进入就绪队列run-queue。</span></span><br><span class="line"><span class="comment">    TASK_UNINTERRUPTIBLE:处于等待队列中的进程，待资源有效时唤醒，不可由其它进程通过信号(signal)或定时中断唤醒。</span></span><br><span class="line"><span class="comment">    TASK_ZOMBIE:表示进程结束但尚未消亡的一种状态(僵死状态)。此时，进程已经结束运行且释放大部分资源，但尚未释放进程控制块。</span></span><br><span class="line"><span class="comment">    TASK_STOPPED:进程被暂停，通过其它进程的信号才能唤醒。导致这种状态的原因有二，或者是对收到SIGSTOP、SIGSTP、SIGTTIN或SIGTTOU信号的反应，或者是受其它进程的ptrace系统调用的控制而暂时将CPU交给控制进程。</span></span><br><span class="line"><span class="comment">    TASK_SWAPPING: 进程页面被交换出内存的进程。</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;　　<span class="comment">//进程标志，与管理有关,在调用fork()时给出</span></span><br><span class="line">    <span class="type">int</span> sigpending;　　　　　<span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">mm_segment_t</span> addr_limit; 　　<span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span></span><br><span class="line">    <span class="comment">/*用户线程空间地址: 0..0xBFFFFFFF。</span></span><br><span class="line"><span class="comment">       内核线程空间地址: 0..0xFFFFFFFF     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">exec_domain</span> *exec_domain;　　<span class="comment">//进程执行域</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> need_resched;　　　　　<span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ptrace;</span><br><span class="line">    <span class="type">int</span> lock_depth;　　<span class="comment">//锁深度</span></span><br><span class="line">    <span class="type">long</span> counter;　　　<span class="comment">//进程的基本时间片,在轮转法调度时表示进程当前还可运行多久，在进程开始运行是被赋为priority的值，以后每隔一个tick(时钟中断)递减1，减到0时引起新一轮调 度。重新调度将从run_queue队列选出counter值最大的就绪进程并给予CPU使用权，因此counter起到了进程的动态优先级的作用</span></span><br><span class="line">    <span class="type">long</span> nice;　　　　 <span class="comment">//静态优先级</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> policy;　　<span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR,分时进程:SCHED_OTHER</span></span><br><span class="line"><span class="comment">//在Linux 中, 采用按需分页的策略解决进程的内存需求。task_struct的数据成员mm 指向关于存储管理的mm_struct结构。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm;　　<span class="comment">//进程内存管理信息</span></span><br><span class="line">    <span class="type">int</span> has_cpu, processor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpus_allowed;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> run_list;　　<span class="comment">//指向运行队列的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sleep_time; 　　<span class="comment">//进程的睡眠时间</span></span><br><span class="line">    <span class="comment">//用于将系统中所有的进程连成一个双向循环链表,其根是init_task</span></span><br><span class="line">    <span class="comment">//在Linux 中所有进程(以PCB 的形式)组成一个双向链表,next_task和prev_task是链表的前后向指针</span></span><br><span class="line">　 <span class="keyword">struct</span> <span class="title class_">task_struct</span> *next_task, *prev_task;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *active_mm;  <span class="comment">//active_mm 指向活动地址空间。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linux_binfmt</span> *binfmt;　　<span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">    <span class="type">int</span> exit_code, exit_signal;</span><br><span class="line">    <span class="type">int</span> pdeath_signal;　　　　<span class="comment">//父进程终止是向子进程发送的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> personality;</span><br><span class="line">    <span class="type">int</span> dumpable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> did_exec:<span class="number">1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid; 　　<span class="comment">//进程标识符,用来代表一个进程</span></span><br><span class="line">    <span class="type">pid_t</span> pgrp;　 <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">    <span class="type">pid_t</span> tty_old_pgrp;  　　<span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">    <span class="type">pid_t</span> session;　　　　　　<span class="comment">//进程的会话标识</span></span><br><span class="line">    <span class="type">pid_t</span> tgid;</span><br><span class="line">    <span class="type">int</span> leader;　　　　　　　　<span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">    &lt;br&gt;　　<span class="comment">//指向最原始的进程任务指针，父进程任务指针，子进程任务指针，新兄弟进程任务指针，旧兄弟进程任务指针。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> thread_group;　　 <span class="comment">//线程链表</span></span><br><span class="line">    &lt;br&gt;　　<span class="comment">//用于将进程链入HASH表,系统进程除了链入双向链表外，还被加入到hash表中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *pidhash_next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> **pidhash_pprev;   </span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait_chldexit; 　　<span class="comment">//供wait4()使用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semaphore</span> *vfork_sem;　　　　 <span class="comment">//供vfork()使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_priority;　　　　　　<span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line">   &lt;br&gt;　　 <span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies,系统根据it_real_value</span></span><br><span class="line">    <span class="comment">//设置定时器的第一个终止时间.在定时器到期时，向进程发送SIGALRM信号，同时根据</span></span><br><span class="line">    <span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span></span><br><span class="line">    <span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送信号SIGPROF，并根据it_prof_incr重置时间.</span></span><br><span class="line">    <span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span></span><br><span class="line">    <span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据it_virt_incr重置初值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_incr, it_prof_incr, it_virt_incr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timer_list</span> real_timer;　　<span class="comment">//指向实时定时器的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tms</span> times; 　　　　　　　  <span class="comment">//记录进程消耗的时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time;　　　　<span class="comment">//进程创建的时间</span></span><br><span class="line">    <span class="type">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];<span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">    <span class="comment">//内存缺页和交换信息:</span></span><br><span class="line">    <span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copyon　Write页和匿名页）和主缺页数（从映射文件或交换</span></span><br><span class="line">    <span class="comment">//设备读入的页面数）；nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span></span><br><span class="line">    <span class="comment">//cmin_flt, cmaj_flt,cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span></span><br><span class="line">    <span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">    <span class="type">int</span> swappable:<span class="number">1</span>; 　　<span class="comment">//表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">    <span class="comment">//进程认证信息</span></span><br><span class="line">    <span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid，euid，egid为有效uid,gid</span></span><br><span class="line">    <span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件系统的访问权限时使用他们。</span></span><br><span class="line">    <span class="comment">//suid，sgid为备份uid,gid</span></span><br><span class="line">    <span class="type">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">    <span class="type">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">    <span class="type">int</span> ngroups;　　　　　<span class="comment">//记录进程在多少个用户组中</span></span><br><span class="line">    <span class="type">gid_t</span> groups[NGROUPS];　　<span class="comment">//记录进程所在的组</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;<span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span></span><br><span class="line">    <span class="type">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;　　<span class="comment">//代表进程所属的用户</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> rlim[RLIM_NLIMITS]; 　　<span class="comment">//与进程相关的资源限制信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math; 　　<span class="comment">//是否使用FPU</span></span><br><span class="line">    <span class="type">char</span> comm[<span class="number">16</span>]; 　　　　<span class="comment">//进程正在运行的可执行文件名</span></span><br><span class="line">     <span class="comment">//文件系统信息</span></span><br><span class="line">    <span class="type">int</span> link_count;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tty_struct</span> *tty;　　<span class="comment">//进程所在的控制终端，如果不需要控制终端，则该指针为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> locks;     <span class="comment">/* How many file locks are being held */</span></span><br><span class="line">    <span class="comment">//进程间通信信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sem_undo</span> *semundo;　　<span class="comment">//进程在信号量上的所有undo操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sem_queue</span> *semsleeping;　　<span class="comment">//当进程因为信号量操作而挂起时，他在该队列中记录等待的操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_struct</span> thread;　　　<span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs; 　　　　<span class="comment">//文件系统信息，fs保存了进程本身与VFS（虚拟文件系统）的关系信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *files;　<span class="comment">//打开文件信息</span></span><br><span class="line">     <span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">spinlock_t</span> sigmask_lock; <span class="comment">/* Protects signal and blocked */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">signal_struct</span> *sig;　<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked;　　　　　　<span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigpending</span> pending; <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;</span><br><span class="line">    <span class="type">size_t</span> sas_ss_size;</span><br><span class="line">    <span class="built_in">int</span> (*notifier)(<span class="type">void</span> *priv);</span><br><span class="line">    <span class="type">void</span> *notifier_data;</span><br><span class="line">    <span class="type">sigset_t</span> *notifier_mask;</span><br><span class="line">    <span class="comment">/* Thread group tracking */</span></span><br><span class="line">    u32 parent_exec_id;</span><br><span class="line">    u32 self_exec_id;</span><br><span class="line">    <span class="type">spinlock_t</span> alloc_lock;   <span class="comment">//用于申请空间时用的自旋锁。自旋锁的主要功能是临界区保护</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>进程标识信息</strong>：<ul><li><strong>进程ID（Process ID, PID）</strong>：唯一标识一个进程的标识符。</li><li><strong>父进程ID</strong>：创建当前进程的父进程的ID。</li></ul></li><li><strong>处理器状态信息</strong>：<ul><li><strong>程序计数器（Program Counter, PC）</strong>：指示下一条将要执行的指令的地址。</li><li><strong>CPU寄存器的内容</strong>：包括通用寄存器、浮点寄存器、状态寄存器等，保存进程的执行状态。</li><li><strong>进程状态</strong>：如运行、就绪、阻塞等状态。</li></ul></li><li><strong>内存管理信息</strong>：<ul><li><strong>基地址和限长寄存器</strong>：用于定义进程的地址空间范围。</li><li><strong>页表或段表</strong>：用于虚拟内存管理，映射虚拟地址到物理地址。</li></ul></li><li><strong>调度和状态信息</strong>：<ul><li><strong>进程优先级</strong>：用于进程调度。</li><li><strong>调度队列指针</strong>：指向进程在调度队列中的位置，用于进程调度。</li><li><strong>其他调度参数</strong>：如时间片长度、剩余时间等。</li></ul></li><li><strong>进程间通信信息</strong>：<ul><li><strong>信号量、消息队列</strong>：用于进程间通信和同步。</li><li><strong>管道和共享内存</strong>：用于进程间数据传输。</li></ul></li><li><strong>I/O状态信息</strong>：<ul><li><strong>打开的文件列表</strong>：进程当前打开的所有文件的列表。</li><li><strong>I/O设备信息</strong>：如进程使用的I/O设备、设备状态等。</li></ul></li><li><strong>汇总信息</strong>：<ul><li><strong>CPU使用时间</strong>：进程使用的CPU时间。</li><li><strong>内存使用量</strong>：进程使用的内存量。</li><li><strong>其他资源使用信息</strong>：如I/O操作次数等。</li></ul></li></ol><h2 id="线程">线程</h2><p>随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p><blockquote><p><strong>补充：进程切换流程</strong></p></blockquote><p>这里我举个例子说明进程A切换到进程B的例子：</p><ol><li><strong>保存进程A的上下文</strong>：<ul><li>将进程A的程序计数器、通用寄存器、状态寄存器等保存到进程A的PCB中。</li><li>保存进程A的页表基地址、段表基地址到PCB中。</li><li>保存进程A的文件描述符表、信号处理信息等。</li></ul></li><li><strong>更新进程A的状态</strong>：<ul><li>将进程A的状态从“运行”改为“就绪”或“阻塞”。</li></ul></li><li><strong>调度器选择进程B</strong>：<ul><li>调度器根据调度算法选择进程B。</li><li>将进程B的状态从“就绪”改为“运行”。</li></ul></li><li><strong>加载进程B的上下文</strong>：<ul><li>从进程B的PCB中恢复程序计数器、通用寄存器、状态寄存器等内容。</li><li>设置页表基地址和段表基地址为进程B的地址空间。</li><li>恢复进程B的文件描述符表、信号处理信息等。</li></ul></li><li><strong>切换到进程B并执行</strong>：<ul><li>更新程序计数器为进程B的下一条指令地址。</li><li>CPU开始执行进程B的代码。</li></ul></li></ol><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p>为了理解线程和线程在内存的布局，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">进程A</span><br><span class="line">├── 进程控制块（PCB）</span><br><span class="line">│   ├── 进程ID（PID）</span><br><span class="line">│   ├── 进程状态</span><br><span class="line">│   ├── 调度信息</span><br><span class="line">│   └── 其他元数据</span><br><span class="line">├── 内存空间</span><br><span class="line">│   ├── 代码段</span><br><span class="line">│   ├── 数据段</span><br><span class="line">│   ├── 堆</span><br><span class="line">│   └── 共享资源</span><br><span class="line">│       ├── 文件描述符</span><br><span class="line">│       └── 信号处理信息</span><br><span class="line">├── 线程1</span><br><span class="line">│   ├── 线程控制块（TCB）</span><br><span class="line">│   │   ├── 线程ID（TID）</span><br><span class="line">│   │   ├── 线程状态</span><br><span class="line">│   │   ├── 寄存器内容</span><br><span class="line">│   │   └── 程序计数器</span><br><span class="line">│   ├── 独立栈</span><br><span class="line">│   └── 共享资源（与进程共享）</span><br><span class="line">├── 线程2</span><br><span class="line">│   ├── 线程控制块（TCB）</span><br><span class="line">│   │   ├── 线程ID（TID）</span><br><span class="line">│   │   ├── 线程状态</span><br><span class="line">│   │   ├── 寄存器内容</span><br><span class="line">│   │   └── 程序计数器</span><br><span class="line">│   ├── 独立栈</span><br><span class="line">│   └── 共享资源（与进程共享）</span><br></pre></td></tr></table></figure><p><strong>线程（Thread）</strong></p><ul><li><strong>线程控制块（TCB）</strong>：保存线程的元数据，如线程ID、状态、寄存器内容、程序计数器等。</li><li><strong>独立栈</strong>：每个线程都有自己的栈，用于存储局部变量和函数调用信息。</li><li><strong>共享资源</strong>：与进程内其他线程共享代码段、数据段、堆和文件描述符等资源。</li></ul><p><strong>因此，我们就知道线程上下文切换比进程上下文切换要快</strong>。</p><p>原因：</p><ol><li><strong>资源共享</strong>：<ul><li><strong>线程</strong>：线程共享同一进程的内存地址空间、文件描述符和其他资源，只需要切换寄存器和程序计数器等上下文信息。</li><li><strong>进程</strong>：进程切换需要切换整个内存地址空间，包括页表和其他资源，涉及更多的状态保存和恢复。</li></ul></li><li><strong>缓存效率</strong>：<ul><li><strong>线程</strong>：由于线程共享同一进程的内存空间，切换时不会导致缓存（如CPU缓存和TLB）的显著失效，提高了缓存命中率。</li><li><strong>进程</strong>：进程切换通常会导致缓存失效，需要重新加载缓存数据，增加了额外的开销。</li></ul></li><li><strong>模式切换</strong>：<ul><li><strong>线程</strong>：线程切换通常在用户态完成，不涉及内核态和用户态的频繁切换。</li><li><strong>进程</strong>：进程切换需要在内核态和用户态之间切换，涉及更多的特权级别改变和指令开销。</li></ul></li></ol><p><strong>总结</strong></p><p>简单来说：进程切换需要切换整个地址空间，包括页表切换和缓存刷新等，还需要保存进程的上下文信息，包括 CPU 寄存器状态和栈指针。但是，同一进程内的线程共享内存地址空间，只需要切换上下文。</p><h3 id="任务调度">任务调度</h3><p>在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。</p><p>上述过程中，任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。</p><p>这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。多任务运行过程的示意图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629160358544.png" alt="image-20240629160358544"></p><h3 id="多线程与多核">多线程与多核</h3><p>上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？</p><p>其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。</p><p>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。<br>内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</p><p>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629162446104.png" alt="image-20240629162446104"></p><p>超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。【超线程技术通过在每个物理核心上模拟多个逻辑处理器，使得核心能够同时处理多个线程，最大化资源利用，提高并行处理能力和整体性能。】</p><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。</p><h4 id="一对一模型">一对一模型</h4><p>对于一对一模型来说，一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果CPU没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。</p><p>但一对一模型也有两个缺点：</p><ol><li>许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163102594.png" alt="image-20240629163102594"></p><h4 id="多对一模型">多对一模型</h4><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。因此相对一对一模型，多对一模型的线程上下文切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。</p><p>但多对一模型也有两个缺点：</p><ol><li>如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；</li><li>在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163124909.png" alt="image-20240629163124909"></p><h4 id="多对多模型">多对多模型</h4><p>多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。由线程库负责在可用的可调度实体上调度用户线程，这使得线程的上下文切换非常快，因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。</p><p>多对多模型的优点有：</p><ol><li>一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；</li><li>多对多模型对用户线程的数量没有限制；</li><li>在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163145410.png" alt="image-20240629163145410"></p><h3 id="线程的生命周期">线程的生命周期</h3><p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。</p><p>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及macOS等流行的操作系统。</p><p>我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163308718.png" alt="image-20240629163308718"></p><p><strong>线程与进程的区别</strong></p><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li><li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li><li><strong>稳定性方面</strong>：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li><li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</li><li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</li></ul><h2 id="协程">协程</h2><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629163537069.png" alt="image-20240629163537069"></p><h3 id="协程的目的">协程的目的</h3><p>在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p><p>对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。</p><p>而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。</p><h3 id="协程的特点">协程的特点</h3><ol><li><strong>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</strong></li><li><strong>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</strong></li><li><strong>由于在同一个线程上，因此可以避免竞争关系而使用锁。</strong></li><li><strong>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</strong></li></ol><h3 id="协程的原理">协程的原理</h3><p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由<code>coroutine</code>负责调度的线程称为<code>Fiber</code>。比如Golang里的 go关键字其实就是负责开启一个<code>Fiber</code>，让<code>func</code>逻辑跑在上面。</p><p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。<br>因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。</p><p><strong>协程与线程比较</strong></p><table><thead><tr><th>比较项</th><th style="text-align:center">线程</th><th style="text-align:center">协程</th></tr></thead><tbody><tr><td>占用资源</td><td style="text-align:center">初始单位为1MB,固定不可变</td><td style="text-align:center">初始一般为 2KB，可随需要而增大</td></tr><tr><td>调度所属</td><td style="text-align:center">由 OS 的内核完成</td><td style="text-align:center">由用户完成</td></tr><tr><td>切换开销</td><td style="text-align:center">涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td><td style="text-align:center">只有三个寄存器的值修改 - PC / SP / DX.</td></tr><tr><td>性能问题</td><td style="text-align:center">资源占用太高，频繁创建销毁会带来严重的性能问题</td><td style="text-align:center">资源占用小,不会带来严重的性能问题</td></tr><tr><td>数据同步</td><td style="text-align:center">需要用锁等机制确保数据的一直性和可见性</td><td style="text-align:center">不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td></tr></tbody></table><p><strong>线程</strong>：适合CPU密集型任务，利用多核并行计算能力，适合需要高并发的场景，但有较高的资源占用和上下文切换开销。</p><p><strong>协程</strong>：适合I/O密集型任务，通过非阻塞I/O和协作调度提高效率，轻量级且避免复杂的同步问题，但无法利用多核并行计算。</p><p>部分学习自：[<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">一文读懂什么是进程、线程、协程</a>](<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">https://www.cnblogs.com/Survivalist/p/11527949.html</a>)</p>]]></content>
    
    
    <summary type="html">理解进程、线程与协程：高效并发编程的关键</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>DNS协议解析</title>
    <link href="https://penge666.github.io/posts/2eaa30e5.html"/>
    <id>https://penge666.github.io/posts/2eaa30e5.html</id>
    <published>2024-06-28T09:17:34.000Z</published>
    <updated>2024-06-30T09:22:07.170Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/351059293">超详细 DNS 协议解析</a></p><h2 id="0-前言"><strong>0. 前言</strong></h2><p>为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171832226.png" alt="image-20240630171832226"></p><h2 id="1-什么是-DNS-协议"><strong>1. 什么是 DNS 协议</strong></h2><p>在学习 DNS 协议之前，我们先区分一下域名和 IP 地址这个两个概念：</p><ul><li><strong>IP 地址</strong>：一长串能够唯一地标记网络上的计算机的数字</li><li><strong>域名</strong>：又称网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）比如 <code>www.baidu.com</code></li></ul><blockquote><p>不知道有没有同学会混淆域名和<strong>网址</strong>的概念，可以这样理解，网址里面含有域名。举个例子：<code>www.gitee.com/veal98</code> 就是一个网址，而 <code>www.gitee.com</code> 就是域名</p></blockquote><p>由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并<strong>通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射</strong>，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析。</p><blockquote><p>DNS 协议可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。但<strong>大多数情况下 DNS 都使用 UDP 进行传输</strong>。</p></blockquote><h2 id="2-域名详解"><strong>2. 域名详解</strong></h2><p>❓ 那么域名由谁来规定和管理呢？不能是随便写吧？</p><p>全世界域名的最高管理机构，是一个叫做 ICANN （Internet Corporation for Assigned Names and Numbers）的组织，总部在美国加州。<strong>ICANN 负责管理全世界域名系统的运作</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171852966.png" alt="image-20240630171852966"></p><p>域名其实是具有一定的层次结构的，从上到下依次为：<strong>根域名</strong>、<strong>顶级域名</strong>（top level domain，TLD）、<strong>二级域名</strong>、（三级域名）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171904380.png" alt="image-20240630171904380"></p><h3 id="①-顶级域名"><strong>① 顶级域名</strong></h3><p>先来讲讲<strong>顶级域名</strong>（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<code>www.baidu.com</code> 的顶级域名就是 <code>.com</code>。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。截至 2015 年 7 月，顶级域名共有 1058 个，它们大致可以分成两类：</p><ul><li>一类是<strong>通用顶级域名</strong>（gTLD），比如<code>.com</code>、<code>.net</code>、<code>.edu</code>、<code>.org</code>、<code>.xxx</code>等等，共有 700 多个。</li><li>另一类是<strong>国家顶级域名</strong>（ccTLD），代表不同的国家和地区，比如<code>.cn</code>（中国）、<code>.io</code>（英属印度洋领地）、<code>.cc</code>（ 科科斯群岛）、<code>.tv</code>（图瓦卢）等，共有 300 多个。</li></ul><p>当然，ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个<strong>托管商</strong>，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，<code>.cn</code> 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 <code>.cn</code> 域名的各种政策。</p><h3 id="②-二级域名"><strong>② 二级域名</strong></h3><p>而<strong>二级域名</strong>(Second Level Domain,SLD) 在通用顶级域名或国家顶级域名之下具有不同的意义：</p><ul><li>通用顶级域名下的二级域名：一般是指域名注册人选择使用的网上名称，如 <code>yahoo.com</code>（商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如 <code>baidu.com</code>）</li><li>国家顶级域名下的二级域名：一般是指类似于通用顶级域名的表示注册人类别和功能的标志。例如，在 <code>.com.cn</code> 域名结构中，<code>.com</code> 此时是置于国家顶级域名 <code>.cn</code> 下的二级域名，表示中国的商业性组织，以此类推。</li></ul><p><strong>三级域名</strong>是形如 <code>www.baidu.com</code> 的域名，可以当做是二级域名的子域名，特征为域名包含两个 <code>.</code>。对于域名所有者/使用者而言，三级域名都是二级域名的附属物而无需单独费用。<strong>三级域名甚至不能称为域名，一般称之为域名下的 “二级目录”</strong>。</p><h3 id="③-根域名"><strong>③ 根域名</strong></h3><p>❓ 那么<strong>根域名</strong>在哪里呢？在层次结构中根域名不是最顶级的吗？域名中怎么没有看见它？</p><p>由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<code>www.xxx.com</code> 被写成 <code>www.xxx.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171917340.png" alt="image-20240630171917340"></p><p>理论上，<strong>所有域名的查询都必须先查询根域名</strong>，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，<strong>ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171933731.png" alt="image-20240630171933731"></p><p>比如，我要访问<code>abc.xyz</code>，也必须先去询问根域名列表，它会告诉我 <code>.xyz</code> 域名由 CentralNic 公司托管。根域名列表还记载，<code>.google</code>由谷歌公司托管，<code>.apple</code>由苹果公司托管等等。</p><p>由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。</p><h2 id="3-域名服务器详解"><strong>3. 域名服务器详解</strong></h2><p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。一个域名服务器所负责管里的分层叫作 <strong>区 (ZONE)</strong>。域名的每层都设有一个域名服务器：</p><ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器</li></ul><p>下面这幅图就很直观了：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171945529.png" alt="image-20240630171945529"></p><p>除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，即<strong>本地域名服务器</strong>。下面我们分别讲解这四种服务器都是用来干什么的</p><h3 id="①-根域名服务器"><strong>① 根域名服务器</strong></h3><p>上面我们提到，ICANN 维护着一张根域名列表，里面记载着顶级域名和对应的托管商，其实根域名列表的正式名称是 <strong>DNS 根区</strong>（DNS root zone），保存 DNS 根区文件的服务器，就叫做 <strong>DNS 根域名服务器</strong>（root name server）。根域名服务器<strong>保存所有的顶级域名服务器的地址</strong></p><p>由于早期的 DNS 查询结果是一个 512 字节的 UDP 数据包。这个包最多可以容纳 13 个服务器的地址，因此就规定全世界有 13 个根域名服务器，编号从 <code>a.root-servers.net</code> 一直到 <code>m.root-servers.net</code>。其中 10 台设置在美国，另外各有一台设置于荷兰、瑞典和日本。</p><p>前面我们说过，理论上<strong>所有域名的查询都必须先查询根域名</strong>，所以一般来说所有的域名服务器都会注册一份根域名服务器的 IP 地址的缓存，用于在必要的时候向其发送请求。</p><h3 id="②-顶级域名服务器"><strong>② 顶级域名服务器</strong></h3><p>按照根域名服务器管理顶级域名的逻辑，顶级域名服务器显然就是用来<strong>管理注册在该顶级域名下的所有二级域名</strong>的，<strong>记录这些二级域名的 IP 地址</strong>。</p><h3 id="③-权限域名服务器"><strong>③ 权限域名服务器</strong></h3><p>按照上面的逻辑，权限域名服务器应该是管理注册在二级域名下的所有三/四级域名的，但其实不是这样，如果一个二级域名或者一个三/四级域名对应一个域名服务器，则域名服务器数量会很多，我们需要使用<strong>划分区</strong>的办法来解决这个问题。那么权限域名服务器就是负责管理一个“<strong>区</strong>”的域名服务器。</p><p>❓ 什么是区？怎样划分区呢？</p><p>区和域其实是不同的，区可以有多种不同的划分方法。以百度为例，我们假设有 <code>fanyi.baidu.com</code>、<code>ai.baidu.com</code>、<code>tieba.baidu.com</code> 这三个三级域名。我们可以这样分区，<code>fanyi.baidu.com</code> 和 <code>tieba.baidu.com</code> 放在 <code>baidu.com</code> 权限域名服务器，<code>ai.baidu.com</code> 放在 <code>ai.baidu.com</code> 权限域名服务器中。并且 <code>baidu.com</code> 权限域名服务器和 <code>ai.baidu.com</code> 权限域名服务器是<strong>同等地位</strong>的，而具体怎么分区是百度公司根据域名多少、访问多少等情况去自己规定的。</p><p>画个图直观理解一下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630171957318.png" alt="image-20240630171957318"></p><h3 id="④-本地域名服务器"><strong>④ 本地域名服务器</strong></h3><p>除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，就是<strong>本地域名服务器</strong>（也被称为<strong>权威域名服务器</strong>）。本地域名服务器是电脑解析时的<strong>默认</strong>域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器。常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172008191.png" alt="image-20240630172008191"></p><p>每个因特网服务提供者或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。<strong>当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</strong>。<strong>本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询</strong>。</p><p>那么具体本地域名服务器是如何向上级域名服务器转发查询请求的呢？</p><h2 id="4-DNS-查询方式"><strong>4. DNS 查询方式</strong></h2><p>具体 DNS 查询的方式有两种：</p><ul><li>递归查询</li><li>迭代查询</li></ul><p>所谓迭代就是，如果请求的接收者不知道所请求的内容，那么<strong>接收者将扮演请求者</strong>，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。</p><p>通俗点来说，在递归查询中，如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案；而迭代查询则是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。</p><p>一般来说，<strong>域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大</strong>。通过下面这两个图就能很好的理解了</p><p>1）递归查询：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172020763.png" alt="image-20240630172020763"></p><p>2）迭代查询：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172030301.png" alt="image-20240630172030301"></p><h2 id="5-域名缓存"><strong>5. 域名缓存</strong></h2><p>上面讲解的是域名服务器之间的 DNS 查询请求过程，但实际上，每个时刻都有无数网民要上网，那每次都去访问本地域名服务器去获取 IP 地址显然是不实际的。解决方法就是<strong>使用缓存保存域名和 IP 地址的映射</strong>。</p><p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p><p>1）<strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</p><p>2）<strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172049327.png" alt="image-20240630172049327"></p><p>Windows 系统默认开启 DNS 缓存服务，服务名是 <code>DNSClient</code>，可以缓存一些常用的域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172100462.png" alt="image-20240630172100462"></p><p>使用命令 <code>ipconfig/displaydns</code> 可以查看电脑中缓存的域名。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172113442.png" alt="image-20240630172113442"></p><p>⭐ 在浏览器中进行访问的时候，会优先查询浏览器缓存，如果未命中则继续查询操作系统缓存，最后再查询本地域名服务器，然后本地域名服务器会递归的查找域名记录，最后返回结果。<strong>主机和本地域名服务器之间的查询方式是递归查询</strong>，也就是说主机请求本地域名服务器，那么本地域名服务器作为请求的接收者一定要给主机想要的答案。</p><h2 id="6-完整域名解析过程"><strong>6. 完整域名解析过程</strong></h2><p>OK，将我们上面所说的域名服务器之间的 DNS 查询请求过程和域名缓存结合起来，就是一个完整的 DNS 协议进行域名解析的过程。这里我们以正向解析为例（域名解析成 IP 地址）：</p><p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p><p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p><p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p><p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p><ul><li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li><li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul><p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p><p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p><p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p><p>配合下图直观理解：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630172124777.png" alt="image-20240630172124777"></p>]]></content>
    
    
    <summary type="html">超详细DNS协议解析</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会</title>
    <link href="https://penge666.github.io/posts/df083c4d.html"/>
    <id>https://penge666.github.io/posts/df083c4d.html</id>
    <published>2024-06-27T03:39:19.000Z</published>
    <updated>2024-06-29T07:13:44.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-了解SQL">第1章 了解SQL</h2><ol><li><p><strong>数据库（database）</strong> 保存有组织的数据的容器（通常是一个文件或一组文件）。</p></li><li><p><strong>表（table）</strong> 某种特定类型数据的结构化清单。</p></li><li><p><strong>模式（schema）</strong> 关于数据库和表的布局及特性的信息。</p></li><li><p><strong>列（column）</strong> 表中的一个字段。所有表都是由一个或多个列组成的。</p></li><li><p><strong>数据类型（datatype）</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p></li><li><p><strong>行（row）</strong> 表中的一个记录。</p></li><li><p><strong>主键（primary key）</strong> 一列（或一组列），其值能够唯一区分表中每个行。</p><p>表中的任何列都可以作为主键，只要它满足以下条件：</p><blockquote><ol><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li></ol></blockquote><p>主键的最好习惯：</p><blockquote><ol><li>不更新主键列中的值；</li><li>不重用主键列的值；</li><li>不在主键列中使用可能会更改的值。</li></ol></blockquote></li></ol><h2 id="第2章-MySQL简介">第2章 MySQL简介</h2><ol><li>DBMS（数据库管理系统）分两类：<ol><li>基于共享文件系统的DBMS，如Microsoft Access和FileMaker；</li><li>基于客户机—服务器的DBMS，如MySQL、Oracle以及Microsoft SQL Server。</li></ol></li></ol><h2 id="第3章-使用MySQL">第3章 使用MySQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">/* 显示所有数据库 */</span></span><br><span class="line">USE mysql; <span class="comment">/* 选择数据库mysql */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> TABLES; <span class="comment">/* 显示所有表 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> <span class="keyword">user</span>; <span class="comment">/* 显示user表中的列信息 */</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">user</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> STATUS; <span class="comment">/* 显示服务器状态信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mysql; <span class="comment">/* 显示创建数据库mysql的SQL语句 */</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>; <span class="comment">/* 显示创建表user的SQL语句 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> grants; <span class="comment">/* 显示用户的授权信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> ERRORS; <span class="comment">/* 显示服务器中的错误信息 */</span></span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS; <span class="comment">/* 显示服务器中的警告信息 */</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用<code>help show</code> 来查看帮助信息。</p></blockquote><h2 id="第4章-检索数据">第4章 检索数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">SELECT</span> user.User <span class="keyword">FROM</span> <span class="keyword">user</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> mysql.user; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Host,<span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span>; <span class="comment">/* 去除重复 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">3</span>; <span class="comment">/* 只显示查询结果的前3条记录 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">2</span>,<span class="number">3</span>; <span class="comment">/* 只显示查询结果的第2条开始（下标从0开始）后面的3条记录 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">2</span>; <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><blockquote><p>SQL不区分大小写，也忽略空格。</p><p>DISTINCT关键字应用于所有列而不仅是前置它的列。</p></blockquote><h2 id="第5章-排序检索数据">第5章 排序检索数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span>; <span class="comment">/* 升序排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">ASC</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">DESC</span>; <span class="comment">/* 降序排序 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span>, Host; <span class="comment">/* 先按User升序排序，再按Host升序排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">DESC</span>, Host; <span class="comment">/* 先按User降序排序，再按Host升序排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">User</span> <span class="keyword">DESC</span>, Host <span class="keyword">ASC</span>; <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><blockquote><p>DESC关键字只应用到直接位于其前面的列名。</p></blockquote><h2 id="第6章-过滤数据">第6章 过滤数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">!=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&lt;&gt;</span> <span class="number">0</span>; <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&lt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&lt;=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="operator">&gt;=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> max_connections <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span>, max_connections <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ssl_cipher <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">/* ssl_cipher字段为NULL */</span></span><br></pre></td></tr></table></figure><h2 id="第7章-数据过滤">第7章 数据过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span> <span class="keyword">OR</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span> <span class="keyword">OR</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>) <span class="keyword">AND</span> max_connections <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host <span class="keyword">IN</span> (<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>AND的优先级比OR高。</p><p>IN操作符完成与OR相同的功能，但是更快。</p></blockquote><h2 id="第8章-用通配符进行过滤">第8章 用通配符进行过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host <span class="keyword">LIKE</span> <span class="string">&#x27;local%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> <span class="keyword">LIKE</span> <span class="string">&#x27;r__t&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>百分号（%）表示任何字符出现任意次数。%不能匹配NULL值。</p><p>下划线（_）只匹配单个字符。</p></blockquote><h2 id="第9章-用正则表达式进行搜索">第9章 用正则表达式进行搜索</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> REGEXP <span class="string">&#x27;r..t&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> Host REGEXP <span class="string">&#x27;%|localhost&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> REGEXP <span class="string">&#x27;r[a-z]&#123;2&#125;t&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Host, <span class="keyword">User</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> REGEXP <span class="string">&#x27;mysql\\.sys&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用类似<code>SELECT 'hello' REGEXP '[0-9]'</code>这样的SQL来测试正常表达式，匹配成功返回1，否则返回0。</p></blockquote><h2 id="第10章-创建计算字段">第10章 创建计算字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="keyword">User</span>, <span class="string">&#x27;(&#x27;</span>, Host, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="keyword">User</span>, <span class="string">&#x27;(&#x27;</span>, Host, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> UserHost <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h2 id="第11章-使用数据处理函数">第11章 使用数据处理函数</h2><table><thead><tr><th style="text-align:left"><strong>函数</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">Left()</td><td style="text-align:left">返回串左边的字符</td></tr><tr><td style="text-align:left">Length()</td><td style="text-align:left">返回串的长度</td></tr><tr><td style="text-align:left">Locate()</td><td style="text-align:left">找出串的一个子串</td></tr><tr><td style="text-align:left">Lower()</td><td style="text-align:left">将串转换为小写</td></tr><tr><td style="text-align:left">LTrim()</td><td style="text-align:left">去掉串左边的空格返</td></tr><tr><td style="text-align:left">Right()</td><td style="text-align:left">返回串右边的字符</td></tr><tr><td style="text-align:left">RTrim()</td><td style="text-align:left">去掉串右边的空格</td></tr><tr><td style="text-align:left">Soundex()</td><td style="text-align:left">返回串的SOUNDEX值</td></tr><tr><td style="text-align:left">SubString()</td><td style="text-align:left">返回子串的字符</td></tr><tr><td style="text-align:left">Upper()</td><td style="text-align:left">将串转换为大写</td></tr><tr><td style="text-align:left">AddDate()</td><td style="text-align:left">增加一个日期（天、周等）</td></tr><tr><td style="text-align:left">AddTime()</td><td style="text-align:left">增加一个时间（时、分等）</td></tr><tr><td style="text-align:left">CurDate()</td><td style="text-align:left">返回当前日期</td></tr><tr><td style="text-align:left">CurTime()</td><td style="text-align:left">返回当前时间</td></tr><tr><td style="text-align:left">Date()</td><td style="text-align:left">返回日期时间的日期部分</td></tr><tr><td style="text-align:left">DateDiff()</td><td style="text-align:left">计算两个日期之差</td></tr><tr><td style="text-align:left">Date_Add()</td><td style="text-align:left">高度灵活的日期运算函数</td></tr><tr><td style="text-align:left">Date_Format()</td><td style="text-align:left">返回一个格式化的日期或时间串</td></tr><tr><td style="text-align:left">Day()</td><td style="text-align:left">返回一个日期的天数部分</td></tr><tr><td style="text-align:left">DayOfWeek()</td><td style="text-align:left">对于一个日期，返回对应的星期几</td></tr><tr><td style="text-align:left">Hour()</td><td style="text-align:left">返回一个时间的小时部分</td></tr><tr><td style="text-align:left">Minute()</td><td style="text-align:left">返回一个时间的分钟部分</td></tr><tr><td style="text-align:left">Month()</td><td style="text-align:left">返回一个日期的月份部分</td></tr><tr><td style="text-align:left">Now()</td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left">Second()</td><td style="text-align:left">返回一个时间的秒部分</td></tr><tr><td style="text-align:left">Time()</td><td style="text-align:left">返回一个日期时间的时间部分</td></tr><tr><td style="text-align:left">Year()</td><td style="text-align:left">返回一个日期的年份部分</td></tr><tr><td style="text-align:left">Abs()</td><td style="text-align:left">返回一个数的绝对值</td></tr><tr><td style="text-align:left">Cos()</td><td style="text-align:left">返回一个角度的余弦</td></tr><tr><td style="text-align:left">Exp()</td><td style="text-align:left">返回一个数的指数值</td></tr><tr><td style="text-align:left">Mod()</td><td style="text-align:left">返回除操作的余数</td></tr><tr><td style="text-align:left">Pi()</td><td style="text-align:left">返回圆周率</td></tr><tr><td style="text-align:left">Rand()</td><td style="text-align:left">返回一个随机数</td></tr><tr><td style="text-align:left">Sin()</td><td style="text-align:left">返回一个角度的正弦</td></tr><tr><td style="text-align:left">Sqrt()</td><td style="text-align:left">返回一个数的平方根</td></tr><tr><td style="text-align:left">Tan()</td><td style="text-align:left">返回一个角度的正切</td></tr></tbody></table><blockquote><p>不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。并且总是应该使用4位数字的年份。</p></blockquote><h2 id="第12章-汇总数据">第12章 汇总数据</h2><ol><li><p><strong>聚集函数（aggregate function）</strong> 运行在行组上，计算和返回单个值的函数。</p></li><li><p><strong>AVG()函数</strong> 计算单列的平均值。</p><blockquote><p>AVG()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>COUNT()函数</strong> 进行计数。</p><blockquote><p>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p><p>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最大值。</p><blockquote><p>MAX()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最小值。</p><blockquote><p>MIN()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>SUM()函数</strong> 用来返回指定列值的和（总计）。</p><blockquote><p>SUM()函数忽略列值为NULL的行。</p></blockquote></li><li><p>以上5个聚集函数都可以如下使用：</p><ol><li><p>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</p></li><li><p>只包含不同的值，指定DISTINCT参数。</p><blockquote><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p><p><strong>将DISTINCT用于MIN()和MAX()</strong> 。虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。</p></blockquote></li></ol></li></ol><h2 id="第13章-分组数据">第13章 分组数据</h2><ol><li><p>使用GROUP BY创建分组时需要注意：</p><ol><li><p>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</p></li><li><p>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p></li><li><p>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</p></li><li><p>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p></li><li><p>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p></li><li><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p><blockquote><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。</p></blockquote></li></ol></li><li><p>分组过滤操作HAVING支持所有WHERE操作符。</p><blockquote><p>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。</p></blockquote></li><li><p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。</p></li><li><p>SELECT子句顺序</p></li></ol><table><thead><tr><th style="text-align:left"><strong>子句</strong></th><th style="text-align:left"><strong>说明</strong></th><th style="text-align:left"><strong>是否必须使用</strong></th></tr></thead><tbody><tr><td style="text-align:left">SELECT</td><td style="text-align:left">要返回的列或表达式</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">FROM</td><td style="text-align:left">从中检索数据的表</td><td style="text-align:left">仅在从表选择数据时使用</td></tr><tr><td style="text-align:left">WHERE</td><td style="text-align:left">行级过滤</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">GROUP BY</td><td style="text-align:left">分组说明</td><td style="text-align:left">仅在按组计算聚集时使用</td></tr><tr><td style="text-align:left">HAVING</td><td style="text-align:left">组级过滤</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">ORDER BY</td><td style="text-align:left">输出排序顺序</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">LIMIT</td><td style="text-align:left">要检索的行数</td><td style="text-align:left">否</td></tr></tbody></table><h2 id="第14章-使用子查询">第14章 使用子查询</h2><ol><li>子查询就是可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</li><li>在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</li></ol><h2 id="第15章-连结表">第15章 连结表</h2><ol><li><p><strong>外键（foreign key）</strong> 为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></li><li><p>由没有联结条件的表关系返回的结果为 <strong>笛卡儿积（cartesian product）</strong> 。如下：</p><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure><blockquote><p>有时我们会听到返回称为 <strong>叉联结（cross join）</strong> 的笛卡儿积的联结类型。</p></blockquote></li><li><p><strong>等值联结（equijoin）</strong> 基于两个表之间的相等测试。这种联结也称为 <strong>内部联结</strong> 。下面的SQL都是等值联结：</p><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第16章-创建高级联结">第16章 创建高级联结</h2><ol><li><p>表别名只在查询执行中使用。</p></li><li><p>自联结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id <span class="operator">=</span> p2.vend_id</span><br><span class="line">  <span class="keyword">AND</span> p2.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>自联结远比处理子查询快得多。</p></blockquote></li><li><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。 <strong>自然联结</strong> 排除多次出现，使每个列只返回一次。这一般是通过对表使用通配符（SELECT*），对所有其他表的列使用明确的子集来完成的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.<span class="operator">*</span>, o.order_num, o.order_data, io.prod_id, io.quantity, io.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> io</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line">  <span class="keyword">AND</span> io.order_num <span class="operator">=</span> o.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;FB&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>外部联结在结果中包含了那些在另一个表中没有关联行的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure></li><li><p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN。</p></li></ol><h2 id="第17章-组合查询">第17章 组合查询</h2><ol><li>MySQL允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为 <strong>并（union）</strong> 或 <strong>复合查询（compound query）</strong> 。</li><li>使用UNION规则时需要遵循的规则：<ol><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ol></li><li>UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。这是UNION的默认行为，如果想返回所有匹配行，可使用UNION ALL而不是UNION。</li><li>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</li></ol><h2 id="第18章-全文本搜索">第18章 全文本搜索</h2><ol><li><p>MyISAM支持全文本搜索，InnoDB不支持。</p></li><li><p>为了进行全文本搜索，必须索引被搜索的列。一般在创建表时使用FULLTEXT启用全文本搜索。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id     <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id     <span class="type">CHAR</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_date   DATETIME    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_text   TEXT        <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><blockquote><p>不要在导入数据时使用FULLTEXT。应该首先导入所有数据，然后再修改表，定义FULLTEXT。</p></blockquote></li><li><p>使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;rabbit&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p><p>搜索不区分大小写，除非使用BINARY方式，否则全文本搜索不区分大小写。</p></blockquote></li><li><p>也是使用LIKE子句进行搜索。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> note_text <span class="keyword">LIKE</span> <span class="string">&#x27;%rabbit%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用LIKE子句进行搜索时，不会对结果进行排序。而使用函数Match()和Against()执行全文本搜索时，会对结果进行排序，具有较高等级的行先返回。等级可以通过下面的方式获取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text, <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;rabbit&#x27;</span>) <span class="keyword">AS</span> <span class="string">&#x27;rank&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> productnotes;</span><br></pre></td></tr></table></figure></li><li><p>在使用 <strong>查询扩展</strong> 时，MySQL对数据和索引进行两遍扫描来完成搜索：</p><ol><li><p>进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</p></li><li><p>MySQL检查这些匹配行并选择所有有用的词；</p></li><li><p>MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>即使没有FULLTEXT索引也可以使用 <strong>布尔文本搜索</strong> ，但这是一种非常缓慢的操作。</p><blockquote><p><strong>排列而不排序</strong> 在布尔方式中，不按等级值降序排序返回的</p></blockquote></li><li><p>全文本搜索的使用说明</p><ol><li><p>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</p></li><li><p>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表。</p></li><li><p>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。</p></li><li><p>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</p></li><li><p>忽略词中的单引号。例如，don’t索引为dont。</p></li><li><p>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</p></li><li><p>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;ft%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一些例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;+rabbit +bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit和bait */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;rabbit bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit或bait */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;&quot;rabbit bait&quot;&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配短语&quot;rabbit bait&quot; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;&gt;rabbit &lt;bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit和bait，增加前者的等级，降低后者的等级 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST(<span class="string">&#x27;+rabbit +(&lt;bait)&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE); <span class="comment">/* 匹配词rabbit和bait，降低后者的等级 */</span></span><br></pre></td></tr></table></figure></li><li><p>全文本布尔操作符</p></li></ol><table><thead><tr><th style="text-align:left"><strong>布尔操作符</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">包含，词必须存在</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">排除，词必须不出现</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">包含，而且增加等级值</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">包含，且减少等级值</td></tr><tr><td style="text-align:left">()</td><td style="text-align:left">把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">取消一个词的排序值</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">词尾的通配符</td></tr><tr><td style="text-align:left">“”</td><td style="text-align:left">定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table><h2 id="第19章-插入数据">第19章 插入数据</h2><ol><li><p>如果表的定义允许，则可以在INSERT操作中省略某些列：</p><ol><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ol></li><li><p>可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> LOW_PRIORITY <span class="keyword">INTO</span></span><br></pre></td></tr></table></figure><blockquote><p>同样适用于UPDATE和DELETE。</p></blockquote></li><li><p>一些例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一次插入一条记录 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name, cust_address)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一次插入多条记录 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name, cust_address)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入检索出的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name, cust_address)</span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_address</span><br><span class="line"><span class="keyword">FROM</span> customers_new;</span><br></pre></td></tr></table></figure><blockquote><p>INSERT SELECT中不要求列名匹配。MySQL使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。</p></blockquote></li></ol><h2 id="第20章-更新和删除数据">第20章 更新和删除数据</h2><ol><li><p>如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IGNORE customers</span><br></pre></td></tr></table></figure></li><li><p>如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</p></li></ol><h2 id="第21章-创建和操纵表">第21章 创建和操纵表</h2><ol><li><p>主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p></li><li><p><strong>函数last_insert_id()</strong> 返回最后一个AUTO_INCREMENT值。</p></li><li><p>外键不能跨引擎。</p></li><li><p>一些例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id     <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id     <span class="type">CHAR</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_date   DATETIME    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_text   TEXT        <span class="keyword">NULL</span>,</span><br><span class="line">    update_cnt  <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(note_id, prod_id),</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (order_num)</span><br><span class="line"><span class="keyword">REFERENCES</span> orders (order_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br><span class="line"></span><br><span class="line">RENAME <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> customers;</span><br><span class="line">RENAME <span class="keyword">TABLE</span> customers <span class="keyword">TO</span> customers_backup, vendors <span class="keyword">TO</span> vendors_backup;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第22章-使用视图">第22章 使用视图</h2><ol><li><p>视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremaillist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>视图的规则和限制</p><ol><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。</li></ol></li><li><p>使用视图</p><ol><li>视图用CREATE VIEW语句来创建。</li><li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</li><li>用DROP删除视图，其语法为DROP VIEW viewname。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li></ol></li><li><p>视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p></li><li><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol></li></ol><h2 id="第23章-使用存储过程">第23章 使用存储过程</h2><ol><li><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(<span class="variable">@pricelow</span>, <span class="variable">@pricehigh</span>, <span class="variable">@priceaverage</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters: onumber = order number</span></span><br><span class="line"><span class="comment">--             taxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line"><span class="comment">--             ototal  = order total variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line">    <span class="keyword">IN</span>  onumber <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span>  taxable <span class="type">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">) COMMENT <span class="string">&#x27;Obtain order total, optionally adding tax&#x27;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">--Declare variable for total</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">--Declare tax percentage</span></span><br><span class="line">    <span class="keyword">DECLARE</span> taxrate <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--GET the order total</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Sum</span>(item_price<span class="operator">*</span>quantity)</span><br><span class="line">    <span class="keyword">FROM</span> orderitems</span><br><span class="line">    <span class="keyword">WHERE</span> order_num <span class="operator">=</span> onumber</span><br><span class="line">    <span class="keyword">INTO</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--Is this taxable</span></span><br><span class="line">    IF taxable <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SELECT</span> total<span class="operator">+</span>(total<span class="operator">/</span><span class="number">100</span><span class="operator">*</span>taxrate) <span class="keyword">INTO</span> total;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><blockquote><p>COMMENT的值会在<code>SHOW PROCEDURE STATUS</code>时显示出来。</p></blockquote></li><li><p>删除存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure></li><li><p>检查存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure><blockquote><p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS</code> 或<code>SHOW PROCEDURE STATUS LIKE 'ordertotal'</code>。</p></blockquote></li><li><p>使用mysql命令行实用程序时需要注意：</p><p>默认的MySQL语句分隔符为<code>;</code> mysql命令行实用程序也使用<code>;</code>作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。<br>解决办法是临时更改命令行实用程序的语句分隔符，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><blockquote><p>除<code>\</code>符号外，任何字符都可以用作语句分隔符。</p></blockquote></li></ol><h2 id="第25章-使用触发器">第25章 使用触发器</h2><ol><li><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于 BEGIN 和 END 语句之间的一组语 句）：</p><ol><li>DELETE；</li><li>INSERT；</li><li>UPDATE。</li></ol></li><li><p>在创建触发器时，需要给出4条信息：</p><ol><li><p>唯一的触发器名；</p></li><li><p>触发器关联的表；</p></li><li><p>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</p></li><li><p>触发器何时执行（处理之前或之后）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> products</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> <span class="string">&#x27;Product added&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>只有表才支持触发器，视图不支持（临时表也不支持）。</p></blockquote></li></ol></li><li><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后）。</p><blockquote><p>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL 将不执行AFTER触发器（如果有的话）。</p></blockquote></li><li><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure><blockquote><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p></blockquote></li><li><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><ol><li><p>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</p></li><li><p>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</p></li><li><p>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.order_new;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p><ol><li><p>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</p></li><li><p>OLD中的值全都是只读的，不能更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num, order_date, cust_id)</span><br><span class="line">    <span class="keyword">VALUE</span>(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p><ol><li><p>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</p></li><li><p>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p></li><li><p>OLD中的值全都是只读的，不能更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updatevendor</span><br><span class="line">BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> vendors</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SET</span> NEW.vend_state <span class="operator">=</span> <span class="built_in">UPPER</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。</p></li></ol><h2 id="第26章-管理事务处理">第26章 管理事务处理</h2><ol><li><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p><blockquote><p>MyISAM和InnoDB是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。</p></blockquote></li><li><p>相关术语：</p><ol><li><strong>事务（transaction）</strong> 指一组SQL语句；</li><li><strong>回退（rollback）</strong> 指撤销指定SQL语句的过程；</li><li><strong>提交（commit）</strong> 指将未存储的SQL语句结果写入数据库表；</li><li><strong>保留点（ savepoint ）</strong> 指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol></li><li><p>开始事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure></li><li><p>回退事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure><blockquote><p>事务处理用来管理INSERT、UPDATE和DELETE语句。你不能回退SELECT语句，也 <strong>不能回退CREATE或DROP操作</strong> 。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p></blockquote></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p></blockquote></li><li><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置保留点。这样，如果需要回退，可以回退到某个保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> delete1; <span class="comment">/* 创建保留点 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1; <span class="comment">/* 回退到保留点 */</span></span><br></pre></td></tr></table></figure><blockquote><p>保留点越多，就越能按自己的意愿灵活地进行回退，所以保留点越多越好。</p><p>保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。也可以用RELEASE SAVEPOINT明确地释放保留点。</p></blockquote></li><li><p>默认的MySQL行为是自动提交所有更改。可以关闭：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>autocommit标志决定是否自动提交更改，不管有没有COMMIT 语句。设置autocommit为0（假）指示MySQL不自动提交更改 （直到autocommit被设置为真为止）。</p><p>autocommit标志是针对每个连接而不是服务器的。</p></blockquote></li></ol><h2 id="第27章-全球化和本地化">第27章 全球化和本地化</h2><ol><li><p>重要术语：</p><ol><li><strong>字符集</strong> 为字母和符号的集合；</li><li><strong>编码</strong> 为某个字符集成员的内部表示；</li><li><strong>校对</strong> 为规定字符如何比较的指令。</li></ol></li><li><p>查看所支持的字符集完整列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看所支持校对的完整列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br></pre></td></tr></table></figure><blockquote><p>许多校对出现两次，一次区分大小写（由_cs表一次不区分大小写（由_ci表示）。</p></blockquote></li><li><p>通常系统管理在安装时定义一个默认的字符集和校对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>可以在创建数据库时，指定默认的字符集和校对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line">  <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>一般，MySQL如下确定使用什么样的字符集和校对：</p><ol><li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li><li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。</li><li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</li></ol></li><li><p>MySQL还允许对每个列设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line">  <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> lastname, firstname <span class="keyword">COLLATE</span> latin1_general_cs;</span><br></pre></td></tr></table></figure><blockquote><p>除了ORDER BY子句，COLLATE还可以用于GROUP BY、HAVING、聚集函数、别名等。</p></blockquote></li><li><p>如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。</p></li></ol><h2 id="第28章-安全管理">第28章 安全管理</h2><ol><li><p>创建用户账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ben IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>重命名用户账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> ben <span class="keyword">TO</span> kom;</span><br></pre></td></tr></table></figure></li><li><p>删除用户账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> kom;</span><br></pre></td></tr></table></figure></li><li><p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。查看用户账号权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> kom;</span><br></pre></td></tr></table></figure><blockquote><p><strong>用户定义为user@host。</strong> MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。</p></blockquote></li><li><p>为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息：</p><ol><li><p>要授予的权限；</p></li><li><p>被授予访问权限的数据库或表；</p></li><li><p>用户名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.<span class="operator">*</span> <span class="keyword">TO</span> kom;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>撤销特定的权限使用REVOKE：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.<span class="operator">*</span> <span class="keyword">FROM</span> kom;</span><br></pre></td></tr></table></figure></li><li><p>GRANT和REVOKE可在几个层次上控制访问权限：</p><ol><li>整个服务器，使用GRANT ALL和REVOKE ALL；</li><li>整个数据库，使用ON database.*；</li><li>特定的表，使用ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ol></li><li><p>更改密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> kom <span class="operator">=</span> PASSWORD(<span class="string">&#x27;456&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不指定用户名时，SET PASSWORD更新当前登录用户的口令。<code>SET PASSWORD = PASSWORD('789')</code></p></blockquote></li><li><p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。</p></li><li><p>可通过列出各权限并用逗号分隔， 将多条GRANT语句串在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON crashcourse.* TO kom</span><br></pre></td></tr></table></figure></li><li><p>权限列表</p></li></ol><table><thead><tr><th style="text-align:left"><strong>权限</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">ALL</td><td style="text-align:left">除GRANT OPTION外的所有权限</td></tr><tr><td style="text-align:left">ALTER</td><td style="text-align:left">使用ALTER TABLE</td></tr><tr><td style="text-align:left">ALTER ROUTINE</td><td style="text-align:left">使用ALTER PROCEDURE和DROP PROCEDURE</td></tr><tr><td style="text-align:left">CREATE</td><td style="text-align:left">使用CREATE TABLE</td></tr><tr><td style="text-align:left">CREATE ROUTINE</td><td style="text-align:left">使用CREATE PROCEDURE</td></tr><tr><td style="text-align:left">CREATE TEMPORARY TABLES</td><td style="text-align:left">使用CREATE TEMPORARY TABLE</td></tr><tr><td style="text-align:left">CREATE USER</td><td style="text-align:left">使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td></tr><tr><td style="text-align:left">CREATE VIEW</td><td style="text-align:left">使用CREATE VIEW</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">使用DELETE</td></tr><tr><td style="text-align:left">DROP</td><td style="text-align:left">使用DROP TABLE</td></tr><tr><td style="text-align:left">EXECUTE</td><td style="text-align:left">使用CALL和存储过程</td></tr><tr><td style="text-align:left">FILE</td><td style="text-align:left">使用SELECT INTO OUTFILE和LOAD DATA INFILE</td></tr><tr><td style="text-align:left">GRANT OPTION</td><td style="text-align:left">使用GRANT和REVOKE</td></tr><tr><td style="text-align:left">INDEX</td><td style="text-align:left">使用CREATE INDEX和DROP INDEX</td></tr><tr><td style="text-align:left">INSERT</td><td style="text-align:left">使用INSERT</td></tr><tr><td style="text-align:left">LOCK TABLES</td><td style="text-align:left">使用LOCK TABLES</td></tr><tr><td style="text-align:left">PROCESS</td><td style="text-align:left">使用SHOW FULL PROCESSLIST</td></tr><tr><td style="text-align:left">RELOAD</td><td style="text-align:left">使用FLUSH</td></tr><tr><td style="text-align:left">REPLICATION CLIENT</td><td style="text-align:left">服务器位置的访问</td></tr><tr><td style="text-align:left">REPLICATION SLAVE</td><td style="text-align:left">由复制从属使用</td></tr><tr><td style="text-align:left">SELECT</td><td style="text-align:left">使用SELECT</td></tr><tr><td style="text-align:left">SHOW DATABASES</td><td style="text-align:left">使用SHOW DATABASES</td></tr><tr><td style="text-align:left">SHOW VIEW</td><td style="text-align:left">使用SHOW CREATE VIEW</td></tr><tr><td style="text-align:left">SHUTDOWN</td><td style="text-align:left">使用mysqladmin shutdown（用来关闭MySQL）</td></tr><tr><td style="text-align:left">SUPER</td><td style="text-align:left">使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录</td></tr><tr><td style="text-align:left">UPDATE</td><td style="text-align:left">使用UPDATE</td></tr><tr><td style="text-align:left">USAGE</td><td style="text-align:left">无访问权限</td></tr></tbody></table><h2 id="第29章-数据库维护">第29章 数据库维护</h2><ol><li><p>备份数据</p><ol><li><p>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</p></li><li><p>可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。</p></li><li><p>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。</p><blockquote><p>为了保证所有数据被写到磁盘（包括索引数据）可能需要在进行备份前使用FLUSH TABLES语句。</p></blockquote></li></ol></li><li><p>进行数据库维护</p><ol><li><p>检查表键是否正确</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> orders;</span><br></pre></td></tr></table></figure></li><li><p>CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> orders, orderitems FAST QUICK;</span><br></pre></td></tr></table></figure><blockquote><p>如果 MyISAM 表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</p><p>如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。</p></blockquote></li></ol></li></ol><h2 id="第30章-改善性能">第30章 改善性能</h2><ol><li>可使用<code>SHOW PROCESSLIST</code> 显示所有活动进程（以及它们的线程ID和执行时间）。可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li><li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。</li><li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li></ol>]]></content>
    
    
    <summary type="html">《MySQL必知必会》</summary>
    
    
    
    <category term="MySQL" scheme="https://penge666.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://penge666.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>epoll原理</title>
    <link href="https://penge666.github.io/posts/808ecc04.html"/>
    <id>https://penge666.github.io/posts/808ecc04.html</id>
    <published>2024-06-26T09:04:09.000Z</published>
    <updated>2024-06-26T09:13:07.874Z</updated>
    
    <content type="html"><![CDATA[<p>文章会从网卡接收数据的流程讲起，串联起 CPU 中断、操作系统进程调度等知识；再一步步分析阻塞接收数据、select 到 epoll 的进化过程，最后探究 epoll 的实现细节。</p><h2 id="一、从网卡接收数据说起"><a href="#一、从网卡接收数据说起" class="headerlink" title="一、从网卡接收数据说起"></a>一、从网卡接收数据说起</h2><p>下边是一个典型的计算机结构图，计算机由 CPU、存储器（内存）与网络接口等部件组成，了解 epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170512773.png" alt="image-20240626170512773"></p><p>下图展示了网卡接收数据的过程：</p><ul><li>在 1 阶段，网卡收到网线传来的数据。</li><li>经过 2 阶段的硬件电路的传输。</li><li>最终 3 阶段将数据写入到内存中的某个地址上。</li></ul><p>这个过程涉及到 DMA 传输、IO 通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170546354.png" alt="image-20240626170546354"></p><p>通过硬件传输，网卡接收的数据存放到内存中，操作系统就可以去读取它们。</p><h2 id="二、如何知道接收了数据"><a href="#二、如何知道接收了数据" class="headerlink" title="二、如何知道接收了数据"></a>二、如何知道接收了数据</h2><p>了解 epoll 本质的第二步，要从 CPU 的角度来看数据接收。理解这个问题，要先了解一个概念：中断。</p><p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时，它应立即去保存数据，保存数据的程序具有较高的优先级（电容可以保存少许电量，供 CPU 运行很短的一小段时间）。</p><p>一般而言，由硬件产生的信号需要 CPU 立马做出回应，不然数据可能就丢失了，所以它的优先级很高。</p><p>CPU 理应中断掉正在执行的程序，去做出响应，当 CPU 完成对硬件的响应后，再重新执行用户程序。</p><p>中断的过程如下图，它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170632344.png" alt="image-20240626170632344"></p><p>以键盘为例，当用户按下键盘某个按键时，键盘会给 CPU 的中断引脚发出一个高电平，CPU 能够捕获这个信号，然后执行键盘中断程序。</p><p>下图展示了各种硬件通过中断与 CPU 交互的过程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170650962.png" alt="image-20240626170650962"></p><p>现在可以回答“如何知道接收了数据？”这个问题了：当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><h2 id="三、进程阻塞为什么不占用-CPU-资源"><a href="#三、进程阻塞为什么不占用-CPU-资源" class="headerlink" title="三、进程阻塞为什么不占用 CPU 资源"></a><strong>三、进程阻塞为什么不占用 CPU 资源</strong></h2><p>了解 epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法。</p><p>下边分析一下进程阻塞为什么不占用 CPU 资源？为简单起见，我们从普通的 recv 接收开始分析，先看看下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 socket</span></span><br><span class="line"><span class="type">int</span> s =socket（AF_INET， SOCK_STREAM， <span class="number">0</span>）; </span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line">bind（s， ...）</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">listen（s， ...）</span><br><span class="line"><span class="comment">//接受客户端连接</span></span><br><span class="line"><span class="type">int</span> c = accept（s， ...）</span><br><span class="line"><span class="comment">//接收客户端数据</span></span><br><span class="line">recv（c， ...）; </span><br><span class="line"><span class="comment">//将数据打印出来</span></span><br><span class="line">printf（...）</span><br></pre></td></tr></table></figure><p>这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen 与 accept，最后调用 recv 接收数据。</p><p>recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。那么阻塞的原理是什么？</p><h2 id="四、工作队列"><a href="#四、工作队列" class="headerlink" title="四、工作队列"></a><strong>四、工作队列</strong></h2><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。</p><p>运行状态是进程获得 CPU 使用权，正在执行代码的状态;等待状态是阻塞状态，比如上述程序运行到recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。</p><p>操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>下图的计算机中运行着 A、B 与 C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170751776.png" alt="image-20240626170751776"></p><h2 id="五、等待队列"><a href="#五、等待队列" class="headerlink" title="五、等待队列"></a><strong>五、等待队列</strong></h2><p>当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象（如下图）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170810525.png" alt="image-20240626170810525"></p><p>这个 socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程。</p><p>当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中（如下图）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170835637.png" alt="image-20240626170835637"></p><p>由于工作队列只剩下了进程 B 和 C，依据进程调度，CPU 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 CPU 资源。</p><p>注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程</p><p>对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p><h2 id="六、唤醒进程"><a href="#六、唤醒进程" class="headerlink" title="六、唤醒进程"></a><strong>六、唤醒进程</strong></h2><p>当 socket 接收到数据后，操作系统将该 socket 等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。</p><p>同时由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</p><h2 id="七、内核接收网络数据全过程"><a href="#七、内核接收网络数据全过程" class="headerlink" title="七、内核接收网络数据全过程"></a>七、内核接收网络数据全过程</h2><p>这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞 recv 下内核接收数据的全过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170918164.png" alt="image-20240626170918164"></p><p>如上图所示，进程在 recv 阻塞期间：</p><ul><li><p>计算机收到了对端传送的数据（步骤 ①）</p></li><li><p>数据经由网卡传送到内存（步骤 ②）</p></li><li><p>然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序（步骤 ③）</p></li></ul><p>此处的中断程序主要有两项功能，先将网络数据写入到对应 socket 的接收缓冲区里面（步骤 ④），</p><p>再唤醒进程 A（步骤 ⑤），重新将进程 A 放入工作队列中。</p><p>唤醒进程的过程如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626170937542.png" alt="image-20240626170937542"></p><p>以上是内核接收数据全过程，这里我们可能会思考两个问题：</p><ul><li><p>操作系统如何知道网络数据对应于哪个 socket？</p></li><li><p>如何同时监视多个 socket 的数据？</p></li></ul><p>第一个问题：因为一个 socket 对应着一个端口号，而网络数据包中包含了 IP 和端口的信息，内核可以通过端口号找到对应的 socket。</p><p>当然，为了提高处理速度，操作系统会维护端口号到 socket 的索引结构，以快速读取。</p><p>第二个问题是多路复用的重中之重，也正是本文后半部分的重点。</p><h2 id="八、同时监视多个-socket-的简单方法"><a href="#八、同时监视多个-socket-的简单方法" class="headerlink" title="八、同时监视多个 socket 的简单方法"></a><strong>八、同时监视多个 socket 的简单方法</strong></h2><p>服务端需要管理多个客户端连接，而 recv 只能监视单个 socket，这种矛盾下，人们开始寻找监视多个 socket 的方法。epoll 的要义就是高效地监视多个 socket。</p><p>从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进，正如 select 之于 epoll。先理解不太高效的 select，才能够更好地理解 epoll 的本质。</p><p>假如能够预先传入一个 socket 列表，如果列表中的 socket 都没有数据，挂起进程，直到有一个 socket收到数据，唤醒进程。这种方法很直接，也是 select 的设计思想。</p><p>为方便理解，我们先复习 select 的用法。在下边的代码中，先准备一个数组 FDS，让 FDS 存放着所有需要监视的 socket。</p><p>然后调用 select，如果 FDS 中的所有 socket 都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select 返回，唤醒进程。</p><p>用户可以遍历 FDS，通过 FD_ISSET 判断具体哪个 socket 收到数据，然后做出处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s =socket（AF_INET， SOCK_STREAM， <span class="number">0</span>）; </span><br><span class="line">bind（s， ...）</span><br><span class="line">listen（s， ...）</span><br><span class="line"><span class="type">int</span> fds[] = 存放需要监听的 socket</span><br><span class="line"><span class="keyword">while</span>（<span class="number">1</span>）&#123; </span><br><span class="line"> <span class="type">int</span> n = select（...， fds， ...）</span><br><span class="line"> <span class="keyword">for</span>（<span class="type">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++）&#123; </span><br><span class="line"> <span class="keyword">if</span>（FD_ISSET（fds[i]， ...））&#123; </span><br><span class="line"> <span class="comment">//fds[i]的数据处理</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、select-的流程"><a href="#九、select-的流程" class="headerlink" title="九、select 的流程"></a><strong>九、select 的流程</strong></h2><p>select 的实现思路很直接，假如程序同时监视如下图的 sock1、sock2 和 sock3 三个 socket，那</p><p>么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。</p><p>当任何一个 socket 收到数据后，中断程序将唤起进程。下图展示了 sock2 接收到了数据的处理流程：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171047235.png" alt="image-20240626171047235"></p><p>注：recv 和 relect 的中断回调可以设置成不同的内容。</p><p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171100759.png" alt="image-20240626171100759"></p><p>经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket列表，就可以得到就绪的 socket。</p><p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p><ul><li><p>每次调用 select 都需要将进程加入到所有监视 socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 FDS 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024个 socket。</p></li><li><p>进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。</p></li></ul><p>那么，有没有减少遍历的方法？有没有保存就绪 socket 的方法？这两个问题便是 epoll 技术要解决的。</p><p>补充说明：本节只解释了 select 的一种情形。当程序调用 select 时，内核会先遍历一遍 socket，</p><p>如果有一个以上的 socket 接收缓冲区有数据，那么 select 直接返回，不会阻塞。</p><p>这也是为什么 select 的返回值有可能大于 1 的原因之一。如果没有 socket 有数据，进程才会阻塞。</p><h2 id="十、epoll-的设计思路"><a href="#十、epoll-的设计思路" class="headerlink" title="十、epoll 的设计思路"></a><strong>十、epoll 的设计思路</strong></h2><p>epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll（poll 和 select 基本一样，有少</p><p>量改进）的增强版本。epoll 通过以下一些措施来改进效率：</p><p><strong>1、措施一：功能分离</strong></p><p>select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171131861.png" alt="image-20240626171131861"></p><p>如上图所示，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。</p><p>epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见，效率就能得到提升。</p><p>为方便理解后续的内容，我们先了解一下 epoll 的用法。如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s =socket（AF_INET， SOCK_STREAM， <span class="number">0</span>）; </span><br><span class="line"></span><br><span class="line">bind（s， ...）</span><br><span class="line"></span><br><span class="line">listen（s， ...）</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd =epoll_create（...）; </span><br><span class="line"></span><br><span class="line">epoll_ctl（epfd， ...）; <span class="comment">//将所有需要监听的 socket 添加到 epfd 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>（<span class="number">1</span>）&#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n =epoll_wait（...）</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>（接收到数据的 socket）&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//处理</span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>功能分离，使得 epoll 有了优化的可能。</p><p><strong>2、措施二：就绪列表</strong></p><p>select 低效的另一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171211493.png" alt="image-20240626171211493"></p><p>如上图所示，计算机共有三个 socket，收到数据的 sock2 和 sock3 被就绪列表 rdlist 所引用。</p><p>当进程被唤醒后，只要获取 rdlist 的内容，就能够知道哪些 socket 收到数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240626171243774.png" alt="image-20240626171243774"></p>]]></content>
    
    
    <summary type="html">epoll原理学习</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络攻击</title>
    <link href="https://penge666.github.io/posts/a9bd00d7.html"/>
    <id>https://penge666.github.io/posts/a9bd00d7.html</id>
    <published>2024-06-23T16:04:43.000Z</published>
    <updated>2024-07-03T16:15:57.055Z</updated>
    
    <content type="html"><![CDATA[<p>对常见的网络攻击有个基本的了解！</p><h2 id="DOS-DDOS攻击">DOS/DDOS攻击</h2><p>DOS（Denial of Service）和DDOS（Distributed Denial of Service）攻击是网络攻击的一种，旨在通过耗尽目标系统的资源（如带宽、CPU、内存等）使其无法正常提供服务。下面举例说明这两种攻击的具体形式和工作原理。</p><h3 id="DOS攻击">DOS攻击</h3><h4 id="示例：Ping-Flood攻击">示例：Ping Flood攻击</h4><p><strong>Ping Flood攻击</strong>是一种常见的DOS攻击，通过向目标系统发送大量的ICMP Echo请求（即Ping请求）来耗尽目标的带宽和处理能力，使其无法正常响应合法的请求。</p><h4 id="工作原理：">工作原理：</h4><ol><li><strong>攻击者</strong>向目标服务器发送大量的Ping请求。</li><li><strong>目标服务器</strong>接收到Ping请求后，需要处理并回复每一个请求。</li><li><strong>大量的请求</strong>使得目标服务器的带宽和CPU资源被大量占用，最终导致服务器无法处理正常的业务请求，服务中断。</li></ol><h4 id="示例操作：">示例操作：</h4><p>假设攻击者使用命令行工具进行Ping Flood攻击：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ping</span> -f -s <span class="number">65500</span> target_ip</span><br></pre></td></tr></table></figure><ul><li><code>-f</code>选项表示快速Ping（在Linux中）。</li><li><code>-s 65500</code>表示发送65500字节的数据包。</li></ul><h3 id="DDOS攻击">DDOS攻击</h3><h4 id="示例：Botnet攻击">示例：Botnet攻击</h4><p><strong>Botnet攻击</strong>是一种常见的DDOS攻击，攻击者通过控制大量的被感染设备（称为僵尸网络，Botnet），同时向目标系统发起攻击，使得目标系统无法处理所有请求，导致服务中断。</p><h4 id="工作原理：-2">工作原理：</h4><ol><li><strong>攻击者</strong>通过恶意软件感染大量的设备（如计算机、物联网设备等），形成一个僵尸网络。</li><li><strong>攻击者</strong>控制僵尸网络中的设备，同时向目标服务器发送大量请求。</li><li><strong>目标服务器</strong>由于同时处理来自多个来源的海量请求，导致资源耗尽，无法正常提供服务。</li></ol><h4 id="示例操作：-2">示例操作：</h4><p>假设攻击者使用一个僵尸网络发起HTTP Flood攻击：</p><ol><li><strong>攻击者</strong>控制僵尸网络中的每个设备运行以下脚本：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标URL</span></span><br><span class="line">url = <span class="string">&quot;http://target_website.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟大量请求</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(response.status_code)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ol><li><strong>僵尸网络</strong>中的每个设备同时运行该脚本，向目标服务器发送大量的HTTP请求。</li></ol><h3 id="区别和防护">区别和防护</h3><h4 id="DOS和DDOS的区别：">DOS和DDOS的区别：</h4><ul><li><strong>DOS攻击</strong>：通常由单一来源发起，攻击规模相对较小。</li><li><strong>DDOS攻击</strong>：由分布在多个地理位置的多个来源发起，攻击规模较大，难以防御。</li></ul><h4 id="防护措施：">防护措施：</h4><ol><li><strong>网络防火墙和入侵检测系统</strong>：可以监控并过滤异常流量。</li><li><strong>流量清洗服务</strong>：一些专门的安全公司提供流量清洗服务，能够在攻击发生时清洗掉恶意流量。</li><li><strong>限流和速率限制</strong>：在服务器上设置请求限流和速率限制，防止单个IP发送过多请求。</li><li><strong>内容分发网络（CDN）</strong>：通过使用CDN将流量分散到多个节点，减少单一服务器的压力。</li><li><strong>IP黑名单</strong>：将可疑的IP地址加入黑名单，阻止其访问。</li></ol><p>通过以上示例和防护措施，可以更好地理解DOS和DDOS攻击的原理及其防御方法。</p><h2 id="Man-in-the-Middle攻击">Man-in-the-Middle攻击</h2><p>Man-in-the-Middle（MITM）攻击是一种网络攻击方式，攻击者通过在通信双方之间插入自己，窃取、篡改或伪造双方的通信数据，而通信双方通常并不知道有第三方存在。以下是MITM攻击的详细说明及示例：</p><h3 id="工作原理">工作原理</h3><ol><li><strong>拦截通信</strong>：攻击者在通信双方（如客户端和服务器）之间插入自己，通常通过网络监听、ARP欺骗、DNS欺骗等方式实现。</li><li><strong>伪装身份</strong>：攻击者伪装成通信的另一方，向双方发送和接收消息。客户端认为自己在与服务器通信，而服务器认为自己在与客户端通信。</li><li><strong>窃取和篡改数据</strong>：攻击者可以在传输过程中窃取敏感信息（如密码、信用卡号等），或篡改数据（如修改交易金额等）。</li></ol><h3 id="示例">示例</h3><h4 id="示例1：HTTP通信中的MITM攻击">示例1：HTTP通信中的MITM攻击</h4><p>假设用户正在使用公共Wi-Fi网络访问一个未加密的HTTP网站，攻击者可以通过以下方式进行MITM攻击：</p><ol><li><p><strong>ARP欺骗</strong>：攻击者向网络中的设备发送伪造的ARP消息，将攻击者的MAC地址绑定到网关的IP地址上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i wlan0 -t <span class="tag">&lt;<span class="name">victim_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">gateway_ip</span>&gt;</span></span><br><span class="line">arpspoof -i wlan0 -t <span class="tag">&lt;<span class="name">gateway_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">victim_ip</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>流量拦截和篡改</strong>：攻击者使用流量分析工具（如Wireshark）拦截HTTP流量，窃取敏感信息，或使用代理工具（如Burp Suite）修改传输的数据。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mitmproxy</span> -p <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><p><strong>伪装身份</strong>：攻击者将自己伪装成合法的服务器和客户端，将拦截到的请求和响应转发给各自的目标，同时进行窃取或篡改。</p></li></ol><h4 id="示例2：DNS欺骗中的MITM攻击">示例2：DNS欺骗中的MITM攻击</h4><p>攻击者通过DNS欺骗将用户重定向到恶意网站：</p><ol><li><p><strong>DNS欺骗</strong>：攻击者向受害者发送伪造的DNS响应，将某个域名解析到攻击者控制的IP地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnsspoof -<span class="selector-tag">i</span> wlan0 -f hosts<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p><code>hosts.txt</code>内容示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168.1.100</span>  example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>伪装网站</strong>：攻击者在自己的服务器上托管一个与目标网站相同的页面，用户在访问example.com时被重定向到攻击者的服务器，并在不知情的情况下输入敏感信息。</p></li></ol><h3 id="防护措施">防护措施</h3><ol><li><strong>使用HTTPS</strong>：HTTPS加密通信可以防止攻击者窃取和篡改数据。确保网站和应用程序使用HTTPS协议。</li><li><strong>证书验证</strong>：客户端应验证服务器的SSL/TLS证书，防止与伪造的服务器通信。</li><li><strong>强认证机制</strong>：使用双因素认证（2FA）等强认证机制，提高账户安全性。</li><li><strong>安全Wi-Fi网络</strong>：避免在不安全的公共Wi-Fi网络上进行敏感操作，或使用VPN加密流量。</li><li><strong>网络监控和检测</strong>：部署入侵检测系统（IDS）和网络监控工具，检测异常活动和潜在攻击。</li><li><strong>DNSSEC</strong>：使用DNS安全扩展（DNSSEC）来验证DNS响应的真实性，防止DNS欺骗。</li></ol><h3 id="总结">总结</h3><p>Man-in-the-Middle攻击通过拦截和篡改通信双方的数据，窃取敏感信息或进行其他恶意操作。了解其工作原理和实施方式，以及采取有效的防护措施，可以显著提高网络通信的安全性。</p><h2 id="Phishing攻击">Phishing攻击</h2><p><strong>Phishing攻击</strong>是一种常见的网络攻击方式，攻击者通过伪装成合法的实体（如银行、在线服务提供商等）诱骗用户提供敏感信息，如用户名、密码、信用卡号等。Phishing攻击主要依赖于社会工程学和伪造的电子邮件、网站、短信等手段来实施。以下是Phishing攻击的详细说明及示例：</p><h3 id="工作原理-2">工作原理</h3><ol><li><strong>伪装身份</strong>：攻击者伪装成合法的机构或个人，发送电子邮件、短信或创建伪造的网站。</li><li><strong>诱骗用户</strong>：通过各种手段（如紧急警告、诱人的优惠等）诱使用户点击链接或提供敏感信息。</li><li><strong>收集信息</strong>：用户提供的信息被攻击者收集并用于非法活动，如身份盗用、金融欺诈等。</li></ol><h3 id="示例-2">示例</h3><h4 id="示例1：电子邮件Phishing攻击">示例1：电子邮件Phishing攻击</h4><p>攻击者通过发送伪造的电子邮件，诱骗用户点击恶意链接或提供敏感信息。</p><ol><li><p><strong>伪造电子邮件</strong>：</p><ul><li>电子邮件看起来来自合法机构（如银行、在线服务提供商等）。</li><li>内容通常包含紧急通知或诱人的优惠，要求用户立即采取行动。</li></ul><p>示例电子邮件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span>: support<span class="variable">@bank</span>.com</span><br><span class="line"><span class="keyword">To</span>: <span class="keyword">user</span><span class="variable">@example</span>.com</span><br><span class="line">Subject: Urgent: <span class="keyword">Update</span> Your Account Information</span><br><span class="line"></span><br><span class="line">Dear Customer,</span><br><span class="line"></span><br><span class="line">We have detected unusual activity <span class="keyword">on</span> your account. Please <span class="keyword">update</span> your account information immediately <span class="keyword">by</span> clicking the link below:</span><br><span class="line"></span><br><span class="line">[<span class="keyword">Update</span> Account Information](http:<span class="operator">/</span><span class="operator">/</span>fakebank.com<span class="operator">/</span><span class="keyword">update</span>)</span><br><span class="line"></span><br><span class="line">Failure <span class="keyword">to</span> <span class="keyword">update</span> your information may <span class="keyword">result</span> <span class="keyword">in</span> account suspension.</span><br><span class="line"></span><br><span class="line">Best regards,</span><br><span class="line">Bank Support Team</span><br></pre></td></tr></table></figure></li><li><p><strong>诱骗用户</strong>：</p><ul><li>用户点击链接后，会被重定向到一个伪造的银行登录页面。</li><li>页面设计与银行官方网站非常相似，诱使用户输入用户名和密码。</li></ul></li><li><p><strong>收集信息</strong>：</p><ul><li>用户输入的敏感信息被攻击者收集，用于非法活动。</li></ul></li></ol><h4 id="示例2：短信Phishing攻击（Smishing）">示例2：短信Phishing攻击（Smishing）</h4><p>攻击者通过发送伪造的短信，诱骗用户点击恶意链接或提供敏感信息。</p><ol><li><p><strong>伪造短信</strong>：</p><ul><li>短信看起来来自合法机构（如银行、快递公司等）。</li><li>内容通常包含紧急通知或诱人的优惠，要求用户立即采取行动。</li></ul><p>示例短信：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">From: BankAlert</span><br><span class="line"><span class="keyword">To</span>: +<span class="number">1234567890</span></span><br><span class="line"><span class="keyword">Message</span>: </span><br><span class="line">[Bank] We have detected suspicious activity <span class="keyword">on</span> your account. Please verify your identity immediately: http:<span class="comment">//fakebank.com/verify</span></span><br></pre></td></tr></table></figure></li><li><p><strong>诱骗用户</strong>：</p><ul><li>用户点击链接后，会被重定向到一个伪造的银行验证页面。</li><li>页面设计与银行官方网站非常相似，诱使用户输入用户名、密码和其他个人信息。</li></ul></li><li><p><strong>收集信息</strong>：</p><ul><li>用户输入的敏感信息被攻击者收集，用于非法活动。</li></ul></li></ol><h3 id="防护措施-2">防护措施</h3><ol><li><strong>注意电子邮件和短信的来源</strong>：<ul><li>检查发件人的电子邮件地址和短信号码。</li><li>谨慎对待不明来源的邮件和短信，尤其是包含链接或附件的。</li></ul></li><li><strong>不随意点击链接</strong>：<ul><li>在点击电子邮件或短信中的链接前，悬停在链接上查看实际网址。</li><li>直接访问官方网站，而不是通过邮件或短信中的链接。</li></ul></li><li><strong>双因素认证（2FA）</strong>：<ul><li>启用双因素认证，增加额外的安全层，防止未经授权的访问。</li></ul></li><li><strong>使用防钓鱼软件</strong>：<ul><li>安装和使用防钓鱼工具和浏览器扩展，检测和阻止钓鱼网站。</li></ul></li><li><strong>定期更新密码</strong>：<ul><li>定期更改账户密码，使用强密码，并避免重复使用密码。</li></ul></li><li><strong>教育和意识</strong>：<ul><li>提高员工和用户的安全意识，定期进行安全培训，教导如何识别和应对钓鱼攻击。</li></ul></li></ol><h3 id="总结-2">总结</h3><p>Phishing攻击通过伪装和社会工程学手段，诱骗用户提供敏感信息。了解其工作原理和常见手段，并采取有效的防护措施，可以显著降低成为Phishing攻击受害者的风险。</p><h2 id="SQL注入">SQL注入</h2><p>SQL注入（SQL Injection）攻击是一种常见的网络攻击方式，攻击者通过在输入字段中插入恶意的SQL代码，使得后台数据库执行未经授权的SQL查询，从而获取、修改或删除数据库中的数据。以下是SQL注入攻击的详细说明及示例：</p><h3 id="工作原理-3">工作原理</h3><ol><li><strong>用户输入</strong>：攻击者在应用程序的输入字段（如登录表单、搜索框等）中输入恶意的SQL代码。</li><li><strong>未处理的输入</strong>：应用程序将用户输入直接插入到SQL查询中，未进行充分的验证或转义。</li><li><strong>执行恶意查询</strong>：数据库服务器执行构造后的SQL查询，导致数据库中的数据泄露、篡改或删除。</li></ol><h3 id="示例-3">示例</h3><p>假设有一个网站登录表单，用户输入用户名和密码后，后台会生成并执行一个SQL查询来验证用户身份。</p><h4 id="原始代码示例">原始代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户输入的用户名和密码</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;Enter your username: &quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;Enter your password: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造SQL查询</span></span><br><span class="line">query = <span class="string">f&quot;SELECT * FROM users WHERE username = &#x27;<span class="subst">&#123;username&#125;</span>&#x27; AND password = &#x27;<span class="subst">&#123;password&#125;</span>&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行SQL查询</span></span><br><span class="line">cursor.execute(query)</span><br><span class="line">result = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查查询结果</span></span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Login successful&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid username or password&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="攻击示例">攻击示例</h4><p>攻击者在用户名字段中输入<code>' OR '1'='1</code>，在密码字段中输入任意值，如<code>' OR '1'='1</code>。</p><p>构造后的SQL查询如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username = <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> <span class="keyword">password</span> = <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个查询始终为真，因为<code>'1'='1'</code>永远为真，导致数据库返回所有用户的数据，攻击者可以绕过身份验证。</p><h3 id="防护措施-3">防护措施</h3><ol><li><p><strong>使用参数化查询</strong>：参数化查询将用户输入与SQL语句分开，防止恶意输入被当作SQL代码执行。</p><figure class="highlight graphql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用参数化查询</span></span><br><span class="line"><span class="keyword">query</span> <span class="punctuation">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = %s AND password = %s&quot;</span></span><br><span class="line">cursor.execute<span class="punctuation">(</span><span class="keyword">query</span>, <span class="punctuation">(</span>username, password<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用ORM（对象关系映射）工具</strong>：ORM工具提供了安全的数据操作接口，避免了直接编写SQL查询。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Django ORM进行查询</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models import<span class="built_in"> User</span></span><br><span class="line"><span class="built_in"></span><span class="built_in"></span></span><br><span class="line"><span class="built_in">user </span>= User.objects.<span class="built_in">get</span>(<span class="attribute">username</span>=username, <span class="attribute">password</span>=password)</span><br></pre></td></tr></table></figure></li><li><p><strong>输入验证和转义</strong>：对用户输入进行严格的验证和转义，防止恶意代码注入。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证用户名和密码</span></span><br><span class="line"><span class="keyword">if</span> not re.<span class="keyword">match</span>(<span class="string">&quot;^[a-zA-Z0-9_]+$&quot;</span>, username):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid username&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> not re.<span class="keyword">match</span>(<span class="string">&quot;^[a-zA-Z0-9_]+$&quot;</span>, password):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid password&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>最小权限原则</strong>：数据库账户应具有最小的权限，仅允许执行必要的操作，减少攻击面。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个具有最小权限的数据库用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;appuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> database_name.* <span class="keyword">TO</span> <span class="string">&#x27;appuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>定期安全审计</strong>：定期进行代码和数据库的安全审计，及时发现和修复潜在的安全漏洞。</p></li></ol><h3 id="总结-3">总结</h3><p>SQL注入攻击通过在输入字段中插入恶意的SQL代码，使得数据库执行未经授权的查询，从而获取、修改或删除数据。了解其工作原理和常见攻击方式，并采取有效的防护措施，如参数化查询、输入验证和最小权限原则，可以显著降低SQL注入攻击的风险。</p><h2 id="XSS攻击">XSS攻击</h2><p>**XSS（Cross-Site Scripting）攻击【**跨站脚本攻击】**是一种网络攻击方式，攻击者在网页中插入恶意的脚本代码，使得脚本在其他用户的浏览器中执行，从而窃取敏感信息、劫持会话、伪造请求等。XSS攻击主要分为三种类型：存储型、反射型和基于DOM的XSS。以下是XSS攻击的详细说明及示例：</p><h3 id="XSS攻击类型">XSS攻击类型</h3><ol><li><strong>存储型XSS（Stored XSS）</strong>：<ul><li>恶意脚本被永久存储在目标服务器上（如数据库、日志文件等）。</li><li>受害者在浏览页面时，脚本会自动执行。</li></ul></li><li><strong>反射型XSS（Reflected XSS）</strong>：<ul><li>恶意脚本通过URL参数传递，并在响应中立即返回并执行。</li><li>攻击者通常通过诱导用户点击恶意链接来实现。</li></ul></li><li><strong>基于DOM的XSS（DOM-based XSS）</strong>：<ul><li>恶意脚本通过修改页面的DOM结构来执行。</li><li>攻击发生在客户端，由浏览器解析和执行。</li></ul></li></ol><h3 id="示例-4">示例</h3><h4 id="示例1：存储型XSS">示例1：存储型XSS</h4><p>攻击者在留言板上插入恶意脚本代码，该脚本被存储在服务器数据库中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 攻击者在留言板上提交恶意脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit_comment&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当其他用户访问包含恶意评论的页面时，浏览器会执行插入的脚本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示评论的页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>User comment: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="示例2：反射型XSS">示例2：反射型XSS</h4><p>攻击者构造恶意URL，诱导用户点击，恶意脚本通过URL参数传递并在响应中执行。</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 攻击者构造的恶意URL --&gt;</span></span></span><br><span class="line"><span class="language-xml">http://example.com/search?query=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 搜索结果页面 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 不安全地将用户输入输出到页面 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Search results for: </span><span class="language-vbscript">&lt;%= <span class="built_in">request</span>.getParameter(<span class="string">&quot;query&quot;</span>) %&gt;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>用户点击恶意链接后，脚本在浏览器中执行，显示一个警告框。</p><h4 id="示例3：基于DOM的XSS">示例3：基于DOM的XSS</h4><p>攻击者通过修改页面的DOM结构来执行恶意脚本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 受害者访问的页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 从URL参数中读取数据并插入到DOM中</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> query = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>).<span class="title function_">get</span>(<span class="string">&#x27;query&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;output&#x27;</span>).<span class="property">innerHTML</span> = query;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者构造恶意URL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 攻击者构造的恶意URL --&gt;</span></span><br><span class="line">http://example.com/page?query=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户点击恶意链接后，脚本在浏览器中执行。</p><h3 id="防护措施-4">防护措施</h3><ol><li><p><strong>输入验证和转义</strong>：</p><ul><li>对用户输入进行严格的验证和转义，防止恶意代码注入。</li><li>在输出时转义HTML特殊字符。</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, escape</span><br><span class="line"></span><br><span class="line"><span class="keyword">app</span> = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@<span class="keyword">app</span>.route(&#x27;/<span class="keyword">search</span>&#x27;)</span><br><span class="line">def <span class="keyword">search</span>():</span><br><span class="line">    <span class="keyword">query</span> = request.<span class="keyword">args</span>.<span class="built_in">get</span>(&#x27;<span class="keyword">query</span>&#x27;)</span><br><span class="line">    safe_query = escape(<span class="keyword">query</span>)</span><br><span class="line">    <span class="keyword">return</span> f&#x27;<span class="keyword">Search</span> results <span class="keyword">for</span>: &#123;safe_query&#125;&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用安全的库和框架</strong>：</p><ul><li>使用经过验证的库和框架来处理用户输入和输出。</li><li>如Django、Rails等框架自带防XSS功能。</li></ul></li><li><p><strong>内容安全策略（CSP）</strong>：</p><ul><li>配置内容安全策略，通过限制脚本资源来源，减少XSS攻击风险。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>HTTP-only和Secure标志</strong>：</p><ul><li>设置HTTP-only和Secure标志，防止JavaScript访问敏感的Cookie。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(<span class="string">&#x27;session_id&#x27;</span>, value, <span class="attribute">httponly</span>=<span class="literal">True</span>, <span class="attribute">secure</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>避免使用危险的JavaScript函数</strong>：</p><ul><li>避免使用<code>innerHTML</code>、<code>document.write</code>等容易引起XSS的函数，使用安全的DOM操作方法。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用textContent代替innerHTML</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>).textContent = query;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-4">总结</h3><p>XSS攻击通过在网页中插入恶意的脚本代码，使得脚本在用户的浏览器中执行。了解其工作原理和常见攻击方式，并采取有效的防护措施，如输入验证和转义、内容安全策略等，可以显著降低XSS攻击的风险。</p>]]></content>
    
    
    <summary type="html">常见网络攻击方式</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Cpp输入方式</title>
    <link href="https://penge666.github.io/posts/2fa03bf9.html"/>
    <id>https://penge666.github.io/posts/2fa03bf9.html</id>
    <published>2024-06-23T09:07:53.000Z</published>
    <updated>2024-06-23T11:41:35.192Z</updated>
    
    <content type="html"><![CDATA[<p>在算竞中经常需要读取数据，这篇文章对Cpp的输入方式总结。</p><h2 id="输入方式">输入方式</h2><h3 id="1-cin"><strong>1.cin</strong></h3><p>（1）cin&gt;&gt;等价于cin.operator&gt;&gt;()，即调用成员函数operator&gt;&gt;()进行读取数据。</p><p>（2）当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。<strong>但是如果读取成功，字符后面的分隔符是残留在</strong>缓冲区的，cin&gt;&gt;不做处理。如果后续接getline()要记得处理换行符！</p><p>补充：</p><ul><li><p><strong>Tab键</strong>：通常在键盘上标记为<code>Tab</code>，按下后插入一个制表符（Tab字符）。制表符的长度通常为多个空格，可以在不同的编辑器或环境中设置长度，常见的设置是4个或8个空格。【在计算机中用于对齐文本的特殊字符】</p></li><li><p><strong>空格键</strong>：按下后插入一个空格字符。每次按下空格键插入一个空格，长度固定。</p></li></ul><p>（3）不想略过空白字符，那就使用 noskipws 流控制。比如：cin&gt;&gt;noskipws&gt;&gt;input;</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, std::string&amp; str) &#123;</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">// 清空字符串</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    is &gt;&gt; std::ws; <span class="comment">// 跳过前导的空白字符</span></span><br><span class="line">    <span class="keyword">while</span> (is.<span class="built_in">get</span>(ch) &amp;&amp; !<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">        str += ch; <span class="comment">// 将字符添加到字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is; <span class="comment">// 返回输入流对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><p>C 库函数 <strong>int isspace(int c)</strong> 检查所传的字符是否是空白字符。</p><p>标准的空白字符包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>     (0x20)    space (SPC) 空格符</span><br><span class="line"><span class="string">&#x27;\t&#x27;</span>    (0x09)    horizontal tab (TAB) 水平制表符    </span><br><span class="line"><span class="string">&#x27;\n&#x27;</span>    (0x0a)    newline (LF) 换行符</span><br><span class="line"><span class="string">&#x27;\v&#x27;</span>    (0x0b)    vertical tab (VT) 垂直制表符</span><br><span class="line"><span class="string">&#x27;\f&#x27;</span>    (0x0c)    feed (FF) 换页符</span><br><span class="line"><span class="string">&#x27;\r&#x27;</span>    (0x0d)    carriage <span class="built_in">return</span> (CR) 回车符</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> n,m,k,p,q;</span><br><span class="line">cin&gt;&gt;std::noskipws&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p&gt;&gt;q;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;q&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q w e a z</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q w e a z</span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-cin-get"><strong>2.cin.get()</strong></h3><p>单用cin.get()只能读取其中一个字符，不能存储为string全部的字符。</p><p>若要存储全部则必须传入一个数组以及长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">main</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[n];</span><br><span class="line">    cin.<span class="built_in">get</span>(a,n); <span class="comment">//实际包括空格只能存n-1个字符，最后一个字符</span></span><br><span class="line">是<span class="string">&#x27;\n&#x27;</span>以回车作为结束符。</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-cin-getline"><strong>3.cin.getline()</strong></h3><p>接受一个字符串，可以接收空格并输出,吃掉末尾的换行符的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(m,<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>cin.getline(m, 5)</code> 时，函数从输入流中读取最多 <code>5 - 1 = 4</code> 个字符，并在读取到的字符后添加一个终止空字符 <code>\0</code>。</p><p>延伸：</p><p>cin.getline()实际上有三个参数，<code>cin.getline(接受字符串的看中间的m,接受个数5,结束字符) </code></p><p>当第三个参数省略时，系统默认为’\0’ 。</p><p>如果将例子中cin.getline()改为cin.getline(m,5,‘a’);当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</p><p>当用在多维数组中的时候，也可以用cin.getline(m[i],20)之类的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> m[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin.<span class="built_in">getline</span>(m[i], <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输出m[&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;]的值:&quot;</span> &lt;&lt; m[j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string输入">string输入</h2><h3 id="4-getline"><strong>4.getline()</strong></h3><p>接受一个字符串，可以接收空格并输出，需包含“#include”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str); <span class="comment">// 和cin.getline()一样可以按某个字符结尾</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-getchar"><strong>5.getchar()</strong></h3><p>函数原型：int getchar(void);</p><p>返回类型为int,参数为void</p><p>头  文  件：#include&lt;stdio.h&gt;</p><p>返  回  值：</p><ol><li>getchar返回的是字符的ASCII码值（整数）</li><li>getchar在读取结束或者失败的时候，会返回EOF。(EOF意思是end of file,本质上是-1）</li></ol><p>读取方式：只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符。<br>结束输入的方式：以Enter结束输入（空格不结束），接受空格符。<br>舍弃回车符的方法：以Enter结束输入时，接受空格，会舍弃最后的回车符。</p><p><strong>getchar函数执行过程详解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">getchar</span>();<span class="comment">//输入字符</span></span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的简单意思就是从键盘读入一个字符，然后输出到屏幕。理所当然，我们输入A，输出就是A，输入B，输出就是B。</p><p>那么我们如果输出的是ABC呢？答案是A。</p><p>解释如下：当我们从键盘输入字符‘A’，‘B’,  ‘C’，并按下回车后，我们的输入被放入了输入缓冲区，这个时候getchar()会从缓冲区中读取我们刚才的输入，一次只读一个字符，所以字符A就被拿出来了，赋值给了ch，然后putchar()又将ch放在了标准输出，也就是这里的屏幕，所以我们看见了最终的显示结果A。同时字符‘A’也被缓冲区释放了，而字符‘B’,'C’仍然被留在了缓冲区。而这样是很不安全的，有可能下次使用的时候，我们的缓冲区会读到一些垃圾，但是当程序结束的时候，它会自动刷新。</p><p>解释：现在，考虑这样一个场景：你的程序在接收了用户的一些输入之后，由于某种原因突然终止了，没有正常退出。这种情况下，这些未处理的输入可能会留在输入缓冲区中，没有被清理掉。当你的程序下次运行并再次试图从输入缓冲区获取输入时，它可能会先读取到这些残留的旧数据，而不是新的用户输入。这就是我们所说的&quot;可能会读到一些垃圾&quot;的含义。</p><h3 id="6-gets">6.gets()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gets</span>(m)用于string类的，需包含<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>。可以接收空格，遇回车结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span><span class="comment">//必须是cstring，否则strlen()方法不能用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">40000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(a);<span class="comment">//必须是char型数组，不能是其他类型数组</span></span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(a);<span class="comment">//得到char型数组的实际长度</span></span><br><span class="line">    <span class="comment">//执行其余操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于多维数组。</p><p>可用于多维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">　　<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">　　<span class="built_in">main</span> ()</span><br><span class="line">　　&#123;</span><br><span class="line">    　　<span class="type">char</span> m[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;\n请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">gets_s</span>(m[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"> <span class="type">int</span> len = <span class="built_in">strlen</span>(m[j]);<span class="comment">//得到char型数组的实际长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;输出m[&quot;</span> &lt;&lt; j &lt;&lt; k &lt;&lt; <span class="string">&quot;]的值:&quot;</span> &lt;&lt; m[j][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="算竞输入补充">算竞输入补充</h2><ul><li><a href="https://blog.csdn.net/ZER00000001/article/details/126345457">竞赛中应该用scanf还是cin？ scanf&amp;printf与cin&amp;cout的比较+快读快写</a></li></ul><p>我利用代码生成了<strong>三千万</strong>个【1，100】以内的随机数，并且将分别用<code>cin</code>和<code>scanf</code>输入到一个数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXNUM  = <span class="number">30000000</span>;</span><br><span class="line"><span class="type">int</span> RandomNumber;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    RandomNumber = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//scanf(&quot;%d &quot;, &amp;number[i]);</span></span><br><span class="line">cin &gt;&gt; number[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;scanf用时：%.3lf\n&quot;</span>, <span class="built_in">double</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在Windows系统<a href="https://so.csdn.net/so/search?q=GCC%E7%BC%96%E8%AF%91%E5%99%A8&amp;spm=1001.2101.3001.7020">GCC编译器</a>下得出的用时数据（单位：秒），且已验证过不存在偶然性：</p><table><thead><tr><th>scanf</th><th>cin</th></tr></thead><tbody><tr><td>6.836</td><td>11.303</td></tr></tbody></table><p>同时，我用printf和cout分别输出<strong>十万个正整数</strong>。</p><table><thead><tr><th>printf</th><th>cout</th></tr></thead><tbody><tr><td>6.172</td><td>11.509</td></tr></tbody></table><p>于是可以得出结论：<strong>cin&amp;cout的确在效率上是低于scanf&amp;printf的</strong></p><p>而我们可以通过std::ios::sync_with_stdio(false);指令关闭同步（这里要注意：当关闭同步之后为了确保准确，不要使用 printf&amp;scanf了），除此之外我们还可以通过std::cin.tie(nullptr);获取cin更优的性能（解除std :: cin和std :: cout之间的绑定，来降低IO的负担使效率提升）。那么在对iostream优化之后的 printf&amp;scanf 和 cin&amp;cout效率差距又有多大呢？我通过上述的实验得出以下数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world!Hello,</span><br></pre></td></tr></table></figure><p>Note：<code>std::ios::sync_with_stdio(false);</code> 这条语句的作用是关闭C++的iostream和C的stdio之间的同步。</p><p>在默认情况下（同步开启），程序的输出会是 “Hello, world!”。因为cout和printf是同步的，所以他们的输出顺序是按照我们写的顺序来的。</p><p>但是，如果我们关闭同步，那么程序的输出就可能不是&quot;Hello, world!&quot;了。可能cout的输出先出现，也可能printf的输出先出现，这取决于哪个操作更快。所以，在关闭同步后，我们就不能再预期混合使用C++的iostream和C的stdio时的输出顺序了。</p><p><strong>疑问：关闭C++的iostream和C的stdio之间的同步为什么能提高速度？</strong></p><p><strong>有趣的解答：</strong></p><p>假设你正在举办一场派对，你邀请了两个DJ，一个是专门播放摇滚音乐的，另一个是专门播放爵士乐的。你希望他们能够交替播放音乐，这样你的派对就可以同时享受到摇滚和爵士的风格。</p><p>但是，为了确保他们能够顺利地交替播放，你需要找一个协调员来时刻注意两位DJ的状态，告诉他们什么时候该停，什么时候该播。这个协调员就相当于同步机制，他确保了摇滚DJ和爵士DJ（相当于iostream和stdio）能够和谐工作。</p><p>然而，这个协调员并不是免费的。他需要时间去观察和指挥，这就可能会延迟音乐的切换，也就是说，派对的整体节奏可能会因为等待协调员的指示而变慢。这就像为了维持iostream和stdio的同步，系统需要做额外的工作（比如刷新缓冲区），这会导致效率的降低。</p><p>现在假设你决定不再需要协调员，让两位DJ自己决定何时播放音乐。这样，你就节省了协调员的成本，派对的节奏也可能会更快。但是，你也无法再保证摇滚音乐和爵士乐能够完美交替，他们可能会同时播放，也可能会有短暂的静音。这就像当你关闭iostream和stdio的同步时，虽然提高了效率，但也无法保证他们的操作顺序。</p><p>总的来说，关闭iostream和stdio的同步可以提高效率，但同时也会牺牲他们的协调性。在某些情况下，这可能是值得的，但在其他情况下，可能就需要考虑其他解决方案了。</p><table><thead><tr><th>scanf</th><th>cin（优化后）</th></tr></thead><tbody><tr><td>6.836</td><td>2.695</td></tr></tbody></table><table><thead><tr><th>printf</th><th>cout （优化后）</th></tr></thead><tbody><tr><td>6.172</td><td>6.178</td></tr></tbody></table><p>可以看见在关闭同步之后cin的效率已经是高于scanf了，并且cout的速度与printf的速度也相差无几，那我们还能不能继续优化呢？</p><p>我们注意到通常在用cout输出的时候，更习惯去使用endl，它既可以达到换行的需求又可以刷新缓冲区，然而在如此高度的循环下它一直对缓冲区的操作却降低了效率，所以将endl换成’\n’cout的效率将会起飞</p><p>（顺带一提，我在开启同步的条件发现endl或是<code>\n</code> 对cout效率的影响并不大，不知道是不是我的问题，希望各位指出）</p><table><thead><tr><th>printf</th><th>cout（‘\n’）</th></tr></thead><tbody><tr><td>6.172</td><td>1.106</td></tr></tbody></table><p>如此一来我们再一次得出结论：<strong>在同步开启时，scanf&amp;printf的效率要高于cin&amp;cout；当同步关闭时，cin&amp;cout的效率要高于scanf&amp;printf。</strong></p><p>最后，附上ACMer喜欢的快读模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*快读快写*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span><span class="comment">//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//自定义的类型T</span></span><br><span class="line">   <span class="keyword">register</span> T sum = <span class="number">0</span>, f1 = <span class="number">1</span>;<span class="comment">//f1是标志位</span></span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="comment">//如果输入的是负数</span></span><br><span class="line">   <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           f1 = <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       sum = sum * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum * f1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int a = read&lt;int&gt;();</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> stk[<span class="number">20</span>];<span class="comment">//模拟压栈</span></span><br><span class="line">   <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       stk[top++] = x % <span class="number">10</span>;</span><br><span class="line">       x /= <span class="number">10</span>;</span><br><span class="line">   &#125;<span class="keyword">while</span>(x);</span><br><span class="line">   <span class="keyword">while</span>(top)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//write(a);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>read</th><th>cin</th></tr></thead><tbody><tr><td>0.485</td><td>2.695</td></tr></tbody></table><table><thead><tr><th>write</th><th>cout</th></tr></thead><tbody><tr><td>18.908</td><td>1.106</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Cpp输入方式总结</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp异常机制</title>
    <link href="https://penge666.github.io/posts/85e41e12.html"/>
    <id>https://penge666.github.io/posts/85e41e12.html</id>
    <published>2024-06-22T13:46:01.000Z</published>
    <updated>2024-06-24T06:47:20.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-异常机制概述">C++异常机制概述</h2><p>异常处理是C++ 的一项语言机制，用于在程序中处理异常事件。异常事件在C++中表示为异常对象。异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为<strong>异常出现点</strong>，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块，在包含了异常出现点的最内层的try块，依次匹配catch语句中的异常对象（<strong>只进行类型匹配，catch参数有时在catch语句中并不会使用到</strong>）。<strong>若匹配成功，则执行catch块内的异常处理语句，然后接着执行try…catch…块之后的代码</strong>。如果在当前的try…catch…块内找不到匹配该异常对象的catch语句,则由更外层的try…catch…块来处理该异常；<strong>如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常</strong>。<strong>如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序。</strong></p><p>一个最简单的try…catch…的例子如下所示。我们有个程序用来记班级学生考试成绩，考试成绩分数的范围在0-100之间，不在此范围内视为数据异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> score;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将分数写入文件或进行其他操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> score)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;你输入的分数数值有问题，请重新输入！&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throw-关键字">throw 关键字</h2><p>在上面这个示例中，throw是个关键字，与抛出表达式构成了throw语句。其语法为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw 表达式<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>throw语句必须包含在try块中，也可以是被包含在调用栈的外层函数的try块中，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：throw包含在外层函数的try块中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> score; <span class="comment">//throw语句被包含在外层main的try语句块中</span></span><br><span class="line">    <span class="comment">//将分数写入文件或进行其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">registerScore</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> score)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;你输入的分数数值有问题，请重新输入！&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行throw语句时，==throw表达式将作为对象被复制构造为一个新的对象，称为异常对象==。异常对象放在内存的特殊位置，<strong>该位置既不是栈也不是堆</strong>，<strong>在window上是放在线程信息块TIB中</strong>。这个构造出来的新对象与本级的try所对应的catch语句进行类型匹配，类型匹配的原则在下面介绍.</p><p>补充：</p><p><strong>在Linux下，异常对象被存放在一个特殊的内存区域，这个内存区域被称为异常处理堆（Exception Handling Heap）</strong>。这个堆是由操作系统提供的，它不同于程序员常说的堆（即通过new、malloc等函数进行动态分配的堆），也不同于栈（即函数调用时用来存储局部变量和函数调用信息的栈）。</p><p>当一个异常被抛出时，异常对象会被复制构造到这个异常处理堆上。这个异常对象会在整个异常处理过程中保持其生命周期，直到异常被完全处理并恢复程序的正常执行流程，这时异常对象才会被销毁。</p><p>这样设计的原因是，异常处理涉及到栈的展开，也就是局部变量的销毁。如果异常对象存储在栈上，那么在异常处理过程中，异常对象可能会被销毁，这显然是不合理的。所以，异常对象被存储在一个独立的、由操作系统提供的异常处理堆上。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240623222008901.png" alt="image-20240623222008901"></p><p>在本例中，依据score构造出来的对象类型为int，与catch(int score)匹配上，程序控制权转交到catch的语句块，进行异常处理代码的执行。如果在本函数内与catch语句的类型匹配不成功，则在调用栈的外层函数继续匹配，如此递归执行直到匹配上catch语句，或者直到main函数都没匹配上而调用系统函数terminate()终止程序。 当执行一个throw语句时，跟在throw语句之后的语句将不再被执行，throw语句的语法有点类似于return，因此导致在调用栈上的函数可能提早退出。</p><h2 id="异常对象">异常对象</h2><p>异常对象是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型。不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的。【因为要复制构造异常对象以及catch之后析构对象，因此不应该将其设置为private】</p><p>异常对象不同于函数的局部对象，局部对象在函数调用结束后就被自动销毁，<strong>而异常对象将驻留在所有可能被激活的catch语句都能访问到的内存空间中，也即上文所说的TIB。当异常对象与catch语句成功匹配上后，在该catch语句的结束处被自动析构。</strong></p><p>在函数中返回局部变量的引用或指针几乎肯定会造成错误，同样的道理，<strong>在throw语句中抛出局部变量的指针或引用也几乎是错误的行为</strong>。如果指针所指向的变量在执行catch语句时已经被销毁，对指针进行解引用将发生意想不到的后果。</p><p>throw出一个表达式时，<strong>该表达式的静态编译类型将决定异常对象的类型</strong>。所以当throw出的是基类指针的解引用，而该指针所指向的实际对象是派生类对象，此时将发生派生类对象切割。</p><p>来看个例子解释下：</p><p>在C++中，如果你抛出一个基类的引用或者指针，但它实际上指向一个派生类对象，那么在抛出异常时，只有基类部分会被抛出，派生类的部分会被切割掉。这就是所谓的&quot;对象切割&quot;问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived d;</span><br><span class="line">        <span class="built_in">foo</span>(d);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (Base&amp; b) &#123;</span><br><span class="line">        b.<span class="built_in">print</span>(); <span class="comment">// 输出 &quot;Base&quot; 而不是 &quot;Derived&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在这个例子中，<code>Derived</code>是<code>Base</code>的派生类。<code>foo</code>函数接收一个<code>Base</code>的引用，并抛出这个引用。在<code>main</code>函数中，我们创建了一个<code>Derived</code>对象<code>d</code>，并将它作为<code>Base</code>的引用传递给<code>foo</code>函数。当<code>foo</code>函数抛出这个引用时，只有<code>Base</code>部分被抛出，<code>Derived</code>部分被切割掉。所以，当我们在<code>catch</code>块中捕获这个异常并调用<code>print</code>函数时，输出的是&quot;Base&quot;，而不是&quot;Derived&quot;。</p><p>除了抛出用户自定义的类型外，C++标准库定义了一组类，用户报告标准库函数遇到的问题。这些标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。</p><table><thead><tr><th>标准异常类</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>exception</td><td>最通用的异常类，只报告异常的发生而不提供任何额外的信息</td><td>exception</td></tr><tr><td>runtime_error</td><td>只有在运行时才能检测出的错误</td><td>stdexcept</td></tr><tr><td>rang_error</td><td>运行时错误：产生了超出有意义值域范围的结果</td><td>stdexcept</td></tr><tr><td>overflow_error</td><td>运行时错误：计算上溢</td><td>stdexcept</td></tr><tr><td>underflow_error</td><td>运行时错误：计算下溢</td><td>stdexcept</td></tr><tr><td>logic_error</td><td>程序逻辑错误</td><td>stdexcept</td></tr><tr><td>domain_error</td><td>逻辑错误：参数对应的结果值不存在</td><td>stdexcept</td></tr><tr><td>invalid_argument</td><td>逻辑错误：无效参数</td><td>stdexcept</td></tr><tr><td>length_error</td><td>逻辑错误：试图创建一个超出该类型最大长度的对象</td><td>stdexcept</td></tr><tr><td>out_of_range</td><td>逻辑错误：使用一个超出有效范围的值</td><td>stdexcept</td></tr><tr><td>bad_alloc</td><td>内存动态分配错误</td><td>new</td></tr><tr><td>bad_cast</td><td>dynamic_cast类型转换出错</td><td>type_info</td></tr></tbody></table><h2 id="catch-关键字">catch 关键字</h2><p>catch语句匹配被抛出的异常对象。如果catch语句的参数是引用类型，则该参数可直接作用于异常对象，即参数的改变也会改变异常对象，==而且在catch中<strong>重新抛出异常</strong>时会继续传递这种改变==。如果catch参数是传值的，则复制构函数将依据异常对象来构造catch参数对象。在该catch语句结束的时候，先析构catch参数对象，然后再析构异常对象。</p><p>在进行异常对象的匹配时，<strong>编译器不会做任何的隐式类型转换或类型提升</strong>。</p><p>除了以下几种情况外，异常对象的类型必须与catch语句的声明类型完全匹配：</p><ul><li>允许从非常量到常量的类型转换。</li><li>允许派生类到基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针。</li><li>函数被转换成指向函数类型的指针。</li></ul><p>寻找catch语句的过程中，匹配上的未必是类型完全匹配那项，而在是最靠前的第一个匹配上的catch语句（我称它为<strong>最先匹配原则</strong>）。<strong>所以，派生类的处理代码catch语句应该放在基类的处理catch语句之前，否则先匹配上的总是参数类型为基类的catch语句，而能够精确匹配的catch语句却不能够被匹配上。</strong></p><p>解释：</p><p>在查找适合的<code>catch</code>块以处理抛出的异常时，C++会按照代码的顺序从上到下查找，当找到第一个能够匹配抛出的异常类型的<code>catch</code>块时，就会执行这个<code>catch</code>块。如果派生类的<code>catch</code>块被放在了基类的<code>catch</code>块之后，那么基类的<code>catch</code>块就会先被匹配上，派生类的<code>catch</code>块就无法被执行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Derived</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Base&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Base\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Derived&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Derived\n&quot;</span>; <span class="comment">// 这个catch块永远不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>foo</code>函数抛出了一个<code>Derived</code>类型的异常，但是在<code>main</code>函数中，先匹配上的是<code>Base</code>类型的<code>catch</code>块，所以输出的是&quot;Caught Base&quot;。尽管有一个精确匹配<code>Derived</code>类型的<code>catch</code>块，但是由于它被放在了<code>Base</code>类型的<code>catch</code>块之后，所以它永远不会被执行。</p><p>为了避免这种情况，我们应该将派生类的<code>catch</code>块放在基类的<code>catch</code>块之前，就像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Derived&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Derived\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(Base&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught Base\n&quot;</span>; <span class="comment">// 只有当抛出的异常不是Derived类型时，这个catch块才会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当<code>foo</code>函数抛出一个<code>Derived</code>类型的异常时，就会先匹配上<code>Derived</code>类型的<code>catch</code>块，输出的就是&quot;Caught Derived&quot;了。</p><hr><p>在catch块中，如果在当前函数内无法解决异常，可以继续向外层抛出异常，让外层catch异常处理块接着处理。此时可以使用不带表达式的throw语句将捕获的异常重新抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(type x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//做了一部分处理</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被重新抛出的异常对象为保存在TIB中的那个异常对象</strong>，与catch的参数对象没有关系，若catch参数对象是引用类型，<strong>可能在catch语句内已经对异常对象进行了修改，那么重新抛出的是修改后的异常对象</strong>；若catch参数对象是非引用类型，则重新抛出的异常对象并没有受到修改。</p><p>使用<code>catch(...)&#123;&#125;</code>可以捕获所有类型的异常，根据最先匹配原则，<code>catch(...)&#123;&#125;</code>应该<strong>放在所有catch语句的最后面</strong>，否则无法让其他可以精确匹配的catch语句得到匹配。通常在catch(…){}语句中执行当前可以做的处理，然后再重新抛出异常。<strong>注意，catch中重新抛出的异常只能被外层的catch语句捕获。</strong></p><h2 id="栈展开、RAII">栈展开、RAII</h2><p>其实栈展开已经在前面说过，就是从异常抛出点一路向外层函数寻找匹配的catch语句的过程，寻找结束于某个匹配的catch语句或标准库函数terminate。这里重点要说的是栈展开过程中对局部变量的销毁问题。我们知道，在函数调用结束时，函数的局部变量会被系统自动销毁，类似的，<strong>throw可能会导致调用链上的语句块提前退出，此时，语句块中的局部变量将按照构成生成顺序的逆序，依次调用析构函数进行对象的销毁</strong>。例如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个没有任何意义的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() :<span class="built_in">a</span>(<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;A默认构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span>  A&amp; rsh)&#123; cout &lt;&lt; <span class="string">&quot;A复制构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; cout &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a ;</span><br><span class="line">            <span class="keyword">throw</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (A a)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A默认构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br></pre></td></tr></table></figure><p>定义变量a时调用了默认构造函数，使用a初始化异常变量时调用了复制构造函数，使用异常变量复制构造catch参数对象时同样调用了复制构造函数。三个构造对应三个析构，也即try语句块中局部变量a自动被析构了。然而，如果a是在自由存储区上分配的内存时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        A * a= <span class="keyword">new</span> A;</span><br><span class="line">        <span class="keyword">throw</span> *a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (A a)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A默认构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A复制构造函数</span><br><span class="line">A析构函数</span><br><span class="line">A析构函数</span><br></pre></td></tr></table></figure><p>同样的三次构造，却只调用了两次的析构函数！说明a的内存在发生异常时并没有被释放掉，发生了内存泄漏。 ==RAII机制有助于解决这个问题==，RAII（Resource acquisition is initialization，资源获取即初始化）。它的思想是以对象管理资源。为了更为方便、鲁棒地释放已获取的资源，避免资源死锁，一个办法是把资源数据用对象封装起来。程序发生异常，执行栈展开时，封装了资源的对象会被自动调用其析构函数以释放资源。C++ 中的智能指针便符合RAII。关于这个问题详细可以看《Effective C++》条款13.</p><p><strong>条款13：以对象管理资源</strong></p><p>为了防止资源泄漏，请使用RAII(Resource Acquisition Is Initialization)对象，在构造函数里面获得资源，在析构函数里面释放资源 <code>auto_ptr</code>(c++11废弃，原因见笔记)，<code>shared_ptr</code>，<code>unique_lock</code>都是RAII类。</p><h2 id="异常机制与构造函数">异常机制与构造函数</h2><p>异常机制的一个合理的使用是在构造函数中。<strong>构造函数没有返回值，所以应该使用异常机制来报告发生的问题</strong>。更重要的是，构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用，因此析构函数应该先析构所有所有已初始化的基对象，成员对象，再抛出异常。 C++类<strong>构造函数初始化列表的异常机制</strong>，称为function-try block。一般形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myClass::<span class="built_in">myClass</span>(type1 pa1)</span><br><span class="line">    <span class="keyword">try</span>:  _myClass_val (初始化值) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">/*构造函数的函数体 */</span></span><br><span class="line">&#125; </span><br><span class="line">  <span class="built_in">catch</span> ( exception&amp; err ) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 构造函数的异常处理部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用.可能会存在内存泄漏。因此提出<strong>构造函数初始化列表的异常机制</strong></p><h2 id="异常机制与析构函数">异常机制与析构函数</h2><p>C++不禁止析构函数向外界抛出异常，==但析构函数被期望不向外界函数抛出异常==。析构函数中向函数外抛出异常，将直接调用terminator()系统函数终止程序。如果一个析构函数内部抛出了异常，就应该在析构函数的内部捕获并处理该异常，不能让异常被抛出析构函数之外。可以如此处理：</p><ul><li>若析构函数抛出异常，调用std::abort()来终止程序。</li><li>在析构函数中catch捕获异常并作处理。</li></ul><p>关于具体细节，有兴趣可以看《Effective C++》条款08：别让异常逃离析构函数。</p><p><strong>解释</strong></p><p>在C++中，析构函数是不应该抛出异常的。如果析构函数中抛出了异常，那么当对象被销毁，或者在异常处理过程中，对象被销毁时，如果析构函数再次抛出异常，程序就会调用<code>std::terminate</code>函数，导致程序立即崩溃。</p><p>这是因为在C++中，如果一个异常没有被捕获，那么程序就会调用<code>std::terminate</code>函数，结束程序的运行。而在一个异常处理过程中，如果又抛出了新的异常，那么这个新的异常就无法被捕获，因为异常处理机制已经在处理一个异常了。</p><p>此外，如果析构函数在执行过程中抛出异常并且没有被正确处理，那么对象可能无法被完全销毁，这就可能导致内存泄漏。</p><p>所以，为了避免这种情况，我们通常推荐在析构函数中使用try/catch块来捕获并处理可能的异常，或者设计析构函数使其不会抛出异常。如果必须在析构函数中执行可能会抛出异常的操作，那么应该将这些操作放在一个单独的函数中，而不是直接放在析构函数中。</p><h2 id="noexcept修饰符与noexcept操作符">noexcept修饰符与noexcept操作符</h2><p>noexcept修饰符是C++ 11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中你可能会看到这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span> ,<span class="type">double</span> )</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这是throw作为函数异常说明，前者表示func（）这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++ 11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//等价于void func() throw()&#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此，被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是阻止异常的传播,提高安全性.</p><p>上面一点提到了，我们不能让异常逃出析构函数，因为那将导致程序的不明确行为或直接终止程序。实际上出于安全的考虑，<strong>C++ 11标准中让类的析构函数默认也是noexcept的</strong>。 <strong>同样是为了安全性的考虑，经常被析构函数用于释放资源的delete函数，C++11也默认将其设置为noexcept</strong>。</p><p>noexcept也可以接受一个常量表达式作为参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure><p>常量表达式的结果会被转换成bool类型，noexcept(bool)表示函数不会抛出异常，noexcept(false)则表示函数有可能会抛出异常。<strong>故若你想更改析构函数默认的noexcept声明，可以显式地加上noexcept(false)声明，但这并不会带给你什么好处</strong>。</p><p>【异常后果自负】</p><p><strong>在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是阻止异常的传播,提高安全性.</strong></p><h2 id="异常处理的性能分析">异常处理的性能分析</h2><p>异常处理机制的主要环节是运行期类型检查。当抛出一个异常时，必须确定异常是不是从try块中抛出。异常处理机制为了完善异常和它的处理器之间的匹配，需要存储每个异常对象的类型信息以及catch语句的额外信息。由于异常对象可以是任何类型（如用户自定义类型），并且也可以是多态的，获取其动态类型必须要使用运行时类型检查（RTTI），此外还需要运行期代码信息和关于每个函数的结构。</p><p>当异常抛出点所在函数无法解决异常时，异常对象沿着调用链被传递出去，程序的控制权也发生了转移。转移的过程中为了将异常对象的信息携带到程序执行处（如对异常对象的复制构造或者catch参数的析构），在时间和空间上都要付出一定的代价，本身也有不安全性，特别是异常对象是个复杂的类的时候。</p><p>异常处理技术在不同平台以及编译器下的实现方式都不同，但都会给程序增加额外的负担，当异常处理被关闭时，额外的数据结构、查找表、一些附加的代码都不会被生成，正是因为如此，对于明确不抛出异常的函数，我们需要使用noexcept进行声明。</p><p>学习自：<a href="https://www.cnblogs.com/QG-whz/p/5136883.html">C++异常机制概述</a></p>]]></content>
    
    
    <summary type="html">Cpp异常机制</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>动态内存分配</title>
    <link href="https://penge666.github.io/posts/49f482c.html"/>
    <id>https://penge666.github.io/posts/49f482c.html</id>
    <published>2024-06-21T07:32:17.000Z</published>
    <updated>2024-06-21T07:40:17.931Z</updated>
    
    <content type="html"><![CDATA[<p>虽然可以mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当需要额外的虚拟内存时，用<strong>动态内存分配器</strong>更方便，也有更好的可移植性。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种基本风格，<strong>显式分配器</strong>要求应用显式释放分配的块，而<strong>隐式分配器</strong>(<strong>也叫做垃圾收集器</strong>)则要求分配器检查不再使用的块并释放。本文将对显示分配器和隐式分配器做更深入的讨论。</p><h3 id="1、malloc和free函数">1、malloc和free函数</h3><h4 id="1-1-malloc函数">1.1 malloc函数</h4><p>c标准库提供了一个称为malloc程序包的显式分配器。程序通过调用malloc函数来从堆中分配块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>; <span class="comment">//返回：若成功则为已分配块的指针，若出错则为null.</span></span><br></pre></td></tr></table></figure><p>malloc函数返回一个指针，指向大小至少为size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。如果malloc遇到问题，那么它就返回null，并设置errno。<strong>malloc不初始化它返回的内存，如果想要已初始化的内存则通过calloc分配，如果想要改变已分配块的大小则使用realloc函数</strong>。</p><h4 id="1-2-malloc的底层——sbrk函数">1.2 malloc的底层——sbrk函数</h4><p>malloc可以通过mmap和munmap来显式分配和释放堆内存，或则还可以使用sbrk函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span></span>; <span class="comment">//成功返回brk的旧值，出错返回-1</span></span><br></pre></td></tr></table></figure><p>sbrk函数通过将内核的brk(指向堆顶部)指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1并设置errno为ENOMEM。如果sbrk的参数为0，则返回的为原来的brk地址。</p><h4 id="1-3-free函数">1.3 free函数</h4><p>程序通过调用free函数来释放已分配的堆块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span>; <span class="comment">//不返回值</span></span><br></pre></td></tr></table></figure><p>ptr必须指向一个已分配块的起始位置，如果不是，那么free的行为就是未定义的。</p><h3 id="2、为什么要使用动态内存">2、为什么要使用动态内存</h3><p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。比如我们需要根据输入的n分配一个对应大小的数据来临时存储数据，这是就用动态分配比较好。</p><blockquote><p>值得注意的是，c99提供了动态的数组大小分配，可以不再需要由程序员显式分配动态空间。不过这种分配方式是否是堆上的空间就需要进一步验证了。</p></blockquote><h3 id="3、分配器的要求和目标">3、分配器的要求和目标</h3><p>显式分配器必须在一些相当严格的约束条件下工作：</p><ul><li><strong>处理任意请求序列</strong>：一个应用可以有任意的分配请求和释放请求序列，分配器不可以假设分配和释放请求的顺序。</li><li><strong>立即响应请求</strong>：分配器必须立即响应分配请求。因此不允许分配器提高性能，从新排列或者缓冲请求。</li><li><strong>只使用堆</strong>：分配器使用的任何数据结构都保存在堆里。</li><li><strong>对齐块</strong>：比如8个字节的对齐。</li><li><strong>不修改已分配的块</strong>：分配器只能操作或者改变空闲块，不允许不能压缩已分配的块。</li></ul><p>分配器在满足上述要求的情况下，需要达到以下两个目标：</p><ul><li>(1)最大化吞吐率,单位时间完成尽可能多的请求。</li><li>(2)最大化存储器的利用率。天真的程序员经常不正确的假设虚拟存储器是一个无限的资源**，事实上，一个系统中被所有进程分配的虚拟存储器的全部数量是受磁盘上交换空间的数量限制的**。好的程序员知道虚拟内存是一个有限的空间，必须高效地使用。</li></ul><p>分配器设计中一个有趣的挑战就是在上述两个目标之间找到一个适当的平衡。</p><h3 id="3、碎片">3、碎片</h3><p>造成堆的空间利用率很低的主要原因是一种被称为碎片的现象，当虽然有未使用的内存但这块内存并不能满足分配请求时，就会产生碎片。有以下两种形式的碎片：内部碎片和外部碎片。</p><ul><li><strong>内部碎片</strong>：在一个已分配块比有效载荷大时发生。比如分配器限制的最小分配至比实际请求值要大，又或者为了对齐而增加块的大小。意味着已分配但是未使用。</li><li>外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大到可以来处理这个请求时发生。<strong>外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块</strong>。</li></ul><h3 id="4、分配器设计">4、分配器设计</h3><p>一个分配器需要在吞吐率和利用率之间把握好平衡，必须要考虑以下几个因素：</p><ul><li>组织空闲块：如何组织</li><li>放置：怎么选择一个合适的块来放置新分配的块。</li><li>分割：新分配的块放到某个空闲块后，如何处理剩余部分。</li><li>合并：如何处理一个刚刚被释放的块。</li></ul><blockquote><p><strong>动态内存分配器补充</strong></p></blockquote><p>动态内存分配器可以是内核的一部分，也可以是运行在用户空间的库。这取决于具体的操作系统和编程环境。</p><p>在许多操作系统中，如Unix和Windows，动态内存分配器是作为C标准库的一部分提供的，例如<code>malloc</code>，<code>calloc</code>，<code>realloc</code>和<code>free</code>函数。这些库函数在用户空间运行，并通过系统调用来请求内核分配或释放内存。</p><p>然而，这些函数的实现通常是建立在操作系统内核提供的更底层的内存管理机制之上的。例如，Unix系统的<code>brk</code>和<code>sbrk</code>系统调用，或者Windows的<code>VirtualAlloc</code>函数。这些底层的内存管理函数是由内核直接提供的，因此可以说，动态内存分配器的这一部分是内核程序。</p><h3 id="5、隐式空闲链表">5、隐式空闲链表</h3><h4 id="5-1-组织空闲块">5.1 组织空闲块</h4><p>假设用下图结构来组织堆块，并且已知采用双字对齐，头部后面的就是应用调用malloc时请求的有效载荷。</p><p><strong>双字对齐(Double Word Alignment)指的是数据在内存中的存储方式,使其地址是4字节(即32位)的倍数。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153323077.png" alt="image-20240621153323077"></p><p>分配器将堆组织为下图式样的一个连续的已分配块和空闲块的序列，该序列被称为<strong>隐式空闲链表</strong>。之所以称为隐式空闲链表是因为分配需要遍历堆中所有的块，才能知道空闲块的集合。注意，<strong>图中用一个已分配而大小为的零的块来标记结束</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153332878.png" alt="image-20240621153332878"></p><p>隐式空闲链表的有点是简单，缺点是放置开销会与已分配块和空闲块块的总数呈线性关系。</p><h4 id="5-2-放置已分配的块">5.2 放置已分配的块</h4><p>当应用发起一个分配请求时，分配器需要从空闲链表中选择一个合适的块来满足请求。分配器的选择方式称为<strong>放置策略</strong>。常见的放置策略有以下几种：</p><ul><li><strong>首次适配</strong>：从头开始搜索空闲链表，选择第一个遇见的合适的空闲块。它的优点在于趋向于将大的空闲块保留在链表的后面，缺点是它趋向于在靠近链表前部处留下小空闲块的碎片，从而增加较大请求块的放置时间。</li><li><strong>下一次适配</strong>：每次从上一次查询结束的地方开始进行搜索，直到遇见合适的空闲块。这种策略通常比首次适配效率高，但是内存利用率则要低得多了</li><li><strong>最佳适配</strong>：检查每个空闲块，选择适合所需请求大小的最小空闲块。最佳适配的内存利用率是三种策略中最高的，但它需要对堆进行彻底的搜索。</li></ul><h4 id="5-3-分割空闲块">5.3 分割空闲块</h4><p>分配器在匹配到一个合适的空闲块后，就需要决定分配这个空闲块中多少空间，可以称之为分割策略，一般有以下两种方式：</p><p>（1）选择用整个空闲块，这个方式简单而且快捷，缺点是可能会造成很多内部碎片。</p><p>（2）分配器嫁给你空闲块分为两个部分，第一部分变成分配块，而剩下的那部分则组织成一个新的空闲块。</p><h4 id="5-4-合并空闲块">5.4 合并空闲块</h4><p>为了避免假碎片问题，分配器需要在释放一个已分配块时，除了重新标记当前块外也需要合并相邻空闲块。合并空闲块的方式称为合并策略，主要分为两种：</p><p>（1）立即合并：就是在每次释放块时，就立即合并所有相邻块，这种方式可能会产生抖动（比如频繁在一个8字节的空闲块中执行3字节的分配与释放，就可能产生大量不必要的分割与合并）。</p><p>（2）推迟合并：即推迟合并空闲块的时机，比如直到某个分配请求失败才扫描整个堆，合并所有的空闲块。快速的分配器通常会选择某种形式的推迟合并。</p><h4 id="5-5-合并空闲块的具体实现">5.5 合并空闲块的具体实现</h4><p>对于向后合并，我们可以通过当前块的头部指针判断下一个块是否空闲，从而进行合并，但是如何合并前面的块呢？搜索整个链表？</p><p>Knuth提出了一种叫做<strong>边界标记</strong>的技术用于常数时间对前面的块进行合并。其实现如下图，通过在每个块的结尾处添加一个脚部，其是头部的一个副本。这样分配器就可以通过检查当前块的前一个字节的内容从而判断前一个块的起始位置和状态。</p><p>比如有一个释放当前块，其前一个块和后一块都是空闲的，此时需要将三块的大小求和然后更新前一块的头部和后一块脚部，明显能在常数时间内完成。</p><p>边界标记的一个缺陷是每一块都要保持一个头部和一个脚部，这会导致显著的内存开销。一种可能的优化方案是在已分配的块剩余部分保存脚部信息，从而减小开销。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153338881.png" alt="image-20240621153338881"></p><h3 id="6、显式空闲链表">6、显式空闲链表</h3><h4 id="6-1-空闲块组织">6.1 空闲块组织</h4><p>其实对于通用的分配器来说，隐式空闲链表是不适合的，一种更好的方法是将空闲块组织为某种形式的显式空闲链表。</p><p>如下图，我们用一个双向链表组织空闲块，为了节省空间，我们将前驱指针pred和后继指针succ放在空闲块的主体当中。双向链表使得首次适配的时间从块总数的线性时间减少到了空闲块总数的线性时间。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153345698.png" alt="image-20240621153345698"></p><p>在释放分配块时，有两种方式，分别为：</p><ul><li><strong>后进先出</strong>LIFO顺序维护链表：将新释放的块放在链表的开始处，加上边界标记后能快速合并完成并放置。</li><li><strong>按照地址顺序维护链表</strong>：这种方式使得每个块的地址都小于它后继的地址。释放一个块比较麻烦，但是首次适配有更高的内存利用率。</li></ul><p>显式空闲链表的需要存储前向和后向指针，这会限制最小块的大小，从而增加内存碎片。</p><h4 id="6-2-分离的空闲链表">6.2 分离的空闲链表</h4><p>为了减少分配时间，人们想出了另一种叫做<strong>分离存储</strong>的方法，主要是通过维护多个空闲链表，其中每个链表中的块有大致相等的大小。也即是分配器维护一个空闲链表数组，然后每个空闲链表中的空闲块按照大小进行升序排序。<strong>简单分离存储</strong>中采用的方式是每个空闲链中的空闲块大小一样，而<strong>分离适配</strong>方式的每个空闲链表中的块大小却不一样，这样适配时需要在空闲链表中进行匹配。</p><p>当有一个分配请求时，我们检查相应的空闲链表。如果链表非空，那么就分配其中第一块的全部。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，然后将这些块链接起来形成新的空闲链表。类型vector中的free list。</p><p>要释放一个块，分配器只需要简单地将这个块插入到相应的空闲链表的头部。</p><h3 id="7、垃圾收集">7、垃圾收集</h3><p>在编写C程序时，一般只能显式地分配与释放堆中的内存（malloc()与free()），程序员不仅需要分配内存，还需要负责内存的释放。但如果能自动回收是不是更好呢？</p><p><strong>垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块</strong>。这些块被称为垃圾，自动回收堆存储的过程叫做垃圾收集。接下来讨论一种垃圾收集算法——Mark&amp;Sweep法，可以称为标记清除法。</p><h4 id="7-1-垃圾收集器垃圾组织">7.1 垃圾收集器垃圾组织</h4><p>垃圾器将内存视为一张有向可达图，组织如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153351873.png" alt="image-20240621153351873"></p><p>垃圾收集器一般采用以下两种（之一）的策略来判断一块堆内存是否为垃圾内存：</p><ul><li>引用计数器：在数据的物理空间中添加一个计数器，当有其他数据与其相关时（引用），该计数器加一，反之则减一。通过定期检查计数器的值，只要为0则认为是垃圾内存，可以释放它所占用的已分配块。使用引用计数器，实现简单直接，但缺点也很明显，它无法回收循环引用的两个对象（假设有对象A与对象B，它们2个互相引用，但实际上对象A与对象B都已经是没用的对象了）。</li><li>可达性分析：垃圾收集器将堆内存视为一张有向图，然后选出一组根节点（例如，在Java中一般为类加载器、全局变量、运行时常量池中的引用类型变量等），根节点必须是足够“活跃“的对象。然后计算从根节点集合出发的可达路径，只要从根节点出发不可达的节点，都视为垃圾内存。</li></ul><h4 id="7-2-Mark-Sweep垃圾收集器">7.2 Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记阶段和清除阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。标记-清除算法实现简单，但它的效率不高，而且会产生许多内存碎片。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621153403384.png" alt="image-20240621153403384"></p><p>再介绍两种垃圾收集器进行回收的算法：</p><ul><li>复制：将程序所拥有的内存空间划分为大小相等的两块，每次都只使用其中的一块。当这一块的内存用完了，就把还存活着的对象复制到另一块内存上，然后将已使用过的内存空间进行清理。这种方法不必考虑内存碎片问题，但内存利用率很低。这个比例不是绝对的，像HotSpot虚拟机为了避免浪费，将内存划分为Eden空间与两个Survivor空间，每次都只使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一个Survivor空间上，然后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例为8：1，只有10%的内存空间会被闲置浪费。</li><li>分代：分代算法根据对象的存活周期的不同将内存划分为多块，这样就可以对不同的年代采用不同的回收算法。一般分为新生代与老年代，新生代存放的是存活率较低的对象，可以采用复制算法；老年代存放的是存活率较高的对象，如果使用复制算法，那么内存空间会不够用，所以必须使用标记-清除或标记-整理算法。</li></ul><h3 id="8、小结">8、小结</h3><p>本节主要讨论动态内存的分配与垃圾回收，主要是大概了解常见的内存管理方式。</p><p>学习自：<a href="https://wendeng.github.io/2019/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/#5%E3%80%81%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">第9章 虚拟内存之动态内存分配与垃圾收集</a></p>]]></content>
    
    
    <summary type="html">VM之动态内存分配</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL-第五章</title>
    <link href="https://penge666.github.io/posts/130ee7c0.html"/>
    <id>https://penge666.github.io/posts/130ee7c0.html</id>
    <published>2024-06-21T02:40:39.000Z</published>
    <updated>2024-06-21T03:23:30.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>所谓关联式容器，观念上类似于关联式数据库，每个元素都有一个键值key和一个实值value</strong>。当向容器插入元素时，容器根据其key值将实值放到适当的位置。关联式容器没有头尾的概念，所以也不会有push_front()，push_back()等操作函数。</p><p>STL关联容器分为set（集合）和map（映射表）两大类，及其衍生体multiset和multimap。这些容器的底层机制均以RB-tree（红黑树）实现。RB-tree也是一个独立容器，但并不开放使用。</p><p>SGI STL还提供一个不在标准规格的关联式容器 hash_table（散列表），以及以 hash_table 为底层机制而完成的 hash_set散列集合、hash_map散列映射表、hash_multiset散列多键集合、hash_multimap散列多键映射表。</p><p>本章我们将主要学习各种容器对应的底层实现原理和应该注意的地方。</p><h3 id="1、树的基本的概念"><a href="#1、树的基本的概念" class="headerlink" title="1、树的基本的概念"></a>1、树的基本的概念</h3><p>一个关于树的比较重要且容易模糊的概念是：</p><ul><li>节点路径长度（也叫深度）：根节点到当前节点所经过的边数和。</li><li>节点的高度：某节点至其最远叶子节点的路径长度的值。</li></ul><p>二叉搜索树在一些情况下不能很好地保持平衡性，所以引入了AVL树（带额外平衡条件的二叉搜索树），其保证任意节点的左右两颗子树的高度差不超过1，这就要求每插入一个节点<br>时都需要进行调整以保证平衡性。调整分为四种情况对应两种调整方式：单旋转和双旋转。</p><p>AVL的不足之处在于过分追求平衡，从而导致插入效率变低，在不大影响查找效率的基础上同时满足大概的平衡就好了，于是人们引入了RB-Tree。</p><h3 id="2、RB-tree"><a href="#2、RB-tree" class="headerlink" title="2、RB-tree"></a>2、RB-tree</h3><p>RB-tree（红黑树）是一种被广泛使用的平衡二搜索树，其通过一些着色法则确保没有一条路径会比其它路径长两倍，从而达到接近平衡目的。RB-tree必须满足以下规则：</p><p>（1）每个节点不是红色就是黑色；</p><p>（2）根节点为黑色；</p><p>（3）如果节点为红，其子节点必须为黑；</p><p>（4）任一节点至NULL（树尾端）的任何路径，所含之黑节点数必须相同。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621105234761.png" alt="image-20240621105234761"></p><p>根据规则（4），新增节点必须为红，根据规则（3），新增节点之父节点必须为黑。当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调整颜色并旋转树形。</p><h4 id="2-1-RB-tree效率所在"><a href="#2-1-RB-tree效率所在" class="headerlink" title="2.1 RB-tree效率所在"></a>2.1 RB-tree效率所在</h4><p>红黑树之所以为红黑树的原因：红黑颜色用来检测树的平衡性，达到AVL树的平衡要求，降低了对旋转的要求，从而提高了统计性能。红黑树相对AVL树能够给我们一个比较便宜的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更好。</p><p>RB-tree不仅在树性的平衡上表现不错，在效率表现和实现复杂度上也保持相当的平衡，所以运用甚广。主要用于存储有序的数据，它的时间复杂度为O(logn)效率非常之高，Java集合中的TreeSet和TreeMap，C++的STL中的set，map以及Linux虚拟内存的管理，都通过红黑树去实现。</p><h4 id="2-2-RB-tree插入节点的调整"><a href="#2-2-RB-tree插入节点的调整" class="headerlink" title="2.2 RB-tree插入节点的调整"></a>2.2 RB-tree插入节点的调整</h4><p>假设新节点为X，其父节点为P，祖父节点为G，伯父节点（父节点的兄弟节点）为S，曾祖父节点为GG。当向RB插入一个节点时，主要讨论四种情况：</p><ul><li>（1）状况1：S为黑且X为外侧插入。对此情况，先对P,G做一次单选转，再更改P,G颜色，即可重新满足红黑树的规则3。</li><li>（2）状况2：S为黑且X为内测插入。对此情况，必须现对P,X做一次单选转并更改G,X颜色，再将结果对G做一次单选转，即可再次满足红黑树规则3。</li><li>（3）状况3：S为红且X为外侧插入。对此情况，现对P和G做一次单选转，并改变X的颜色。此时如果GG为黑，一切搞定，但如果GG为红，则问题比较大，见状况4。</li><li>（4）状况4：S为红且X为外侧插入。对此情况，先对P和G做一次单选转，并改便X的颜色。此时如果GG也为红。害的持续网上做，直到不再有父子连续为红的情况。</li></ul><p>红黑树删除基本思想是：删除后，用其子树替换，这部分与二叉搜索树的删除的思想本质一样，但是红黑树删除后，可能会破坏红黑树的性质，此时就需要进行树的调整操作即可。</p><h4 id="2-3-RB-tree节点设计和迭代器"><a href="#2-3-RB-tree节点设计和迭代器" class="headerlink" title="2.3 RB-tree节点设计和迭代器"></a>2.3 RB-tree节点设计和迭代器</h4><p>RB-tree有红黑二色，并且拥有左右子节点，很容易勾勒出其结构风貌。实现上，为了有更大的弹性，节点分为两层。同时由于RB-tree的各种操作时常需要上溯其父节点，所以特别在数据结构中安排了一个parent指针。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621105252305.png" alt="image-20240621105252305"></p><p>SGI将RB-tree迭代器实现分为两层。上图是两层节点结构和双层迭代器结构间的关系，其中_ rb_tree_node继承自rb_tree_node_base，rb_tree_iterator继承自_rb_tree_base_iterator。</p><h4 id="2-4-RB-tree的元素插入接口"><a href="#2-4-RB-tree的元素插入接口" class="headerlink" title="2.4 RB-tree的元素插入接口"></a>2.4 RB-tree的元素插入接口</h4><p>RB-tree提供两种插入操作：insert_unique()和insert_equal()，前者标识被插入节点的键值（key）在整棵树中必须独一无二,如果整棵树中已存在相同的键值，插入操作就不会真正进行;后者标识被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功。</p><p>当然插入元素后是需要对RB-tree进行调整的，这里不进行讲解了。</p><h3 id="3、set和multiset"><a href="#3、set和multiset" class="headerlink" title="3、set和multiset"></a>3、set和multiset</h3><p>set的所有特性可以归纳为以下几点：</p><p>（1）所有元素都会根据元素的键值自动被排序。</p><p>（2）set是集合，它的元素的键值就是实值，实值就是键值，不允许两个元素有相同的值。</p><p>（3）<strong>不可以通过set的iterator来改变元素的值，因为set的元素值就是键值，改变键值会违反元素排列的规则</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  *it = (*it) * <span class="number">2</span>; <span class="comment">// 编译错误，set的元素不能被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; new_s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  new_s.<span class="built_in">insert</span>((*it) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>是C++中的一个关联容器，它包含的元素都是唯一的，且自动按照顺序排序。这个规则是由<span class="built_in">set</span>的内部实现决定的，它使用了一种名为红黑树的数据结构。在红黑树中，每个节点的键值对应着<span class="built_in">set</span>中的一个元素，而且这些节点按照键值的大小进行排序。</span><br><span class="line">当我们试图改变<span class="built_in">set</span>中的一个元素值时，实际上就是试图改变红黑树中的一个节点的键值。但是，由于红黑树中的节点是按照键值大小排序的，所以如果我们改变了一个节点的键值，就可能破坏树的排序，使得它不再满足红黑树的性质。</span><br><span class="line">举个简单的例子，比如我们有一个<span class="built_in">set</span>，它包含三个元素：1，2，3，对应着红黑树中的三个节点。这三个节点是按照键值大小排序的：1 &lt; 2 &lt; 3。如果我们试图将元素2改为4，那么原本的排序就会被破坏：1 &lt; 4 &lt; 3，这就不再满足红黑树的性质了。</span><br><span class="line">因此，为了保持<span class="built_in">set</span>的顺序性和元素唯一性，我们不能通过迭代器来直接改变<span class="built_in">set</span>中的元素值。如果我们需要改变元素值，可以先删除原来的元素，然后再插入新的元素。</span><br></pre></td></tr></table></figure><p>（4）<strong>在客户端对set进行插入或删除操作后，之前的迭代器依然有效。当然，被删除的元素的迭代器是个例外。</strong></p><p>解释：在C++的<code>set</code>容器中，元素的插入和删除操作都是通过调整红黑树的节点来完成的，而不是通过移动元素。这就意味着当你插入或删除元素时，其他元素的位置并不会发生改变，所以指向这些元素的迭代器依然有效。</p><p>（5）它的底层机制是RB-tree，几乎所有的操作都只是转调用RB-tree的操作行为而已。</p><p>（6）set提供的算法包括交集、并集、差集、对称差集等。</p><p>multiset和set几乎一样，唯一的区别是，multiset允许键值重复。因此set使用底层RB-tree的insert_unique()实现插入，而multiset插入采用的是RB-tree的insert_equal()而非insert_unique()。</p><h3 id="4、map和multimap"><a href="#4、map和multimap" class="headerlink" title="4、map和multimap"></a>4、map和multimap</h3><p>map的特性可以归纳为以下几条：</p><p>（1）所有元素都会根据元素的键值自动被排序。</p><p>（2）map的所有元素都是pair，第一个值是键值，第二个是实值。</p><p>（3）map不允许两个元素拥有相同的键值。</p><p>（4）可以通过map的迭代器来改变元素的实值，但不可以改变键值，那样会违反元素的排列规则。</p><p>（5）在客户端对map进行插入或删除操作后，之前的迭代器依然有效。当然，被删除的元素的迭代器是个例外。</p><p>（6）它的底层机制是RB-tree。几乎所有的操作都只是转调用RB-tree的操作行为而已。</p><p>multimap和map几乎一样，唯一的区别是，multimap允许键值重复。因此map使用底层RB-tree的insert_unique()实现插入，而multimap插入采用的是RB-tree的insert_equal()而非insert_unique()。</p><h3 id="5、hashtable"><a href="#5、hashtable" class="headerlink" title="5、hashtable"></a>5、hashtable</h3><p>二叉搜索树具有对数平均时间的表现，但这样的表现依赖于一个假设：<strong>输入的数据有足够的随机性</strong>。本节要结束一种名为hash table(散列表)的数据结构，这种结构使得插入、删除、搜寻等操作上都具有“常数平均时间”的表现，而且这种表现以统计为基础，不依赖于输入元素的随机性。</p><h4 id="5-1-hashtable的散列函数和碰撞冲突问题"><a href="#5-1-hashtable的散列函数和碰撞冲突问题" class="headerlink" title="5.1 hashtable的散列函数和碰撞冲突问题"></a>5.1 hashtable的散列函数和碰撞冲突问题</h4><p>hashtable可以提供对任意有名项的存取和删除操作，这种结构的用意在于提供常数时间的的基本操作，而不依赖于插入元素的随机性，是以统计为基础的。</p><p>为了将特定键值key输入转为hash table的索引，就需要<strong>散列函数hash function</strong>，其主要负责将某一元素映射为一个”大小可接受之索引”。使用hash function带来的问题：可能有不同元素映射到相同的位置，即具有相同索引，这便是<strong>碰撞或冲突问题</strong>。</p><p>解决碰撞问题的方法常见的有线性探测、二次探测、开链等。<strong>stl hashtable采用的hash方式是开链法</strong>。</p><ul><li>（1）线性探测：当hash function计算出某个元素的插入位置，而该位置空间不再可用时，就循序往下一一寻找，直到找到一个可用空间为止。线性探测会造成<strong>主集团问题</strong>：平均插入成本的成长幅度，远高于<strong>负载系数</strong>的成长幅度。</li><li>（2）二次探测：主要用来解决主集团问题。解决碰撞的方程式为F(i) = i^2。如果hash function计算出新元素的位置为H,而该位置实际上已被使用，那么就依次尝试H+1^2,H+2^2,H+3^2,H+4^2,….,H+i^2，而不像线性探测尝试的是H+1,H+2,H+3,H+4,….,H+i。<strong>二次探测可以消除主集团，却可能造成次集团</strong>：两个元素经hash function计算出来的位置若相同，则插入时所探测的位置也相同，形成某种浪费。消除次集团的方法如复式散列。</li><li>（3）开链：这种做法是在每一个表格元素中维护一个list。hash function为选择某一个list，然后我们在那个list身上执行元素的插入、搜寻、删除等操作。若list够短，速度还是够快。使用开链法，表格的负载系数将大于1。</li></ul><h4 id="5-2-STI-STL的hashtable的数据结构"><a href="#5-2-STI-STL的hashtable的数据结构" class="headerlink" title="5.2 STI STL的hashtable的数据结构"></a>5.2 STI STL的hashtable的数据结构</h4><p>SGI STL中hash table使用的是开链法进行的冲突处理，其结构如图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621110618363.png" alt="image-20240621110618363"></p><p><strong>bucket所维护的linked list不采用STL的list或者slist，而是自行维护hash table node</strong>。而至于<strong>buckets聚合体，则使用vector来完成</strong>，以便有动态扩容能力。</p><p>STL中的hash迭代器，是一种forward迭代器，只能++。有指向当前节点的指针和指向对应的vector的指针，没有后退操作，也就是没有所谓的逆向迭代器。有过next到list的尾端，就跳至下一个bucket。</p><p>设计思想：hashtable以质数来设计表格大小，预先计算好了28个质数，以备随时访问，大约都是两倍的关系递增，同时提供一个函数，查询28个质数中“最接近某数且大于某数”的质数作为vector的长度，如果需要重新分配，则分配下一个质数长度的vector。<br><strong>stl hash table扩张表格的触发条件是：当元素的数目大于或等于表格的大小</strong>。（这个条件应该是为了保证常数操作时间，在统计基础上得出的）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240621110704901.png" alt="image-20240621110704901"></p><p>insert分为insert_unique和insert_equal操作，前者保证插入的数不能有重复，后者可以插入键值相同的数。可以先用unique之后再用equal。insert_unique：先调用resize函数，看是否需要增大vector，然后插入，vector的索引通过取余得到。</p><p>resize：如果已有元素的个数大于vector的size，需要根据得到的最新质数，分配新的空间，将在旧空间的元素，重新计算hash，复制到新的空间，最后旧空间与新空间swap一下即可。insert_equal:也是先调用resize，遍历找到和他相同的节点，在该节点的前面插入。</p><p><strong>hashtable有一些无法处理的型别，比如string，double，float。除非用户为那些型别写了相应的hash function</strong>。</p><h3 id="6、hash-set和hash-multiset"><a href="#6、hash-set和hash-multiset" class="headerlink" title="6、hash_set和hash_multiset"></a>6、hash_set和hash_multiset</h3><p><strong>hash_set是以hashtable为底层机制</strong>。因hash_set所供应的操作接口，hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为。</p><p>set是为了能够快速搜寻元素。其底层是Rb-tree有自动排序功能，但hashtable没有自动排序功能，故hash_set没有自动排序功能。hash_set和set一样，元素的键值就是实值，实值就是键值。hash_set和set使用方式基本相同。</p><p><strong>hash_multiset和multiset完全相同</strong>，唯一差别是底层实现机制不同，hash_multiset的底层实现机制是hashtable，multiset的底层实现机制是Rb-tree。<strong>hash_multiset和hash_set实现上的唯一差别是</strong>，hash_set的插入操作采用hashtable中的insert_unique()，而hash_multiset的插入操作采用hashtable中的insert_euqal()。hash_multiset和hash_set使用方式基本相同。</p><p>解释：</p><p><code>set</code>是基于红黑树实现的，红黑树是一种自平衡二叉搜索树，它可以保证元素按照一定的顺序排列。因此，<code>set</code>中的元素是自动排序的。在<code>set</code>中插入、删除和查找元素的时间复杂度都是O(log n)。</p><p><code>hash_set</code>是基于哈希表实现的。哈希表是一种使用哈希函数将元素映射到表中一个位置的数据结构，因此，<code>hash_set</code>中的元素不是有序的。在理想情况下，<code>hash_set</code>中插入、删除和查找元素的时间复杂度都是O(1)，但这取决于哈希函数的质量和哈希表的负载因子。如果哈希函数的质量不好，或者哈希表的负载因子过高，那么这些操作的时间复杂度可能会增大</p><p><strong>输出是无序的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> si:s) </span><br><span class="line">cout&lt;&lt;si&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较：</p><ol><li><code>set</code>：<ul><li>查找、插入和删除操作的时间复杂度都是O(log n)。</li><li><code>set</code>是基于红黑树实现的，因此元素会自动排序。</li><li>如果你的应用需要有序的数据，并且/或者你预期会有大量的查找操作，那么<code>set</code>可能是更好的选择。</li></ul></li><li><code>hash_set</code>：<ul><li>在理想情况下（也就是哈希函数的质量好，哈希冲突少），查找、插入和删除操作的时间复杂度都是O(1)。但如果哈希冲突多，最坏的情况下，这些操作的时间复杂度可能会达到O(n)。</li><li><code>hash_set</code>是基于哈希表实现的，因此元素不会自动排序。</li><li>如果你的应用不需要有序的数据，且预期会有大量的插入和删除操作，那么<code>hash_set</code>可能提供更好的性能。</li></ul></li></ol><h3 id="7、hash-map和hash-multimap"><a href="#7、hash-map和hash-multimap" class="headerlink" title="7、hash_map和hash_multimap"></a>7、hash_map和hash_multimap</h3><p>hash_map的底层实现机制也是hashtable。故hash_map所供应的操作接口，hashtable都提供了，所以几乎所有的hash_map操作行为，都只是转调用hashtable的操作行为而已。</p><p>map能够根据键值快速搜索元素，其底层实现机制是Rb-tree，Rb-tree具有自动排序功能，故map具有自动排序功能，但hashtable没有自动排序功能，故hash_map没有自动排序功能。hash_map和map都有相同的特性，即每一个元素都同时拥有一个实值（value）和一个键值（key）。hash_map和map使用方式大体相同。</p><p><strong>hash_multimap的特征与multimap完全相同</strong>，唯一差别为它的底层实现机制是hashtable，故hash_multimap的元素并不会被自动排序<strong>。hash_multimap和hash_map实现上的唯一差别是</strong>，hash_multimap的插入操作使用底层机制hashtable中的insert_equal()，而hahs_map使用的是底层机制hashtable中的insert_unique()。hash_multimap使用方式与hash_map完全相同。</p><h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><p>在实际使用过程中，到底选择这几种容器中的哪一个？通常应该根据遵循以下原则：</p><p>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p><p>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p><p>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p><p>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p><p>（5）如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p><p>学习自：<a href="https://wendeng.github.io/2019/05/18/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC5%E7%AB%A0%20%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/">《STL源码剖析》第5章 关联式容器</a></p>]]></content>
    
    
    <summary type="html">STL-关联式容器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://penge666.github.io/posts/d5c4ed7d.html"/>
    <id>https://penge666.github.io/posts/d5c4ed7d.html</id>
    <published>2024-06-20T02:52:56.000Z</published>
    <updated>2024-06-20T03:50:16.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树为何必须掌握？">红黑树为何必须掌握？</h2><p>来看看，红黑树的广泛的应用</p><ul><li>JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树</li><li>Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构</li><li>Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。</li><li>多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。</li></ul><p>面试过程中，HashMap 常常是面试的重点， 而且会以<strong>连环炮 的方式</strong>进行发问，</p><p>所以， <strong>红黑树基本是 面试必须的 要点</strong>， <strong>如果 答不上来，面试就有 很大程度 就黄了</strong>。</p><p>红黑树，又比较复杂，有非常多的场景, 大家记住不容易。</p><h3 id="本文的介绍次序">本文的介绍次序</h3><p>本文，从 BST二叉查找树， 到AVL 平衡二叉树， 再到 RBT 红黑树，</p><p>为大家 做好 <strong>清晰的场景分析</strong>， 帮助大家记忆。</p><h2 id="BST二叉查找树">BST二叉查找树</h2><h3 id="什么是二叉查找树呢？">什么是二叉查找树呢？</h3><p>二叉查找树（BST）具备以下特性：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ol><h3 id="二叉搜索树-BST的完美情况">二叉搜索树 BST的完美情况</h3><p>一般人们理解的二叉树（<strong>又叫二叉搜索树 BST</strong>）会出现一个问题，完美的情况下，它是这样的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105359350.png" alt="image-20240620105359350"></p><h3 id="二叉搜索树的查找流程"><strong>二叉搜索树的查找流程</strong></h3><p>如何查找值为7的节点？<br>1.查看根节点8，因为7&lt;8，所以再查看它的左子节点6<br>2.查看左子节点6，因为7&gt;6，所以再查看它的右子节点7<br>3.查看右子节点7，因为7=7，所以就找到啦，</p><h3 id="二叉搜索树的极端情况">二叉搜索树的极端情况</h3><p>二叉查找树是有缺点的，在不断插入的时候，**有可能出现这样一种情况：**很容易“退化”成链表，</p><p>如果bst 树的节点正好从大到小的插入，此时树的结构也类似于链表结构，这时候的查询或写入耗时与链表相同。</p><h4 id="退化成为了-链表的特殊BST">退化成为了 链表的特殊BST</h4><p>一颗特殊BST，退化成为了 链表，如下图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105443483.png" alt="image-20240620105443483"></p><p>它和链表一样，搜索的时候，最坏情况的时间复杂度O(n) 。</p><h4 id="那么我们怎么避免这种情况呢？">那么我们怎么避免这种情况呢？</h4><p>为了避免这种特殊的情况发生，引入了平衡二叉树（AVL）和红黑树（red-black tree）。</p><p>AVL 、rbt 都是通过本身的建树原则来控制树的层数和节点位置，</p><p>因为rbtree是由AVL演变而来，所以我们从了解AVL开始。</p><h2 id="AVL平衡二叉树">AVL平衡二叉树</h2><p>平衡二叉树也叫AVL（发明者名字简写），也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡。</p><blockquote><p>AVL树是最先发明的自平衡二叉查找树。</p><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。</p><p>增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p></blockquote><h3 id="AVL树的特性">AVL树的特性</h3><p>AVL树本质上还是一棵二叉搜索树，它有以下特性：</p><ul><li>特性1： 对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li><li>特性2：对于AVL树而言，其中任何子树仍然是AVL树；</li><li>特性3：每个节点的左右子节点的高度之差的绝对值最多为1；</li></ul><blockquote><p>特性1表明，AVL 继承于 BST , 所以:</p><p>1.AVL本身首先是一棵BST 二叉搜索树。<br>2.AVL带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p></blockquote><p>在插入、删除树节点的时候，如果破坏了以上的原则，<strong>AVL树会自动进行调整</strong>使得以上三条原则仍然成立。</p><p>也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。</p><h3 id="AVL树的平衡功能">AVL树的平衡功能</h3><p>举个例子，下左图为AVL树最长的2节点与最短的8节点高度差为1；</p><p>当插入一个新的节点后，根据上面第一条原则，它会出现在2节点的左子树，但这样一来就违反了原则3。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105501175.png" alt="image-20240620105501175"></p><p>此时AVL树会通过节点的旋转进行进行平衡，</p><p>AVL调整的过程称之为左旋和右旋，</p><h3 id="AVL平衡的调整过程">AVL平衡的调整过程</h3><p><strong>旋转之前，首先确定旋转支点（pivot）：</strong> 这个旋转支点就是失去平衡这部分树，在自平衡之后的根节点，</p><p>平衡的调整过程，需要根据pivot它来进行旋转。</p><p>我们在学习AVL树的旋转时，不要将失衡问题扩大到整个树来看，这样会扰乱你的思路，</p><p>我们只关注<strong>失衡子树的根结点</strong> 及它的子节点和孙子节点即可。</p><p>事实上，AVL树的旋转，我们权且叫“AVL旋转”是有规律可循的，因为只要聚焦到**失衡子树，**然后进行左旋、右旋即可。</p><blockquote><p>很多人在左旋和右旋有时候弄不明白，</p><p>其实左旋就是逆时针转，右旋是顺时针转</p></blockquote><h2 id="AVL子树失衡的四大场景">AVL子树失衡的四大场景</h2><p>导致AVL失衡的场景就是有限的4个：</p><ul><li>左左结构失衡（LL型失衡）</li><li>右右结构失衡（RR型失衡）</li><li>左右结构失衡（LR型失衡）</li><li>右左结构失衡（RL型失衡）</li></ul><p>删除元素，也会导致AVL失衡，需要再平衡，但是原理和插入元素是类似的。</p><p>这里聚焦 介绍插入元素的平衡过程， 删除元素，不做介绍。</p><h3 id="场景1-LL型失衡-左左结构失衡（右旋）：">场景1: LL型失衡-左左结构失衡（右旋）：</h3><blockquote><p>场景： 插入的元素在子树root的左侧不平衡元素的左侧</p><p>此时，以root的左儿为支点，也就是，左侧的不平衡元素为pivot(支点), 进行右旋</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105528496.png" alt="image-20240620105528496"></p><blockquote><p>右旋过程中，如果pivot有右子树，则作为 原root的 左子树， 保障AVL的特性1</p></blockquote><h4 id="记忆要点">记忆要点</h4><p>尼恩备注记忆要点，LL型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，与失衡的方向相反，</p><p>LL 型失衡，与左边 相反的方向， 是右边，所以是右旋</p></blockquote><h3 id="场景2-RR型失衡：右右结构失衡（左旋）">场景2 RR型失衡：右右结构失衡（左旋）</h3><blockquote><p>场景：插入的元素在子树root右侧的不平衡子树的右侧</p><p>此时，以root的右儿为支点，也就是，右侧的不平衡元素 为 pivot(支点)， 进行左旋</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105559041.png" alt="image-20240620105559041"></p><blockquote><p>左旋过程中，如果pivot有左子树，则作为 原root的 右子树，</p><p>保障AVL的特性1，</p></blockquote><h4 id="记忆要点-2">记忆要点</h4><p>尼恩备注记忆要点，RR型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RR 型失衡，与右边 相反的方向， 是左边，所以是左旋</p></blockquote><h3 id="场景3-LR型失衡：左右结构失衡（左旋-右旋）："><strong>场景3 LR型失衡：左右结构失衡（左旋+右旋）：</strong></h3><blockquote><p>场景： 插入的元素在左侧的不平衡元素的右侧</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105626532.png" alt="image-20240620105626532"></p><h4 id="记忆要点-3">记忆要点</h4><p>尼恩备注记忆要点，LR型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>LR型失衡，与只相反的方向是 RL，但是先旋转底部，再旋转顶部，RL进行次序颠倒，LR</p><p>所以， LR型失衡，旋转的方式，是先左旋， 再右旋</p></blockquote><h3 id="场景4-RL失衡-右左结构-（右旋-左旋）："><strong>场景4 RL失衡: 右左结构 （右旋+左旋）：</strong></h3><p>场景： 插入的元素在右侧的不平衡元素的左侧</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105648900.png" alt="image-20240620105648900"></p><h4 id="记忆要点-4">记忆要点</h4><p>尼恩备注记忆要点，RL型失衡怎么 平衡呢？</p><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RL型失衡，与只相反的方向是 LR，但是先旋转底部，再旋转顶部，所以，LR进行次序颠倒，RL</p><p>最终， RL型失衡，旋转的方式，是先右旋， 再左旋</p></blockquote><h3 id="AVL树平衡总结">AVL树平衡总结</h3><p>可见无论哪种情况的失衡，都可以通过旋转来调整。</p><p>不难看出，旋转在图上像是将pivot(支点)节点向上提（将它提升为root节点），而后两边的节点会物理的分布在新root节点的两边，</p><p>接下来按照AVL二叉树的要求：</p><blockquote><p>左子树小于root，右子树大于root进行调整。</p></blockquote><p>从图LL结构可以看出，当右旋时原来pivot（7）的右子树（8）会转变到原root点（9）的左子树处；</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105713476.png" alt="image-20240620105713476"></p><p>从图右右结构可见，当左旋时，原来pivot（18）的左子树会分布到原root点（9）的右子树。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620105728010.png" alt="image-20240620105728010"></p><p>对于左右结构和右左结构无非是经过多次旋转达到稳定，旋转的方式并没有区别，</p><p>AVL树本质上还是一棵<strong>二叉搜索树</strong>，它有以下特性：<br>1.本身首先是一棵二叉搜索树。<br>2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p><p>也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。</p><h3 id="AVL树的删除">AVL树的删除</h3><p><strong>删除的判断标准</strong></p><ol><li>要删除的节点是什么类型的节点？；</li><li>删除后是否会破坏平衡 ；</li></ol><p><strong>节点类型</strong></p><ol><li>叶子节点；</li><li>节点只有左子树或只有右子树 ；</li><li>既有左右子树都有。</li></ol><p><strong>处理的思路</strong></p><ol><li>当删除为叶子节点，则直接删除，并从父亲节点开始往上看，判断是否失衡；如果没有失衡，再判断父亲的父节点是否失衡，直到根节点。若失衡则判断失衡类型（LL、LR、RR、RL），再进行相应的调整。</li><li>删除的节点只有左子树或只有右子树，那么将节点删除，以左子树或右子树进行代替，并进行相应的平衡判断，若失衡则调整，一直到根节点 ；</li><li>删除的节点既有左子树又有右子树，找到其前驱或者后驱节点将其替换，再判断是否失衡，然后根据失衡情况调整，直到根节点。</li></ol><h2 id="常见AVL面试题">常见AVL面试题</h2><h3 id="问：什么是AVL左旋和右旋？">问：什么是AVL左旋和右旋？</h3><blockquote><p>加入节点后，左旋和右旋 ，维护AVL平衡性</p></blockquote><p>右旋转</p><p>场景： 插入的元素在不平衡元素的左侧的左侧</p><blockquote><p>x.right = y</p><p>y.left = xxx(原x.right)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对节点y进行向右旋转操作，返回旋转后新的根节点x</span><br><span class="line">         y                             x</span><br><span class="line">        / \                          /   \</span><br><span class="line">       x   <span class="variable constant_">T4</span>     向右旋转 (y)        z     y</span><br><span class="line">      / \       - - - - - - - -&gt;    <span class="regexp">/ \   /</span> \</span><br><span class="line">     z   <span class="variable constant_">T3</span>                       <span class="variable constant_">T1</span>  <span class="variable constant_">T2</span> <span class="variable constant_">T3</span> <span class="variable constant_">T4</span></span><br><span class="line">    / \</span><br><span class="line">  <span class="variable constant_">T1</span>   <span class="variable constant_">T2</span></span><br></pre></td></tr></table></figure><blockquote><p>场景：插入的元素在不平衡元素的右侧的右侧</p><p>// 向左旋转过程</p><p>x.left = y;</p><p>y.right =(原x.left )</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对节点y进行向左旋转操作，返回旋转后新的根节点x</span><br><span class="line">        y                             x</span><br><span class="line">      /  \                          /   \</span><br><span class="line">     <span class="variable constant_">T1</span>   x      向左旋转 (y)       y     z</span><br><span class="line">         / \   - - - - - - - -&gt;   <span class="regexp">/ \   /</span> \</span><br><span class="line">       <span class="variable constant_">T2</span>  z                     <span class="variable constant_">T1</span> <span class="variable constant_">T2</span> <span class="variable constant_">T3</span> <span class="variable constant_">T4</span></span><br><span class="line">          / \</span><br><span class="line">         <span class="variable constant_">T3</span> <span class="variable constant_">T4</span></span><br></pre></td></tr></table></figure><h3 id="AVL树的问题">AVL树的问题</h3><p>既然AVL树可以保证二叉树的平衡，这就意味着AVL搜索的时候，它最坏情况的时间复杂度O(logn) ，要低于普通二叉树BST和链表的最坏情况O(n)。</p><p>那么HashMap直接使用AVL树来替换链表就好了，为什么选择用红黑树呢？</p><p>原因是：</p><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;= 1，</p><p>所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p><p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是 <strong>增加删除 频繁</strong>的场景。</p><p><strong>红黑树(rbt)做了什么优化呢？</strong></p><p>红黑树(rbt)继承了AVL可自平衡的优点，</p><p>同时, 红黑树(rbt)在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除 频繁</strong>的场景。</p><p>在实际应用中，红黑树的使用要多得多。</p><h2 id="红黑树（RBTree）">红黑树（RBTree）</h2><p>红黑树是一种特化的AVL树（平衡二叉树）</p><p>红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）.</p><p>在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”.</p><h3 id="什么是红黑树？">什么是红黑树？</h3><p>红黑树也是一种自平衡二叉查找树，它与AVL树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。</p><p>与AVL树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时<strong>较少的旋转</strong>操作，整体来说性能要优于AVL树。</p><p>虽然RBTree是复杂的, 但它的<strong>最坏情况运行时间</strong>也是非常良好的,并且在实践中是高效的：</p><blockquote><p>它可以在<strong>O(log n)<strong>时间内做查找,插入和删除,这里的</strong>n 是树中元素的数目.</strong></p></blockquote><h3 id="红黑树的特性">红黑树的特性</h3><p>红黑树是实际应用中最常用的平衡二叉查找树，它不严格的具有平衡属性，但平均的使用性能非常良好。</p><p>在红黑树中，节点被标记为红色和黑色两种颜色。</p><p>红黑树的原则有以下几点：</p><ul><li>特性1：节点非黑即红</li><li>特性2：根节点一定是黑色</li><li>特性3：叶子节点（NIL）一定是黑色</li><li>特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620110228778.png" alt="image-20240620110228778"></p><p><strong>红色属性</strong> 说明，红色节点的孩子，一定是黑色。 但是，RBTree 黑色节点的孩子，可以是红色，也可以是黑色，具体如下图。</p><p><strong>叶子属性</strong> 说明， 叶子节点可以是空nil ，AVL的叶子节点不是空的，具体如下图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620112849376.png" alt="image-20240620112849376"></p><p><strong>Note：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</strong></p><blockquote><p><strong>Q&amp;A环节</strong></p></blockquote><p><strong>疑问</strong>：为什么红黑树的特性：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。可以保证 从根节点到叶子节点的最长可能路径不会超过最短可能路径的两倍长度。</p><p><strong>解释：</strong></p><p>首先，我们需要明白这个性质的含义：在从根节点到任何叶子节点的所有路径中，黑色节点的数量是相同的。</p><p>那么，考虑红黑树的两个规则：</p><ol><li>每个节点不是红色就是黑色。</li><li>不允许有两个连续的红色节点（即，红色节点的子节点也不能是红色）。</li></ol><p>基于这两点，我们可以得出以下结论：</p><ul><li>最短的可能路径全是黑色节点（因为不能有两个连续的红色节点）。</li><li>最长的可能路径是红色和黑色节点交替（因为不能有两个连续的红色节点）。</li></ul><p>因此，从根节点到叶子节点的最长可能路径（红黑交替）长度是最短可能路径（全黑）长度的两倍。这就是为什么红黑树的性质能保证树的高度平衡，进而保证了查找、插入和删除操作的效率。</p><p>插入的操作</p><p>基于上面的原则，我们一般在插入红黑树节点的时候，会将这个节点设置为红色，</p><p>原因参照最后一条原则： <strong>红色破坏原则的可能性最小</strong>，如果是黑色, 很可能<strong>导致这条支路的黑色节点比其它支路的要多1</strong>，破坏了平衡。</p><h4 id="记忆要点：">记忆要点：</h4><p>可以按照括号里边的分类，记住 红黑树的几个原则：</p><ul><li>（<strong>颜色属性</strong>）性质1：节点非黑即红</li><li>（<strong>根属性</strong>）性质2：根节点一定是黑色</li><li>（<strong>叶子属性</strong>）性质3：叶子节点（NIL）一定是黑色</li><li>（<strong>红色属性</strong>）性质4：每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>**（黑色属性）性质5：**从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p>黑色属性，可以理解为<strong>平衡特征</strong>， 如果满足不了平衡特征，就要进行平衡操作。</p><p><strong>空间换时间</strong></p><p>RBT有点属于一种<strong>空间换时间</strong>类型的优化，</p><p>在avl的节点上，增加了 <strong>颜色属性的 数据</strong>，相当于 增加了空间的消耗。 通过颜色属性的增加， 换取，后面平衡操作的次数 减少。</p><h3 id="黑色完美平衡">黑色完美平衡</h3><p>红黑树并不是一颗<strong>AVL平衡二叉搜索树</strong>，从图上可以看到，根节点P的左子树显然比右子树高</p><p>根据 红黑树的特性5，从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点， 说明：</p><blockquote><p>rbt 的 左子树和右子树的黑节点的层数是相等的</p><p>红黑树的平衡条件，不是以整体的高度来约束的，而是以黑色 节点的 高度，来约束的。</p></blockquote><p>所以称红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113125056.png" alt="image-20240620113125056"></p><p>看看<strong>黑色完美平衡</strong>的效果，</p><p>去掉 rbt中的红色节点，会得到 一个四叉树， 从根节点到每一个叶子，高度相同，就是rbt的root到叶子的黑色路径长度。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113216714.png" alt="image-20240620113216714"></p><h2 id="红黑树的恢复平衡过程的三个操作">红黑树的恢复平衡过程的三个操作</h2><p>一旦红黑树5个原则有不满足的情况，我们视为平衡被打破，如何 恢复平衡？</p><p>靠它的三种操作：<strong>变色、左旋、右旋</strong>。</p><h3 id="1-变色">1.变色</h3><p>节点的颜色由红变黑或由黑变红。（这个操作很好了解）</p><h3 id="2-左旋">2.左旋</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的左子树（左旋），pivot的原左子树变成 原root节点的 右子树，pivot的原右子树保持不变。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113236142.png" alt="image-20240620113236142"></p><h3 id="3-右旋：">3.右旋：</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的右子树（<strong>右旋</strong>），pivot的原右子树变成 原root节点的 左子树，pivot的原左子树保持不变。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113251895.png" alt="image-20240620113251895"></p><p>红黑树的左旋、右旋操作，AVL树的左旋，右旋操作 差不多</p><h2 id="红黑树插入节点情景分析">红黑树插入节点情景分析</h2><p>【重点】</p><p>新插入的节点都是红色</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620112811187.png" alt="image-20240620112811187"></p><h3 id="红黑树的节点结构">红黑树的节点结构</h3><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="默认新插入的节点为红色：">默认新插入的节点为红色：</h4><p>因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突</p><h3 id="场景1：红黑树为空树">场景1：红黑树为空树</h3><p>直接把插入结点作为根节点就可以了</p><p>另外：根据红黑树性质 2根节点是黑色的。还需要把插入节点设置为黑色。</p><h3 id="场景2：插入节点的Key已经存在">场景2：插入节点的Key已经存在</h3><p>更新当前节点的值，为插入节点的值。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113320622.png" alt="image-20240620113320622"></p><h3 id="情景3：插入节点的父节点为黑色">情景3：插入节点的父节点为黑色</h3><p>由于插入的节点是红色的，当插入节点的父节点是黑色时，不会影响红黑树的平衡，</p><p>所以： <strong>直接插入无需做自平衡</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113338000.png" alt="image-20240620113338000"></p><h3 id="情景4：插入节点的父节点为红色">情景4：插入节点的父节点为红色</h3><p>根据性质2：根节点是黑色。</p><p>如果插入节点的父节点为红色节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点(三代关系)。</p><p>根据性质4：每个<strong>红色</strong>节点的两个子节点一定是<strong>黑色</strong>的。不能有<strong>两个红色节点相连</strong>。</p><p>此时会出现两种状态：</p><ul><li>父亲和叔叔为红色</li><li>父亲为红色，叔叔为黑色</li></ul><p>如图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113425244.png" alt="image-20240620113425244"></p><h4 id="场景4-1：父亲和叔叔为红色节点">场景4.1：父亲和叔叔为红色节点</h4><p>根据性质4：<strong>红色节点不能相连 ==》祖父节点肯定为黑色节点：</strong></p><p>父亲为红色，那么此时该插入子树的红黑树层数的情况是：黑红红。</p><p>因为不可能同时存在两个相连的红色节点，需要进行 变色， 显然处理方式是把其改为：红黑红</p><p><strong>变色 处理</strong>：黑红红 ==&gt; 红黑红</p><p>1.将F和V节点改为黑色</p><p>2.将P改为红色</p><p>3.将P设置为当前节点，进行后续处理</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113440304.png" alt="image-20240620113440304"></p><p>可以看到，将P设置为红色了，</p><p>如果<strong>P的父节点是黑色</strong>，那么无需做处理；</p><p>但如果P的父节点是红色，则违反红黑树性质了，所以需要将P设置为当前节点，继续插入操作, 作自平衡处理，直到整体平衡为止。</p><h4 id="场景4-2：叔叔为黑色，父亲为红色，并且插在父亲的左节点">场景4.2：叔叔为黑色，父亲为红色，并且插在父亲的左节点</h4><p>分为两种情况</p><ul><li>LL 红色插入</li></ul><p>叔叔为黑色，或者不存在（NIL）也是黑节点，并且节点的父亲节点是祖父节点的左子节点</p><p>注意：单纯从插入来看，叔叔节点非红即黑(NIL节点)，否则破坏了红黑树性质5，此时路径会比其他路径多一个黑色节点。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113455760.png" alt="image-20240620113455760"></p><h5 id="场景4-2-1-LL型失衡">场景4.2.1 LL型失衡</h5><p>细分场景 1： 新插入节点，为其父节点的左子节点(LL红色情况)， 插入后 就是LL 型失衡</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113518798.png" alt="image-20240620113518798"></p><h6 id="自平衡处理：">自平衡处理：</h6><p>1.变颜色：</p><p>将F设置为黑色，将P设置为红色</p><p>2.对F节点进行<strong>右旋</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113531635.png" alt="image-20240620113531635"></p><h5 id="场景4-2-2-LR型失衡">场景4.2.2 LR型失衡</h5><p>细分场景 2： 新插入节点，为其父节点的右子节点(LR红色情况)， 插入后 就是LR 型失衡</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113547703.png" alt="image-20240620113547703"></p><h6 id="自平衡处理：-2">自平衡处理：</h6><p>1.对F进行左旋</p><p>2.将F设置为当前节点，得到LL红色情况</p><p>3.按照LL红色情况处理(1.变色 2.右旋P节点)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113601729.png" alt="image-20240620113601729"></p><h4 id="情景4-3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点">情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点</h4><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113619641.png" alt="image-20240620113619641"></p><h5 id="情景4-3-1：RR型失衡">情景4.3.1：RR型失衡</h5><p>新插入节点，为其父节点的右子节点(RR红色情况)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113648077.png" alt="image-20240620113648077"></p><h6 id="自平衡处理：-3">自平衡处理：</h6><p>1.变色：</p><p>将F设置为黑色，将P设置为红色</p><p>2.对P节点进行<strong>左旋</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113700149.png" alt="image-20240620113700149"></p><h5 id="情景4-3-2：RL型失衡">情景4.3.2：RL型失衡</h5><p>新插入节点，为其父节点的左子节点(RL红色情况)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113712441.png" alt="image-20240620113712441"></p><h6 id="自平衡处理：-4">自平衡处理：</h6><p>1.对F进行右旋</p><p>2.将F设置为当前节点，得到RR红色情况</p><p>3.按照RR红色情况处理(1.变色 2.左旋 P节点)</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240620113724640.png" alt="image-20240620113724640"></p><h2 id="RBT面试题：">RBT面试题：</h2><h3 id="问：有了二叉搜索树，为什么还需要平衡二叉树？"><strong>问：有了二叉搜索树，为什么还需要平衡二叉树？</strong></h3><p>二叉搜索树容易退化成一条链</p><p>这时，查找的时间复杂度从O ( log n）也将退化成O ( N )</p><p>引入对左右子树高度差有限制的平衡二叉树 AVL，保证查找操作的最坏时间复杂度也为O ( log n）</p><h3 id="问：有了平衡二叉树，为什么还需要红黑树？">问：有了平衡二叉树，为什么还需要红黑树？</h3><p>AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡</p><p>在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣</p><p>红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，</p><p>整体性能优于AVL</p><ul><li><strong>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</strong></li><li><strong>红黑树的红黑规则，保证最坏的情况下，也能在O ( log n）时间内完成查找操作。</strong></li></ul><h3 id="问：红黑树那几个原则，你还记得么？">问：红黑树那几个原则，你还记得么？</h3><p>可以按照括号里边的分类，记住 红黑树的几个原则：</p><ul><li>（<strong>颜色属性</strong>）节点非黑即红</li><li>（<strong>根属性</strong>）根节点一定是黑色</li><li>（<strong>叶子属性</strong>）叶子节点（NIL）一定是黑色</li><li>（<strong>红色属性</strong>）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>**（黑色属性）**从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><h3 id="问：红黑树写入操作-，是如何找到它的父节点的？">问：红黑树写入操作 ，是如何找到它的父节点的？</h3><p>红黑树的节点 TreeNode它就是继承Node结构，</p><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TreeNode在Node基础上加了几个字段，分别指向父节点parent，然后指向左子节点left，还有指向右子节点的right，</p><p>然后还有表示颜色red属性</p><h6 id="红黑树的插入操作：">红黑树的插入操作：</h6><p>首先是找到一个合适的插入点，就是找到插入节点的父节点，</p><p>由于红黑树 它又满足BST二叉查找树的 有序特性，这个找父节点的操作和二叉查找树是完全一致的。</p><p>二叉查找树，左子节点小于当前节点，右子节点大于当前节点，</p><p>然后每一次向下查找一层就可以排除掉一半的数据，查找的效率在log(N)</p><p>最终查找到nil节点或者 key一样的节点。</p><p>如果最终查找到 key一样的节点，进行更新操作。这个TreeNode.key 与当前 put.key 完全一致。这就不需要插入，替换value就可以了，父节点就是当前节点的父节点</p><p>如果最终查找到nil节点，进行插入操作。nil节点的父节点，就是当前节点的父节点，把插入的节点替换nil节点。然后进行红黑树的 平衡处理。</p><h3 id="问：红黑树的有那些内部操作">问：红黑树的有那些内部操作</h3><p><strong>变色</strong></p><p>把一个红色的节点变成黑色，或者把一个黑色的节点变成红色，就是对这个节点的<code>变色</code>。</p><p><strong>旋转</strong></p><p>与平衡二叉树的旋转操作类似。</p><h3 id="红黑树与AVL树区别">红黑树与AVL树区别</h3><p><strong>1、调整平衡的实现机制不同</strong></p><p>红黑树根据路径上黑色节点数目一致，来确定是否失衡，如果失衡，就通过变色和旋转来恢复</p><p>AVL根据树的<a href="https://so.csdn.net/so/search?q=%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90&amp;spm=1001.2101.3001.7020">平衡因子</a>(<strong>所有节点的左右子树高度差的绝对值不超过1</strong>)，来确定是否失衡，如果失衡，就通过旋转来恢复</p><p><strong>2、红黑树的插入效率更高</strong></p><p>红黑树是用<strong>非严格的平衡</strong>来换取增删节点时候旋转次数的降低，<strong>任何不平衡都会在三次旋转之内解决</strong>，</p><p>红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能</p><p>而AVL是<strong>严格平衡树</strong>(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</p><p>所以红黑树的插入效率更高</p><p><strong>3、红黑树统计性能比AVL树更高</strong></p><p>红黑树能够以<strong>O(log n)</strong> 的时间复杂度进行查询、插入、删除操作。</p><p>AVL树查找、插入和删除在平均和最坏情况下都是<strong>O(log n)</strong>。</p><p>红黑树的算法时间复杂度和AVL相同，<strong>但统计性能比AVL树更高</strong>。</p><p><strong>解释：</strong></p><p>&quot;统计性能&quot;这个词在这里是指红黑树在插入和删除操作上的性能比AVL树更高。</p><p>红黑树和AVL树都是自平衡的二叉查找树，它们都可以在对数时间内完成查找、插入和删除操作。然而，由于它们的平衡条件和调整策略不同，它们在不同操作上的性能表现也有所不同。</p><ol><li>AVL树要求每个节点的左右子树的高度差最多为1，这是一种较为严格的平衡条件。这使得AVL树的查找性能非常高，因为每次查找的复杂度都是严格的对数级别。然而，每次插入和删除节点时，都可能需要进行一系列的旋转操作来重新达到平衡，这就导致了AVL树在插入和删除操作上的性能可能不如红黑树。</li><li>红黑树的平衡条件相对较松，只要求任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。这意味着红黑树在插入和删除节点时，需要进行旋转操作的频率较低，因此在插入和删除操作上的性能比AVL树更高。</li></ol><p>所以，当我们说&quot;红黑树的统计性能比AVL树更高&quot;时，我们是在说在进行大量的插入和删除操作时，红黑树的性能表现可能会优于AVL树。然而，如果你的应用场景主要是进行查找操作，那么AVL树可能会是更好的选择，因为它的查找性能更高。</p><p><strong>4、适用性：AVL查找效率高</strong></p><p><strong>如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树</strong>。</p><p>即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。</p><p>学习自：<a href="https://www.cnblogs.com/crazymakercircle/p/16320430.html">红黑树（图解+秒懂+史上最全）</a></p>]]></content>
    
    
    <summary type="html">图解红黑树</summary>
    
    
    
    <category term="数据结构" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="数据结构" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>STL-第四章</title>
    <link href="https://penge666.github.io/posts/7c902287.html"/>
    <id>https://penge666.github.io/posts/7c902287.html</id>
    <published>2024-06-19T11:43:55.000Z</published>
    <updated>2024-06-19T13:26:24.330Z</updated>
    
    <content type="html"><![CDATA[<p>所谓序列式容器，其中的元素<strong>都可序，但未必有序</strong>，C++语言本身提供了一个序列式容器array，STL另外再提供vector、list、deque、stack、queue、priority-queue等序列容器。<strong>其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器。</strong></p><p>本文将主要总结各种序列式容器的实现和用法。</p><h3 id="1、vector容器">1、vector容器</h3><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置就不能改变，如果要换个大点的空间，需要程序员自己来；<strong>vector是动态空间</strong>，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。</p><p>vector的实现技术，<strong>关键在于其对大小的控制以及重新配置时的数据移动效率</strong>。因为“配置新空间/数据移动/释放旧空间”是一个大工程。</p><h4 id="1-1-vector的迭代器">1.1 vector的迭代器</h4><p>由于vector使用的是连续线性的空间，普通指针能满足所有vector迭代器的所需的操作行为，所以其迭代器实际就是原生指针，支持随机存取，为Random Access Iterator。</p><h4 id="1-2-vector的数据结构">1.2 vector的数据结构</h4><p>vector所采用的数据结构：线性连续空间。</p><p>它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619194653351.png" alt="image-20240619194653351"></p><p>vector的空间配置策略为：</p><ul><li>当插入元素的时候，如果配置的空间不足，则扩充空间至当前的两倍，如果仍然不足则扩充至所需空间。</li><li>容量的扩张必须经历“重新配置、元素移动、释放原空间”等过程。</li></ul><p><strong>Note</strong>：Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍。</p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在Linux + GCC下</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//4</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在 win 10 + VS2019下</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//3</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//6 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时已占用的长度为3，再继续两个数据，此时长度变为8，可以清晰的看到空间的变化过程</p><p>需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响。</p><blockquote><p><strong>emplace_back()和push_back()的区别</strong></p></blockquote><p>总结：</p><p>1、push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p>2、push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>3、emplace_back不能完全代替push_back。</p><p>举例说明：</p><p><strong>总结1，2</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.<span class="built_in">emplace_back</span>(<span class="number">2</span>);  </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>这里将移动构造函数注释掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure><p>因此，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p><strong>总结3：</strong></p><p><a href="https://www.zhihu.com/question/387522517/answer/1151089633">https://www.zhihu.com/question/387522517/answer/1151089633</a></p><p>例子1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// error</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">v.emplace_back&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为不知道你{1,2,3}是什么类型。</p><p>例子2：直接构造的坏处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 编译出错</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 通过编译，但运行时抛出异常并且难以定位</span></span><br></pre></td></tr></table></figure><p>例子3：特殊情况只能用push_back</p><p><a href="https://www.zhihu.com/question/347743586/answer/835340740">https://www.zhihu.com/question/347743586/answer/835340740</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;S&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>&#125;);    <span class="comment">// 没问题</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(&#123;<span class="number">0</span>&#125;); <span class="comment">// 编不过</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>resize()和reserve()的区别</strong></p></blockquote><p><strong>resize用法</strong></p><ol><li>resize(n)</li></ol><ul><li><p>调整容器的长度大小，使其能容纳n个元素。</p></li><li><p>如果n小于容器的当前的size，则删除多出来的元素。</p></li><li><p>否则，添加采用值初始化的元素。</p></li></ul><ol start="2"><li>resize(n，t)</li></ol><ul><li>多一个参数t，将所有新添加的元素初始化为t。</li></ul><p><strong>reserve用法</strong></p><ul><li>预分配n个元素的存储空间。</li></ul><p>看个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">150</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">50  100</span><br><span class="line">150  150</span><br><span class="line">150  150</span><br><span class="line">50  150</span><br></pre></td></tr></table></figure><p><strong>容器的capacity（容量）与size（长度）</strong></p><p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，</p><p>因为此时容器中还没有创建任何对象。</p><p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。</p><h3 id="2、list容器">2、list容器</h3><p><strong>list是一个双list是一个双向链表，每次插入或删除一个元素，就分配或释放一个元素的空间</strong>；所以list对空间的控制十分精确，而且任何位置的插入或删除需要的时间都是常数，即时间复杂度为o(1)。</p><p>list和vector是两种最常用的容器，什么时候选用哪种容器，视元素的多寡、元素的构造复杂度以及元素存取的行为特性，一般来说查找比较多的情况用vector,而插入和删除比较多的场景则比较适合list。</p><p>list节点的结构见如下源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-list的迭代器">2.1 list的迭代器</h4><p>list迭代器正确的递增、递减、取值、成员取用操作是指，递增指向下一个节点，递减指向上一个节点，取值取的是节点的数据值，成员取用时取用的是节点的成员。list不能再以原生指针作为迭代器，而需要定义特定的iterator类。<strong>list迭代器是一种Bidirectional Iterator</strong>，支持单步的前进或后退操作。</p><p>list迭代器有一个重要性质：<strong>插入和结合操作都不会有list迭代器失效</strong>，这在vector是不成立的，因为vector的插入操作可能造成原来的重新配置，导致原有的迭代器全部失效。<strong>list的元素删除操作也只有指向删除元素的那个迭代器失效，其他迭代器不受影响</strong>。</p><p><strong>这是因为 <code>std::list</code> 使用链表实现,插入和删除只需要修改指针</strong>。</p><h4 id="2-2-list的数据结构">2.2 list的数据结构</h4><p>list的结构如下图，SGI list不仅是一个双向链表，而且还是一个<strong>环状双向链表</strong>，所以它只需一个指针，便可完整表现整个链表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619202315033.png" alt="image-20240619202315033"></p><p>list缺省使用alloc作为空间配置器，以节点大小为配置单位。</p><p>当我们以push_back()将元素插入list尾部时，此函数内部调用insert()，insert()是一个重载函数，有多种形式最简单的一种是：首先配置并构造一个节点，然后在尾端进行适当的指针操作，最后将节点插入进去，list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效。由于list是一个双向循环链表，只要我们把边界条件处理好，那么，在头部或者尾部插入元素的操作几乎是一样的，list内部提供一个所谓的迁移操作：将某连续范围的元素迁移到某个特定位置之前，节点间的指针移动而已。</p><blockquote><p>需要注意的是：list不能使用stl提供的通用sort算法，因为sort算法只接受Random Access Iterator，所以提供了自己的sort方法,可以直接调用，其内部好像是将原链分解为多个链表，然后依次进行合并。</p></blockquote><h3 id="3、deque容器">3、deque容器</h3><p>vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾分别做元素的的安插和删除操作；vector当然也可以在头尾两端做动作，但是其头部动作效率奇差。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619205225280.png" alt="image-20240619205225280"></p><p>deque和vector的差异：</p><ul><li>一在于deque允许常数时间内对头端进行元素的插入或移除操作</li><li>二在于deque没有所谓容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。deque没有必要提供所谓的空间保留功能。vector只能向尾端“生长”，而deque可以在前端或者尾端增加新空间。不存在像vector那样“因空间不足而分配一块更大的空间然后复制元素”问题。</li></ul><h4 id="3-1-deque的迭代器">3.1 deque的迭代器</h4><p>deque提供random access iterator，但并不是原生指针。其实现的复杂度也很大，这也影响到相关算法的效率。所以<strong>如非必要，应该尽量使用vector而不是deque</strong>。对的确需要进行排序时，可以先将元素复制到一个vector，排序后再复制回deque。</p><h4 id="3-2-deque的数据结构">3.2 deque的数据结构</h4><p>deque的数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//指向map指针的指针</span></span><br><span class="line">    map_pointer map;<span class="comment">//指向map</span></span><br><span class="line">    size_type map_size;<span class="comment">//map的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">itertator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deque采用的是一种<strong>分段连续空间存储结构</strong>，采用一个map来管理这些空间段，这里所谓map是一小块连续空间，其中每个元素都是指针，指向另外一段较大的连续线性空间，称为缓冲区，<strong>缓冲区才是deque的存储空间主体</strong>，SGI STL允许我们指定缓冲区大小，默认值0表示使用512bytes缓冲区。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619205752980.png" alt="image-20240619205752980"></p><p>由于<strong>每个缓冲区的大小是固定的</strong>，当有新元素加入而空间不足时，就分配一个新的缓冲区,配置策略为reallocate_map()。 deque的这种结构，使得其迭代器上的操作可能需要跨越多个缓冲区，这使得迭代器的实现非常复杂。</p><p>deque的迭代器数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    T* cur;<span class="comment">//迭代器所指缓冲区当前的元素</span></span><br><span class="line">    T* first;<span class="comment">//迭代器所指缓冲区第一个元素</span></span><br><span class="line">    T* last;<span class="comment">//迭代器所指缓冲区最后一个元素</span></span><br><span class="line">    map_pointer node;<span class="comment">//指向map中的node</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619210621348.png" alt="image-20240619210621348"></p><p>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p><p><strong>Note</strong>：deque 并不是每个缓冲区都对应一个迭代器。deque 只有一个整体的迭代器,它负责在整个 deque 的缓冲区之间进行跳转。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619210258680.png" alt="image-20240619210258680"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619210248652.png" alt="image-20240619210248652"></p><h3 id="4、stack容器">4、stack容器</h3><p>stack是一种<strong>先进后出</strong>的数据结构，它只有一个出口,stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端元素外，没有任何其他方式可以存取stack的其他元素，换言之，<strong>stack不允许有遍历行为</strong>。</p><p>stack不支持对元素的遍历，因此<strong>没有迭代器</strong>。</p><h4 id="4-1-stack的数据结构">4.1 stack的数据结构</h4><p>stack是一种先进后出的数据结构，只可以在顶端进行元素操作。如果有某种双向开口的数据结构，将其接口改变，符合“先进后出”的特性，就可以形成一个stack：deque和list都是这样的结构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619205935560.png" alt="image-20240619205935560"></p><p>SGI STL便以deque作为缺省情况下的stack底部结构。由于stack是以底部容器deque完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为<strong>adapter（配接器）</strong>,因此，STL stack往往不被归类为container（容器），而被归类为container adapter。</p><h3 id="5、queue容器">5、queue容器</h3><p>queue是一种先进先出的数据结构，它有两个出口。queue允许新增元素、移除元素、从底端加入元素、取得最顶端元素（queue不允许有遍历行为）。</p><p>与stack一样，queue也不允许有遍历行为，queue没有迭代器。</p><p>与stack类似，SGI STL默认情况下以deque作为queue的底部结构。也是一种container adapter。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211611039.png" alt="image-20240619211611039"></p><h3 id="6、heap">6、heap</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演priority queue的助手,它分为 max heap 和min heap，在缺省情况下，<strong>max-heap是priority queue的底层实现机制</strong>。</p><h4 id="6-1-heap的数据结构">6.1 heap的数据结构</h4><p>以array表达tree的方式，称为<strong>隐式表述法</strong>,这样就可以使用一个array表示出一颗完全二叉树。array的缺点是无法动态的改变大小，所以实际实现机制中的<strong>max-heap实际上是以一个vector表现的完全二叉树</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211707150.png" alt="image-20240619211707150"></p><p>从上图可以看出，第0号元素保留，这样就可以使得从arry[1]开始保存A，位于位置i的某个结点arry[i]，他的左子结点必然在arry[2<em>i]中，右子结点必然位于arry[2</em>i+1]，其父亲结点必然位于arry[i/2]处。</p><h4 id="6-2-heap的相关算法">6.2 heap的相关算法</h4><ul><li>（1）建立堆：make_heap(_First, _Last, _Comp)<br>传入vector的迭代器，默认是建立最大堆的。对int类型，<strong>可以在第三个参数传入greater()得到最小堆</strong>。</li><li>（2）在堆中添加数据：push_heap(_First, _Last)<br>要先在容器中加入数据push_back()，再调用push_heap()，vector的元素放在尾端，所以实际上push_heap所做的操作就是将尾端元素和其父节点进行比较，如果大于父节点则交换并不断上溯<strong>直到不满足大于为止</strong>。</li><li>（3）在堆中删除数据：pop_heap(_First, _Last)<br>该算法主要是先将vector的根节点即最大值放到vector的尾端，然后处理[start,end-1)区间的元素，从根节点开始，<strong>只要父节点的元素小于某个子节点的元素就进行交换并继续下溯</strong>，否则停止。 调用pop_heap()结束后vector()可以通过pop_back()取出最大元素。</li><li>（4）堆排序sort_heap(_First, _Last)<br>sort_heap算法的内部实现原理：每次pop_heap可获得heap中键值最大的元素，如果持续对整个heap做pop_heap操作，每次将操作范围从后向前缩减一个元素，当整个程序执行完毕时，便有了一个递增的序列。</li></ul><h4 id="6-3-heap的迭代器">6.3 heap的迭代器</h4><p><strong>heap本身并不是一个容器，它更多的是依靠vector容器底层，并在上面实现算法从而实现对tree的表达。heap不提供遍历功能，也没有对应的迭代器。</strong></p><h3 id="7、priority-queue">7、priority__queue</h3><p>priority_queue是一个拥有权值观念的queue，它允许加入新元素、移除旧元素、审视新元素等功能。由于是一个queue，所以只能在底端加入元素，在顶端取出元素。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211809000.png" alt="image-20240619211809000"></p><p>priority_queue带有权值概念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列。<strong>priority_queue缺省情况下是以vector为底层容器，并加上heap处理规则实现</strong>，因此，STL priority_queue往往不被归类为container(容器)，而被归类为container adapter。</p><p>与queue一样，priority_queue也没有迭代器。</p><h3 id="8、slist">8、slist</h3><p>list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前<strong>者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator</strong>。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。</p><p>考虑到效率问题，<strong>slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的.</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619212132376.png" alt="image-20240619212132376"></p><p>slist的单向迭代器如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240619211824831.png" alt="image-20240619211824831"></p><p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Allco</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">slist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> list_node* <span class="title function_">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span>&#123;&#125;<span class="comment">//配置空间、构造元素</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">destroy_node</span><span class="params">(list_node* node)</span>&#123;&#125;<span class="comment">//析构函数、释放空间</span></span><br><span class="line">private:</span><br><span class="line">    list_node_base head; <span class="comment">//头部</span></span><br><span class="line">public:</span><br><span class="line">    iterator <span class="title function_">begin</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    iterator <span class="title function_">end</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    size_type <span class="title function_">size</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">swap</span><span class="params">(slist&amp; L)</span>&#123;&#125;<span class="comment">//交换两个slist，只需要换head即可</span></span><br><span class="line">    reference <span class="title function_">front</span><span class="params">()</span>&#123;&#125; <span class="comment">//取头部元素</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">const</span> value&amp; x)</span>&#123;&#125;<span class="comment">//头部插入元素</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pop_front</span><span class="params">()</span>&#123;&#125;<span class="comment">//从头部取走元素</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line">fl.push_front(<span class="number">1</span>);</span><br><span class="line">fl.push_front(<span class="number">3</span>);</span><br><span class="line">fl.push_front(<span class="number">2</span>);</span><br><span class="line">fl.push_front(<span class="number">6</span>);</span><br><span class="line">fl.push_front(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator ite1 = fl.begin();</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator ite2 = fl.end();</span><br><span class="line"><span class="keyword">for</span>(;ite1 != ite2; ++ite1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ite1 &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 5 6 2 3 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ite1 = find(fl.begin(), fl.end(), <span class="number">2</span>); <span class="comment">//寻找2的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ite1 != ite2)</span><br><span class="line">fl.insert_after(ite1, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : fl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//5 6 2 99 3 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ite1 = find(fl.begin(), fl.end(), <span class="number">6</span>); <span class="comment">//寻找6的位置</span></span><br><span class="line"><span class="keyword">if</span> (ite1 != ite2)</span><br><span class="line">fl.erase_after(ite1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : fl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//5 6 99 3 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、总结">9、总结</h3><p>在实际使用过程中，到底选择这几种容器中的哪一个？通常应该根据遵循以下原则：</p><p>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p><p>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p><p>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p><p>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p><p>（5）如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p>]]></content>
    
    
    <summary type="html">STL-序列式容器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存工作原理</title>
    <link href="https://penge666.github.io/posts/b1b4d1ef.html"/>
    <id>https://penge666.github.io/posts/b1b4d1ef.html</id>
    <published>2024-06-18T07:57:06.000Z</published>
    <updated>2024-06-18T09:30:32.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导言"><strong>导言</strong></h3><p>虚拟内存是当今计算机系统中最重要的抽象概念之一，它的提出是为了更加有效地管理内存并且降低内存出错的概率。虚拟内存影响着计算机的方方面面，包括硬件设计、文件系统、共享对象和进程/线程调度等等，每一个致力于编写高效且出错概率低的程序的程序员都应该深入学习虚拟内存。</p><p>本文全面而深入地剖析了虚拟内存的工作原理，帮助读者快速而深刻地理解这个重要的概念。</p><h3 id="计算机存储器"><strong>计算机存储器</strong></h3><p>存储器是计算机的核心部件之一，在完全理想的状态下，存储器应该要同时具备以下三种特性：</p><ol><li>速度足够快：存储器的存取速度应当快于 CPU 执行一条指令，这样 CPU 的效率才不会受限于存储器</li><li>容量足够大：容量能够存储计算机所需的全部数据</li><li>价格足够便宜：价格低廉，所有类型的计算机都能配备</li></ol><p>但是现实往往是残酷的，我们目前的计算机技术无法同时满足上述的三个条件，于是现代计算机的存储器设计采用了一种分层次的结构：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172131123.png" alt="image-20240618172131123"></p><p>从顶至底，现代计算机里的存储器类型分别有：寄存器、高速缓存、主存和磁盘，这些存储器的速度逐级递减而容量逐级递增。存取速度最快的是寄存器，因为寄存器的制作材料和 CPU 是相同的，所以速度和 CPU 一样快，CPU 访问寄存器是没有时延的，然而因为价格昂贵，因此容量也极小，一般 32 位的 CPU 配备的寄存器容量是 32✖️32 Bit，64 位的 CPU 则是 64✖️64 Bit，不管是 32 位还是 64 位，寄存器容量都小于 1 KB，且寄存器也必须通过软件自行管理。</p><p>第二层是高速缓存，也即我们平时了解的 CPU 高速缓存 L1、L2、L3，一般 L1 是每个 CPU 独享，L3 是全部 CPU 共享，而 L2 则根据不同的架构设计会被设计成独享或者共享两种模式之一，比如 Intel 的多核芯片采用的是共享 L2 模式而 AMD 的多核芯片则采用的是独享 L2 模式。</p><p>第三层则是主存，也即主内存，通常称作随机访问存储器（Random Access Memory, RAM）。是与 CPU 直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质。</p><p>最后则是磁盘，磁盘和主存相比，每个二进制位的成本低了两个数量级，因此容量比之会大得多，动辄上 GB、TB，而缺点则是访问速度则比主存慢了大概三个数量级。机械硬盘速度慢主要是因为机械臂需要不断在金属盘片之间移动，等待磁盘扇区旋转至磁头之下，然后才能进行读写操作，因此效率很低。</p><h3 id="主存"><strong>主存</strong></h3><h4 id="物理内存">物理内存</h4><p>我们平时一直提及的物理内存就是上文中对应的第三种计算机存储器，RAM 主存，它在计算机中以内存条的形式存在，嵌在主板的内存槽上，用来加载各式各样的程序与数据以供 CPU 直接运行和使用。</p><h4 id="虚拟内存">虚拟内存</h4><p>在计算机领域有一句如同摩西十诫般神圣的哲言：“<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>”，从内存管理、网络模型、并发调度甚至是硬件架构，都能看到这句哲言在闪烁着光芒，而虚拟内存则是这一哲言的完美实践之一。</p><p>虚拟内存是现代计算机中的一个非常重要的存储器抽象，主要是用来解决应用程序日益增长的内存使用需求：现代物理内存的容量增长已经非常快速了，然而还是跟不上应用程序对主存需求的增长速度，对于应用程序来说内存还是可能会不够用，因此便需要一种方法来解决这两者之间的容量差矛盾。为了更高效地管理内存并尽可能消除程序错误，现代计算机系统对物理主存 RAM 进行抽象，实现了***虚拟内存 (Virtual Memory, VM)***技术。</p><h3 id="虚拟内存-2"><strong>虚拟内存</strong></h3><p>虚拟内存的核心原理是：为每个程序设置一段&quot;连续&quot;的虚拟地址空间，把这个地址空间分割成多个具有连续地址范围的页 (Page)，并把这些页和物理内存做映射，在程序运行期间动态映射到物理内存。当程序引用到一段在物理内存的地址空间时，由硬件立刻执行必要的映射；而当程序引用到一段不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><p>其实虚拟内存技术从某种角度来看的话，很像是糅合了基址寄存器和界限寄存器之后的新技术。它使得整个进程的地址空间可以通过较小的虚拟单元映射到物理内存，而不需要为程序的代码和数据地址进行重定位。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172246028.png" alt="image-20240618172246028"></p><p>虚拟地址空间按照固定大小划分成被称为页（Page）的若干单元，物理内存中对应的则是页框（Page Frame）。这两者一般来说是一样的大小，如上图中的是 4KB，不过实际上计算机系统中一般是 512 字节到 1 GB，这就是虚拟内存的分页技术。因为是虚拟内存空间，每个进程分配的大小是 4GB (32 位架构)，而实际上当然不可能给所有在运行中的进程都分配 4GB 的物理内存，所以虚拟内存技术还需要利用到一种 <code>交换（swapping）</code>技术，也就是通常所说的页面置换算法，在进程运行期间只分配映射当前使用到的内存，暂时不使用的数据则写回磁盘作为副本保存，需要用的时候再读入内存，动态地在磁盘和内存之间交换数据。</p><h4 id="页表">页表</h4><p>页表（Page Table），每次进行虚拟地址到物理地址的映射之时，都需要读取页表，从数学角度来说页表就是一个函数，入参是虚拟页号（Virtual Page Number，简称 VPN），输出是物理页框号（Physical Page Number，简称 PPN，也就是物理地址的基址）。</p><p>页表由多个页表项（Page Table Entry, 简称 PTE）组成，页表项的结构取决于机器架构，不过基本上都大同小异。一般来说页表项中都会存储物理页框号、修改位、访问位、保护位和 “在/不在” 位（有效位）等信息。</p><ul><li>物理页框号：这是 PTE 中最重要的域值，毕竟页表存在的意义就是提供 VPN 到 PPN 的映射。</li><li>有效位：表示该页面当前是否存在于主存中，1 表示存在，0 表示缺失，当进程尝试访问一个有效位为 0 的页面时，就会引起一个缺页中断。</li><li>保护位：指示该页面所允许的访问类型，比如 0 表示可读写，1 表示只读。</li><li>修改位和访问位：为了记录页面使用情况而引入的，一般是页面置换算法会使用到。比如当一个内存页面被程序修改过之后，硬件会自动设置修改位，如果下次程序发生缺页中断需要运行页面置换算法把该页面调出以便为即将调入的页面腾出空间之时，就会先去访问修改位，从而得知该页面被修改过，也就是脏页 (Dirty Page)，则需要把最新的页面内容写回到磁盘保存，否则就表示内存和磁盘上的副本内容是同步的，无需写回磁盘；而访问位同样也是系统在程序访问页面时自动设置的，它也是页面置换算法会使用到的一个值，系统会根据页面是否正在被访问来觉得是否要淘汰掉这个页面，一般来说不再使用的页面更适合被淘汰掉。</li><li>高速缓存禁止位：用于禁止页面被放入 CPU 高速缓存，这个值主要适用于那些映射到寄存器等实时 I/O 设备而非普通主存的内存页面，这一类实时 I/O 设备需要拿到最新的数据，而 CPU 高速缓存中的数据可能是旧的拷贝。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172300555.png" alt="image-20240618172300555"></p><h4 id="地址翻译">地址翻译</h4><p>进程在运行期间产生的内存地址都是虚拟地址，如果计算机没有引入虚拟内存这种存储器抽象技术的话，则 CPU 会把这些地址直接发送到内存地址总线上，然后访问和虚拟地址相同值的物理地址；如果使用虚拟内存技术的话，CPU 则是把这些虚拟地址通过地址总线送到内存管理单元（Memory Management Unit，简称 MMU），MMU 将虚拟地址翻译成物理地址之后再通过内存总线去访问物理内存：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172315295.png" alt="image-20240618172315295"></p><p>虚拟地址（比如 16 位地址 8196=0010 000000000100）分为两部分：虚拟页号（Virtual Page Number，简称 VPN，这里是高 4 位部分）和偏移量（Virtual Page Offset，简称 VPO，这里是低 12 位部分），虚拟地址转换成物理地址是通过页表（page table）来实现的。</p><p>这里我们基于一个例子来分析当页面命中时，计算机各个硬件是如何交互的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172327132.png" alt="image-20240618172327132"></p><ul><li><strong>第 1 步</strong>：处理器生成一个虚拟地址 VA，通过总线发送到 MMU；</li><li><strong>第 2 步</strong>：MMU 通过虚拟页号得到页表项的地址 PTEA，通过内存总线从 CPU 高速缓存/主存读取这个页表项 PTE；</li><li><strong>第 3 步</strong>：CPU 高速缓存或者主存通过内存总线向 MMU 返回页表项 PTE；</li><li><strong>第 4 步</strong>：MMU 先把页表项中的物理页框号 PPN 复制到寄存器的高三位中，接着把 12 位的偏移量 VPO 复制到寄存器的末 12 位构成 15 位的物理地址，即可以把该寄存器存储的物理内存地址 PA 发送到内存总线，访问高速缓存/主存；</li><li><strong>第 5 步</strong>：CPU 高速缓存/主存返回该物理地址对应的数据给处理器。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172339034.png" alt="image-20240618172339034"></p><p>在 MMU 进行地址转换时，如果页表项的有效位是 0，则表示该页面并没有映射到真实的物理页框号 PPN，则会引发一个<strong>缺页中断</strong>，CPU 陷入操作系统内核，接着操作系统就会通过页面置换算法选择一个页面将其换出 (swap)，以便为即将调入的新页面腾出位置，如果要换出的页面的页表项里的修改位已经被设置过，也就是被更新过，则这是一个脏页 (Dirty Page)，需要写回磁盘更新该页面在磁盘上的副本，如果该页面是&quot;干净&quot;的，也就是没有被修改过，则直接用调入的新页面覆盖掉被换出的旧页面即可。</p><p>缺页中断的具体流程如下：</p><ul><li><strong>第 1 步到第 3 步</strong>：和前面的页面命中的前 3 步是一致的；</li><li><strong>第 4 步</strong>：检查返回的页表项 PTE 发现其有效位是 0，则 MMU 触发一次缺页中断异常，然后 CPU 转入到操作系统内核中的缺页中断处理器；</li><li><strong>第 5 步</strong>：缺页中断处理程序检查所需的虚拟地址是否合法，确认合法后系统则检查是否有空闲物理页框号 PPN 可以映射给该缺失的虚拟页面，如果没有空闲页框，则执行页面置换算法寻找一个现有的虚拟页面淘汰，如果该页面已经被修改过，则写回磁盘，更新该页面在磁盘上的副本；</li><li><strong>第 6 步</strong>：缺页中断处理程序从磁盘调入新的页面到内存，更新页表项 PTE；</li><li><strong>第 7 步</strong>：缺页中断程序返回到原先的进程，重新执行引起缺页中断的指令，CPU 将引起缺页中断的虚拟地址重新发送给 MMU，此时该虚拟地址已经有了映射的物理页框号 PPN，因此会按照前面『Page Hit』的流程走一遍，最后主存把请求的数据返回给处理器。</li></ul><p><strong>解释下</strong>：PTE和PTEA的概念</p><ol><li>PTE（Page Table Entry）：在虚拟内存系统中，PTE是页表中的一个条目，用于映射虚拟地址到物理地址。每一个PTE都包含一些控制位，如有效位（表示这个条目是否有效）和脏位（表示这个页面是否被修改过）等。</li><li>PTEA（Page Table Entry Address）：PTEA则是页表条目的地址，也就是指向PTE的指针。PTEA通常由虚拟地址的一部分（例如高位）来生成，用于在页表中查找对应的PTE。</li></ol><p>因此，PTE和PTEA的主要区别在于，PTE是用于虚拟到物理地址映射的条目，而PTEA则是这些条目在内存中的地址。</p><p>我认为，作者之所以在上述图中那么画是为了更加精准的说明概念！</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172350174.png" alt="image-20240618172350174"></p><h4 id="虚拟内存和高速缓存">虚拟内存和高速缓存</h4><p>前面在分析虚拟内存的工作原理之时，谈到页表的存储位置，为了简化处理，都是默认把主存和高速缓存放在一起，而实际上更详细的流程应该是如下的原理图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172403418.png" alt="image-20240618172403418"></p><p>如果一台计算机同时配备了虚拟内存技术和 CPU 高速缓存，那么 MMU 每次都会优先尝试到高速缓存中进行寻址，如果缓存命中则会直接返回，只有当缓存不命中之后才去主存寻址。</p><p>通常来说，大多数系统都会选择利用物理内存地址去访问高速缓存，因为高速缓存相比于主存要小得多，所以使用物理寻址也不会太复杂；另外也因为高速缓存容量很小，所以系统需要尽量在多个进程之间共享数据块，而使用物理地址能够使得多进程同时在高速缓存中存储数据块以及共享来自相同虚拟内存页的数据块变得更加直观。</p><h4 id="加速翻译-优化页表">加速翻译&amp;优化页表</h4><p>经过前面的剖析，相信读者们已经了解了虚拟内存及其分页&amp;地址翻译的基础和原理。现在我们可以引入虚拟内存中两个核心的需求，或者说瓶颈：</p><ul><li>虚拟地址到物理地址的映射过程必须要非常快，地址翻译如何加速。</li><li>虚拟地址范围的增大必然会导致页表的膨胀，形成大页表。</li></ul><p>这两个因素决定了虚拟内存这项技术能不能真正地广泛应用到计算机中，如何解决这两个问题呢？</p><p>正如文章开头所说：“<strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>”。因此，虽然虚拟内存本身就已经是一个中间层了，但是中间层里的问题同样可以通过再引入一个中间层来解决。</p><p>加速地址翻译过程的方案目前是通过引入页表缓存模块 – TLB，而大页表则是通过实现多级页表或倒排页表来解决。</p><h5 id="TLB-加速"><strong>TLB 加速</strong></h5><p><strong>翻译后备缓冲器</strong>（Translation Lookaside Buffer，TLB），也叫快表，是用来加速虚拟地址翻译的，因为虚拟内存的分页机制，页表一般是保存在内存中的一块固定的存储区，而 MMU 每次翻译虚拟地址的时候都需要从页表中匹配一个对应的 PTE，导致进程通过 MMU 访问指定内存数据的时候比没有分页机制的系统多了一次内存访问，一般会多耗费几十到几百个 CPU 时钟周期，性能至少下降一半，如果 PTE 碰巧缓存在 CPU L1 高速缓存中，则开销可以降低到一两个周期，但是我们不能寄希望于每次要匹配的 PTE 都刚好在 L1 中，因此需要引入加速机制，即 TLB 快表。</p><p>TLB 可以简单地理解成页表的高速缓存，保存了最高频被访问的页表项 PTE。由于 TLB 一般是硬件实现的，因此速度极快，MMU 收到虚拟地址时一般会先通过硬件 TLB 并行地在页表中匹配对应的 PTE，若命中且该 PTE 的访问操作不违反保护位（比如尝试写一个只读的内存地址），则直接从 TLB 取出对应的物理页框号 PPN 返回，若不命中则会穿透到主存页表里查询，并且会在查询到最新页表项之后存入 TLB，以备下次缓存命中，如果 TLB 当前的存储空间不足则会替换掉现有的其中一个 PTE。</p><p>下面来具体分析一下 TLB 命中和不命中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172417006.png" alt="image-20240618172417006"></p><p><strong>TLB 命中</strong>：</p><ul><li><strong>第 1 步</strong>：CPU 产生一个虚拟地址 VA；</li><li><strong>第 2 步和第 3 步</strong>：MMU 从 TLB 中取出对应的 PTE；</li><li><strong>第 4 步</strong>：MMU 将这个虚拟地址 VA 翻译成一个真实的物理地址 PA，通过地址总线发送到高速缓存/主存中去；</li><li><strong>第 5 步</strong>：高速缓存/主存将物理地址 PA 上的数据返回给 CPU。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172440033.png" alt="image-20240618172440033"></p><p><strong>TLB 不命中</strong>：</p><ul><li><strong>第 1 步</strong>：CPU 产生一个虚拟地址 VA；</li><li><strong>第 2 步至第 4 步</strong>：查询 TLB 失败，走正常的主存页表查询流程拿到 PTE，然后把它放入 TLB 缓存，以备下次查询，如果 TLB 此时的存储空间不足，则这个操作会汰换掉 TLB 中另一个已存在的 PTE；</li><li><strong>第 5 步</strong>：MMU 将这个虚拟地址 VA 翻译成一个真实的物理地址 PA，通过地址总线发送到高速缓存/主存中去；</li><li><strong>第 6 步</strong>：高速缓存/主存将物理地址 PA 上的数据返回给 CPU。</li></ul><h5 id="多级页表"><strong>多级页表</strong></h5><p>TLB 的引入可以一定程度上解决虚拟地址到物理地址翻译的开销问题，接下来还需要解决另一个问题：大页表。</p><p>理论上一台 32 位的计算机的寻址空间是 4GB，也就是说每一个运行在该计算机上的进程理论上的虚拟寻址范围是 4GB。到目前为止，我们一直在讨论的都是单页表的情形，如果每一个进程都把理论上可用的内存页都装载进一个页表里，但是实际上进程会真正使用到的内存其实可能只有很小的一部分，而我们也知道页表也是保存在计算机主存中的，那么势必会造成大量的内存浪费，甚至有可能导致计算机物理内存不足从而无法并行地运行更多进程。</p><p>这个问题一般通过<strong>多级页表</strong>（Multi-Level Page Tables）来解决，通过把一个大页表进行拆分，形成多级的页表，我们具体来看一个二级页表应该如何设计：假定一个虚拟地址是 32 位，由 10 位的一级页表索引、10 位的二级页表索引以及 12 位的地址偏移量，则 PTE 是 4 字节，页面 page 大小是 2^12 = 4KB，总共需要 2^20 个 PTE，一级页表中的每个 PTE 负责映射虚拟地址空间中的一个 4MB 的 chunk，每一个 chunk 都由 1024 个连续的页面 Page 组成，如果寻址空间是 4GB，那么一共只需要 1024 个 PTE 就足够覆盖整个进程地址空间。二级页表中的每一个 PTE 都负责映射到一个 4KB 的虚拟内存页面，和单页表的原理是一样的。</p><p>多级页表的关键在于，我们并不需要为一级页表中的每一个 PTE 都分配一个二级页表，而只需要为进程当前使用到的地址做相应的分配和映射。因此，对于大部分进程来说，它们的一级页表中有大量空置的 PTE，那么这部分 PTE 对应的二级页表也将无需存在，这是一个相当可观的内存节约，事实上对于一个典型的程序来说，理论上的 4GB 可用虚拟内存地址空间绝大部分都会处于这样一种未分配的状态；更进一步，在程序运行过程中，只需要把一级页表放在主存中，虚拟内存系统可以在实际需要的时候才去创建、调入和调出二级页表，这样就可以确保只有那些最频繁被使用的二级页表才会常驻在主存中，此举亦极大地缓解了主存的压力。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172454801.png" alt="image-20240618172454801"></p><p>多级页表的层级深度可以按照需求不断扩充，一般来说，级数越多，灵活性越高。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172505424.png" alt="image-20240618172505424"></p><p>比如有个一个 k 级页表，虚拟地址由 k 个 VPN 和 1 个 VPO 组成，每一个 VPN i 都是一个到第 i 级页表的索引，其中 1 &lt;= i &lt;= k。第 j 级页表中的每一个 PTE（1 &lt;= j &lt;= k-1）都指向第 j+1 级页表的基址。第 k 级页表中的每一个 PTE 都包含一个物理地址的页框号 PPN，或者一个磁盘块的地址（该内存页已经被页面置换算法换出到磁盘中）。MMU 每次都需要访问 k 个 PTE 才能找到物理页框号 PPN 然后加上虚拟地址中的偏移量 VPO 从而生成一个物理地址。这里读者可能会对 MMU 每次都访问 k 个 PTE 表示性能上的担忧，此时就是 TLB 出场的时候了，计算机正是通过把每一级页表中的 PTE 缓存在 TLB 中从而让多级页表的性能不至于落后单页表太多。</p><h5 id="倒排页表"><strong>倒排页表</strong></h5><p>另一种针对页式虚拟内存管理大页表问题的解决方案是<strong>倒排页表</strong>（Inverted Page Table，简称 IPT）。倒排页表的原理和搜索引擎的倒排索引相似，都是通过反转映射过程来实现。</p><p>在搜索引擎中，有两个概念：文档 doc 和 关键词 keyword，我们的需求是通过 keyword 快速找到对应的 doc 列表，如果搜索引擎的存储结构是正向索引，也即是通过 doc 映射到其中包含的所有 keyword 列表，那么我们要找到某一个指定的 keyword 所对应的 doc 列表，那么便需要扫描索引库中的所有 doc，找到包含该 keyword 的 doc，再根据打分模型进行打分，排序后返回，这种设计无疑是低效的；所以我们需要反转一下正向索引从而得到倒排索引，也即通过 keyword 映射到所有包含它的 doc 列表，这样当我们查询包含某个指定 keyword 的 doc 列表时，只需要利用倒排索引就可以快速定位到对应的结果，然后还是根据打分模型进行排序返回。</p><p>上面的描述只是搜索引擎倒排索引的简化原理，实际的倒排索引设计是要复杂很多的，有兴趣的读者可以自行查找资料学习，这里就不再展开。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172519621.png" alt="image-20240618172519621"></p><p>回到虚拟内存的倒排页表，它正是采用了和倒排索引类似的思想，反转了映射过程：前面我们学习到的页表设计都是以虚拟地址页号 VPN 作为页表项 PTE 索引，映射到物理页框号 PPN，而在倒排页表中则是以 PPN 作为 PTE 索引，映射到 (进程号，虚拟页号 VPN)。</p><p>倒排页表在寻址空间更大的 CPU 架构下尤其高效，或者应该说更适合那些『虚拟内存空间/物理内存空间』比例非常大的场景，因为这种设计是以实际物理内存页框作为 PTE 索引，而不是以远超物理内存的虚拟内存作为索引。例如，以 64 位架构为例，如果是单页表结构，还是用 12 位作为页面地址偏移量，也就是 4KB 的内存页大小，那么以最理论化的方式来计算，则需要 2^52 个 PTE，每个 PTE 占 8 个字节，那么整个页表需要 32PB 的内存空间，这完全是不可接受的，而如果采用倒排页表，假定使用 4GB 的 RAM，则只需要 2^20 个 PTE，极大减少内存使用量。</p><p>倒排页表虽然在节省内存空间方面效果显著，但同时却引入了另一个重大的缺陷：地址翻译过程变得更加低效。我们都清楚 MMU 的工作就是要把虚拟内存地址翻译成物理内存地址，现在索引结构变了，物理页框号 PPN 作为索引，从原来的 VPN --&gt; PPN 变成了 PPN --&gt; VPN，那么当进程尝试访问一个虚拟内存地址之时，CPU 在通过地址总线把 VPN 发送到 MMU 之后，基于倒排页表的设计，MMU 并不知道这个 VPN 对应的是不是一个缺页，所以不得不扫描整个倒排页表来找到该 VPN，而最要命的是就算是一个非缺页的 VPN，每次内存访问还是需要执行这个全表扫描操作，假设是前面提到的 4GB RAM 的例子，那么相当于每次都要扫描 2^20 个 PTE，相当低效。</p><p>这时候又是我们的老朋友 – TLB 出场的时候了，我们只需要把高频使用的页面缓存在 TLB 中，借助于硬件，在 TLB 缓存命中的情况下虚拟内存地址的翻译过程就可以像普通页表那样快速，然而当 TLB 失效的时候，则还是需要通过软件的方式去扫描整个倒排页表，线性扫描的方式非常低效，因此一般倒排页表会基于哈希表来实现，假设有 1G 的物理内存，那么这里就一共有 2^18 个 4KB 大小的页框，建立一张以 PPN 作为 key 的哈希表，则可以划分成 2^18 个 4KB 大小的页框，假设 0 作为 PPN 的起点，则 [0, 2^18 - 1] 就是 PPN 的取值范围，以此作为 Hash map 的 key，然后实现一个哈希函数，使用 VPN 作为入参，使得哈希函数最后输出的哈希值落在 [0, 2^18 - 1] 区间内，每一个 key 值对应的 value 中存储的是 (VPN, PNN)，那么所有具有相同哈希值的 VPN 会被链接在一起形成一个冲突链，如果我们把哈希表的槽数设置成跟物理页框数量一致的话，那么这个倒排哈希表中的冲突链的平均长度将会是 1 个 PTE，可以大大提高查询速度。当 VPN 通过倒排页表匹配到 PPN 之后，这个 (VPN, PPN) 映射关系就会马上被缓存进 TLB，以加速下次虚拟地址翻译。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618172533984.png" alt="image-20240618172533984"></p><p>倒排页表在 64 位架构的计算机中很常见，因为在 64 位架构下，基于分页的虚拟内存中即便把页面 Page 的大小从一般的 4KB 提升至 4MB，依然需要一个拥有 2^42 个 PTE 的巨型页表放在主存中（理论上，实际上不会这么实现），极大地消耗内存。</p><p>简单来说：</p><p>倒排页表是一种用于操作系统内存管理的技术，主要用于解决传统页表在处理大量内存时所需的过多内存空间问题。</p><p>在传统的页表系统中，操作系统为每个进程都维护一个页表，用于将进程的虚拟地址映射到物理地址。然而，随着内存大小的增长，这种方式需要的页表空间也会急剧增加，这在一些内存资源紧张的环境下，如嵌入式系统，是无法接受的。</p><p>倒排页表的思想是，<strong>不再为每个进程维护一个页表，而是只维护一个全局的页表。这个全局页表的每个条目不再是虚拟地址到物理地址的映射，而是物理地址到虚拟地址的映射，因此被称为“倒排”。</strong></p><p><strong>倒排页表中的每个条目，包含了物理地址、对应的虚拟地址、以及这个虚拟地址所属的进程ID。当一个进程需要访问内存时，操作系统会在倒排页表中查找，找到与进程ID和虚拟地址都匹配的条目，然后使用条目中的物理地址来访问内存。</strong></p><p>这种方式的优点是，表的大小与物理内存的大小成正比，而不是与虚拟内存的大小成正比，因此大大减小了页表所需的内存空间。然而，这也带来了一些缺点，比如查找页表的速度会比传统的页表慢，因为需要遍历整个倒排页表来找到匹配的条目。</p><h3 id="总结"><strong>总结</strong></h3><p>现在让我们来回顾一下本文的核心内容：虚拟内存是存在于计算机 CPU 和物理内存之间一个中间层，主要作用是高效管理内存并减少内存出错。虚拟内存的几个核心概念有：</p><ol><li><strong>页表</strong>：从数学角度来说页表就是一个函数，入参是虚拟页号 VPN，输出是物理页框号 PPN，也就是物理地址的基址。页表由页表项组成，页表项中保存了所有用来进行地址翻译所需的信息，页表是虚拟内存得以正常运作的基础，每一个虚拟地址要翻译成物理地址都需要借助它来完成。<strong>页表通常保存在计算机的内存中。每个进程都有它自己的页表，它是操作系统用来管理虚拟内存的一种重要数据结构。每个进程的页表都是独立的，用于将该进程的虚拟内存地址映射到物理内存地址。当进程需要访问内存时，它会提供一个虚拟内存地址，操作系统会通过查找该进程的页表，将虚拟内存地址转换为对应的物理内存地址，然后才能进行实际的内存访问。因此，可以说每个进程都有一个页表，这个页表存储在内存中，并由操作系统进行管理。这样做的好处是每个进程都有自己的独立地址空间，互不干扰，提高了系统的稳定性和安全性。</strong></li><li><strong>TLB</strong>：计算机硬件，主要用来解决引入虚拟内存之后寻址的性能问题，加速地址翻译。如果没有 TLB 来解决虚拟内存的性能问题，那么虚拟内存将只可能是一个学术上的理论而无法真正广泛地应用在计算机中。</li><li><strong>多级页表和倒排页表</strong>：用来解决虚拟地址空间爆炸性膨胀而导致的大页表问题，多级页表通过将单页表进行分拆并按需分配虚拟内存页而倒排页表则是通过反转映射关系来实现节省内存的效果。</li></ol><p>最后，虚拟内存技术中还需要涉及到操作系统的页面置换机制，由于页面置换机制也是一个较为庞杂和复杂的概念，本文便不再继续剖析这一部分的原理，我们在以后的文章中再单独拿来讲解。</p><p>原文作者：allanpan，腾讯 IEG 后台开发工程师</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g">https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g</a></p>]]></content>
    
    
    <summary type="html">深入剖析虚拟内存工作原理</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket协议</title>
    <link href="https://penge666.github.io/posts/5447b09e.html"/>
    <id>https://penge666.github.io/posts/5447b09e.html</id>
    <published>2024-06-18T02:20:28.000Z</published>
    <updated>2024-06-18T02:35:07.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言">0.前言</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102135047.png" alt="image-20240618102135047"></p><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p><p>WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。</p><h2 id="1-WebSocket简介">1.WebSocket简介</h2><p>webSocket是什么:</p><p>1、WebSocket是一种在单个TCP连接上进行全双工通信的协议</p><p>2、WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据</p><p>3、在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输</p><p>4、需要安装第三方包：cmd中：go get -u -v <a href="https://link.zhihu.com/?target=http%3A//github.com/gorilla/websocket">github.com/gorilla/websocket</a></p><p>WebSocket 是一种标准协议，用于在客户端和服务端之间进行双向数据传输。但它跟 HTTP 没什么关系，它是一种基于 TCP 的一种独立实现。</p><p>以前客户端想知道服务端的处理进度，要不停地使用 Ajax 进行轮询，让浏览器隔个几秒就向服务器发一次请求，这对服务器压力较高。另外一种轮询就是采用 long poll 的方式，这就跟打电话差不多，没收到消息就一直不挂电话，也就是说，客户端发起连接后，如果没消息，就一直不返回 Response 给客户端，连接阶段一直是阻塞的。</p><p>而 WebSocket 解决了 HTTP 的这几个难题。首先，当服务器完成协议升级后（ HTTP -&gt; WebSocket ），服务端可以主动推送信息给客户端，解决了轮询造成的同步延迟问题。由于 WebSocket 只需要一次 HTTP 握手，服务端就能一直与客户端保持通讯，直到关闭连接，这样就解决了服务器需要反复解析 HTTP 协议，减少了资源的开销。</p><p>WebSocket协议支持（在受控环境中运行不受信任的代码的）客户端与（选择加入该代码的通信的）远程主机之间进行全双工通信。用于此的安全模型是Web浏览器常用的基于原始的安全模式。 协议包括一个开放的握手以及随后的TCP层上的消息帧。 该技术的目标是为基于浏览器的、需要和服务器进行双向通信的（服务器不能依赖于打开多个HTTP连接（例如，使用XMLHttpRequest或和长轮询））应用程序提供一种通信机制。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102203194.png" alt="image-20240618102203194"></p><p>websocket 是一个基于应用层的网络协议，建立在tcp 协议之上，和 http 协议可以说是兄弟的关系，但是这个兄弟有点依赖 http ，为什么这么说呢？我们都知道 HTTP 实现了三次握手来建立通信连接，实际上 websocket 的创始人很聪明，他不想重复的去造轮子，反正我兄弟已经实现了握手了，我干嘛还要重写一套呢？先让它去冲锋陷阵呢，我坐收渔翁之利不是更香 吗，所以一般来说，我们会先用 HTTP 先进行三次握手，再向服务器请求升级为websocket 协议，这就好比说，嘿兄弟你先去给我排个队占个坑位建个小房子，到时候我在把这房子改造成摩天大楼。而且一般来说 80 和 443 端口一般 web 服务端都会外放出去，这样可以有效的避免防火墙的限制。当然，你创建的 websocket 服务端进程的端口也需要外放出去。</p><p>很多人会想问，web开发 使用 HTTP 协议不是已经差不多够用了吗？为什么还要我再多学一种呢？这不是搞事情嘛，仔细想想，一门新技术的产生必然有原因的，如果没有需求，我们干嘛那么蛋疼去写那么多东西，就是因为 HTTP 这个协议有些业务需求支持太过于鸡肋了，从 HTTP 0.9 到现在的 HTTP3.0 ，HTTP协议可以说说是在普通的web开发领域已经是十分完善且高效的了，说这个协议养活了全球半数的公司也不为过吧，像 2.0 服务器推送技术，3.0 采用了 UDP 而放弃了原来的 TCP ,这些改动都是为了进一步提升协议的性能，然而大家现在还是基本使用的 HTTP 1.1 这个最为经典的协议, 也是让开发者挺尴尬的。</p><p>绝大多数的web开发都是应用层开发者,大多数都是基于已有的应用层去开发应用，可以说我们最熟悉、日常打交道最多的就是应用层协议了，底下 TCP/IP 协议我们基本很少会去处理，当然大厂可能就不一样了，自己弄一套协议也是正常的，这大概也是程序员和码农的区别吧，搬砖还是创新，差别还是很大的。网络这种分层协议的好处我在之前的文章也说过了，这种隔离性很方便就可以让我们基于原来的基础去拓展，具有较好的兼容性。</p><p>总的来说，它就是一种依赖HTTP协议的，支持全双工通信的一种应用层网络协议。</p><h2 id="2-WebSocket产生背景">2.WebSocket产生背景</h2><p>简单的说，WebSocket协议之前，双工通信是通过多个http链接来实现，这导致了效率低下。WebSocket解决了这个问题。下面是标准RFC6455中的产生背景概述。</p><p>长久以来, 创建实现客户端和用户端之间双工通讯的web app都会造成HTTP轮询的滥用: 客户端向主机不断发送不同的HTTP呼叫来进行询问。</p><p><strong>这会导致一系列的问题：</strong></p><ul><li>1.服务器被迫为每个客户端使用许多不同的底层TCP连接：一个用于向客户端发送信息，其它用于接收每个传入消息。</li><li>2.有些协议有很高的开销，每一个客户端和服务器之间都有HTTP头。</li><li>3.客户端脚本被迫维护从传出连接到传入连接的映射来追踪回复。</li></ul><p>一个更简单的解决方案是使用单个TCP连接双向通信。 这就是WebSocket协议所提供的功能。 结合WebSocket API ，WebSocket协议提供了一个用来替代HTTP轮询实现网页到远程主机的双向通信的方法。</p><p>WebSocket协议被设计来取代用HTTP作为传输层的双向通讯技术,这些技术只能牺牲效率和可依赖性其中一方来提高另一方，因为HTTP最初的目的不是为了双向通讯。</p><h2 id="3-WebSocket实现原理">3.WebSocket实现原理</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102242067.png" alt="image-20240618102242067"></p><p>在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：</p><ol><li><p>Header：互相沟通的Header是很小的-大概只有 2 Bytes。</p></li><li><p>Server Push：服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。</p></li></ol><h2 id="4-WebSocket协议举例">4.WebSocket协议举例</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102254393.png" alt="image-20240618102254393"></p><p>浏览器请求:</p><ul><li>GET /webfin/websocket/ HTTP/1.1。</li><li>Host: localhost。</li><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==。</li><li>Origin: <a href="https://link.zhihu.com/?target=http%3A//xn--zfru1gfr6bz63i/">http://服务器地址</a>。</li><li>Sec-WebSocket-Version: 13。</li></ul><p>服务器回应:</p><ul><li>HTTP/1.1 101 Switching Protocols。</li><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=。</li><li>WebSocket借用http请求进行握手，相比正常的http请求，多了一些内容。其中：</li><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>表示希望将http协议升级到Websocket协议。Sec-WebSocket-Key是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。</li></ul><p>服务器返回:</p><ul><li>Upgrade: websocket。</li><li>Connection: Upgrade。</li><li>告诉浏览器即将升级的是Websocket协议</li></ul><p>Sec-WebSocket-Accept是将请求包“Sec-WebSocket-Key”的值，与”258EAFA5-E914-47DA-95CA-C5AB0DC85B11″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码得到的。用来说明自己是WebSocket助理服务器。</p><p>Sec-WebSocket-Version是WebSocket协议版本号。RFC6455要求使用的版本是13，之前草案的版本均应当被弃用。</p><h2 id="5-WebSocket使用">5.WebSocket使用</h2><h3 id="5-1-WebSocket-介绍">5.1 WebSocket 介绍</h3><p>WebSocket 发起单个请求，服务端不需要等待客服端，客户端在任何时候也能发消息到服务端，减少了轮询时候的延迟.经历一次连接后，服务器能给客户端发多次。下图是轮询与WebSocket的区别。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102307422.png" alt="image-20240618102307422"></p><p>基于http的实时消息是相当的复杂，在无状态的请求中维持回话的状态增加了复杂度，跨域也很麻烦，使用ajax处理请求有序请求需要考虑更多。通过ajax进行交流也不简单。每一个延伸http功能的目的不是增加他的复杂度。websocket 可以大大简化实时通信应用中的链接。</p><p>Websocket是一种底层网络协议，可以让你在这个基础上建立别的标准协议。比如在WebSocket的客户端的基础上使用XMPP登录不同的聊天服务器，因为所有的XMPP服务理解相同的标准协议。WebSocket是web应用的一种创新。</p><p>为了与其他平台竞争，WebSocket是H5应用提供的一部分先进功能。每个操作系统都需要网络功能，能够让应用使用Sockets与别的主机进行通信，是每个大平台的核心功能。在很多方面，让Web应用表现的像操作系统平台是html5的趋势。像socket这样底层的网络协议APIs不会符合原始的安全模型，也不会有web api那样的设计风格。WebSocket给H5应用提供TCP的方式不会消弱网络安全且有现代的Api。</p><p>WebSocket是Html5平台的一个重要组件也是开发者强有力的工具。简单的说，你需要WebSocket创建世界级的web应用。它弥补了http不适合实时通信的重大缺陷。异步、双向通信模式，通过传输层协议使WebSocket具有普遍灵活性。想象一下你能用WebSocket创建正真实实时应用的所有方式。比如聊天、协作文档编辑、大规模多人在线游戏（MMO）,股票交易应用等等。</p><p>WebSocket是一个协议，但也有一个WebSocket API，这让你的应用去控制WebSocket的协议去响应被服务端触发的事件。API是W3C开发，协议是IETE制定。现代浏览器支持WebSocket API，这包括使用全双工和双向链接的方法和特性。让你执行像打开关闭链接、发送接收消息、监听服务端事件等必要操作。</p><h3 id="5-2-WebSocket-API">5.2 WebSocket API</h3><p>WebSocket API其实就是一个使用WebSocket协议的接口，通过它来建立全双工通道来收发消息，简单易学，要连接远程服务器，只需要创建一个WebSocket对象实体，并传入一个服务端的URL。在客户端和服务端一开始握手的期间，http协议升级到WebSocket协议就建立了连接，底层都是TCP协议。一旦建立连接，通过WebSocket接口可以反复的发送消息。在你的代码里面，你可以使用异步事件监听连接生命周期的每个阶段。</p><p>WebSocket API是纯事件驱动，一旦建立全双工连接，当服务端给客户端发送数据或者资源，它能自动发送状态改变的数据和通知。所以你不需要为了状态的更新而去轮训Server，在客户端监听即可。</p><p>首先，我们需要通过调用WebSocket构造函数来创建一个WebSocket连接，构造函数会返回一个WebSocket实例，可以用来监听事件。这些事件会告诉你什么时候连接建立，什么时候消息到达，什么时候连接关闭了，以及什么时候发生了错误。WebSocket协议定义了两种URL方案，WS和WSS分别代表了客户端和服务端之间未加密和加密的通信。WS(WebSocket)类似于Http URL，而WSS（WebSocket Security）URL 表示连接是基于安全传输层（TLS/SSL）和https的连接是同样的安全机制。</p><p>WebSocket的构造函数需要一个URL参数和一个可选的协议参数（一个或者多个协议的名字），协议的参数例如XMPP（Extensible Messaging and Presence Protocol）、SOAP（Simple Object Access Protocol）或者自定义协议。而URL参数需要以WS://或者WSS://开头，例如：ws://<a href="https://link.zhihu.com/?target=http%3A//www.websocket.org">http://www.websocket.org</a>，如果URL有语法错误，构造函数会抛出异常。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create new WebSocket connection</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.websocket.org&quot;</span>);</span><br><span class="line"><span class="comment">//测试了下链接不上。</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102319312.png" alt="image-20240618102319312"></p><p>第二个参数是协议名称，是可选的，服务端和客服端使用的协议必须一致，这样收发消息彼此才能理解，你可以定义一个或多个客户端使用的协议，服务端会选择一个来使用，一个客服端和一个服务端之间只能有一个协议。当然都得基于WebSocket，WebSocket的重大好处之一就是基于WebSocket协议的广泛使用，让你的Web能够拥有传统桌面程序那样的能力。</p><p>言归正传，我们回到构造函数，在第一次握手之后，和协议的名称一起，客户端会发送一个Sec-WebSocket-Protocol 头，服务端会选择0个或一个协议，响应会带上同样的Sec-WebSocket-Protocol 头，否则会关闭连接。通过协议协商（Protocol negotiation ），我们可以知道给定的WebSocket服务器所支持的协议和版本，然后应用选择协议使用。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connecting to the server with one protocol called myProtocol</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="type">WebSocket</span>(<span class="string">&quot;ws://echo.websocket.org&quot;</span>, <span class="string">&quot;myProtocol&quot;</span>);</span><br><span class="line"><span class="comment">//myProtocol 是假设的一个定义好的且符合标准的协议。</span></span><br></pre></td></tr></table></figure><p>你可以传递一个协议的数组。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> echoSocket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org&quot;</span>, [<span class="string">&quot;com.kaazing.echo&quot;</span>,<span class="string">&quot;example.imaginary.protocol&quot;</span>])</span><br><span class="line"><span class="comment">//服务端会选择其中一个使用</span></span><br><span class="line">echoSocket.onopen = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="comment">// Check the protocol chosen by the server</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(echoSocket.protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：com.kaazing.ech</p><p>协议这个参数有三种。</p><p>1.注册协议：根据RFC6455（WebSocket 协议）和IANA被官方注册的标准协议。例如 微软的SOAP。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102325187.png" alt="image-20240618102325187"></p><p>看到两个华为的：</p><p>2.开放协议：被广泛使用的标注协议，例如XMPP和STOMP。但没有被正式注册。</p><p>3.自定义协议：自己编写和使用的WebSocket的协议。 协议会再后续章节给出详细介绍，下面先看事件、对象和方法以及实例。</p><h3 id="5-3-WebSocket事件">5.3 WebSocket事件</h3><p>WebSocket API是纯事件驱动，通过监听事件可以处理到来的数据和改变的链接状态。客户端不需要为了更新数据而轮训服务器。服务端发送数据后，消息和事件会异步到达。WebSocket编程遵循一个异步编程模型，只需要对WebSocket对象增加回调函数就可以监听事件。你也可以使用addEventListener()方法来监听。而一个WebSocket对象分四类不同事件。</p><h4 id="5-3-1-open">5.3.1 open</h4><p>一旦服务端响应WebSocket连接请求，就会触发open事件。响应的回调函数称为onopen。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Event handler for the WebSocket connection opening</span></span><br><span class="line">ws.onopen = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Connection open...&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>open事件触发的时候，意味着协议握手结束，WebSocket已经准备好收发数据。如果你的应用收到open事件，就可以确定服务端已经处理了建立连接的请求，且同意和你的应用通信。</p><h4 id="5-3-2-Message"><strong>5.3.2 Message</strong></h4><p>当消息被接受会触发消息事件，响应的回调函数叫做onmessage。如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受文本消息的事件处理实例：</span></span><br><span class="line">ws.onmessage = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeof</span> e.data === <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;String message received&quot;</span>, e, e.data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Other message received&quot;</span>, e, e.data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了文本消息，WebSocket消息机制还能处理二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置二进制数据类型为blob（默认类型）</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line"><span class="comment">// Event handler for receiving Blob messages</span></span><br><span class="line">ws.onmessage = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(e.data instanceof Blob)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Blob message received&quot;</span>, e.data);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(e.data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayBuffer</span></span><br><span class="line">ws.<span class="property">binaryType</span> = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">ArrayBuffer</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ArrayBuffer Message Received&quot;</span>, + e.<span class="property">data</span>);</span><br><span class="line"><span class="comment">// e.data即ArrayBuffer类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-3-3-Error">5.3.<strong>3 Error</strong></h4><p>如果发生意外的失败会触发error事件，相应的函数称为onerror,错误会导致连接关闭。如果你收到一个错误事件，那么你很快会收到一个关闭事件，在关闭事件中也许会告诉你错误的原因。而对错误事件的处理比较适合做重连的逻辑。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">ws.onerror = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;WebSocket Error: &quot;</span> , e);</span><br><span class="line"><span class="comment">//Custom function for handling errors</span></span><br><span class="line">handleErrors(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-3-4-Close"><strong>5.3.4 Close</strong></h4><p>不言而喻，当连接关闭的时候回触发这个事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再收发消息。</p><p>WebSocket的规范其实还定义了ping和pong 架构（frames），可以用来做keep-alive，心跳，网络状态查询，latency instrumentation（延迟仪表？），但是目前 WebSocket API还没有公布这些特性，尽管浏览器支持了ping，但不会触发ping事件，相反，浏览器会自动响应pong，第八章会将更多关于ping和pong的细节。</p><p>当然你可以调用close方法断开与服务端的链接来触发onclose事件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;Connection closed&quot;</span>, e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>连接失败和成功的关闭握手都会触发关闭事件，WebSocket的对象的readyState属性就代表连接的状态（2代表正在关闭，3代表已经关闭）。关闭事件有三个属性可以用来做异常处理和重获： wasClean,code和reason。wasClean是一个bool值，代表连接是否干净的关闭。 如果是响应服务端的close事件，这个值为true，如果是别的原因，比如因为是底层TCP连接关闭，wasClean为false。code和reason代表关闭连接时服务端发送的状态，这两个属性和给入close方法的code和reason参数是对应的，稍后会描述细节。</p><h3 id="5-4-WebSocket-方法">5.4 WebSocket 方法</h3><p><strong>WebSocket 对象有两个方法：send()和close()。</strong></p><h4 id="5-4-1-send">5.4.1 send()</h4><p>一旦在服务端和客户端建立了全双工的双向连接，可以使用send方法去发送消息。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送一个文本消息</span></span><br><span class="line">ws.send(<span class="string">&quot;Hello WebSocket!&quot;</span>);</span><br></pre></td></tr></table></figure><p>当连接是open的时候send()方法传送数据，当连接关闭或获取不到的时候回抛出异常。一个通常的错误是人们喜欢在连接open之前发送消息。如下所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将不会工作</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="type">WebSocket</span>(<span class="string">&quot;ws://echo.websocket.org&quot;</span>)</span><br><span class="line">ws.send(<span class="string">&quot;Initial data&quot;</span>);</span><br></pre></td></tr></table></figure><p>正确的姿势如下，应该等待open事件触发后再发送消息。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">ws</span> = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org&quot;</span>)</span><br><span class="line"><span class="keyword">ws</span>.onopen = <span class="keyword">function</span>(<span class="keyword">e</span>) &#123;</span><br><span class="line"><span class="keyword">ws</span>.s</span><br></pre></td></tr></table></figure><p>如果想通过响应别的事件去发送消息，可以检查readyState属性的值为open的时候来实现。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">myEventHandler</span>(data) &#123;</span><br><span class="line">if (ws.readyState === WebSocket.OPEN) &#123;</span><br><span class="line"><span class="comment">//open的时候即可发送</span></span><br><span class="line">ws<span class="selector-class">.send</span>(data);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"><span class="comment">// Do something else in this case.</span></span><br><span class="line"><span class="comment">//Possibly ignore the data or enqueue it.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送二进制数据：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a Blob</span></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="type">Blob</span>(<span class="string">&quot;blob contents&quot;</span>);</span><br><span class="line">ws.send(blob);</span><br><span class="line"><span class="comment">// Send an ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="type">Uint8Array</span>([<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">9</span>]);</span><br><span class="line">ws.send(a.buffer);</span><br></pre></td></tr></table></figure><p>Blob对象和JavaScript File API一起使用的时候相当有用，可以发送或接受文件，大部分的多媒体文件，图像，视频和音频文件。这一章末尾会结合File API提供读取文件内容来发送WebSocket消息的实例代码。</p><h4 id="5-4-2-close"><strong>5.4.2 close()</strong></h4><p>使用close方法来关闭连接，如果连接以及关闭，这方法将什么也不做。调用close方法只后，将不能发送数据。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>close方法可以传入两个可选的参数，code（numerical）和reason（string）,以告诉服务端为什么终止连接。第三章讲到关闭握手的时候再详细讨论这两个参数。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功结束会话</span></span><br><span class="line">ws.<span class="keyword">close</span>(<span class="number">1000</span>, <span class="string">&quot;Closing normally&quot;</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment">//1000是状态码，代表正常结束。</span></span><br></pre></td></tr></table></figure><h3 id="5-5-WebSocket-属性">5.5 WebSocket 属性</h3><p>WebSocket对象有三个属性，readyState，bufferedAmount和Protocol。</p><h4 id="5-5-1-readyState"><strong>5.5.1 readyState</strong></h4><p>WebSocket对象通过只读属性readyState来传达连接状态，它会更加连接状态自动改变。下表展示了readyState属性的四个不同的值。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102337677.png" alt="image-20240618102337677"></p><p>了解当前连接的状态有助于我们调试。</p><h4 id="5-5-2-bufferedAmount"><strong>5.5.2 bufferedAmount</strong></h4><p>有时候需要检查传输数据的大小，尤其是客户端传输大量数据的时候。虽然send()方法会马上执行，但数据并不是马上传输。浏览器会缓存应用流出的数据，你可以使用bufferedAmount属性检查已经进入队列但还未被传输的数据大小。这个值不包含协议框架、操作系统缓存和网络软件的开销。</p><p>下面这个例子展示了如何使用bufferedAmount属性每秒更新发送。如果网络不能处理这个频率，它会自适应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10k</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">THRESHOLD</span> = <span class="number">10240</span>;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://echo.websocket.org&quot;</span>);</span><br><span class="line"><span class="comment">// Listen for the opening event</span></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">setInterval</span>( <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//缓存未满的时候发送</span></span><br><span class="line"><span class="keyword">if</span> (ws.<span class="property">bufferedAmount</span> &lt; <span class="variable constant_">THRESHOLD</span>) &#123;</span><br><span class="line">ws.<span class="title function_">send</span>(<span class="title function_">getApplicationState</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用bufferedAmount属性发送数据可以避免网络饱和。</span></span><br></pre></td></tr></table></figure><h4 id="5-5-3-protocol"><strong>5.5.3 protocol</strong></h4><p>在构造函数中，protocol参数让服务端知道客户端使用的WebSocket协议。而WebSocket对象的这个属性就是指的最终服务端确定下来的协议名称，当服务端没有选择客户端提供的协议或者在连接握手结束之前，这个属性都是空的。</p><p>完整实例：</p><p>现在我们已经过了一遍WebSocket的构造函数、事件、属性和方法，接下来通过一个完整的实例来学习WebSocket API。实例使用“Echo”服务器：ws://<a href="https://link.zhihu.com/?target=http%3A//echo.websocket.org">http://echo.websocket.org</a>，它能够接受和返回发过去的数据。这样有助于理解WebSocket API是如何和服务器交互的。</p><p>首先，我们先建立连接，让页面展示客户端连接服务端的信息，然后发送、接受消息，最后关闭连接。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Websocket Echo Client<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化连接和事件</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">            output = document.getElementById(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">            ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org/echo&quot;</span>);</span><br><span class="line">            <span class="comment">// 监听open</span></span><br><span class="line">            ws.onopen = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">                sendMessage(<span class="string">&quot;Hello WebSocket!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听close</span></span><br><span class="line">            ws.onclose = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Disconnected: &quot;</span> + e.reason);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听errors</span></span><br><span class="line">            ws.onerror = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Error &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听 messages </span></span><br><span class="line">            ws.onmessage = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;Message received: &quot;</span> + e.data);</span><br><span class="line">                <span class="comment">//收到消息后关闭</span></span><br><span class="line">                ws.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">            ws.send(msg);</span><br><span class="line">            <span class="built_in">log</span>(<span class="string">&quot;Message sent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// logging</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">s</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> p = document.createElement(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">            p.style.wordWrap = <span class="string">&quot;break-word&quot;</span>;</span><br><span class="line">            p.textContent = s;</span><br><span class="line">            output.appendChild(p);</span><br><span class="line">            <span class="comment">// Also log information on the javascript console</span></span><br><span class="line">            <span class="built_in">console</span>.<span class="built_in">log</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Start </span></span><br><span class="line">        setup();</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102346962.png" alt="image-20240618102346962"></p><p>判断浏览器是否支持：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (window.WebSocket)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;This browser supports WebSocket!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&quot;This browser does not support WebSocket.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102427323.png" alt="image-20240618102427323"></p><h2 id="6-WebSocket语言支持">6.WebSocket语言支持</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102445482.png" alt="image-20240618102445482"></p><ul><li>所有主流浏览器都支持RFC6455。但是具体的WebSocket版本有区别。</li><li>php jetty netty ruby Kaazing nginx python Tomcat Django erlang</li><li>WebSocket浏览器支持</li><li>WebSocket浏览器支持</li><li>netty .net等语言均可以用来实现支持WebSocket的服务器。</li><li>websocket api在浏览器端的广泛实现似乎只是一个时间问题了, 值得注意的是服务器端没有标准的api, 各个实现都有自己的一套api, 并且tcp也没有类似的提案, 所以使用websocket开发服务器端有一定的风险.可能会被锁定在某个平台上或者将来被迫升级。</li></ul><p>WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）。</p><ul><li>首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解：</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102450054.png" alt="image-20240618102450054"></p><ul><li>有交集，但是并不是全部。另外Html5是指的一系列新的API，或- 者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。</li><li>通俗来说，你可以用HTTP 协议 传输非Html 数据 ，就是这样=。=</li><li>再简单来说， 层级不一样 。</li></ul><h2 id="7-WebSocket通信">7.WebSocket通信</h2><h3 id="7-1-连接握手">7.1 连接握手</h3><p>连接握手分为两个步骤：请求和应答。WebSocket利用了HTTP协议来建立连接，使用的是HTTP的协议升级机制。</p><h4 id="7-1-1-请求">7.1.1 请求</h4><p>一个标准的HTTP请求，格式如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102455041.png" alt="image-20240618102455041"></p><p>请求头的具体格式定义参见**<a href="https://link.zhihu.com/?target=https%3A//link.csdn.net/%3Ftarget%3Dhttps%3A//www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">Request-Line格式</a>**。</p><p><strong>请求header中的字段解析:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102500391.png" alt="image-20240618102500391"></p><p>协议升级机制</p><p>Origin</p><p>所有浏览器将会发送一个 Origin请求头。 你可以将这个请求头用于安全方面（检查是否是同一个域，白名单/ 黑名单等），如果你不喜欢这个请求发起源，你可以发送一个403 Forbidden。需要注意的是非浏览器只能发送一个模拟的 Origin。大多数应用会拒绝不含这个请求头的请求。</p><p>Sec-WebSocket-Key</p><p>由客户端随机生成的，提供基本的防护，防止恶意或者无意的连接。</p><h4 id="7-1-2-应答">7.1.2 应答</h4><p><strong>返回字段解析：</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102505962.png" alt="image-20240618102505962"></p><p>Connection</p><p>可以参见 rfc7230 6.1 和 rfc7230 6.7。</p><p>Sec-WebSocket-Accept</p><p>它通过客户端发送的Sec-WebSocket-Key 计算出来。计算方法：</p><p>将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；</p><p>通过 SHA1 计算出摘要，并转成 base64 字符串。</p><p>Sec-WebSocket-Key / Sec-WebSocket-Accept 的主要作用还是为了避免一些网络通信过程中，一些非期待的数据包，”乱入“进来，导致一些错误的响应，并不能用于实现登录认证和数据安全，这些功能还需要应用层自己实现。</p><h3 id="7-2-数据传输（双工）">7.2 数据传输（双工）</h3><p>WebSocket 以 frame 为单位传输数据, frame 是客户端和服务端数据传输的最小单元。当一条消息过长时, 通信方可以将该消息拆分成多个 frame 发送, 接收方收到以后重新拼接、解码从而还原出完整的消息, 在 WebSocket 中, frame 有多种类型, frame 的类型由 frame 头部的 Opcode 字段指示, WebSocket frame 的结构如下所示:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102511307.png" alt="image-20240618102511307"></p><p>该结构的字段语义如下:</p><p>FIN, 长度为 1 比特, 该标志位用于指示当前的 frame 是消息的最后一个分段, 因为 WebSocket 支持将长消息切分为若干个 frame 发送, 切分以后, 除了最后一个 frame, 前面的 frame 的 FIN 字段都为 0, 最后一个 frame 的 FIN 字段为 1, 当然, 若消息没有分段, 那么一个 frame 便包含了完成的消息, 此时其 FIN 字段值为 1。</p><p>RSV 1 ~ 3, 这三个字段为保留字段, 只有在 WebSocket 扩展时用, 若不启用扩展, 则该三个字段应置为 1, 若接收方收到 RSV 1 ~ 3 不全为 0 的 frame, 并且双方没有协商使用 WebSocket 协议扩展, 则接收方应立即终止 WebSocket 连接。</p><p>Opcode, 长度为 4 比特, 该字段将指示 frame 的类型, RFC 6455 定义的 Opcode 共有如下几种:</p><ul><li>0x0, 代表当前是一个 continuation frame，既被切分的长消息的每个分片frame</li><li>0x1, 代表当前是一个 text frame</li><li>0x2, 代表当前是一个 binary frame</li><li>0x3 ~ 7, 目前保留, 以后将用作更多的非控制类 frame</li><li>0x8, 代表当前是一个 connection close, 用于关闭 WebSocket 连接</li><li>0x9, 代表当前是一个 ping frame</li><li>0xA, 代表当前是一个 pong frame</li><li>0xB ~ F, 目前保留, 以后将用作更多的控制类 frame</li></ul><ol><li>Mask, 长度为 1 比特, 该字段是一个标志位, 用于指示 frame 的数据 (Payload) 是否使用掩码掩盖, RFC 6455 规定当且仅当由客户端向服务端发送的 frame, 需要使用掩码覆盖, 掩码覆盖主要为了解决代理缓存污染攻击 (更多细节见 RFC 6455 Section 10.3)。</li><li>Payload Len, 以字节为单位指示 frame Payload 的长度, 该字段的长度可变, 可能为 7 比特, 也可能为 7 + 16 比特, 也可能为 7 + 64 比特. 具体来说, 当 Payload 的实际长度在 [0, 125] 时, 则 Payload Len 字段的长度为 7 比特, 它的值直接代表了 Payload 的实际长度; 当 Payload 的实际长度为 126 时, 则 Payload Len 后跟随的 16 位将被解释为 16-bit 的无符号整数, 该整数的值指示 Payload 的实际长度; 当 Payload 的实际长度为 127 时, 其后的 64 比特将被解释为 64-bit 的无符号整数, 该整数的值指示 Payload 的实际长度。</li><li>Masking-key, 该字段为可选字段, 当 Mask 标志位为 1 时, 代表这是一个掩码覆盖的 frame, 此时 Masking-key 字段存在, 其长度为 32 位, RFC 6455 规定所有由客户端发往服务端的 frame 都必须使用掩码覆盖, 即对于所有由客户端发往服务端的 frame, 该字段都必须存在, 该字段的值是由客户端使用熵值足够大的随机数发生器生成, 关于掩码覆盖, 将下面讨论, 若 Mask 标识位 0, 则 frame 中将设置该字段 (注意是不设置该字段, 而不仅仅是不给该字段赋值)。</li><li>Payload, 该字段的长度是任意的, 该字段即为 frame 的数据部分, 若通信双方协商使用了 WebSocket 扩展, 则该扩展数据 (Extension data) 也将存放在此处, 扩展数据 + 应用数据, 它们的长度和便为 Payload Len 字段指示的值。</li></ol><p>以下是一个客户端和服务端相互传递文本消息的示例</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102516687.png" alt="image-20240618102516687"></p><p><strong>其中模拟了长消息被切分为多个帧（continuation frame）的例子。</strong></p><h3 id="7-3-关闭请求">7.3 关闭请求</h3><p><strong>关闭相对简单，由客户端或服务端发送关闭帧，即可完成关闭。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102521173.png" alt="image-20240618102521173"></p><h2 id="8-WebSocket协议进一步理解">8.WebSocket协议进一步理解</h2><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p><h3 id="8-1-WebSocket是什么"><strong>8.1 WebSocket是什么</strong></h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。主流浏览器都已经支持。</p><p>WebSocket 是一种全新的协议。它将 TCP 的 Socket（套接字）应用在了网页上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工通信。</p><p>WebSocket 协议在2008年诞生，2011年成为国际标准。主流浏览器都已经支持。WebSocket 协议借用 HTTP协议 的 101 switch protocol 来达到协议转换，从HTTP协议切换WebSocket通信协议。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。</p><h3 id="8-2-WebSocket出现之前的实时技术">8.2 WebSocket出现之前的实时技术</h3><p>轮询：最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的通信。</p><p>长轮询：长轮询也采用轮询的方式，不过采取的是阻塞模型，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p><p>其他方式：如xhr-streaming、隐藏iframe、ActiveX控件、SSE。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102526317.png" alt="image-20240618102526317"></p><p>轮询技术非真正实时技术。使用 Ajax 方式模拟实时效果，每次客户端和服务器端交互，都是一次 HTTP 的请求和应答过程，且每次的 HTTP 请求和应答都带有完整 HTTP 头信息，增加传输的数据量。需构建两个http连接。客户端和服务器端编程实现比较复杂，为模拟真实的实时效果，需构造两个 HTTP 连接来模拟客户端和服务器的双向通信，一个连接用来处理客户端到服务器端的数据传输，一个连接用来处理服务器端到客户端的数据传输，增加了编程实现的复杂度、服务器端的负载，制约了应用系统的扩展性。</p><h3 id="8-3-WebSocket应用场景">8.3 WebSocket应用场景</h3><p>BS架构下的即时通讯、游戏等应用需要客户端与服务端间的双向通信，而HTTP的请求/响应模型并不适合这种场景。会存在一定的问题：</p><ul><li>服务器端被迫提供两类接口，一类提供给客户端轮询新消息，一类提供给客户端推送消息给服务器端。</li><li>HTTP协议有较多的额外开销，每次发送消息都会有一个HTTP header信息，而且如果不用Keep-Alive每次还都要握手。</li><li>客户端的脚本比如JS可能还需要跟踪整个过程，发送一个消息后，我可能需要跟踪这个消息的返回。</li></ul><p>Websocket出现使得浏览器提供socket的支持成为可能，从而在浏览器和服务器之间建立一条基于tcp的双向连接通道，web开发人员可以很方便的利用websocket构建实时web应用。<strong>WebSocket适用于以下场景:</strong></p><ul><li>在线聊天场景：例如qq聊天、淘宝与客服聊天、在线客服等等。这种场景都是需要实时的接收服务器推送的内容。</li><li>协同办公：例如腾讯在线文档，腾讯的在线文档是支持多人编辑的，在excel中，一旦有人修改就要立即同步给所有人。</li><li>直播弹幕：例如虎牙、斗鱼等各大直播平台，在直播时都是有弹幕的，遇到一些精彩片段时，往往会有弹幕刷屏。在这种情况下使用WebSocket会有一个更好的用户体验。</li><li>位置共享：例如微信里位置共享，这种场景需要用户实时的共享自己的位置给服务器，服务器收到位置信息后，要实时的推送给其它共享者的，实时性要求较高；百度地图导航系统，在自己位置到达某个地方之后，语音会立即播报前面道路情况，比如上高架、下地道、拐弯、直行、学校慢行等等。这种场景实时性特别高，汽车速度很快，延迟1秒钟，可能就错过了最佳提醒时机。</li><li>其他通过定义WebSocket子协议的扩展支持：例如sip、mqtt、xmpp、stomp等。</li></ul><h3 id="8-4-WebSocket协议栈">8.4 WebSocket协议栈</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102531782.png" alt="image-20240618102531782"></p><p>**WebSocket是基于TCP的应用层协议。**需要特别注意的是：虽然WebSocket协议在建立连接时会使用HTTP协议，但这并意味着WebSocket协议是基于HTTP协议实现的。</p><h3 id="8-5-WebSocket与HTTP的区别">8.5 WebSocket与HTTP的区别</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102537661.png" alt="image-20240618102537661"></p><ul><li>通信方式不同。WebSocket是双向通信模式，客户端与服务器之间只有在握手阶段是使用HTTP协议的“请求-响应”模式交互，而一旦连接建立之后的通信则使用双向模式交互，不论是客户端还是服务端都可以随时将数据发送给对方；而HTTP协议则至始至终都采用“请求-响应”模式进行通信。也正因为如此，HTTP协议的通信效率没有WebSocket高。</li><li>协议格式不同。HTTP协议的一个数据包就是一条完整的消息；而WebSocket客户端与服务端通信的最小单位是帧，由1个或多个帧组成一条完整的消息。即：发送端将消息切割成多个帧，并发送给服务端；服务端接收消息帧，并将关联的帧重新组装成完整的消息。</li></ul><h3 id="8-6-WebSocket握手过程">8.6 WebSocket握手过程</h3><p><strong>客户端到服务端:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102545826.png" alt="image-20240618102545826"></p><ul><li>GET ws://localhost…… HTTP/1.1 ：打开阶段握手，使用http1.1协议。</li><li>Upgrade：websocket，表示请求为特殊http请求，请求的目的是要将客户端和服务端的通信协议从http升级为websocket。</li><li>Sec-websocket-key：Base64 encode 的值，是浏览器随机生成的。客户端向服务端提供的握手信息。</li></ul><p><strong>服务端到客户端:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102551698.png" alt="image-20240618102551698"></p><ul><li>101状态码：表示切换协议。服务器根据客户端的请求切换到Websocket协议。</li><li>Sec-websocket-accept: 将请求头中的Set-websocket-key添加字符串并做SHA-1加密后做Base64编码，告知客户端服务器能够发起websocket连接。</li></ul><p><strong>客户端发起连接的约定:</strong></p><ul><li>如果请求为wss,则在TCP建立后，进行TLS连接建立。</li><li>请求的方式必须为GET，HTTP版本至少为HTTP1.1。</li><li>请求头中必须有Host。</li><li>请求头中必须有Upgrade，取值必须为websocket。</li><li>请求头中必须有Connection，取值必须为Upgrade。</li><li>请求头中必须有Sec-WebSocket-Key，取值为16字节随机数的Base64编码。</li><li>请求头中必须有Sec-WebSocket-Version，取值为13。</li><li>请求头中可选Sec-WebSocket-Protocol，取值为客户端期望的一个或多个子协议(多个以逗号分割)。</li><li>请求头中可选Sec-WebSocket-Extensitons，取值为子协议支持的扩展集(一般是压缩方式)。</li><li>可以包含cookie、Authorization等HTTP规范内合法的请求头。</li></ul><p><strong>客户端检查服务端的响应:</strong></p><ul><li>服务端返回状态码为101代表升级成功，否则判定连接失败。</li><li>响应头中缺少Upgrade或取值不是websocket，判定连接失败。</li><li>响应头中缺少Connection或取值不是Upgrade，判定连接失败。</li><li>响应头中缺少Sec-WebSocket-Accept或取值非法（其值为请求头中的Set-websocket-key添加字符串并做SHA-1加密后做Base64编码），判定连接失败。</li><li>响应头中有Sec-WebSocket-Extensions,但取值不是请求头中的子集，判定连接失败。</li><li>响应头中有Sec-WebSocket-Protocol,但取值不是请求头中的子集，判定连接失败。</li></ul><p><strong>服务端处理客户端连接:</strong></p><ul><li>服务端根据请求中的Sec-WebSocket-Protocol 字段，选择一个子协议返回，如果不返回，表示不同意请求的任何子协议。如果请求中未携带，也不返回。</li><li>如果建立连接成功，返回状态码为101。</li><li>响应头Connection设置为Upgrade。</li><li>响应头Upgrade设置为websocket。</li><li>Sec-WebSocket-Accpet根据请求头Set-websocket-key计算得到，计算方式为：Set-websocket-key的值添加字符串： 258EAFA5-E914-47DA-95CA-C5AB0DC85B11并做SHA-1加密后得到16进制表示的字符串，将每两位当作一个字节进行分隔，得到字节数组，对字节数组做Base64编码。</li></ul><h3 id="8-7-WebSocket帧格式">8.7 WebSocket帧格式</h3><p><strong>WebSocket通信流程如下:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102600446.png" alt="image-20240618102600446"></p><p><strong>Websocket帧格式如下:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102605562.png" alt="image-20240618102605562"></p><p><strong>第一部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102609366.png" alt="image-20240618102609366"></p><p>FIN：1位，用于描述消息是否结束，如果为1则该消息为消息尾部，如果为零则还有后续数据包。</p><p>RSV1,RSV2,RSV3：各1位，用于扩展定义，如果没有扩展约定的情况则必须为0。</p><p>OPCODE：4位，用于表示消息接收类型，如果接收到未知的opcode，接收端必须关闭连接。</p><p>OPCODE说明:</p><ul><li>0x0表示附加数据帧，当前数据帧为分片的数据帧。</li><li>0x1表示文本数据帧，采用UTF-8编码。</li><li>0x2表示二进制数据帧。</li><li>0x3-7暂时无定义，为以后的非控制帧保留。</li><li>0x8表示连接关闭。</li><li>0x9表示ping。</li><li>0xA表示pong。</li><li>0xB-F暂时无定义，为以后的控制帧保留。</li></ul><p><strong>第二部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102614081.png" alt="image-20240618102614081"></p><ul><li>MASK：1位，用于标识PayloadData是否经过掩码处理。服务端发送给客户端的数据帧不能使用掩码，客户端发送给服务端的数据帧必须使用掩码。如果一个帧的数据使用了掩码，那么在Maksing-key部分必须是一个32个bit位的掩码，用来给服务端解码数据。</li><li>Payload len：数据的长度：默认位7个bit位。如果数据的长度小于125个字节（注意：是字节）则用默认的7个bit来标示数据的长度。如果数据的长度为126个字节，则用后面相邻的2个字节来保存一个16bit位的无符号整数作为数据的长度。如果数据的长度大于126个字节，则用后面相邻的8个字节来保存一个64bit位的无符号整数作为数据的长度。</li><li>payload len本来是只能用7bit来表达的，也就是最多一个frame的payload只能有127个字节，为了表示更大的长度，给出的解决方案是添加扩展payload len字段。当payload实际长度超过126（包括），但在2^16-1长度内，则将payload len置为126，payload的实际长度由长为16bit的extended payload length来表达。当payload实际长度超过216（包括），但在264-1长度内，则将payload置为127，payload的实际长度由长为64bit的extended payload length来表达。</li></ul><p><strong>第三部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102620063.png" alt="img"></p><p>数据掩码：如果MASK设置位0，则该部分可以省略，如果MASK设置位1，则Masking-key是一个32位的掩码。用来解码客户端发送给服务端的数据帧。</p><p><strong>第四部分:</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102625050.png" alt="image-20240618102625050"></p><p>数据：该部分，也是最后一部分，是帧真正要发送的数据，可以是任意长度。</p><h3 id="8-8-WebSocket分片传输">8.8 WebSocket分片传输</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102630470.png" alt="image-20240618102630470"></p><p>控制帧可能插在一个Message的多个分片之间，但一个Message的分片不能交替传输(除非有扩展特别定义)。</p><p>控制帧不可分片。</p><p>分片需要按照分送方提交顺序传递给接收方，但由于IP路由特性，实际并不能保证顺序到达。</p><p>控制帧包括:</p><ul><li>Close：用于关闭连接，可以携带数据，表示关闭原因。</li><li>Ping：可以携带数据。</li><li>Pong：用于Keep-alive，返回最近一次Ping中的数据，可以只发送Pong帧，做单向心跳。</li></ul><p>连接关闭时状态码说明:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102638253.png" alt="image-20240618102638253"></p><h3 id="8-9-WebSocket相关扩展">8.9 WebSocket相关扩展</h3><p>Stomp：</p><p>STOMP是基于帧的协议，它的前身是TTMP协议（一个简单的基于文本的协议），专为消息中间件设计。是属于消息队列的一种协议, 和AMQP, JMS平级。它的简单性恰巧可以用于定义websocket的消息体格式. STOMP协议很多MQ都已支持, 比如RabbitMq, ActiveMq。生产者（发送消息）、消息代理、消费者（订阅然后收到消息）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102644517.png" alt="image-20240618102644517"></p><p>\2. SockJs：</p><p>SockJS是一个浏览器JavaScript库，它提供了一个类似于网络的对象。SockJS提供了一个连贯的、跨浏览器的Javascript API，它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域通信通道。</p><p>SockJS的一大好处在于提供了浏览器兼容性。优先使用原生WebSocket，如果在不支持websocket的浏览器中，会自动降为轮询的方式。 除此之外，spring也对socketJS提供了支持。</p><p>\3. <a href="https://link.zhihu.com/?target=http%3A//Socket.io">Socket.io</a>：</p><p><a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>实际上是WebSocket的父集，<a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>封装了WebSocket和轮询等方法，会根据情况选择方法来进行通讯。</p><p><a href="https://link.zhihu.com/?target=http%3A//Sockei.io">http://Sockei.io</a>最早由Node.js实现，Node.js提供了高效的服务端运行环境，但由于Browser对HTML5的支持不一，为了兼容所有浏览器，提供实时的用户体验，并为开发者提供客户端与服务端一致的编程体验，于是<a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>诞生了。Java模仿Node.js实现了Java版的<a href="https://link.zhihu.com/?target=http%3A//Netty-socket.io">http://Netty-socket.io</a>库。</p><p><a href="https://link.zhihu.com/?target=http%3A//Socket.io">http://Socket.io</a>将WebSocket和Polling机制以及其它的实时通信方式封装成通用的接口，并在服务端实现了这些实时机制相应代码，包括：AJAX Long Polling、Adobe Flash Socket、AJAX multipart streaming、Forever Iframem、JSONP Polling。</p><h2 id="9-WebSocket-能解决什么问题">9.WebSocket 能解决什么问题</h2><p>工程师应该是以解决问题为主的，如果不会解决问题，只会伸手，必然不会长远，有思考，才会有突破，才能高效的处理事情，所以 websocket 到底解决了什么问题呢？它存在的价值是什么？</p><p>这还是得从HTTP说起，大家应该都很熟悉这门协议，我们简单说一下它的特点：</p><p>•三次握手、四次挥手 的方式建立连接和关闭连接</p><p>•支持长连接和短连接两种连接方式</p><p>•有同源策略的限制（端口，协议，域名）</p><p>•单次 请求-响应 机制，只支持单向通信</p><p>其中最鸡肋的就是最后一个特点，单向通信，什么意思呐？ 就是说只能由一方发起请求（客户端），另一方响应请求（服务端），而且每一次的请求都是一个单独的事件，请求之间还无法具有关联性，也就是说我上个请求和下个请求完全是隔离的，无法具有连续性。</p><p>也许你觉得这样的说法比较难懂，我们来举一个栗子：</p><p>每个人都打过电话吧，电话打通后可以一直聊天是不是觉得很舒服啊，这是一种全双工的通信方式，双方都可以主动传递信息。彼此的聊天也具有连续性。我们简单把这种方式理解为 websocket 协议支持的方式。</p><p>如果打电话变成了 HTTP 那种方式呢？ 那就不叫打电话了，而是联通爸爸的智能语音助手了，我们知道客户端和服务端本身的身份并不是固定的，只要你可以发起通信，就可以充当客户端，能响应请求，就可以当做服务端，但是在HTTP的世界里一般来说，客户端（大多数情况下是浏览器）和服务器一般是固定的，我们打电话 去查话费，会询问要人工服务还是智能助手，如果选了助手，你只要问她问题，她就会找对应的答案来回答你（响应你），一般都是简单的业务，你不问她也不会跟你闲聊，主动才有故事啊！</p><p>但是实际上有很多的业务是需要双方都有主动性的，半双工的模式肯定是不够用的，例如聊天室，跟机器人聊天没意思啊，又例如主动推送，我无聊的时候手都不想点屏幕，你能不能主动一点给我推一些好玩的信息过来。</p><p>只要做过前后端分离的同学应该都被跨域的问题折磨过。浏览器的这种同源策略，会导致 不同端口/不同域名/不同协议 的请求会有限制，当然这问题前后端都能处理，然而 websocket 就没有这种要求，他支持任何域名或者端口的访问（协议固定了只能是 ws/wss) ,所以它让人用的更加舒服</p><p>所以，上面 HTTP 存在的这些问题，websocket 都能解决！！！</p><h2 id="10-WebSocket工作原理">10.WebSocket工作原理</h2><p>主动是 websocket 的一大特点，像之前如果客户端想知道服务端对某个事件的处理进度，就只能通过轮训( Poll )的方式去询问，十分的耗费资源，会存在十分多的无效请求。下面我简单说推送技术的三种模型区别：</p><ul><li>•pull (主动获取) 即客户端主动发起请求，获取消息</li><li>•poll (周期性主动获取) 即周期性的主动发起请求，获取消息</li><li>•push (主动推送) 服务端主动推送消息给客户端</li></ul><p>pull 和 poll 的唯一区别只在于周期性，但是很明显周期性的去询问，对业务来说清晰度很高，这也是为什么很多小公司都是基于轮训的方式去处理业务，因为简单嘛，能力不够机器来撑。这也是很多公司都会面临的问题，如果业务达到了瓶颈，使劲的堆机器，如果用新技术或者更高级的作法，开发成本和维护成本也会变高，还不如简单一点去增加机器配置。</p><p>如果两个人需要通话，首先需要建立一个连接，而且必须是一个长链接，大家都不希望讲几句话就得重新打吧，根据上面说的，websocket 会复用之前 HTTP 建立好的长链接，然后再进行升级，所以他和轮训的区别大致如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102652651.png" alt="image-20240618102652651"></p><p>图片省去了建立连接的过程，我们可以发现，基于轮训的方式，必须由客户端手动去请求，才会有响应，而基于 websocket 协议，不再需要你主动约妹子了，妹子也可以主动去约你，这才是公平的世界。</p><p>为了更好的阐述这个连接的原理，可以使用swoole 自带的 创建websocket 的功能进行测试，服务端代码如下，如果连接不上，可以看看是不是检查一下端口开放情况（iptables/filewall)和网络的连通性，代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>创建websocket服务器对象，监听<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9501</span>端口</span><br><span class="line"><span class="variable">$ws</span> = new Swoole\WebSocket\Server(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">9501</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>监听WebSocket连接打开事件</span><br><span class="line"><span class="variable">$ws</span>-&gt;on(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$ws</span>, <span class="variable">$request</span>) &#123;</span><br><span class="line">    var_dump(<span class="variable">$request</span>-&gt;fd, <span class="variable">$request</span>-&gt;get, <span class="variable">$request</span>-&gt;server); <span class="regexp">//</span>request 对象包含请求的相关信息</span><br><span class="line">    <span class="regexp">//</span><span class="variable">$ws</span>-&gt;push(<span class="variable">$request</span>-&gt;fd, <span class="string">&quot;hello, welcome\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>监听WebSocket消息事件</span><br><span class="line"><span class="variable">$ws</span>-&gt;on(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$ws</span>, <span class="variable">$frame</span>) &#123;  <span class="regexp">//</span> frame 是存储信息的变量，也就是传输帧</span><br><span class="line">    echo <span class="string">&quot;Message: &#123;$frame-&gt;data&#125;\n&quot;</span>;</span><br><span class="line">    <span class="variable">$ws</span>-&gt;push(<span class="variable">$frame</span>-&gt;fd, <span class="string">&quot;server: &#123;$frame-&gt;data&#125;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>监听WebSocket连接关闭事件</span><br><span class="line"><span class="variable">$ws</span>-&gt;on(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$ws</span>, <span class="variable">$fd</span>) &#123; <span class="regexp">//</span> fd 是客户端的标志</span><br><span class="line">    echo <span class="string">&quot;client-&#123;$fd&#125; is closed\n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$ws</span>-&gt;start(); <span class="regexp">//</span> 启动这个进程</span><br></pre></td></tr></table></figure><p>我们可以发现，相比于 HTTP 的头部，websocket 的数据结构十分的简单小巧，没有像 HTTP 协议一样老是带着笨重的头部，这一设计让websocket的报文可以在体量上更具优势，所以传输效率来说更高 。</p><p>当然，我们传输的文本也不能在大街上裸跑啊，既然 HTTP 都有衣服穿了（HTTPS），websocket（ws) 当然也有 （wss）。</p><p>在以前的文章我们也简单聊过 HTTPS 是个什么东西，大家不了解可以去翻一下之前的文章，总的来说就是使用了非对称加密算法进行了对称加密密钥的传输，后续采用对称加密解密的方式进行数据安全处理。</p><p>如果你的业务需要支撑双全工的通信，那么 websocket 便是一个很不错的选择。网上大多数关于 websocket 的文章，大多是基于前端学习者的角度，他们使用 Chrome 的console 的调试实验，本篇文章更多是基于后端开发者的角度。希望对你有所帮助。</p><h2 id="11-进一步解析什么是WebSocket协议">11.进一步解析什么是WebSocket协议</h2><h3 id="11-1websocket特点">11.1websocket特点</h3><p>1.websocket优点</p><ul><li>保持连接状态：websocket需要先创建连接，使其成为有状态的协议。</li><li>更好支持二进制：定义了二进制帧，增加安全性。</li><li>支持扩展：定义了扩展，可以自己实现部分部分自定义。</li><li>压缩效果好：可以沿用上下文的内容，有更好的压缩效果。</li></ul><p>2.websocket缺点</p><ul><li>开发要求高： 前端后端都增加了一定的难度。</li><li>推送消息相对复杂。</li><li>HTTP协议已经很成熟，现今websocket则太新了一点。</li></ul><h3 id="11-2websocket协议通信过程">11.2websocket协议通信过程</h3><p><strong>协议有两个部分：handshake（握手）和 data transfer（数据传输）。</strong></p><p>1.handshake</p><h4 id="11-2-1-客户端">11.2.1 客户端</h4><p>客户端握手报文是在HTTP的基础上发送一次HTTP协议升级请求。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure><p>Sec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或者无意的连接。</p><p>Sec-WebSocket-Version 表示 WebSocket 的版本，最初 WebSocket 协议太多，不同厂商都有自己的协议版本，不过现在已经定下来了。如果服务端不支持该版本，需要返回一个 Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</p><h4 id="11-2-2-服务端">11.2.2 服务端</h4><p>服务端响应握手也是在HTTP协议基础上回应一个Switching Protocols。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat</span><br></pre></td></tr></table></figure><p>Linux下对应实现代码，注释在代码中。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_handshake</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> sec_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sec_accept[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(linebuf));<span class="comment">//清空以暂存一行报文</span></span><br><span class="line">        index = <span class="built_in">readline</span>(ev-&gt;buffer, index, linebuf);<span class="comment">//获取一行报文</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;Sec-WebSocket-Key&quot;</span>))<span class="comment">//如果一行报文里面包括了Sec-WebSocket-Key</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(linebuf, GUID);<span class="comment">//和GUID连接起来</span></span><br><span class="line">            <span class="built_in">SHA1</span>(linebuf+WEBSOCK_KEY_LENGTH, <span class="built_in">strlen</span>(linebuf+WEBSOCK_KEY_LENGTH), sec_data);<span class="comment">//SHA1</span></span><br><span class="line">            <span class="built_in">base64_encode</span>(sec_data, <span class="built_in">strlen</span>(sec_data), sec_accept);<span class="comment">//base64编码</span></span><br><span class="line">            <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, MAX_BUFLEN);<span class="comment">//清空服务端数据缓冲区</span></span><br><span class="line"></span><br><span class="line">            ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer,<span class="comment">//组装握手响应报文到数据缓冲区，下一步有进行下发</span></span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Upgrade: websocket\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Connection: Upgrade\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Sec-websocket-Accept: %s\r\n\r\n&quot;</span>, sec_accept);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(index != <span class="number">-1</span> &amp;&amp; (ev-&gt;buffer[index] != <span class="string">&#x27;\r&#x27;</span>) || (ev-&gt;buffer[index] != <span class="string">&#x27;\n&#x27;</span>));<span class="comment">//遇到空行之前</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-2-3-data-transfer">11.2.3 data transfer</h4><p>先看数据包格式。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102700462.png" alt="image-20240618102700462"></p><p>FIN：指示这是消息中的最后一个片段。第一个片段也可能是最后的片段。</p><p>RSV1, RSV2, RSV3：一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。</p><p>opcode：操作代码。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">x0</span></span>：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x1</span></span>：表示这是一个文本帧（frame）；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x2</span></span>：表示这是一个二进制帧（frame）；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x3</span></span>-7：保留的操作代码，用于后续定义的非控制帧；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x8</span></span>：表示连接断开；</span><br><span class="line"><span class="tag">%<span class="selector-tag">x9</span></span>：表示这是一个 ping 操作；</span><br><span class="line"><span class="tag">%<span class="selector-tag">xA</span></span>：表示这是一个 pong 操作；</span><br><span class="line"><span class="tag">%<span class="selector-tag">xB</span></span>-F：保留的操作代码，用于后续定义的控制帧。</span><br></pre></td></tr></table></figure><ul><li>mask：是否需要掩码。</li><li>Payload length: 7bit or 7 + 16bit or 7 + 64bit</li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 表示数据载荷的长度</span><br><span class="line"><span class="keyword">x</span> 为 <span class="number">0</span>~<span class="number">126</span>：数据的长度为 <span class="keyword">x</span> 字节；</span><br><span class="line"><span class="keyword">x</span> 为 <span class="number">126</span>：后续 <span class="number">2</span> 个字节代表一个 <span class="number">16</span> 位的无符号整数，该无符号整数的值为数据的长度；</span><br><span class="line"><span class="keyword">x</span> 为 <span class="number">127</span>：后续 <span class="number">8</span> 个字节代表一个 <span class="number">64</span> 位的无符号整数（最高位为 <span class="number">0</span>），该无符号整数的值为数据的长度。</span><br></pre></td></tr></table></figure><p>payload data：消息体。 下面是服务端的代码实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GUID            <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span></span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123; </span><br><span class="line">    WS_HANDSHAKE = <span class="number">0</span>,<span class="comment">//握手</span></span><br><span class="line">    WS_TANSMISSION = <span class="number">1</span>,<span class="comment">//通信</span></span><br><span class="line">    WS_END = <span class="number">2</span>,<span class="comment">//end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_ophdr</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> opcode:<span class="number">4</span>,</span><br><span class="line">    rsv3:<span class="number">1</span>,</span><br><span class="line">    rsv2:<span class="number">1</span>,</span><br><span class="line">    rsv1:<span class="number">1</span>,</span><br><span class="line">    fin:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pl_len:<span class="number">7</span>,</span><br><span class="line">    mask:<span class="number">1</span>;</span><br><span class="line">&#125;ws_ophdr;<span class="comment">//协议前两个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_head_126</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> payload_lenght;</span><br><span class="line">    <span class="type">char</span> mask_key[<span class="number">4</span>];</span><br><span class="line">&#125;ws_head_126;<span class="comment">//协议mask和消息体长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*解码*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">websocket_umask</span><span class="params">(<span class="type">char</span> *payload, <span class="type">int</span> length, <span class="type">char</span> *mask_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;length; i++)</span><br><span class="line">    payload[i] ^= mask_key[i%<span class="number">4</span>];<span class="comment">//异或</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_transmission</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ws_ophdr *ophdr = (ws_ophdr*)ev-&gt;buffer;<span class="comment">//协议前两个自己</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ws_recv_data length=%d\n&quot;</span>, ophdr-&gt;pl_len);</span><br><span class="line">    <span class="keyword">if</span>(ophdr-&gt;pl_len &lt;<span class="number">126</span>)<span class="comment">//如果消息体长度小于126</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * payload = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr) + <span class="number">4</span>;<span class="comment">//获取消息地址</span></span><br><span class="line">        <span class="keyword">if</span>(ophdr-&gt;mask)<span class="comment">//如果消息是掩码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">websocket_umask</span>(payload, ophdr-&gt;pl_len, ev-&gt;buffer+<span class="number">2</span>);<span class="comment">//解码，异或</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;payload:%s\n&quot;</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;payload : %s\n&quot;</span>, payload);<span class="comment">//消息回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;pl_len == <span class="number">126</span>) &#123;</span><br><span class="line">ws_head_126 *hdr126 = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ws_head_127 *hdr127 = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status_machine == WS_HANDSHAKE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">websocket_handshake</span>(ev);<span class="comment">//握手</span></span><br><span class="line">        ev-&gt;status_machine = WS_TANSMISSION;<span class="comment">//设置标志位</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status_machine == WS_TANSMISSION)&#123;</span><br><span class="line">        <span class="built_in">websocket_transmission</span>(ev);<span class="comment">//通信</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码是基于reactor百万并发服务器框架实现的。</strong></p><h3 id="11-3-epoll反应堆模型下实现http协议">11.3.epoll反应堆模型下实现http协议</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240618102724950.png" alt="image-20240618102724950"></p><p>1.客户端结构体</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//clientfd</span></span><br><span class="line">    <span class="type">int</span> events;<span class="comment">//事件：读、写或异常</span></span><br><span class="line">    <span class="type">int</span> status;<span class="comment">//是否位于epfd红黑监听树上</span></span><br><span class="line">    <span class="type">void</span> *arg;<span class="comment">//参数</span></span><br><span class="line">    <span class="type">long</span> last_active;<span class="comment">//上次数据收发的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);<span class="comment">//回调函数，单回调，后面修改成多回调</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];<span class="comment">//数据缓冲区</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//数据长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*http param*/</span></span><br><span class="line">    <span class="type">int</span> method;<span class="comment">//http协议请求头部</span></span><br><span class="line">    <span class="type">char</span> resource[MAX_BUFLEN];<span class="comment">//请求的资源</span></span><br><span class="line">    <span class="type">int</span> ret_code;<span class="comment">//响应状态码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http%3A//2.int">2.int</a> http_response(struct qsevent *ev)</p><p>当客户端发送tcp连接时，服务端的listenfd会触发输入事件会调用ev-&gt;callback即accept_cb回调函数响应连接并获得clientfd，连接之后，http数据报文发送上来，服务端的clientfd触发输入事件会调用ev-&gt;callback即recv_cb回调函数进行数据接收，并解析http报文。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//用于从buffer中获取每一行的请求报文</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">readline</span>(ev-&gt;buffer, <span class="number">0</span>, linebuf);<span class="comment">//读取第一行请求方法，readline函数，后面介绍</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;GET&quot;</span>))<span class="comment">//strstr判断是否存在GET请求方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;method = HTTP_METHOD_GET;<span class="comment">//GET方法表示客户端需要获取资源</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] != <span class="string">&#x27; &#x27;</span>)i++;<span class="comment">//跳过空格</span></span><br><span class="line">        linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(ev-&gt;resource, <span class="string">&quot;./%s/%s&quot;</span>, HTTP_METHOD_ROOT, linebuf+<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>));<span class="comment">//将资源的名字以文件路径形式存储在ev-&gt;resource中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;resource:%s\n&quot;</span>, ev-&gt;resource);<span class="comment">//回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;POST&quot;</span>))<span class="comment">//POST的请求方法，暂时没写，方法差不多</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http%3A//3.int">http://3.int</a> http_response(struct qsevent *ev)</p><p>服务器对客户端的响应报文数据进行http封装储存在buffer中，事件触发时在send_cb回调函数发送给客户端。详细解释请看代码注释。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">http_response</span>(<span class="params">struct</span> <span class="params">qsevent</span> *<span class="params">ev</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">ev</span> <span class="operator">==</span> <span class="variable">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="title function_">memset</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>, <span class="number">0</span>, <span class="variable">MAX_BUFLEN</span>);<span class="comment">//清空缓冲区准备储存报文</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;resource:%s<span class="char escape_">\n</span>&quot;</span>, <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">resource</span>);<span class="comment">//resource：客户端请求的资源文件，通过http_reques函数获取</span></span><br><span class="line">    int <span class="variable">filefd</span> <span class="operator">=</span> <span class="title function_">open</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">resource</span>, <span class="variable">O_RDONLY</span>);<span class="comment">//只读方式打开获得文件句柄</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">filefd</span> <span class="operator">==</span> <span class="number">-1</span>)<span class="comment">//获取失败则发送404 NOT FOUND</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">ret_code</span> <span class="operator">=</span> <span class="number">404</span>;<span class="comment">//404状态码</span></span><br><span class="line">        <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">length</span> <span class="operator">=</span> <span class="title function_">sprintf</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>,<span class="comment">//将下面数据传入ev-&gt;buffer</span></span><br><span class="line">         <span class="comment">/***状态行***/</span></span><br><span class="line">         <span class="comment">/*版本号 状态码 状态码描述 */</span></span><br><span class="line">                             <span class="string">&quot;HTTP/1.1 404 NOT FOUND<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/***消息报头***/</span></span><br><span class="line">                             <span class="comment">/*获取当前时间*/</span></span><br><span class="line">                             <span class="string">&quot;date: Thu, 11 Nov 2021 12:28:52 GMT<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/*响应正文类型；              编码方式*/</span></span><br><span class="line">                             <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/*响应正文长度          空行*/</span></span><br><span class="line">                             <span class="string">&quot;Content-Length: 85<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                             <span class="comment">/***响应正文***/</span></span><br><span class="line">                             <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">struct</span> <span class="variable">stat</span> <span class="variable">stat_buf</span>;<span class="comment">//文件信息</span></span><br><span class="line">        <span class="title function_">fstat</span>(<span class="variable">filefd</span>, <span class="operator">&amp;</span><span class="variable">stat_buf</span>);<span class="comment">//fstat通过文件句柄获取文件信息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">S_ISDIR</span>(<span class="variable">stat_buf</span>.<span class="property">st_mode</span>))<span class="comment">//如果文件是一个目录</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">printf</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>, <span class="comment">//同上，将404放入buffer中</span></span><br><span class="line">                   <span class="string">&quot;HTTP/1.1 404 Not Found<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Length: 85<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span> );</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">S_ISREG</span>(<span class="variable">stat_buf</span>.<span class="property">st_mode</span>)) <span class="comment">//如果文件是存在</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">ret_code</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">//200状态码</span></span><br><span class="line"></span><br><span class="line">            <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">length</span> <span class="operator">=</span> <span class="title function_">sprintf</span>(<span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">buffer</span>, <span class="comment">//length记录长度，buffer储存响应报文</span></span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 200 OK<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Length: %ld<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>, </span><br><span class="line">                                 <span class="variable">stat_buf</span>.<span class="property">st_size</span> );<span class="comment">//文件长度储存在stat_buf.st_size中</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">ev</span><span class="operator">-</span><span class="operator">&gt;</span><span class="variable">length</span>;<span class="comment">//返回报文长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.总代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_METHOD_ROOT    <span class="string">&quot;html&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFLEN          4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLLSIZE       1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS    1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_METHOD_GET     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_METHOD_POST    1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*NCALLBACK)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> events;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> last_active;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*http param*/</span></span><br><span class="line">    <span class="type">int</span> method;</span><br><span class="line">    <span class="type">char</span> resource[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> ret_code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qseventblock</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *eventsarrry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsreactor</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="type">int</span> blkcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *evblk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readline</span><span class="params">(<span class="type">char</span> *allbuf, <span class="type">int</span> idx, <span class="type">char</span> *linebuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(allbuf);    </span><br><span class="line">    <span class="keyword">for</span>( ; idx&lt;len; idx++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(allbuf[idx] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; allbuf[idx+<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> idx+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        *(linebuf++) = allbuf[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs_event_set</span><span class="params">(<span class="keyword">struct</span> qsevent *ev, <span class="type">int</span> fd, NCALLBACK callback, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_add</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> events, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    epv.events = ev-&gt;events = events;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_MOD error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_ADD error\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_del</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_DEL error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock</span><span class="params">(<span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(fd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listener[%d] lstening..\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">readline</span>(ev-&gt;buffer, <span class="number">0</span>, linebuf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;method = HTTP_METHOD_GET;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] != <span class="string">&#x27; &#x27;</span>)i++;</span><br><span class="line">        linebuf[<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>) + i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(ev-&gt;resource, <span class="string">&quot;./%s/%s&quot;</span>, HTTP_METHOD_ROOT, linebuf+<span class="built_in">sizeof</span>(<span class="string">&quot;GET &quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;resource:%s\n&quot;</span>, ev-&gt;resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_response</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, MAX_BUFLEN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;resource:%s\n&quot;</span>, ev-&gt;resource);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> filefd = <span class="built_in">open</span>(ev-&gt;resource, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(filefd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;ret_code = <span class="number">404</span>;</span><br><span class="line">        ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer,</span><br><span class="line">                             <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;date: Thu, 11 Nov 2021 12:28:52 GMT\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;Content-Length: 85\r\n\r\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;\r\n\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> stat stat_buf;</span><br><span class="line">        <span class="built_in">fstat</span>(filefd, &amp;stat_buf);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(stat_buf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(ev-&gt;buffer, </span><br><span class="line">                   <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Content-Length: 85\r\n\r\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;404&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;\r\n\r\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISREG</span>(stat_buf.st_mode)) </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ev-&gt;ret_code = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">            ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer, </span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Date: Thu, 11 Nov 2021 12:28:52 GMT\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Type: text/html;charset=ISO-8859-1\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Content-Length: %ld\r\n\r\n&quot;</span>, </span><br><span class="line">                                 stat_buf.st_size );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ev-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_init</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(reactor, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *block = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;blockinit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *evs = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(MAX_EPOLLSIZE * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent));</span><br><span class="line">    <span class="keyword">if</span>(evs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;evsnit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="built_in">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    block-&gt;eventsarrry = evs;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;blkcnt = <span class="number">1</span>;</span><br><span class="line">    reactor-&gt;evblk = block;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_alloc</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *tailblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(tailblock-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    tailblock = tailblock-&gt;next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *newblock = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(newblock == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newblock alloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newblock, <span class="number">0</span>, <span class="built_in">sizeof</span>(newblock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *neweventarray = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent) * MAX_EPOLLSIZE);</span><br><span class="line">    <span class="keyword">if</span>(neweventarray == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;neweventarray malloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(neweventarray, <span class="number">0</span>, <span class="built_in">sizeof</span>(neweventarray));</span><br><span class="line"></span><br><span class="line">    newblock-&gt;eventsarrry = neweventarray;</span><br><span class="line">    newblock-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tailblock-&gt;next = newblock;</span><br><span class="line">    reactor-&gt;blkcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = sockfd / MAX_EPOLLSIZE;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= reactor-&gt;blkcnt)<span class="built_in">qsreactor_alloc</span>(reactor);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *idxblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;index &amp;&amp; idxblock != <span class="literal">NULL</span>)</span><br><span class="line">    idxblock = idxblock-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;idxblock-&gt;eventsarrry[sockfd%MAX_EPOLLSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_destory</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    <span class="built_in">free</span>(reactor-&gt;evblk);</span><br><span class="line">    reactor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_addlistener</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd, NCALLBACK acceptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, sockfd);</span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, sockfd, acceptor, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span>   *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">http_response</span>(ev);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, ev-&gt;buffer, ev-&gt;length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clent[%d] &quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ev-&gt;ret_code == <span class="number">200</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> filefd = <span class="built_in">open</span>(ev-&gt;resource, O_RDONLY);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">stat</span> stat_buf;</span><br><span class="line">            <span class="built_in">fstat</span>(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sendfile</span>(fd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);</span><br><span class="line">            <span class="built_in">close</span>(filefd);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, recv_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">recv</span>(fd, ev-&gt;buffer, MAX_BUFLEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;length = len;</span><br><span class="line">        ev-&gt;buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">http_request</span>(ev);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, send_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] close\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;reacv error,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((flag = <span class="built_in">fcntl</span>(clientfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl noblock error, %d\n&quot;</span>,MAX_BUFLEN);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, clientfd, recv_cb, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d], pos[%d]\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), <span class="built_in">ntohs</span>(client_addr.sin_port), clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_run</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EPOLL_EVENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = (<span class="keyword">struct</span> qsevent*)events[i].data.ptr;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">sock</span>(port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    <span class="built_in">qsreactor_init</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_addlistener</span>(reactor, sockfd, accept_cb);</span><br><span class="line">    <span class="built_in">qsreactor_run</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_destory</span>(reactor);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.epoll反应堆模型下实现websocket协议</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFLEN          4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLLSIZE       1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS    1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GUID            <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123; </span><br><span class="line">    WS_HANDSHAKE = <span class="number">0</span>,</span><br><span class="line">    WS_TANSMISSION = <span class="number">1</span>,</span><br><span class="line">    WS_END = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_ophdr</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> opcode:<span class="number">4</span>,</span><br><span class="line">    rsv3:<span class="number">1</span>,</span><br><span class="line">    rsv2:<span class="number">1</span>,</span><br><span class="line">    rsv1:<span class="number">1</span>,</span><br><span class="line">    fin:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pl_len:<span class="number">7</span>,</span><br><span class="line">    mask:<span class="number">1</span>;</span><br><span class="line">&#125;ws_ophdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_head_126</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> payload_lenght;</span><br><span class="line">    <span class="type">char</span> mask_key[<span class="number">4</span>];</span><br><span class="line">&#125;ws_head_126;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ws_head_127</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> payload_lenght;</span><br><span class="line">    <span class="type">char</span> mask_key[<span class="number">4</span>];</span><br><span class="line">&#125;ws_head_127;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*NCALLBACK)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> events;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> last_active;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*websocket param*/</span></span><br><span class="line">    <span class="type">int</span> status_machine;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qseventblock</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *eventsarrry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsreactor</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="type">int</span> blkcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *evblk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readline</span><span class="params">(<span class="type">char</span> *allbuf, <span class="type">int</span> idx, <span class="type">char</span> *linebuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(allbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;idx &lt; len;idx ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allbuf[idx] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; allbuf[idx+<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> idx+<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *(linebuf++) = allbuf[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">base64_encode</span><span class="params">(<span class="type">char</span> *in_str, <span class="type">int</span> in_len, <span class="type">char</span> *out_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    BIO *b64, *bio;    </span><br><span class="line">    BUF_MEM *bptr = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_str == <span class="literal">NULL</span> || out_str == <span class="literal">NULL</span>)        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">    b64 = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_f_base64</span>());    </span><br><span class="line">    bio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());    </span><br><span class="line">    bio = <span class="built_in">BIO_push</span>(b64, bio);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_write</span>(bio, in_str, in_len);    </span><br><span class="line">    <span class="built_in">BIO_flush</span>(bio);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_get_mem_ptr</span>(bio, &amp;bptr);    </span><br><span class="line">    <span class="built_in">memcpy</span>(out_str, bptr-&gt;data, bptr-&gt;length);    </span><br><span class="line">    out_str[bptr-&gt;length<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;    </span><br><span class="line">    size = bptr-&gt;length;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_free_all</span>(bio);    </span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCK_KEY_LENGTH  19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_handshake</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> sec_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sec_accept[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(linebuf));</span><br><span class="line">        index = <span class="built_in">readline</span>(ev-&gt;buffer, index, linebuf);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(linebuf, <span class="string">&quot;Sec-WebSocket-Key&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(linebuf, GUID);</span><br><span class="line">            <span class="built_in">SHA1</span>(linebuf+WEBSOCK_KEY_LENGTH, <span class="built_in">strlen</span>(linebuf+WEBSOCK_KEY_LENGTH), sec_data);</span><br><span class="line">            <span class="built_in">base64_encode</span>(sec_data, <span class="built_in">strlen</span>(sec_data), sec_accept);</span><br><span class="line">            <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, MAX_BUFLEN);</span><br><span class="line"></span><br><span class="line">            ev-&gt;length = <span class="built_in">sprintf</span>(ev-&gt;buffer,</span><br><span class="line">                                 <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Upgrade: websocket\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Connection: Upgrade\r\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;Sec-websocket-Accept: %s\r\n\r\n&quot;</span>, sec_accept);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(index != <span class="number">-1</span> &amp;&amp; (ev-&gt;buffer[index] != <span class="string">&#x27;\r&#x27;</span>) || (ev-&gt;buffer[index] != <span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">websocket_umask</span><span class="params">(<span class="type">char</span> *payload, <span class="type">int</span> length, <span class="type">char</span> *mask_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;length; i++)</span><br><span class="line">    payload[i] ^= mask_key[i%<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_transmission</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ws_ophdr *ophdr = (ws_ophdr*)ev-&gt;buffer;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ws_recv_data length=%d\n&quot;</span>, ophdr-&gt;pl_len);</span><br><span class="line">    <span class="keyword">if</span>(ophdr-&gt;pl_len &lt;<span class="number">126</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * payload = ev-&gt;buffer + <span class="built_in">sizeof</span>(ws_ophdr) + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(ophdr-&gt;mask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">websocket_umask</span>(payload, ophdr-&gt;pl_len, ev-&gt;buffer+<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;payload:%s\n&quot;</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(ev-&gt;buffer, <span class="number">0</span>, ev-&gt;length);</span><br><span class="line">        <span class="built_in">strcpy</span>(ev-&gt;buffer, <span class="string">&quot;00ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">websocket_request</span><span class="params">(<span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status_machine == WS_HANDSHAKE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">websocket_handshake</span>(ev);</span><br><span class="line">        ev-&gt;status_machine = WS_TANSMISSION;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status_machine == WS_TANSMISSION)&#123;</span><br><span class="line">        <span class="built_in">websocket_transmission</span>(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs_event_set</span><span class="params">(<span class="keyword">struct</span> qsevent *ev, <span class="type">int</span> fd, NCALLBACK callback, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_add</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> events, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    epv.events = ev-&gt;events = events;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_MOD error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_ADD error\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_del</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_DEL error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock</span><span class="params">(<span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(fd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listener[%d] lstening..\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_init</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(reactor, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *block = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;blockinit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *evs = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(MAX_EPOLLSIZE * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent));</span><br><span class="line">    <span class="keyword">if</span>(evs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;evsnit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="built_in">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    block-&gt;eventsarrry = evs;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;blkcnt = <span class="number">1</span>;</span><br><span class="line">    reactor-&gt;evblk = block;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_alloc</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *tailblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(tailblock-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    tailblock = tailblock-&gt;next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *newblock = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(newblock == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newblock alloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newblock, <span class="number">0</span>, <span class="built_in">sizeof</span>(newblock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *neweventarray = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent) * MAX_EPOLLSIZE);</span><br><span class="line">    <span class="keyword">if</span>(neweventarray == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;neweventarray malloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(neweventarray, <span class="number">0</span>, <span class="built_in">sizeof</span>(neweventarray));</span><br><span class="line"></span><br><span class="line">    newblock-&gt;eventsarrry = neweventarray;</span><br><span class="line">    newblock-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tailblock-&gt;next = newblock;</span><br><span class="line">    reactor-&gt;blkcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = sockfd / MAX_EPOLLSIZE;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= reactor-&gt;blkcnt)<span class="built_in">qsreactor_alloc</span>(reactor);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *idxblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;index &amp;&amp; idxblock != <span class="literal">NULL</span>)</span><br><span class="line">    idxblock = idxblock-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;idxblock-&gt;eventsarrry[sockfd%MAX_EPOLLSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_destory</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    <span class="built_in">free</span>(reactor-&gt;evblk);</span><br><span class="line">    reactor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_addlistener</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd, NCALLBACK acceptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, sockfd);</span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, sockfd, acceptor, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span>   *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, ev-&gt;buffer, ev-&gt;length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clent[%d] &quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to client[%d]:\n%s\n&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, recv_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">recv</span>(fd, ev-&gt;buffer, MAX_BUFLEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;length = len;</span><br><span class="line">        ev-&gt;buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]:\n%s\n&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">websocket_request</span>(ev);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, send_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] close\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;reacv error,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((flag = <span class="built_in">fcntl</span>(clientfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl noblock error, %d\n&quot;</span>,MAX_BUFLEN);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, clientfd);</span><br><span class="line"></span><br><span class="line">    event-&gt;status_machine = WS_HANDSHAKE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, clientfd, recv_cb, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d], pos[%d]\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), <span class="built_in">ntohs</span>(client_addr.sin_port), clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_run</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EPOLL_EVENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = (<span class="keyword">struct</span> qsevent*)events[i].data.ptr;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">sock</span>(port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    <span class="built_in">qsreactor_init</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_addlistener</span>(reactor, sockfd, accept_cb);</span><br><span class="line">    <span class="built_in">qsreactor_run</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_destory</span>(reactor);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.C1000K reactor模型，epoll实现，连接并回发一段数据，测试正常</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFLEN          4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLLSIZE       1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS    1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*NCALLBACK)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> events;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> last_active;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*callback)(<span class="type">int</span> fd, <span class="type">int</span> event, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[MAX_BUFLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qseventblock</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *eventsarrry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsreactor</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="type">int</span> blkcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *evblk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs_event_set</span><span class="params">(<span class="keyword">struct</span> qsevent *ev, <span class="type">int</span> fd, NCALLBACK callback, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_add</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> events, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    epv.events = ev-&gt;events = events;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_MOD error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_ADD error\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qs_event_del</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> qsevent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;EPOLL_CTL_DEL error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock</span><span class="params">(<span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="built_in">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(fd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listener[%d] lstening..\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_init</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(reactor, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *block = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;blockinit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *evs = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(MAX_EPOLLSIZE * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent));</span><br><span class="line">    <span class="keyword">if</span>(evs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;evsnit malloc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="built_in">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    block-&gt;eventsarrry = evs;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;blkcnt = <span class="number">1</span>;</span><br><span class="line">    reactor-&gt;evblk = block;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_alloc</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *tailblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(tailblock-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    tailblock = tailblock-&gt;next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *newblock = (<span class="keyword">struct</span> qseventblock*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qseventblock));</span><br><span class="line">    <span class="keyword">if</span>(newblock == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newblock alloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newblock, <span class="number">0</span>, <span class="built_in">sizeof</span>(newblock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *neweventarray = (<span class="keyword">struct</span> qsevent*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsevent) * MAX_EPOLLSIZE);</span><br><span class="line">    <span class="keyword">if</span>(neweventarray == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;neweventarray malloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(neweventarray, <span class="number">0</span>, <span class="built_in">sizeof</span>(neweventarray));</span><br><span class="line"></span><br><span class="line">    newblock-&gt;eventsarrry = neweventarray;</span><br><span class="line">    newblock-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tailblock-&gt;next = newblock;</span><br><span class="line">    reactor-&gt;blkcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qsevent</span> *<span class="built_in">qsreactor_idx</span>(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = sockfd / MAX_EPOLLSIZE;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= reactor-&gt;blkcnt)<span class="built_in">qsreactor_alloc</span>(reactor);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qseventblock</span> *idxblock = reactor-&gt;evblk;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;index &amp;&amp; idxblock != <span class="literal">NULL</span>)</span><br><span class="line">        idxblock = idxblock-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;idxblock-&gt;eventsarrry[sockfd%MAX_EPOLLSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_destory</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    <span class="built_in">free</span>(reactor-&gt;evblk);</span><br><span class="line">    reactor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_addlistener</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor, <span class="type">int</span> sockfd, NCALLBACK acceptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, sockfd);</span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, sockfd, acceptor, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span>   *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, ev-&gt;buffer, ev-&gt;length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clent[%d] &quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, recv_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = <span class="built_in">qsreactor_idx</span>(reactor, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">recv</span>(fd, ev-&gt;buffer, MAX_BUFLEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;length = len;</span><br><span class="line">        ev-&gt;buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]:%s&quot;</span>, fd, ev-&gt;buffer);</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">qs_event_set</span>(ev, fd, send_cb, reactor);</span><br><span class="line">        <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] close\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qs_event_del</span>(reactor-&gt;epfd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client[%d]&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;reacv error,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)arg;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((flag = <span class="built_in">fcntl</span>(clientfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl noblock error, %d\n&quot;</span>,MAX_BUFLEN);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsevent</span> *event = <span class="built_in">qsreactor_idx</span>(reactor, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qs_event_set</span>(event, clientfd, recv_cb, reactor);</span><br><span class="line">    <span class="built_in">qs_event_add</span>(reactor-&gt;epfd, EPOLLIN, event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d], pos[%d]\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), <span class="built_in">ntohs</span>(client_addr.sin_port), clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsreactor_run</span><span class="params">(<span class="keyword">struct</span> qsreactor *reactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reactor == <span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;evblk == <span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(reactor-&gt;epfd &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EPOLL_EVENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">qsevent</span> *ev = (<span class="keyword">struct</span> qsevent*)events[i].data.ptr;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">            &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">callback</span>(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">sock</span>(port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qsreactor</span> *reactor = (<span class="keyword">struct</span> qsreactor*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> qsreactor));</span><br><span class="line">    <span class="built_in">qsreactor_init</span>(reactor);</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">qsreactor_addlistener</span>(reactor, sockfd, accept_cb);</span><br><span class="line">    <span class="built_in">qsreactor_run</span>(reactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsreactor_destory</span>(reactor);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问：从协议原理和底层代码实现角度详细说明WebSocket怎么实现由服务器主动发送给客户端的？</p><p>目前的理解：</p><p>在WebSocket协议的底层，实际上是基于TCP协议的。当WebSocket连接建立时，会在客户端和服务器之间建立一个持久的TCP连接。这个TCP连接是全双工的，数据可以在任意方向上流动。因此，服务器可以随时将数据发送到这个TCP连接上，而无需等待客户端的请求。这就是WebSocket如何实现服务器主动向客户端发送数据的原理。</p><p>在代码层面，WebSocket服务器通常会有一个事件循环，用于监听TCP连接上的事件。当服务器有数据需要发送到客户端时，它会将数据写入到TCP连接上，然后由操作系统的网络栈将数据发送到客户端。这个过程是非阻塞的，服务器无需等待数据被发送出去，可以立即继续处理其他任务。这就是WebSocket如何在底层代码实现服务器主动向客户端发送数据的。</p><p>我认为本质还是WebSocket服务器的实现遵循他设计的概念。</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/581974844">https://zhuanlan.zhihu.com/p/581974844</a></p><p>参考：<a href="https://xiaolincoding.com/network/2_http/http_websocket.html#websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">既然有 HTTP 协议，为什么还要有 WebSocket？</a></p>]]></content>
    
    
    <summary type="html">WebSocket协议及原理</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="https://penge666.github.io/posts/3ebec1e4.html"/>
    <id>https://penge666.github.io/posts/3ebec1e4.html</id>
    <published>2024-06-17T02:45:46.000Z</published>
    <updated>2024-06-17T07:32:37.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我们要了解 进程间是如何通信的，那么就需要了解进程是什么。</p><p>进程：其实进程就是运行起来的程序，程序运行起来需要被加载到内存中。进程和可执行文件很像(文件名.exe)-&gt;这就是可执行文件.但是他们又有所不同.可执行文件就像是静态的,躺在我们的硬盘中,但是,我们在任务管理器中可以明显的看到我们的进程是动态的,是在内存中不断被加载的.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617104735563.png" alt="image-20240617104735563"></p><p>进程他是一个运行的程序，是在内存中不断被加载的。那么这些进程是如何通信的？</p><h2 id="进程间通信方式">进程间通信方式</h2><p><strong>1.为什么需要进程间通信?</strong></p><p>每一个进程都拥有自己的独立的进程虚拟地址空间，造成了进程独立性，从而进程间通信技术就是为了各个进程之间可以很好的交换数据或者进程控制等应运而生的。</p><p><strong>2.进程通信的几种方式</strong></p><p>进程间的通信有 ：<strong>管道 消息队列 共享内存 信号  套接字</strong>。</p><p>总结：</p><ol><li><p>管道：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。</p></li><li><p>系统IPC</p></li></ol><ul><li><p>消息队列：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。</p></li><li><p>信号量semaphore：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。</p></li><li><p>信号：用于通知接收进程某个事件的发生。</p></li><li><p>内存共享：使多个进程访问同一块内存空间。</p></li></ul><ol start="3"><li>套接字socket：用于不同主机直接的通信。</li></ol><p><strong>3.进程间通信的目的</strong></p><p>数据传输：一个进程需要将它的数据发送给另一个进程</p><p>资源共享：多个进程之间共享同样的资源。</p><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止 时要通知父进程）</p><p>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另 一个进程的所有陷入和异常，并能够及时知道它的状态改变</p><h2 id="管道">管道</h2><h3 id="匿名管道">匿名管道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep mysql</span><br></pre></td></tr></table></figure><p>了解linux的朋友肯定熟悉   【|】这个符号  其实竖线就是一个管道，管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行，这种管道是没有名字，所以【|】表示的管道称为匿名管道，用完了就销毁。</p><p>匿名管道的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617105408840.png" alt="image-20240617105408840"></p><p>管道就是一端写入数据，另一端读取。 <strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取。</p><p>看到这，你可能会有疑问，两个进程都在一个进程里，怎么实现通信的。</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617105706002.png" alt="image-20240617105706002"></p><p>这样就实现了不同进程之间的通信，但是问题又来了，因为管道是只能一端写一段读，如果两个进程同时写的话，那岂不是会混乱。</p><p>所以我们一般会这样：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><p>通过以上我们知道：匿名管道是一个半双工的通信方式，就是一个发 另一个读。并且只能在具有亲缘关系的进程之间通信。很不方便。于是我们有了命名管道</p><h3 id="命名管道">命名管道</h3><p>命名管道：需要通过 mkfifo 命令来创建并指定好名字。相当提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> Pipe</span></span><br></pre></td></tr></table></figure><p>Pipe就是这个管道的名字。</p><p>接下来，我们往 Pipe 这个管道写入数据：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">echo</span> <span class="string">&quot;hello&quot;</span> &gt; Pipe  <span class="string">//</span> 将数据写进管道</span><br><span class="line">                         <span class="string">//</span> 停住了 <span class="string">...</span></span><br></pre></td></tr></table></figure><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> cat &lt; Pipe  <span class="comment">// 读取管道里的数据</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p><p><strong>总结</strong></p><p>我们发现，不管是匿名管道还是命名管道，都是半双工的通信方式，并且只能一方写，另一方读。通信效率非常低下，所以我们<strong>又引出了消息队列</strong>。</p><h2 id="消息队列">消息队列</h2><p>我们说到，管道的通信效率低下，不适合进程间频繁的交流，于是消息队列很好的解决了这个问题。</p><p>消息队列，<strong>就是一个消息的链表，是一系列保存在内核中消息的列表</strong>。当一个进程需要通信的时候，只需要将数据写入这个消息列表当中，就可以正常退出干其他事情了，另一个进程需要数据的时候只需去读取数据就行了。</p><p>补充：</p><p>消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><ol><li>队列的特性是先进先出，消息队列也是满足先进先出的特性的，内核当中实现消息队列的时候，是采用链表这个结构体。</li><li>消息队列当中的元素是有类型的，每一种类型是有优先级概念的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">同一类型保证先进先出的特性;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>:</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, size t msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//msgflg :</span></span><br><span class="line"><span class="comment">//       IPC NOWAIT : 非阻塞模式</span></span><br><span class="line"><span class="comment">//                 0: 阻塞模式</span></span><br><span class="line"> </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, size t msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  long msgtype : 数据类型</span></span><br><span class="line"><span class="comment">//  ==0:取队列当中的第一个</span></span><br><span class="line"><span class="comment">//  &gt; 0:取和msgtypc相等的元素</span></span><br><span class="line"><span class="comment">//  &lt; 0: 先取绝对值，然后在范围内去最小的优先级的元素</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid ds *buf)</span>;</span><br><span class="line"> </span><br><span class="line">结论:消息队列的生命周期也是跟随内核.</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617110328223.png" alt="image-20240617110328223"></p><p><strong>管道 VS 消息队列</strong></p><p>管道是最基本的 IPC 方法之一，它允许一个进程向另一个进程发送数据。然而，管道是半双工的，这意味着数据只能在一个方向上流动，如果两个进程需要相互通信，就需要建立两个管道。另外，管道的信息传递是无格式的，接收进程需要知道数据的格式才能正确解析。</p><p>消息队列是另一种 IPC 方法，它解决了管道的一些限制。消息队列是全双工的，这意味着数据可以在两个方向上流动，只需要一个<strong>消息队列就可以实现双向通信</strong>。此外，<strong>消息队列发送的是格式化的消息</strong>，每个消息都有一个类型，这使得接收进程可以根据消息类型来选择处理的消息，提高了通信的灵活性。</p><blockquote><p>全双工（Full Duplex）和半双工（Half Duplex）</p></blockquote><p>全双工（Full Duplex）通信允许数据在两个方向上同时进行传输。就像在电话通话中，你可以在同一时间既能听到对方的声音，也能向对方讲话，这就是全双工通信。</p><p>而半双工（Half Duplex）通信则是数据只能在一个方向上流动，同一时间只允许一个方向的通信，不能同时进行接收和发送。例如，对讲机就是典型的半双工通信设备，你在讲话的时候，对方只能听，不能同时与你交谈。</p><p>综上说所，消息队列很好的解决了管道不能频繁交流的问题，但是也存在了不足，就是交流不及时，还有大小受限制。并且<strong>在通信的过程中，会存在大量频繁的用户态和内核态的不断转换</strong>，进程写入消息时，会发生用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><h2 id="共享内存">共享内存</h2><h3 id="共享内存的原理">共享内存的原理</h3><p>首先在物理内存当中创建了一块内存<br>不同的进程通过页表映射， 将同一块物理内存映射到自己的虚拟地址空间<br>不同的进程， 操作进程虚拟地址， 通过页表的映射， 就相当于操作同一块内存，从而完成了数据交换</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617111139897.png" alt="image-20240617111139897"></p><h3 id="共享内存的接口">共享内存的接口</h3><p><strong>创建共享内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, size t size, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    key :共享内存标识符， 这个标识符相当于共享内存的身份证 程序员在第一次创建的时候， 可以随意给 值， 只要和当前操作系统当中的其他的共享内存标识符不重复</span></span><br><span class="line"><span class="comment">//     eg : 0x99999999 0x88888888 0x12345678</span></span><br><span class="line"><span class="comment">//     size : 共享内存的大小，单位字节</span></span><br><span class="line"><span class="comment">//  shmrlg :</span></span><br><span class="line"><span class="comment">//       IPC CREAT : 如果共享内存不存在， 则创建共享内存</span></span><br><span class="line"><span class="comment">//        IPC_EXCL: 需要搭配IPC CREAT一起使用， 这样的宏在搭配使用的时候，  还是采用按位或的方式 </span></span><br><span class="line"><span class="comment">//其实核心的思想就是位图</span></span><br><span class="line"><span class="comment">//     eg :IPC CREAT IPC EXCL:</span></span><br><span class="line"><span class="comment">//           如果想要获取的共享内存，已经存在， 则报错如果想要过去的共享内存，  是刚刚新创建出来的 </span></span><br><span class="line"><span class="comment">  //共享内存，则返回舞作句柄</span></span><br><span class="line"><span class="comment">       总结:使用shmget这个函数的时候一定更自己刚刚创建出来的共享内存</span></span><br><span class="line"><span class="comment">       返回值:返回值是返回共享内存的操作句柄</span></span><br><span class="line"><span class="comment">    共享内存的标识符和共享内存的操作句柄区别是什么?</span></span><br><span class="line"><span class="comment">     标识符:是用来标识共享内存的， 相当于共享内存的身份证，意味者不同的进程可以通过标识符找到这个共享内存</span></span><br><span class="line"><span class="comment">     操作句柄:进程可以通过操作句柄来对共享内存进行操作(附加， 分离， 删除)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>将共享内存附加到进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span> <span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    shmid : 共享内存操作句柄</span></span><br><span class="line"><span class="comment">    shmaddr : 附加到共享内存的什么虚拟地址， 允许传递NULL值， 让操作系统帮我们选择附加到共享区当中的那个地址， 这个地址通过该函数的返回值返回给我们</span></span><br><span class="line"><span class="comment">    shmflgt:</span></span><br><span class="line"><span class="comment">    SHM RDONLY 规定当前进程只能对共享内存进行读操作</span></span><br><span class="line"><span class="comment">    0 : 可读可写</span></span><br><span class="line"><span class="comment">    返回值: 返回共享内存附加到共享区的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>将共享内存和进程分离</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span> </span>;</span><br><span class="line"><span class="comment">//shmaddr : shmat的返回值</span></span><br></pre></td></tr></table></figure><p><strong>操作共享内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span> <span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> emd, <span class="keyword">struct</span> shmid ds *buf)</span> </span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    shmid : 共享操作句柄</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    cmd : 告诉shmct1函数需要做什么操作</span></span><br><span class="line"><span class="comment">         IPC STAT :获取当前共享内存的属性信息，放在buf当中， buf是出参</span></span><br><span class="line"><span class="comment">          IPC SET :设置共享内存的属性信息， 是用buf来进行设置的， bur是入参</span></span><br><span class="line"><span class="comment">          IPC RMID :删除共享内存， buf可以直接传递为NULL</span></span><br><span class="line"><span class="comment">    buf : 共享内存的结构体</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>删除共享内存</strong></p><ol><li>当使用shmct1或者使用ipcrm，删除共享内存之后， 共享内存就实际被释<br>放掉了</li><li>当共享内存被群放掉之后， 共享内存的标识符会被设置成为0x00000000.表示其他进程不能通过之前的标识符找到该共享内存， 并且共享内存的状态会被设置成为dest (destroy)</li><li>当共享内存被群放掉之后了， 但是还是有进程在附加着共享内存，当前描述共享内存的结构体并没有被释放， 直到当前共享内存的附加进程数量为0的时候才会被释放掉</li></ol><p><strong>总结</strong></p><p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。但是也引入了一个问题，就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。为了解决这一问题我们又引入了信号量的概念。</p><h2 id="信号量">信号量</h2><p>为了防止多个进程同时访问公共资源，造成数据混乱，必须想一个保护机制，使得共享的资源，在任意时刻只能被一个进程访问。于是便提出了信号量。</p><p>信号量（semaphore）它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>控制信号量的方式有两种原子操作：</p><ul><li>一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>进程互斥访问资源  初始化信号量为 <code>1</code></strong></p><blockquote><p>假如有A B两个进程  信号量初始化为 1， 现在A 要访问共享内存 进行了p操作，信号量变为 0，说明还有可用资源，A就可以顺利访问共享资源了。</p><p>结果这会B进程又要来访问资源，进行了p操作，信号量变成了-1，说明资源已经有进程占用了，那么B进程就会阻塞等待。</p><p>A进程这会访问完了，出来了，进行了V操作，信号量变成了 0 ，看见了B在哪等待，于是唤醒了B,说你可以进去了，于是B就可以访问了，访问完之后，进行V操作，信号量又变回了1。</p></blockquote><p><strong>进程同步访问资源  初始化信号量为 0</strong></p><p>我们都知道，进程是抢占式占用资源，但是我们有时想让多个进程相互合作，实现同一个任务，比如先让A进程生产数据，B进程才能读取数据。但是我们不知道到底那个进程先抢占了资源。假如A还没有生产数据呢，但是B进程又要读取，我们该如何做？</p><p>于是我们边有了进程同步：</p><blockquote><p>我们可以初始化信号量为 0：<br>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；<br>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；<br>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</p></blockquote><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><p><strong>总结：信号量不是用来通信的，信号量是和共享内存结合，来限制多进程同时访问共享资源的。防止冲突的一种保护机制</strong></p><h2 id="信号">信号</h2><p>我们上述说到的都是正常情况下的进程通信，那么如果进程出现异常了呢，这个时候我们就需要用信号通知的方式，实现通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$  <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>总共定义了62个信号。</p><blockquote><p>非实时信号: 非可靠信号</p><p>特点: 信号可能会丢失</p><p>1~31信号</p><p>实时信号:可靠信号</p><p>特点: 信号不会丢失</p><p>33~64</p></blockquote><p><strong>信号的操作原理：</strong></p><ol><li>信号产生：信号可以由操作系统、进程或用户生成。如硬件错误、软件中断、操作系统异常等情况，操作系统会产生信号。进程也可以使用系统调用，如 kill，给其他进程发送信号。用户通过终端（如按下 ctrl+c）也可以产生信号。</li><li>信号发送：一旦信号产生，它就会被发送给目标进程。信号在发送时会指定信号类型，例如 SIGINT 表示键盘中断信号，SIGKILL 表示终止进程信号等。</li><li>信号接收与处理：进程接收到信号后，有以下几种处理方式：<ul><li>忽略信号</li><li>捕获信号：设置一个函数，当信号发生时，执行该函数</li><li>使用默认操作：每种信号都有一个默认操作，如终止进程、停止进程或忽略信号等。</li></ul></li><li>信号阻塞：进程可以选择阻塞某些信号。被阻塞的信号不会立即被处理，而是被挂起，直到进程解除阻塞。</li></ol><p><strong>举个例子说明下我们经常使用通过终端（如按下 ctrl+c）杀死进程的原理</strong></p><ol><li>用户在终端按 ctrl+c，终端驱动程序会捕获这个键盘事件，并向前台进程组发送 SIGINT 信号。</li><li>收到 SIGINT 信号的进程会查找对应的信号处理函数**。在进程的控制块（PCB，Process Control Block）中，有一个信号处理表，用于存储进程对每种信号的处理方式。如果进程设置了捕获该信号的处理函数，那么就会执行该函数**；如果没有设置，那么执行该信号的默认操作。对于 SIGINT 信号，如果没有捕获，那么默认操作就是终止进程。</li><li>如果进程被终止，操作系统会回收该进程的资源，包括内存资源、文件描述符、环境变量等，并将该进程的状态设置为退出（Exit）。</li><li>进程的父进程会收到 SIGCHLD 信号，通知其子进程已经终止。父进程可以通过 wait() 或 waitpid() 函数获取子进程的退出状态，完成对子进程的回收。</li></ol><p>说到这里，我们发现上面的所有进程间通信方式都只是局限在本机，那我我们自然而然的就引出了网络<strong>Socket 通信，实现不同电脑中的进程通信。</strong></p><h2 id="socket通信">socket通信</h2><p>这个可以看我的多路复用那篇文章</p><p>编程流程：</p><p>服务端:创建套接字，绑定地址信息</p><p>客户端:创建套接字，不推荐绑定地址信息 (可以绑定 )</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617112159033.png" alt="image-20240617112159033"></p><p>创建套接字的含义:</p><p>将进程和网卡进行绑定，进程可以从网卡当中接收数据，也可以通过网卡发送数据。</p><p>绑定地址信息的含义:</p><p>绑定ip，绑定端口，是为了在网络当中可以标识出来一台主机和一个进程。<br>对于接收方而言:发送数据的人就知道接收方在那台机器那个进程了</p><p>对于发送方而言:能标识网络数据从那台机器那个进程发送出去的</p><h2 id="总结">总结</h2><p>如果面试官问你说说，进程间是如何通信的，你该做一下回答。</p><p>首先  进程间的通信有  <strong>管道 消息队列 共享内存 信号  套接字。</strong></p><p><strong>管道分为 匿名管道和命名管道。</strong></p><p>**匿名管道 ：他是一个半双工的通信方式，就是一个发 另一个读。**并且只能在具有亲缘关系的进程之间通信。很不方便，于是便有了命名管道： 同理命名管道也是一个半双工的通信方式，一个发 另一个读。但是可以实现不同进程之间的通信了。</p><p>这又产生了问题，就是这个通信不迅速，效率低下又成了问题，于是又产生出了消息队列。</p><p><strong>消息队列：消息队列是保存在内核中的消息链表</strong>，比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。这样就是像写信一样，一来一封，我回一封，而且消息队列在内核当中，我们去读取的时候，还会有用户态和内核态之间的转换，效率虽然说有所改变，但是还是不够及时。所以共享内存又出来了。</p><p><strong>共享内存：就是两个进程，各拿出一块虚拟内存空间，映射到相同的物理空间</strong>。这样一个进程在进行读写操作的时候，另外一个进程立马就可以看到。通信的效率大大提高，但是又带来了新的问题。就是如果遇到两个或者多个进程同时给这个空间写东西，就会产生冲突。</p><p>那么为了防止多个进程同时共享资源，就提出了信号量，使得在任意时刻资源只能被一个进程访问。信号量说白了就相当于一个计数器，有两个操作：（他不能通信只能配合共享内存）</p><ul><li><p><strong>P操作</strong>：相当于每来一个进程要访问的时候，先给信号量减1，减1之后  如果信号量还&gt;&gt;=0  说明这会这个资源还没有占用可以访问，如果减一之后&lt;0,说明有其他进程正占用着资源，需要等待。</p></li><li><p><strong>V操作</strong>：每个进程要走的时候，先给信号量+1  如果说+1了之后，还&lt;&lt;=0，说明前面还有排队的进程，这个时候就会把前面排队的进程唤醒，说我走了，你可以去访问资源了。如果+1&gt;0   说明前面没有排队的进程，也就是没有阻塞的进程，如果后面有进程要访问的话，直接就可以访问。</p></li></ul><p>说了这些都是在一台主机上的进程间的通信，那么也产生出了Socket，也就是套接字。这实现了不同电脑上的进程通信。</p><p>最后还有个  信号： 信号就是可以给进程发送一个命令，进程就会做相应的工作。</p><p>摘录自：<a href="https://blog.csdn.net/qq_45615577/article/details/129316185#:~:text=%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E3%80%90%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E3%80%91%E6%9C%80%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%B4%201%20%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%20%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%202%20%E4%BA%94%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89,3%20%E5%85%AD%E3%80%81%E4%BF%A1%E5%8F%B7%204%20%E4%B8%83%E3%80%81socket%E9%80%9A%E4%BF%A1%205%20%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93">面试常问【进程间通信】最详细解说</a></p>]]></content>
    
    
    <summary type="html">进程间通信机制</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>容器网络模式</title>
    <link href="https://penge666.github.io/posts/c67182ed.html"/>
    <id>https://penge666.github.io/posts/c67182ed.html</id>
    <published>2024-06-16T08:27:10.000Z</published>
    <updated>2024-06-17T02:29:29.821Z</updated>
    
    <content type="html"><![CDATA[<p>《再见少年拉满弓》</p><p>东风吹破少年梦，从此再无赤子心。<br>黄昏重铸英雄梦，再见少年拉满弓。<br>再见少年拉满弓，不惧岁月不惧风，<br>少年扶摇上九重，胸中豪情破苍穹。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617101725751.png" alt="image-20240617101725751"></p><ul><li><strong>bridge模式：–net=bridge 桥接模式（默认设置，自己创建也使用bridge 模式）</strong></li><li><strong>host模式：–net=host 和宿主即共享网络</strong></li><li><strong>container模式：–net=container:NAME_or_ID 容器网络连通!(很少用，局限性很大！)</strong></li><li><strong>none模式：–net=none 不配置网络</strong></li></ul><h2 id="查看所有的docker网络">查看所有的docker网络</h2><p>命令：<code>docker network ls</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@penge ➜ toktik git(main)  docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME           DRIVER    SCOPE</span><br><span class="line">151c5fe4b87c   bridge         bridge    <span class="built_in">local</span></span><br><span class="line">5c21b13981a4   host           host      <span class="built_in">local</span></span><br><span class="line">c51c6b57875f   none           null      <span class="built_in">local</span></span><br><span class="line">b0165c5b9c95   yaml_default   bridge    <span class="built_in">local</span></span><br></pre></td></tr></table></figure><h2 id="bridge-网桥模式">bridge 网桥模式</h2><p>Docker安装启动后会在宿主主机上创建一个名为 docker0 的虚拟网桥，处于七层网络模型的数据链路层，后续每当我们创建一个新的docker容器，在不指定容器网络模式的情况下，docker会通过 docker0 与主机的网络连接，docker0 相当于网桥。</p><p>补充：网桥，也被称为网络桥接器或桥接器，是一种用于连接同一种或不同种类的网络段以形成一个大网络的设备。它的工作方式类似于路由器，但是它通常只用于连接本地网络（LAN）。</p><p>使用 bridge 模式新创建的容器，容器内部都会有一个虚拟网卡，名为 eth0，容器之间可以通过容器内部的IP相互通信。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617102059535.png" alt="image-20240617102059535"></p><p>解释上图：在该模式中，Docker 会创建一个虚拟以太网桥 <code>docker0</code>，新建的容器会自动桥接到这个接口，然后docker会依据docker0在创建的时候设立的网络段给容器分配ip。</p><p><strong>Note</strong>：但默认的方式存在一个问题，就是每次重启docker默认的网络段也会发生变化，而采用该网络段的docker容器也会跟着发生变化。当然我们也可以自定义一个网络段，然后自己给创建的容器分配指定的ip。</p><p>命令：<code>docker run -d -name tomcat01 --net=bridge -p 8085:80 tomcat:latest</code><br>说明：</p><ul><li>–net=bridge 可省略 ，-p 指定端口映射</li><li>网桥默认 IP 范围是一般都是 172.17.x.x</li></ul><h2 id="host-模式">host 模式</h2><p>如果指定的host模式容器不会拥有一个独立network namespace，而是与宿主主机共用network namespace。也就说明容器本身不会有的网卡信息，而是使用宿主主机的网络信息。容器除了网络，其他比如文件系统、进程等依然都是隔离的。</p><ul><li>host 网络模式需要在创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定；</li><li>采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；</li><li>host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617102245846.png" alt="image-20240617102245846"></p><p>说明：</p><ul><li>–net=host 指定</li><li>容器和宿主主机共享 Network namespace</li><li>host模式因为和宿主主机共享network namespace，会有可能出现端口冲突的情况。</li></ul><h2 id="container模式">container模式</h2><p>container模式和host模式很类似，host模式和宿主主机共享network namespace;container模式和指定的容器共享，两者之间除了网络共享（网卡、主机名、IP 地址），其他方面还是隔离的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617102450256.png" alt="image-20240617102450256"></p><p>命令：<code>docker run -d -name tomcat02 --net=container:name/id -p 8000:80 tomcat:latest</code><br>说明：</p><ul><li>–-net={容器id 或容器name} 指定</li><li>当前容器和另外一个容器共享 Network namespace</li></ul><h2 id="none模式">none模式</h2><p>如果dockers容器指定的网络模式为none,该容器没有办法联网，外界也无法访问它，可以用来本次测试。</p><p>命令：<code>docker run -d -name tomcat02 --net=none -p 8000:80 tomcat:latest</code><br>说明：</p><ul><li>–net=none 指定</li><li>容器有独立的Network namespace，但并没有对其进行任何网络设置，如果需要的话，需要自定义配置网络</li></ul><h2 id="Docker-网络桥接模式和-Host-模式的区别">Docker 网络桥接模式和 Host 模式的区别</h2><p>首先，我们需要了解一下 Docker 的两种网络模式之间的区别。在桥接网络模式下，Docker 将为每个容器创建一个独立的网络命名空间，并为容器分配一个|P 地址。而在 Host 网络模式下，容器将直接使用主机的网络栈，与主机共享网络接口和 IP 地址，这意味着容器可以直接访问主机上的所有网络服务，同时也会导致容器与主机网络之间的隔离性降低。</p><p>学习自：<a href="https://www.cnblogs.com/xiongzaiqiren/p/18177383/docker-network">docker网络配置：bridge模式、host模式、container模式、none模式</a></p><p>优秀教程：<a href="https://www.cnblogs.com/taoxiaoxin/p/18082633">Docker 网络模式详解及容器间网络通信 </a></p>]]></content>
    
    
    <summary type="html">容器网络4种模式</summary>
    
    
    
    <category term="Docker" scheme="https://penge666.github.io/categories/Docker/"/>
    
    <category term="微服务" scheme="https://penge666.github.io/categories/Docker/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Docker" scheme="https://penge666.github.io/tags/Docker/"/>
    
    <category term="微服务" scheme="https://penge666.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>内存回收</title>
    <link href="https://penge666.github.io/posts/8ed57ebe.html"/>
    <id>https://penge666.github.io/posts/8ed57ebe.html</id>
    <published>2024-06-16T03:40:35.000Z</published>
    <updated>2024-06-17T07:32:23.329Z</updated>
    
    <content type="html"><![CDATA[<p>如果应用程序申请内存的速度，超过内存回收的速度，内存就会被用满。当内存用满，操作系统就开始需要频繁地切换页面，进行频繁地磁盘读写。<strong>所以我们观察到的系统性能下降，往往是一种突然的崩溃，因为一旦内存被占满，系统性能就开始雪崩式下降</strong>。</p><h2 id="什么是-GC">什么是 GC</h2><p>通常意义上我们说的垃圾回收器（Garbage Collector，GC），和多数同学的理解会有出入。你可能认为 GC 是做内存回收用的模块，而事实上程序语言提供的 GC 往往是应用的实际内存管理者。刚刚入门咱们就遇到了一个容易出现理解偏差的问题，所以 GC 是值得花时间细学的。</p><p>如上图所示，一方面 GC 要承接操作系统虚拟内存的架构，另一方面 GC 还要为应用提供内存管理。GC 有一个含义，就是 Garbage Collection 内存回收的具体动作。无论是名词的回收器，还是动词的回收行为，在下文中我都称作 GC。</p><p>下面我们具体来看一下 GC 都需要承担哪些“工作”，这里我总结为以下 4 种。</p><ol><li>GC 要和操作系统进行交互，负责申请内存，并把不用的内存还给操作系统（释放内存）。</li><li>应用会向 GC 申请内存。</li><li>GC 要承担我们通常意义上说的垃圾回收能力，标记不用的对象，并回收他们。</li><li>GC 还需要针对应用特性进行动态的优化。</li></ol><p>所以现在程序语言实现的 GC 模块通常是实际负责应用内存管理的模块。在程序语言实现 GC 的时候，会关注下面这几个指标。</p><ul><li><strong>吞吐量（Throughput）</strong>：执行程序（不包括 GC 执行的时间）和总是间的占比。注意这个吞吐量和通常意义上应用去处理作业的吞吐量是不一样的，这是从 GC 的角度去看应用。只要不在 GC，就认为是吞吐量的一部分。</li><li><strong>足迹（FootPrint）</strong>： 一个程序使用了多少硬件的资源，也称作程序在硬件上的足迹。GC 里面说的足迹，通常就是应用对内存的占用情况。比如说应用运行需要 2G 内存，但是好的 GC 算法能够帮助我们减少 500MB 的内存使用，满足足迹这个指标。</li><li><strong>暂停时间（Pause Time）</strong>： GC 执行的时候，通常需要停下应用（避免同步问题），这称为 Stop The World，或者暂停。不同应用对某次内存回收可以暂停的时间需求是不同的，比如说一个游戏应用，暂停了几毫秒用户都可能有很大意见；而看网页的用户，稍微慢了几毫秒是没有感觉的。</li></ul><h2 id="GC-目标的思考">GC 目标的思考</h2><p>如果单纯从让 GC 尽快把工作做完的角度来讲，其实是提升吞吐量。比如利用好多核优势就是一种最直观的方法。</p><p>因为涉及并行计算，我这里给你讲讲并行计算领域非常重要的阿姆达定律，这个定律用来衡量并行计算对原有算法的改进，公式如下：</p><p>S = 1 / (1- P)</p><p>你现在看到的是一个简化版的阿姆达定律，P 是任务中可以并发执行部分的占比，S 是并行带来的理论提速倍数的极限。比如说 P 是 0.9，代入公式可得：</p><p>S = 1 / （1 - 0.9） = 10</p><p>上面表达式代表着有 90% 的任务可以并行，只有 10% 的任务不能够并行。假设我们拥有无限多的 CPU 去分担 90% 可以并行的任务，其实就相当于并行的任务可以在非常短的时间内完成。但是还有 10% 的任务不能并行，因此理论极限是 1⁄0.1=10 倍。</p><p>通常我们设计 GC，都希望它能够支持并行处理任务。因为 GC 本身也有着繁重的工作量，需要扫描所有的对象，对内存进行标记清除和整理等。</p><p><strong>经过上述分析，那么我们在设计算法的时候是不是应该尽量做到高并发呢？</strong></p><p>很可惜并不是这样。如果算法支持的并发度非常高，那么和单线程算法相比，它也会带来更多的其他开销。比如任务拆分的开销、解决同步问题的开销，还有就是空间开销，GC 领域空间开销通常称为 FootPrint。理想情况下当然是核越多越好，但是如果考虑计算本身的成本，就需要找到折中的方案。</p><p>还有一个问题是，GC 往往不能拥有太长的暂停时间（Pause Time），因为 GC 和应用是并发的执行。如果 GC 导致应用暂停（Stop The World，STL）太久，那么对有的应用来说是灾难性的。 比如说你用鼠标的时候，如果突然卡了你会很抓狂。如果一个应用提供给百万级的用户用，假设这个应用帮每个用户每天节省了 1s 的等待时间，那么按照乔布斯的说法每天就为用户节省了 11 天的时间，每年是 11 年——5 年就相当于拯救了一条生命。</p><p>如果暂停时间只允许很短，那么 GC 和应用的交替就需要非常频繁。这对 GC 算法要求就会上升，因为每次用户程序执行后，会产生新的变化，甚至会对已有的 GC 结果产生影响。后面我们在讨论标记-清除算法的时候，你会感受到这种情况。</p><p>所以说，吞吐量高，不代表暂停时间少，也不代表空间使用（FootPrint）小。 同样的，使用空间小的 GC 算法，吞吐量反而也会下降。<strong>正因为三者之间存在类似相同成本代价下不可兼得的关系，往往编程语言会提供参数让你选择根据自己的应用特性决定 GC 行为</strong>。</p><h2 id="引用计数算法（Reference-Counter）">引用计数算法（Reference Counter）</h2><p>接下来我们说说，具体怎么去实现 GC。实现 GC 最简单的方案叫作引用计数，下图中节点的引用计数是 2，代表有两个节点都引用了它。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152305818.png" alt="image-20240617152305818"></p><p>如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它——此时，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。</p><p>但是，这个算法可能会出现下图中循环引用的问题（我们写程序的过程中经常会遇到这样的引用关系）。下图中三个节点，因为循环引用，引用计数都是 1。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152317573.png" alt="image-20240617152317573"></p><p>引用计数是 1，因此就算这 3 个对象不会再使用了，GC 不会回收它们。</p><p>另一个考虑是在多线程环境下引用计数的算法一旦算错 1 次（比如因为没有处理好竞争条件），那么就无法再纠正了。而且处理竞争条件本身也比较耗费性能。</p><p>还有就是引用计数法回收内存会产生碎片，当然碎片不是只有引用计数法才有的问题，所有的 GC 都需要面对碎片。下图中内存回收的碎片可以通过整理的方式，清理出更多空间出来。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152356815.png" alt="image-20240617152356815"></p><p>综上，<strong>引用计数法出错概率大</strong>，比如我们编程时会有对象的循环引用；另一方面，<strong>引用计数法容错能力差</strong>，一旦计算错了，就会导致内存永久无法被回收，因此我们需要更好的方式。</p><h2 id="Root-Tracing-算法">Root Tracing 算法</h2><p>下面我再给你介绍一种更好的方式—— Root Tracing 算法。这是一类算法，后面我们会讲解的标记-清除算法和 3 色标记-清除算法都属于这一类。</p><p>Root Tracing 的原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用关系的源头。比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。在 Java 中根对象就包括在栈上创建指向堆的对象；JVM 的一些元数据，包括 Method Area 中的对象等。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152430225.png" alt="image-20240617152430225"></p><p>在 Root Tracing 工作过程中，如果一个对象和根对象间有连通路径，也就是从根节点开始遍历可以找到这个对象，代表有对象可以引用到这个对象，那么这个节点就不需要被回收。所以算法的本质还是引用，只不过判断条件从引用计数变成了有根对象的引用链。</p><p>如果一个对象从根对象不可达，那么这个对象就应该被回收，即便这个对象存在循环引用。可以看到，上图中红色的 3 个对象循环引用，并且到根集合没有引用链，因此需要被回收。这样就解决了循环引用的问题。</p><p>Root Tracing 的容错性很好，GC 通过不断地执行 Root Tracing 算法找到需要回收的元素。如果在这个过程中，有一些本来应该回收的元素没有被计算出（比如并发原因），也不会导致这些对象永久无法回收。因为在下次执行 Root Tracing 的时候，GC 就会通过执行 Root Tracing 算法找到这些元素。不像引用计数法，一旦算错就很难恢复。</p><p><strong>补充</strong>：</p><p>在 Root Tracing 算法中，根节点通常指的是垃圾收集器（Garbage Collector, GC）在执行标记过程时的起始点。这些根节点通常是全局变量或者是当前执行的函数的参数和局部变量，因为它们是可以直接访问的。垃圾收集器从这些根节点开始遍历，找出所有它们能直接或间接引用到的对象，这些对象被认为是&quot;活动的&quot;，也就是说它们在当前的程序执行中仍然有可能被用到。而那些不能从根节点达到的对象，就被认为是&quot;死亡的&quot;，也就是说它们在后续的程序执行中不会再被用到，因此可以被垃圾收集器回收。</p><h3 id="标记-清除（Mark-Sweep）算法">标记-清除（Mark Sweep）算法</h3><p>下面我为你具体介绍一种 Root Tracing 的算法， 就是标记清除-算法。标记-清除算法中，用白色代表一种不确定的状态：可能被回收。 黑色代表一种确定的状态：不会被回收。算法的实现，就是为所有的对象染色。算法执行结束后，所有是白色的对象就需要被回收。</p><p>算法实现过程中，假设有两个全局变量是已知的：</p><ul><li>heapSet 中拥有所有对象</li><li>rootSet 中拥有所有 Root Object</li></ul><p>算法执行的第一步，就是将所有的对象染成白色，代码如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    obj.color = white</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义一个标记函数，它会递归地将一个对象的所有子对象染成黑色，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">mark</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> obj.<span class="property">color</span> == white &#123;</span><br><span class="line"></span><br><span class="line">    obj.<span class="property">color</span> = black</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="title function_">references</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充知识">补充知识</h4><p>上面的 mark 函数对 obj 进行了深度优先搜索。深度优先搜索，就是自然的递归序。随着递归函数执行，遇到子元素就遍历子元素，就构成了天然的深度优先搜索。还有一个相对的概念是广度优先搜索（Breadth First Serach），如果你不知道深度优先搜索和广度优先搜索，可以看下我下面的图例。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152450701.png" alt="image-20240617152450701"></p><p>上图中，深度优先搜索优先遍历完整的子树（递归），广度优先搜索优先遍历所有的子节点（逐层）。</p><p>然后我们从所有的 Root Object 开始执行 mark 函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for root in rootSet &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">mark</span>(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结束后，所有和 Root Object 连通的对象都已经被染成了黑色。然后我们遍历整个 heapSet 找到白色的对象进行回收，这一步开始是<strong>清除（Sweep）阶段</strong>，以上是<strong>标记（Mark）阶段</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> obj in heapSet &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> obj.color == white &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上算法就是一个简单的标记-清除算法。相比引用计数，这个算法不需要维护状态。算法执行开始所有节点都被标记了一遍。结束的时候，算法找到的垃圾就被清除了。 算法有两个阶段，标记阶段（Mark），还有清除阶段（Sweep），因此被称为标记-清除算法。</p><p>这里请你思考：如果上面的 GC 程序在某个时刻暂停了下来，然后开始执行用户程序。如果用户程序删除了对某个已经标记为黑色对象的所有引用，用户程序没办法通知 GC 程序。这个节点就会变成浮动垃圾（Floating Garbage），需要等待下一个 GC 程序执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152504217.png" alt="image-20240617152504217"></p><p>假设用户程序和 GC 交替执行，用户程序不断进行修改（Mutation），而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。</p><p>另一方面，考虑到 GC 是一个非常消耗性能程序，在某些情况下，我们希望 GC 能够增量回收。 比如说，用户仅仅是高频删除了一部分对象，那么是否可以考虑设计不需要从整个 Root 集合进行遍历，而是增量的只处理最近这一批变更的算法呢？答案是可以的，我们平时可以多执行增量 GC，偶尔执行一次全量 GC。</p><h2 id="三色标记-清除算法（Tri-Color-Mark-Sweep）">三色标记-清除算法（Tri-Color Mark Sweep）</h2><p>接下来，我会和你讨论这种有<strong>三个颜色标记的算法，通常称作三色标记-清除算法</strong>。首先，我们重新定义黑、白、灰三种颜色的含义：</p><ul><li>白色代表需要 GC 的对象；</li><li>黑色代表<strong>确定</strong>不需要 GC 的对象；</li><li>灰色代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增量任务。</li></ul><p>在三色标记-清除算法中，一开始所有对象都染成白色。初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执行 Mutation。</p><p>算法需要维护 3 个集合，白色集合、黑色集合、灰色集合。3 个集合是互斥的，对象只能在一个集合中。执行之初，所有对象都放入白色集合，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152557659.png" alt="image-20240617152557659"></p><p>第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152620646.png" alt="image-20240617152620646"></p><p>接下来算法会不断从灰色集合中取出元素进行标记，主体标记程序如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> greySet.size() &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> item = greySet.<span class="keyword">remove</span>();</span><br><span class="line"></span><br><span class="line">  mark(item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记的过程主要分为 3 个步骤：</p><ol><li>如果对象在白色集合中，那么先将对象放入灰色集合；</li><li>然后遍历节点的所有的引用对象，并递归所有引用对象；</li><li>当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。</li></ol><p>伪代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">mark</span>(obj) &#123;</span><br><span class="line"></span><br><span class="line">  if obj in whiteSet &#123;</span><br><span class="line"></span><br><span class="line">    greySet<span class="selector-class">.add</span>(obj)</span><br><span class="line"></span><br><span class="line">    for v in <span class="built_in">refs</span>(obj) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">mark</span>(v)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greySet<span class="selector-class">.remove</span>(obj)</span><br><span class="line"></span><br><span class="line">    blackSet<span class="selector-class">.add</span>(obj)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以观察下上面的程序，这是一个 DFS 的过程。如果多个线程对不同的 Root Object 并发执行这个算法，我们需要保证 3 个集合都是线程安全的，可以考虑利用 ConcurrentSet（这样性能更好），或者对临界区上锁。并发执行这个算法的时候，如果发现一个灰色节点说明其他线程正在处理这个节点，就忽略这个节点。这样，就解决了标记程序可以并发执行的问题。</p><p>当标记算法执行完成的时候，所有不需要 GC 的元素都会涂黑：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152642253.png" alt="image-20240617152642253"></p><p>标记算法完成后，白色集合内就是需要回收的对象。</p><p>以上，是类似双色标记-清除算法的全量 GC 程序，我们从 Root 集合开始遍历，完成了对所有元素的标记（将它们放入对应的集合）。</p><p>接下来我们来考虑增加 GC（Incremental GC）的实现。首先对用户的修改进行分类，有这样 3 类修改（Mutation）需要考虑：</p><ol><li>创建新对象</li><li>删除已有对象</li><li>调整已有引用</li></ol><p>如果用户程序创建了新对象，可以考虑把新对象直接标记为灰色。虽然，也可以考虑标记为黑色，但是标记为灰色可以让 GC 意识到新增了未完成的任务。比如用户创建了新对象之后，新对象引用了之前删除的对象，就需要重新标记创建的部分。</p><p>如果用户删除了已有的对象，通常做法是等待下一次全量 Mark 算法处理。下图中我们删除了 Root Object 到 A 的引用，这个时候如果把 A 标记成白色，那么还需要判断是否还有其他路径引用到 A，而且 B,C 节点的颜色也需要重新计算。关键的问题是，虽然可以实现一个基于 A 的 DFS 去解决这个问题，但实际情况是我们并不着急解决这个问题，因为内存空间往往是有富余的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152654270.png" alt="image-20240617152654270"></p><p><strong>在调整已有的引用关系时，三色标记算法的表现明显更好</strong>。下图是对象 B 将对 C 的引用改成了对 F 的引用，C,F 被加入灰色集合。接下来 GC 会递归遍历 C,F，最终然后 F,E,G 都会进入灰色集合。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617152727248.png" alt="image-20240617152727248"></p><p>内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求“Stop The World”。<strong>三色算法的优势就在于它支持多一些情况的 Mutation，这样能够提高“垃圾”被并发回收的概率</strong>。</p><p>目前的 GC 主要都是基于三色标记算法。 至于清除算法，有原地回收算法，也有把存活下来的对象（黑色对象）全部拷贝到一个新的区域的算法。</p><h2 id="总结">总结</h2><p><strong>好处</strong></p><ol><li>用于垃圾回收器升级，将STW变为并发标记。STW就是在标记垃圾的时候，必须暂停程序，而使用并发标记，就是程序一边运行，一边标记垃圾。</li><li>避免重复扫描对象，提升标记阶段的效率。</li></ol><p><strong>存在问题</strong></p><ul><li><p><strong>浮动垃圾</strong>:并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描,所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从GCRoot中去找到，所以成为了浮动垃圾，浮动垃圾对系统的影响不大，留给下一次GC进行处理即可。</p></li><li><p><strong>对象漏标问题（需要的对象被回收)</strong>︰并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用)，同时黑色对象引用了该对象（增加引用)(这两部可以不分先后顺序);因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被GC回收，此问题会导致系统出现问题，而CMS与G1，两种回收器在使用三色标记法时，都采取了一些措施来应对这些问题，<strong>CMS对增加引用环节进行处理(Increment Update)，G1则对删除引用环节进行处理(SATB)。</strong></p></li></ul><p>推荐资料：<a href="https://www.bookstack.cn/books/gc-handbook">https://www.bookstack.cn/books/gc-handbook</a></p>]]></content>
    
    
    <summary type="html">内存回收</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
