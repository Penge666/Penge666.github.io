<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-05-16T14:42:46.884Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发练习题</title>
    <link href="https://penge666.github.io/posts/624cfcb.html"/>
    <id>https://penge666.github.io/posts/624cfcb.html</id>
    <published>2024-05-16T14:42:12.000Z</published>
    <updated>2024-05-16T14:42:46.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>非常好的并发编程练手例子。</p><h2 id="基础知识">基础知识</h2><h3 id="信号量">信号量</h3><ul><li><p>信号量的类型：<code>sem_t</code></p></li><li><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p><ul><li>功能：初始化信号量</li><li>参数<ul><li><code>sem</code>：信号量变量的地址</li><li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li><li><code>value </code>：信号量中的值，代表容器大小</li></ul></li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p><ul><li>功能：释放资源</li></ul></li><li><p><code>int sem_wait(sem_t *sem);</code>【wait先判断再-】</p><ul><li>如果信号量的值大于0，<code>sem_wait</code>会立即返回，并将信号量的值减少1。</li><li>如果信号量的值为0，<code>sem_wait</code>会阻塞，直到信号量的值变得大于0。这通常发生在另一个线程或进程增加了信号量的值，表示它已经释放了它先前持有的资源。</li></ul></li><li><p><code>int sem_trywait(sem_t *sem);</code></p></li><li><p><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></p></li><li><p><code>int sem_post(sem_t *sem);</code></p><ul><li>功能：对信号量解锁，调用一次对信号量的值+1</li></ul></li><li><p><code>int sem_getvalue(sem_t *sem, int *sval);</code></p></li></ul><h3 id="future-promise和async">future, promise和async</h3><h2 id="练习题">练习题</h2><h3 id="按序打印">按序打印</h3><p><a href="https://leetcode.cn/problems/print-in-order/">1114. 按序打印</a></p><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span>()</span> &#123; print(<span class="string">&quot;first&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span>()</span> &#123; print(<span class="string">&quot;second&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span>()</span> &#123; print(<span class="string">&quot;third&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个不同的线程 A、B、C 将会共用一个 <code>Foo</code> 实例。</p><ul><li>线程 A 将会调用 <code>first()</code> 方法</li><li>线程 B 将会调用 <code>second()</code> 方法</li><li>线程 C 将会调用 <code>third()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p><p><strong>提示：</strong></p><ul><li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li><li>你看到的输入格式主要是为了确保测试的全面性。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1,2,3]</span></span><br><span class="line">输出：<span class="string">&quot;firstsecondthird&quot;</span></span><br><span class="line">解释：</span><br><span class="line">有三个线程会被异步启动。输入 <span class="selector-attr">[1,2,3]</span> 表示线程 A 将会调用 <span class="built_in">first</span>() 方法，线程 B 将会调用 <span class="built_in">second</span>() 方法，线程 C 将会调用 <span class="built_in">third</span>() 方法。正确的输出是 <span class="string">&quot;firstsecondthird&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1,3,2]</span></span><br><span class="line">输出：<span class="string">&quot;firstsecondthird&quot;</span></span><br><span class="line">解释：</span><br><span class="line">输入 <span class="selector-attr">[1,3,2]</span> 表示线程 A 将会调用 <span class="built_in">first</span>() 方法，线程 B 将会调用 <span class="built_in">third</span>() 方法，线程 C 将会调用 <span class="built_in">second</span>() 方法。正确的输出是 <span class="string">&quot;firstsecondthird&quot;</span>。</span><br></pre></td></tr></table></figure><p>（1）信号量</p><p>信号量是用来实现对共享资源的同步访问的机制，通过主动等待和主动唤醒来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> firstJobDone;</span><br><span class="line">    <span class="type">sem_t</span> secondJobDone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;firstJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;secondJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;firstJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;firstJobDone);</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;secondJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;secondJobDone);</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）互斥锁</p><p>互斥锁是用来防止多个线程同时访问共享资源对象的机制，在同一时间只有一个线程可以拥有一个特定的锁对象，其他线程如果尝试获取锁会阻塞直到锁资源被释放或直接返回失败。</p><p>针对这道题我们可以用两个互斥锁来阻塞 second 和 third 函数，分别在 first 和 second 执行结束后解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mx1, mx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mx1.<span class="built_in">lock</span>();</span><br><span class="line">        mx2.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        mx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        mx1.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        mx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        mx2.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）条件变量</p><p>条件变量一般和互斥锁搭配使用，互斥锁用于上锁，条件变量用于在多线程环境中等待特定事件发生。这里一把锁和2把锁都是OK的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                &#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);</span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        k = <span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                &#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）异步操作</p><p>异步操作是一种，在不需要等待被调用方返回结果之前，就让操作继续进行下去的方法。针对这道题可以使用基于 future/promise 的异步编程模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; num1, num2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        num1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = num1.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        num2.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="type">int</span> num = num2.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）原子操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">while</span> (!b)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">while</span> (!b)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交替打印-FooBar">交替打印 FooBar</h3><p><a href="https://leetcode.cn/problems/print-foobar-alternately/">交替打印 FooBar</a></p><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同的线程将会共用一个 <code>FooBar</code> 实例：</p><ul><li>线程 A 将会调用 <code>foo()</code> 方法，而</li><li>线程 B 将会调用 <code>bar()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>&quot;foobar&quot;</code> 被输出 <code>n</code> 次。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;foobar&quot;</span></span><br><span class="line">解释：这里有两个线程被异步启动。其中一个调用 <span class="built_in">foo</span>() 方法, 另一个调用 <span class="built_in">bar</span>() 方法，<span class="string">&quot;foobar&quot;</span> 将被输出一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;foobarfoobar&quot;</span></span><br><span class="line">解释：<span class="string">&quot;foobar&quot;</span> 将被输出两次。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>（1）信号量</p><p>将其中一个信号量设置成1就可以啦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> sem1, sem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;sem2);</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;sem1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;sem1);</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;sem2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FooBar <span class="title">fooBar</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;FooBar::foo, &amp;fooBar, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;FooBar::bar, &amp;fooBar, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;bar&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 互斥锁</p><p>和上一题类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    mutex mxt1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        mxt1.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            mtx2.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            mxt1.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            mxt1.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(3)条件变量</p><p>和上一道的条件变量类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            k = <span class="number">2</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（4）异步编程</p><p><strong>Note</strong>：在你的代码中，你使用了 <code>std::promise</code> 和 <code>std::future</code> 来同步 <code>foo</code> 和 <code>bar</code> 方法。然而，你在每个循环迭代中都调用了 <code>get()</code> 方法，这导致了问题。<code>std::future::get()</code> 方法只能被调用一次，因为它会移动（而不是复制）值。如果你尝试第二次调用 <code>get()</code>，会抛出一个 <code>std::future_error</code> 异常。</p><p>解决这个问题的一种方法是在每次迭代中重新创建 <code>std::promise</code> 和 <code>std::future</code> 对象。你可以在循环的每一次迭代后用新的 <code>std::promise</code> 对象替换旧的对象，然后从新的 <code>std::promise</code> 对象获取新的 <code>std::future</code> 对象。</p><p>不过我这里用投机的方式创建一个新的对象即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        p1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            p1.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            p1 = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            p2.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            p2.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            p2 = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">            p1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（5）原子操作</p><p>貌似用不用atomic都可以~可能这才是最纯粹的控制并发的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span> (a)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            a = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span> (!a)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            a = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="打印零与奇偶数">打印零与奇偶数</h3><p><a href="https://leetcode.cn/problems/print-zero-even-odd/">打印零与奇偶数</a></p><p>现有函数 <code>printNumber</code> 可以用一个整数参数调用，并输出该整数到控制台。</p><ul><li>例如，调用 <code>printNumber(7)</code> 将会输出 <code>7</code> 到控制台。</li></ul><p>给你类 <code>ZeroEvenOdd</code> 的一个实例，该类中有三个函数：<code>zero</code>、<code>even</code> 和 <code>odd</code> 。<code>ZeroEvenOdd</code> 的相同实例将会传递给三个不同线程：</p><ul><li>**线程 A：**调用 <code>zero()</code> ，只输出 <code>0</code></li><li>**线程 B：**调用 <code>even()</code> ，只输出偶数</li><li>**线程 C：**调用 <code>odd()</code> ，只输出奇数</li></ul><p>修改给出的类，以输出序列 <code>&quot;010203040506...&quot;</code> ，其中序列的长度必须为 <code>2n</code> 。</p><p>实现 <code>ZeroEvenOdd</code> 类：</p><ul><li><code>ZeroEvenOdd(int n)</code> 用数字 <code>n</code> 初始化对象，表示需要输出的数。</li><li><code>void zero(printNumber)</code> 调用 <code>printNumber</code> 以输出一个 0 。</li><li><code>void even(printNumber)</code> 调用<code>printNumber</code> 以输出偶数。</li><li><code>void odd(printNumber)</code> 调用 <code>printNumber</code> 以输出奇数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;0102&quot;</span></span><br><span class="line">解释：三条线程异步执行，其中一个调用 zero()，另一个线程调用 <span class="built_in">even</span>()，最后一个线程调用<span class="built_in">odd</span>()。正确的输出为 <span class="string">&quot;0102&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="string">&quot;0102030405&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>（1）原子变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">cnt</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zeroEvenOdd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;ZeroEvenOdd::zero, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;ZeroEvenOdd::even, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;ZeroEvenOdd::odd, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）信号量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> zero1, even1, odd1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;zero1, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;even1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;odd1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;zero1);</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sem_post</span>(&amp;odd1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sem_post</span>(&amp;even1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;even1);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;zero1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;odd1);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;zero1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zeroEvenOdd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;ZeroEvenOdd::zero, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;ZeroEvenOdd::even, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;ZeroEvenOdd::odd, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)条件变量+互斥锁</p><p>记得要写notify_all()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx, mtx1, mtx2;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">flag</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">0</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">2</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">1</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(4)互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx, mtx1, mtx2;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">flag</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx2.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx1.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="H2O生成">H2O生成</h3><p><a href="https://leetcode.cn/problems/building-h2o/">1117. H2O 生成</a></p><p>现在有两种线程，氧 <code>oxygen</code> 和氢 <code>hydrogen</code>，你的目标是组织这两种线程来产生水分子。</p><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 <code>releaseHydrogen</code> 和 <code>releaseOxygen</code> 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><ul><li>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</li><li>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</li></ul><p>书写满足这些限制条件的氢、氧线程同步代码。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">water</span> = <span class="string">&quot;HOH&quot;</span></span><br><span class="line">输出: <span class="string">&quot;HHO&quot;</span></span><br><span class="line">解释: <span class="string">&quot;HOH&quot;</span> 和 <span class="string">&quot;OHH&quot;</span> 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">water</span> = <span class="string">&quot;OOHHHH&quot;</span></span><br><span class="line">输出: <span class="string">&quot;HHOHHO&quot;</span></span><br><span class="line">解释: <span class="string">&quot;HOHHHO&quot;</span>, <span class="string">&quot;OHHHHO&quot;</span>, <span class="string">&quot;HHOHOH&quot;</span>, <span class="string">&quot;HOHHOH&quot;</span>, <span class="string">&quot;OHHHOH&quot;</span>, <span class="string">&quot;HHOOHH&quot;</span>, <span class="string">&quot;HOHOHH&quot;</span> 和 <span class="string">&quot;OHHOHH&quot;</span> 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 * n == water.length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>water[i] == 'O' or 'H'</code></li><li>输入字符串 <code>water</code> 中的 ‘H’ 总数将会是 <code>2 * n</code> 。</li><li>输入字符串 <code>water</code> 中的 ‘O’ 总数将会是 <code>n</code> 。</li></ul><p>思路：</p><p>一道典型的阅读理解题。</p><p>题目的意思是，要一个水分子，一个水分子的生成。一个水分子是两个H一个O，也就是要运行两次hydrogen和一次oxygen。要想保证水分子正常生成，那么当有了2个H时，就不能再，执行hydrogen了，它就要等。同理，当有了1个O时，就不能再执行oxygen，就要等。</p><p>同时，当任何时候凑够了2个H，1个O时，也即能生成水分子时，就要把计数重置，以生成下一个水分子。</p><p>一个水分子内部，是不用管顺序的，也即HHO，OHH，HOH都是合法的。</p><p>互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H2O</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx1,mtx2;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">H2O</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hydrogen</span><span class="params">(function&lt;<span class="type">void</span>()&gt; releaseHydrogen)</span> </span>&#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">releaseHydrogen</span>();</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>) mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oxygen</span><span class="params">(function&lt;<span class="type">void</span>()&gt; releaseOxygen)</span> </span>&#123;</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">releaseOxygen</span>();</span><br><span class="line">        cnt+=<span class="number">2</span>;</span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交替打印字符串">交替打印字符串</h3><p><a href="https://leetcode.cn/problems/fizz-buzz-multithreaded/"> 交替打印字符串</a></p><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><ul><li>如果这个数字可以被 3 整除，输出 “fizz”。</li><li>如果这个数字可以被 5 整除，输出 “buzz”。</li><li>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。</li></ul><p>例如，当 <code>n = 15</code>，输出： <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>。</p><p>假设有这么一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">FizzBuzz</span>(int n) &#123; ... &#125;               <span class="comment">// constructor</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fizz</span>(<span class="params">printFizz</span>) &#123; ... &#125;          <span class="comment">// only output &quot;fizz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">buzz</span>(<span class="params">printBuzz</span>) &#123; ... &#125;          <span class="comment">// only output &quot;buzz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fizzbuzz</span>(<span class="params">printFizzBuzz</span>) &#123; ... &#125;  <span class="comment">// only output &quot;fizzbuzz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">number</span>(<span class="params">printNumber</span>) &#123; ... &#125;      <span class="comment">// only output the numbers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请你实现一个有四个线程的多线程版 <code>FizzBuzz</code>， 同一个 <code>FizzBuzz</code> 实例会被如下四个线程使用：</p><ol><li>线程A将调用 <code>fizz()</code> 来判断是否能被 3 整除，如果可以，则输出 <code>fizz</code>。</li><li>线程B将调用 <code>buzz()</code> 来判断是否能被 5 整除，如果可以，则输出 <code>buzz</code>。</li><li>线程C将调用 <code>fizzbuzz()</code> 来判断是否同时能被 3 和 5 整除，如果可以，则输出 <code>fizzbuzz</code>。</li><li>线程D将调用 <code>number()</code> 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li></ol><p><strong>提示：</strong></p><ul><li>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分。</li></ul><p>1.互斥锁+条件变量</p><p>一波暴力出奇迹~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FizzBuzz</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz() outputs &quot;fizz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;cnt%<span class="number">5</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printFizz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz() outputs &quot;buzz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buzz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBuzz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">3</span>!=<span class="number">0</span>&amp;&amp;cnt%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printBuzz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz() outputs &quot;fizzbuzz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizzbuzz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizzBuzz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">5</span>==<span class="number">0</span>&amp;&amp;cnt%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printFizzBuzz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">number</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">5</span>==<span class="number">0</span>||cnt%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printNumber</span>(cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FizzBuzz <span class="title">tmp</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;FizzBuzz::fizz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;fizz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;FizzBuzz::buzz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;buzz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;FizzBuzz::fizzbuzz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;fizzbuzz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(&amp;FizzBuzz::number, &amp;tmp, [](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐">哲学家进餐</h3><p><a href="https://leetcode.cn/problems/the-dining-philosophers/">哲学家进餐</a></p><p>明天补~</p>]]></content>
    
    
    <summary type="html">经典并发练手案例</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux Performance</title>
    <link href="https://penge666.github.io/posts/e16c05c.html"/>
    <id>https://penge666.github.io/posts/e16c05c.html</id>
    <published>2024-05-16T02:43:10.000Z</published>
    <updated>2024-05-16T09:38:48.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516145620615.png" alt="image-20240516145620615"></p><p><a href="https://www.brendangregg.com/linuxperf.html">Linux Performance</a></p><h2 id="CPU篇">CPU篇</h2><h3 id="CPU性能指标">CPU性能指标</h3><p><strong>CPU使用率</strong></p><ul><li>用户CPU使用率：CPU使用率高，通常说明有应用程序比较繁忙。</li><li>系统CPU使用率：CPU使用率高，说明内核比较繁忙。</li><li>等待I/O的CPU使用率：iowait,表示等待I/O的时间百分比，iowait高通常说明系统与硬件设备I/O交互时间比较长。<ul><li>iowait指的是CPU等待硬盘I/O（输入/输出）操作完成的时间百分比。在这种状态下，CPU没有执行任何代码，因为它正在等待硬盘的I/O操作完成。</li></ul></li><li>软中断和硬中断的CPU使用率，内核调用软中断处理程序，硬中断处理程序的百分比。</li></ul><p><strong>平均负载</strong></p><p>平均负载其实就是平均活跃进程数。平均负载大于CPU数量表示CPU不足以服务线程，有些线程在等待；如果平均负载小于CPU数量，这代表还有一些余量。</p><p>主要包括三个数值，分别值过去1分钟，5分钟，15分钟的平均负载。</p><p>平均负载与 CPU 使用率关系：平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。【可运行状态是指正在使用或等待使用 CPU，而不可中断状态是指进程正执行某种 I/O 操作，比如读写磁盘】。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p><ul><li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li><li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><p><strong>上下文切换</strong></p><p>频繁上下文切换，将时间消耗在寄存器、内核栈以及虚拟内存等数据保持与恢复上。切换分为以下两类：</p><ul><li><p>无法获取资源而导致的自愿上下文切换。</p></li><li><p>被系统强制调度导致的非自愿上下文切换。</p></li></ul><p><strong>CPU缓存命中率</strong></p><p>CPU速度比内存访问速度快得多，协调这两者巨大性能差距，使用CPU缓存。缓存的是热点的内存数据。L1 L2 L3到缓存。L1 L2常用在单核中，L3则用在多核中。L1-&gt;L3三级缓存大小依次增大，相应性能依次降低。命中率衡量的是CPU缓存的复用情况，命中率越高，则性能越好。</p><h3 id="常用命令">常用命令</h3><table><thead><tr><th style="text-align:center"><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">uptime</td><td>平均负载</td></tr><tr><td style="text-align:center">vmstat</td><td>包括系统范围的CPU平均负载，上下文切换次数、中断次数、还包括处于运行和不可中断状态的进程数量</td></tr><tr><td style="text-align:center">mpstat</td><td>单个CPU统计信息和软中断次数</td></tr><tr><td style="text-align:center">sar</td><td>统计历史信息</td></tr><tr><td style="text-align:center">ps</td><td>进程状态和CPU使用率</td></tr><tr><td style="text-align:center">top</td><td>监控平均负载，运行队列、整体CPU使用率，以及每个进程/线程CPU用量</td></tr><tr><td style="text-align:center">pidstat</td><td>每个进程/线程CPU用量分解</td></tr><tr><td style="text-align:center">time</td><td>给一个命令计时，带CPU用量分解</td></tr><tr><td style="text-align:center">Dtrace,perf</td><td>CPU剖析和跟踪</td></tr><tr><td style="text-align:center">perf</td><td>CPU性能计数器分析，CPU缓存，cpu调度</td></tr></tbody></table><h4 id="uptime"><strong>uptime</strong></h4><p>功能：打印平均负载，系统运行时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">uptime</span></span><br><span class="line"> 10:56:18 up 72 days, 20:32,  2 <span class="built_in">users</span>,  load average: 25.44, 25.69, 25.18</span><br></pre></td></tr></table></figure><p>最后三个数字是1,5,15分钟内的平均负载。通过这三个值可以判断系统负载在此段时间内上升，下降还是平稳。</p><p>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</p><p>把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势，一般当平均负载高于 CPU 数量 70% 的时候，应该分析排查负载高的问题。</p><p>查看几个 CPU数量【lscpu】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br><span class="line">40</span><br></pre></td></tr></table></figure><h4 id="vmstat"><strong>vmstat</strong></h4><p>(Vitual Memory Static)</p><p>功能：报告虚拟内存统计信息</p><p>具体使用<code>vmstat --help</code>查看详细用法。</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示活跃和非活跃内存</td></tr><tr><td>-f</td><td>显示从系统启动至今的fork数量</td></tr><tr><td>-m</td><td>显示slabinfo</td></tr><tr><td><strong>-s</strong></td><td><strong>显示内存相关统计信息及多种系统活动数量</strong></td></tr><tr><td>-d</td><td>显示磁盘相关的统计信息</td></tr><tr><td>-S</td><td>使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节(Byte)，默认单位为K(1024 Bytes)</td></tr><tr><td>delay</td><td>刷新时间间隔，如果不指定，只显示一条结果</td></tr><tr><td>count</td><td>刷新次数，如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 1 秒后输出 1 组数据</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ vmstat 1 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line">23  0 1719692 7783592 400820 23694264    0    0     1     4    0    0 46  0 54  0  0</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>类别</strong></th><th><strong>参数</strong></th><th><strong>含义</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Procs</strong></td><td>r</td><td>（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</td><td>当这个值超过了cpu个数，就会出现cpu瓶颈。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高</td></tr><tr><td></td><td>b</td><td>等待IO的进程数量，阻塞的进程</td><td></td></tr><tr><td><strong>system</strong></td><td>in</td><td>每秒中断数，包括时钟中断</td><td>这两个值越大，会看到由内核消耗的cpu时间sy会越多这个值要越小越好，太大了，要考虑调低线程或者进程的数目</td></tr><tr><td></td><td>cs</td><td>每秒上下文切换数</td><td>同上，当进行线程的切换，进行上下文切换，这个值越小越好。</td></tr><tr><td><strong>CPU</strong></td><td>us</td><td>用户进程执行消耗cpu时间</td><td>us的值比较高时，说明用户进程消耗的cpu时间多</td></tr><tr><td></td><td>sy</td><td>系统进程消耗cpu时间</td><td>sys的值过高时，说明系统内核消耗的cpu资源多，例如I/O频繁操作。</td></tr><tr><td></td><td>Id</td><td>空闲时间(包括IO等待时间)</td><td>一般来说 us+sy+id=100</td></tr><tr><td></td><td>wa</td><td>等待IO时间</td><td>wa过高时，说明io等待比较严重，可能由于磁盘大量随机访问造成，也有可能是磁盘的带宽出现瓶颈。</td></tr><tr><td></td><td>st</td><td>来自于虚拟机偷取的CPU所占的百分比</td><td></td></tr><tr><td><strong>io</strong></td><td>bi</td><td>每秒从文件系统或SWAP读入到RAM（blocks in）的块数，block(1KB磁盘块)为单位</td><td>随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</td></tr><tr><td></td><td>bo</td><td>每秒从RAM写出到文件系统或SWAP（blocks out）的块数，block(1KB磁盘块)为单位</td><td></td></tr><tr><td><strong>swap</strong></td><td>si</td><td>每秒从SWAP(交换分区)读入到RAM（swap in）的大小，单位是KB</td><td>内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响。</td></tr><tr><td></td><td>so</td><td>每秒从RAM写出到SWAP（swap out）的大小，单位是KB</td><td></td></tr><tr><td><strong>memory</strong></td><td>swpd</td><td>使用的虚拟内存的大小，单位是KB</td><td></td></tr><tr><td></td><td>free</td><td>可用的物理内存大小，单位是KB</td><td></td></tr><tr><td></td><td>buff</td><td>物理内存用来缓存读写操作的buffer大小，单位是KB</td><td></td></tr><tr><td></td><td>cache</td><td>物理内存用来缓存进程地址空间的cache大小，单位是KB</td><td></td></tr></tbody></table><h4 id="mpstat"><strong>mpstat</strong></h4><p>（Multiprocessor Statistics）</p><p>功能：报告处理器相关的统计信息。</p><p>报告每个CPU的统计信息，-p ALL 用来打印CPU的报告，默认只打印系统级别的总结信息。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-P {|ALL}</td><td>表示监控哪个CPU，例如mpstat -P 0  mpstat -P 7  mpstat -P ALL</td></tr><tr><td>internal</td><td>相邻的两次采样的间隔时间</td></tr><tr><td>count</td><td>采样的次数，count只能和delay一起使用</td></tr></tbody></table><p>各个字段含义</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>%usr</td><td>用户态占用CPU的时间(%)，不包含nice值为正的进程时间，但包括了 guest 时间。</td></tr><tr><td>%nice</td><td>代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</td></tr><tr><td>%sys</td><td>内核态占用CPU的时间(%)</td></tr><tr><td>%iowait</td><td>等待IO占用CPU的时间(%)</td></tr><tr><td>%irq</td><td>硬中断占用CPU的时间(%)</td></tr><tr><td>%soft</td><td>软中断占用CPU的时间(%)</td></tr><tr><td>%guest</td><td>CPU处理虚拟进程花费的时间开销</td></tr><tr><td>%idle</td><td>空闲CPU的时间(%)</td></tr><tr><td>%steal</td><td>代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</td></tr></tbody></table><h4 id="top"><strong>top</strong></h4><p>功能：显示最消耗CPU的任务，并且有百分百。</p><p>top的使用方式 top [-d number] | top [-bnp]</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-d number</td><td>number代表秒数，表示top命令显示的页面更新一次的间隔 (default=5s)</td></tr><tr><td>-b</td><td>以批次的方式执行top</td></tr><tr><td>-n</td><td>与-b配合使用，表示需要进行几次top命令的输出结果</td></tr><tr><td>-p</td><td>指定特定的pid进程号进行观察</td></tr></tbody></table><p>top命令显示的页面还可以输入以下按键执行相应的功能（注意大小写区分的）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>？</td><td>显示在top当中可以输入的命令</td></tr><tr><td>P</td><td>以CPU的使用资源排序显示</td></tr><tr><td>M</td><td>以内存的使用资源排序显示</td></tr><tr><td>N</td><td>以pid排序显示</td></tr><tr><td>T</td><td>由进程使用的时间累计排序显示</td></tr><tr><td>k</td><td>给某一个pid一个信号,可以用来杀死进程(9)</td></tr><tr><td>r</td><td>给某个pid重新定制一个nice值（即优先级)</td></tr><tr><td>q</td><td>退出top（用ctrl+c也可以退出top）</td></tr></tbody></table><p>top各输出参数含义</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516115231233.png" alt="image-20240516115231233"></p><p>一、top前五条信息解释</p><p>top - 14:49:28 up 1:33, 1 user, load average: 0.00, 0.00, 0.00</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>14:49:28</td><td>表示当前时间</td></tr><tr><td>up 1:33</td><td>系统远行时间，格式为时：分</td></tr><tr><td>1 user</td><td>当前登陆用户数</td></tr><tr><td>load average: 0.00, 0.00, 0.00</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值</td></tr></tbody></table><p>Tasks: 80 total, 2 running, 78 sleeping, 0 stopped, 0 zombie</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>Tasks: 80 total</td><td>进程总数</td></tr><tr><td>2 running</td><td>正在运行的进程数</td></tr><tr><td>78 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr></tbody></table><p>Cpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>0.0%us</td><td>用户空间占用CPU百分比</td></tr><tr><td>0.0%sy</td><td>内核空间占用CPU百分比</td></tr><tr><td>0.0%ni</td><td>用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td>100.0%id</td><td>空闲CPU百分比</td></tr><tr><td>0.0%wa</td><td>等待输入输出的CPU时间百分比</td></tr><tr><td>0.0%hi</td><td>硬中断（Hardware IRQ）占用CPU的百分比</td></tr><tr><td>0.0%si</td><td>软中断（Software Interrupts）占用CPU的百分比</td></tr><tr><td>0.0 st</td><td>用于有虚拟cpu的情况，用来指示被虚拟机偷掉的cpu时间</td></tr></tbody></table><p>Mem: 1922488k total, 406936k used, 1515552k free, 11940k buffers</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>1922488k total</td><td>物理内存总量</td></tr><tr><td>406936k used</td><td>使用的物理内存总量</td></tr><tr><td>1515552k free</td><td>空闲内存总量</td></tr><tr><td>11940k buffers</td><td>用作内核缓存的内存量</td></tr></tbody></table><p>Swap: 835576k total, 0k used, 835576k free, 111596k cached</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>835576k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>835576k free</td><td>空闲交换区总量</td></tr><tr><td>111596k cached</td><td>缓冲的交换区总量</td></tr></tbody></table><p>二、进程信息</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>PID</td><td>进程id</td></tr><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td>SHR</td><td>共享内存大小，单位kb</td></tr><tr><td>S</td><td>进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>COMMAND</td><td>命令名/命令行</td></tr></tbody></table><p>Note:</p><ul><li>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</li><li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li><li>%MEM 是进程使用物理内存占系统总内存的百分比。</li></ul><p>默认进入top时，各进程是按照CPU的占用量来排序的。</p><h4 id="sar">sar</h4><p>文章：<a href="https://www.cnblogs.com/zsql/p/11628766.html">linux分析利刃之sar命令详解 </a></p><p>功能：收集、报告或保存系统活动信息</p><p>sar是一个非常全面的一个分析工具，可以比较瑞士军刀，对文件的读写，系统调用的使用情况，磁盘IO，CPU相关使用情况，内存使用情况，进程活动等都可以进行有效的分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-A：所有报告的总和</span><br><span class="line">-u：输出CPU使用情况的统计信息</span><br><span class="line">-v：输出inode、文件和其他内核表的统计信息</span><br><span class="line">-d：输出每一个块设备的活动信息</span><br><span class="line">-r：输出内存和交换空间的统计信息</span><br><span class="line">-b：显示I/O和传送速率的统计信息-R：输出内存页面的统计信息</span><br><span class="line">-y：终端设备活动情况</span><br><span class="line">-w：输出系统交换活动信息</span><br><span class="line">-B：显示换页状态；</span><br><span class="line">-e：设置显示报告的结束时间</span><br><span class="line">-f：从指定文件提取报告</span><br><span class="line">-i：设状态信息刷新的间隔时间</span><br><span class="line">-p：报告每个CPU的状态</span><br><span class="line">-q：平均负载分析</span><br></pre></td></tr></table></figure><p>1.统计CPU使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -u 1 3<span class="comment"># 统计CPU的使用情况，每间隔1秒钟统计一次总共统计三次</span></span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时00分10秒     CPU     %user     %<span class="built_in">nice</span>   %system   %iowait    %steal     %idle</span><br><span class="line">15时00分11秒     all     60.64      0.00      0.90      0.00      0.00     38.46</span><br><span class="line">15时00分12秒     all     62.84      0.00      0.45      0.00      0.00     36.71</span><br><span class="line">15时00分13秒     all     60.88      0.00      1.08      0.00      0.00     38.04</span><br><span class="line">平均时间:     all     61.46      0.00      0.81      0.00      0.00     37.73</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -o test.txt -u 1 3</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -u -f test.txt</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时01分57秒     CPU     %user     %<span class="built_in">nice</span>   %system   %iowait    %steal     %idle</span><br><span class="line">15时01分58秒     all     61.59      0.00      0.43      0.00      0.00     37.99</span><br><span class="line">15时01分59秒     all     66.08      1.00      0.93      0.00      0.00     31.99</span><br><span class="line">15时02分00秒     all     62.38      0.10      1.13      0.00      0.00     36.39</span><br><span class="line">平均时间:     all     63.35      0.37      0.83      0.00      0.00     35.45</span><br></pre></td></tr></table></figure><p>2.查看磁盘IO</p><p>查看I/O和传递速率的统计信息，每间隔1秒钟统计一次总共统计三次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -b 1 3</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时03分49秒       tps      rtps      wtps      dtps   bread/s   bwrtn/s   bdscd/s</span><br><span class="line">15时03分50秒      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15时03分51秒      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15时03分52秒      2.00      0.00      2.00      0.00      0.00     24.00      0.00</span><br><span class="line">平均时间:      0.67      0.00      0.67      0.00      0.00      8.00      0.00</span><br></pre></td></tr></table></figure><h4 id="pidstat">pidstat</h4><p>pidstat 是sysstat软件套件的一部分，sysstat包含很多监控linux系统状态的工具，它能够从大多数linux发行版的软件源中获得。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install sysstat</span><br></pre></td></tr></table></figure><p>功能：pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</p><p>按进程或线程打印CPU用量，包括用户态和系统态时间的分解。</p><p><strong>cpu使用情况统计(-u)，针对特定进程统计(-p)</strong></p><ul><li><strong>UID</strong>:一列代表了进程的用户标识符（User Identifier）</li><li><strong>PID</strong>: 进程pid</li><li><strong>%usr</strong>: 进程在用户态运行所占cpu时间比率</li><li><strong>%system</strong>: 进程在内核态运行所占cpu时间比率</li><li>%<strong>guest</strong> :任务花费在虚拟机上的cpu使用率（运行在虚拟处理器）</li><li><strong>%CPU</strong>: 进程运行所占cpu时间比率</li><li><strong>CPU</strong>: 指示进程在哪个核运行</li><li><strong>Command</strong>: 拉起进程对应的命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ pidstat</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时08分27秒   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">15时08分27秒     0         1    0.01    0.01    0.00    0.00    0.01    32  systemd</span><br><span class="line">15时08分27秒     0         2    0.00    0.00    0.00    0.00    0.00    32  kthreadd</span><br><span class="line">15时08分27秒     0        14    0.00    0.00    0.00    0.00    0.00     0  ksoftirqd/0</span><br><span class="line">15时08分27秒     0        15    0.00    0.08    0.00    0.02    0.08    29  rcu_sched</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分析CPU性能瓶颈方法">分析CPU性能瓶颈方法</h3><p>《速查表》</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516151750649.png" alt="image-20240516151750649"></p><p>通常先运行几个支持指标较多的工具，<strong>top,vmstat和pidstat</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516152157984.png" alt="image-20240516152157984"></p><ul><li>从 top 的输出可以得到各种 CPU 使用率以及僵尸进程和平均负载等信息。</li><li>从 vmstat 的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数。</li><li>从 pidstat 的输出可以得到进程的用户 CPU 使用率、系统 CPU 使用率、以及自愿上下文切换和非自愿上下文切换情况。</li></ul><p>分析问题待填坑。</p><p><strong>系统优化</strong></p><ul><li><strong>CPU 绑定</strong>：一个进程可以被设置为只在一个或者多个特定的CPU上运行，而不是在所有的CPU上随机调度。这种技术被称为CPU亲和性（CPU Affinity）。通过设置CPU亲和性，可以提高缓存命中率和内存访问性能，从而提高整体性能。</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</li></ul><h2 id="内存篇">内存篇</h2><h3 id="内存信息">内存信息</h3><p>查看内存信息命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516163609218.png" alt="image-20240516163609218"></p><p>查看红框信息</p><ul><li>MemTotal：系统总内存，由于 BIOS、内核等会占用一些内存，所以这里和配置声称的内存会有一些出入，比如我这里配置有 2G，但其实只有 1.95G 可用。</li><li>MemFree：系统空闲内存。</li><li>MemAvailable：应用程序可用内存。有人会比较奇怪和 MemFree 的区别，可以从两个层面来区分，<strong>MemFree 是系统层面的，而 MemAvailable 是应用程序层面的</strong>。系统中有些内存虽然被使用了但是有一部分是可以回收的，比如 Buffers、Cached 及 Slab 这些内存，这部分可以回收的内存加上 MemFree 才是 MemAvailable 的内存值，这是内核通过特定算法算出来的，是一个估算值。</li><li>Buffers：缓冲区内存</li><li>Cached：缓存</li></ul><h3 id="常用命令-2">常用命令</h3><h4 id="free"><strong>free</strong></h4><p>查看内存使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：    65566072    34371864     6931596      927388    24262612    29574080</span><br><span class="line">交换：     2097148     1718532      378616</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free -h</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：        62Gi        32Gi       6.6Gi       905Mi        23Gi        28Gi</span><br><span class="line">交换：       2.0Gi       1.6Gi       369Mi</span><br></pre></td></tr></table></figure><p>我们观察到free 很小，buff/cache 却很大。这是由于Linux设计思想：内存闲着反正也是闲着，不如拿出来做系统缓存和缓冲区，提高数据读写的速率。</p><ul><li>Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。</li><li>Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。</li></ul><p><strong>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中</strong>。</p><p>Swap</p><p>交换空间是硬盘上的一块区域，它被操作系统用作虚拟内存，用来在物理内存（RAM）不足时，存放暂时不需要的内存数据。</p><p>详细来说，当系统的物理内存不足以支持当前的所有进程时，操作系统会选择一些暂时不活跃的内存页，把它们从物理内存移动到交换空间，从而释放出物理内存给当前活跃的进程使用。这个过程被称为“交换出”（Swap Out）。</p><p>反过来，当这些被交换出的内存页再次被需要时，操作系统会把它们从交换空间移回到物理内存，这个过程被称为“交换入”（Swap In）。</p><h4 id="pmap">pmap</h4><p>这个命令用于查看进程的内存映像信息，能够查看进程在哪些地方用了多少内存。常用 pmap -x pid 来查看。</p><p>可以看到该进程内存被哪些库、哪些文件所占用，据此我们定位程序对内存的使用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516164838320.png" alt="image-20240516164838320"></p><p>几个字段介绍一下：</p><ul><li><p>Address：占用内存的文件的内存起始地址。</p></li><li><p>Kbytes：占用内存的字节数。</p></li><li><p>RSS：实际占用内存大小。</p></li><li><p>Dirty：脏页大小。</p></li><li><p>Mapping：占用内存的文件，[anon] 为已分配的内存，[stack] 为程序堆栈</p></li><li><p>最后的 total 为统计的总值。我们可以使用 pmap -x pid | tail -1 这样只显示最后一行，循环显示最后一行，达到监控该进程的目的。使用：</p><p>while true; do pmap -x pid | tail -1; sleep 1; done</p></li></ul><h2 id="IO-篇">IO 篇</h2><p>IO 和 存储密切相关，存储可以概括为磁盘，内存，缓存，三者读写的性能差距非常大，<strong>磁盘读写是毫秒级的（一般 0.1-10ms），内存读写是微妙级的（一般 0.1-10us），cache 是纳秒级的（一般 1-10ns）。</strong></p><h3 id="磁盘性能指标">磁盘性能指标</h3><p>五个常见指标</p><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li><li><strong>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数（每秒读写的次数）。</strong></li><li><strong>吞吐量，是指每秒的 I/O 请求大小（每秒读写的数据量）。</strong></li><li><strong>响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</strong></li></ul><h3 id="常用命令-3">常用命令</h3><h4 id="fdisk">fdisk</h4><p>查看磁盘信息，包括磁盘容量，扇区大小，IO 大小等信息，常用 fdisk -l 查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo fdisk -l</span><br><span class="line">Disk /dev/loop0：63.97 MiB，67051520 字节，130960 个扇区</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="df"><strong>df</strong></h4><p>查看磁盘使用情况，通常看磁盘使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">df</span> -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev             32G     0   32G    0% /dev</span><br><span class="line">tmpfs           6.3G  2.8M  6.3G    1% /run</span><br><span class="line">/dev/sda2       439G  253G  164G   61% /</span><br><span class="line">tmpfs            32G  136K   32G    1% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs            32G     0   32G    0% /sys/fs/cgroup</span><br><span class="line">/dev/loop1      128K  128K     0  100% /snap/bare/5</span><br><span class="line">/dev/loop4       56M   56M     0  100% /snap/core18/2812</span><br><span class="line">/dev/loop6       75M   75M     0  100% /snap/core22/1122</span><br><span class="line">/dev/loop18     350M  350M     0  100% /snap/gnome-3-38-2004/140</span><br><span class="line">/dev/loop17      13M   13M     0  100% /snap/snap-store/959</span><br><span class="line">/dev/loop13     350M  350M     0  100% /snap/gnome-3-38-2004/143</span><br><span class="line">/dev/loop19      92M   92M     0  100% /snap/gtk-common-themes/1535</span><br><span class="line">/dev/loop14     219M  219M     0  100% /snap/gnome-3-34-1804/90</span><br><span class="line">/dev/loop12      82M   82M     0  100% /snap/gtk-common-themes/1534</span><br><span class="line">/dev/loop10     219M  219M     0  100% /snap/gnome-3-34-1804/93</span><br><span class="line">/dev/sda1       511M  6.1M  505M    2% /boot/efi</span><br><span class="line">/dev/sdb2       3.6T  438G  3.0T   13% /data</span><br><span class="line">tmpfs           6.3G   76K  6.3G    1% /run/user/1000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="vmstat-2">vmstat</h4><p>常用的还是这个万能的 vmstat：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line">24  0 1718020 6435840 450144 23930416    0    0     1     4    0    0 46  0 54  0  0</span><br></pre></td></tr></table></figure><p>对于 IO，我们常关注三个部分：</p><ul><li>b 值：表示因为 IO 阻塞排队的任务数</li><li>bi 和 bo 值：表示每秒读写磁盘的块数，bi（block in）是写磁盘，bo（block out）是读磁盘。</li><li>wa 值：表示因为 IO 等待（wait）而消耗的 CPU 比例。</li></ul><p>一般这几个值偏大，都意味着系统 IO 的消耗较大，对于读请求较大的服务器，b、bo、wa 的值偏大，而写请求较大的服务器，b、bi、wa 的值偏大。</p><h4 id="iostat"><strong>iostat</strong></h4><p>vmstat 虽然万能，但是它分析的东西有限，<strong>iostat 是专业分析 IO 性能的工具，可以方便查看 CPU、网卡、tty 设备、磁盘、CD-ROM 等等设备的信息</strong>，非常强大，总结下来，共有以下几种用法：</p><p><strong>1）iostat -c 查看部分 CPU 使用情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ iostat -c</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %<span class="built_in">nice</span> %system %iowait  %steal   %idle</span><br><span class="line">          45.91    0.00    0.31    0.01    0.00   53.77</span><br></pre></td></tr></table></figure><p>这里显示的是多个 CPU 的平均值，每个字段的含义我就不多解释了，我一般会重点关注 %iowait 和 %idle，分别表示 CPU 等待 IO 完成时间的百分比和 CPU 空闲时间百分比。</p><p><strong>如果 %iowait 较高，则表明磁盘存在 IO 瓶颈，如果 %idle 较高，则 CPU 比较空闲，如果两个值都比较高，则有可能 CPU 在等待分配内存，瓶颈在内存，此时应该加大内存，如果 %idle 较低，则此时瓶颈在 CPU，应该增加 CPU 资源。</strong></p><p><strong>2）iostat -d 查看磁盘使用情况</strong>，主要是<strong>显示 IOPS 和吞吐量信息</strong>（-k : 以 KB 为单位显示，-m：以 M 为单位显示）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ iostat -d -k</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">loop0             0.00         0.00         0.00         0.00        731          0          0</span><br><span class="line">loop1             0.00         0.00         0.00         0.00         21          0          0</span><br><span class="line">loop10            0.00         0.00         0.00         0.00       2175          0          0</span><br><span class="line">loop11            0.00         0.00         0.00         0.00       1460          0          0</span><br><span class="line">loop12            0.00         0.00         0.00         0.00       2120          0          0</span><br><span class="line">loop13            0.00         0.00         0.00         0.00       2192          0          0</span><br><span class="line">loop14            0.00         0.00         0.00         0.00       2155          0          0</span><br><span class="line">loop15            0.00         0.00         0.00         0.00       1234          0          0</span><br><span class="line">loop16            0.00         0.00         0.00         0.00       1500          0          0</span><br></pre></td></tr></table></figure><p>其中，几个参数分别解释如下：</p><ul><li>tps：设备每秒的传输次数（transfers per second），也就是读写次数。</li><li>kB_read/s 和 kB_wrtn/s：每秒读写磁盘的数据量。</li><li>kB_read 和 kB_wrtn：读取磁盘的数据总量。</li></ul><p><strong>3）iostat -x 查看磁盘详细信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %<span class="built_in">nice</span> %system %iowait  %steal   %idle</span><br><span class="line">          45.91    0.00    0.31    0.01    0.00   53.77</span><br><span class="line"></span><br><span class="line">Device            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz  aqu-sz  %util</span><br><span class="line">loop0            0.00      0.00     0.00   0.00    0.25     7.31    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00   0.00</span><br><span class="line">loop1            0.00      0.00     0.00   0.00    0.33     1.40    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00   0.00</span><br></pre></td></tr></table></figure><p>其中，几个参数解释如下；</p><ul><li>rrqm/s 和 wrqm/s：分别每秒进行合并的读操作数和写操作数，这是什么意思呢，合并就是说把多次 IO 请求合并成少量的几次，这样可以减小 IO 开销，buffer 存在的意义就是为了解决这个问题的。</li><li>r/s 和 w/s：每秒磁盘读写的次数。这两个值相加就是 tps。</li><li>rkB/s 和 wkB/s：每秒磁盘读写的数据量，这两个值和上面的 kB_read/s、kB_wrnt/s 是一样的。</li><li>avgrq-sz：平均每次读写磁盘扇区的大小。</li><li>avgqu-sze：平均 IO 队列长度。队列长度越短越好。</li><li>await：平均每次磁盘读写的等待时间（ms）。</li><li>svctm：平均每次磁盘读写的服务时间（ms）。</li><li>%util：一秒钟有百分之多少的时间用于磁盘读写操作。</li></ul><p>以上这些参数太多了，我们并不需要每个都关注，可以重点关注两个：</p><p><strong>a. %util：衡量 IO 的繁忙程度</strong></p><p>这个值越大，说明产生的 IO 请求较多，IO 压力较大，我们可以结合 %idle 参数来看，如果 %idle &lt; 70% 就说明 IO 比较繁忙了。也可以结合 vmstat 的 b 参数（等待 IO 的进程数）和 wa 参数（IO 等待所占 CPU 时间百分比）来看，如果 wa &gt; 30% 也说明 IO 较为繁忙。</p><p><strong>b. await：衡量 IO 的响应速度</strong></p><p>通俗理解，await 就像我们去医院看病排队等待的时间，这个值和医生的服务速度（svctm）和你前面排队的人数（avgqu-size）有关。如果 svctm 和 await 接近，说明磁盘 IO 响应时间较快，排队较少，如果 await 远大于 svctm，说明此时队列太长，响应较慢，这时可以考虑换性能更好的磁盘或升级 CPU。</p><p><strong>4）iostat 1 2 默认显示 cpu 和 吞吐量信息，1 定时 1s 显示，2 显示 2 条信息</strong></p><h4 id="iotop"><strong>iotop</strong></h4><p>用于查看每个进程的 IO 情况，有了这个命令，就可以定位具体哪个进程的 IO 开销比较大了。</p><p>总结：<strong>fdisk -l 和 df 查看磁盘基本信息，iostat -d 查看磁盘 IOPS 和吞吐量，iostat -x 结合 vmstat 查看磁盘的繁忙程度和处理效率</strong>。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/weixin_45465395/article/details/115728520">linux top命令详解（看这一篇就够了）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1OTY2MzMxOQ==&amp;mid=2247484103&amp;idx=1&amp;sn=d437fd54bac8ac00522aa4538ca9c7a1&amp;chksm=ea74367fdd03bf699d603f39836bb35c0e6190f6781e0eda104a3710705034293255e85bd6b4&amp;scene=21#wechat_redirect">一文掌握 Linux 性能分析之 CPU 篇</a></li></ul>]]></content>
    
    
    <summary type="html">Linux Performance</summary>
    
    
    
    <category term="Linux" scheme="https://penge666.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://penge666.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Sanitizer</title>
    <link href="https://penge666.github.io/posts/f07e3ce0.html"/>
    <id>https://penge666.github.io/posts/f07e3ce0.html</id>
    <published>2024-05-14T11:48:21.000Z</published>
    <updated>2024-05-14T12:29:22.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sanitizer">Sanitizer</h2><p>Sanitizer是由Google发起的开源工具集，用于检测内存泄露等问题。它包括了AddressSanitizer、MemorySanitizer、ThreadSanitizer、LeakSanitizer等多种工具。这些工具最初是LLVM项目的一部分，后来也被GNU的GCC编译器支持。从GCC的4.8版本开始，就已经支持AddressSanitizer和ThreadSanitizer，而4.9版本则开始支持LeakSanitizer。</p><ul><li><strong>AddressSanitizer</strong>，检测内存访问问题</li><li><strong>MemorySanitizer</strong>，检测未初始化内存问题</li><li><strong>ThreadSanitizer</strong>，检测线程竞态和死锁问题</li><li><strong>LeakSanitizer</strong>，检测内存泄露问题</li></ul><p>编译器自带。相比于检测工具valgrind，它对程序性能的影响更小，用过valgrind的就知道，使用valgrind后程序的性能大大降低。</p><p>官方链接：<a href="https://link.zhihu.com/?target=https%3A//github.com/google/sanitizers/wiki/">https://link.zhihu.com/?target=https%3A//github.com/google/sanitizers/wiki/</a></p><h2 id="AddressSanitizer">AddressSanitizer</h2><p><strong>原理介绍</strong><br>AddressSanitizer（简称ASan）是一种内存错误检测器，它可以检测出各种内存相关的错误，包括内存泄漏。在Android NDK中，我们可以通过在编译选项中添加-fsanitize=address来启用ASan。ASan会在程序运行时监控内存操作，当检测到内存泄漏时，会打印出详细的错误信息，包括泄漏的大小、位置和堆栈信息。</p><p><strong>AddressSanitizer的原理</strong></p><ul><li><p>内存布局变换：ASan在编译时改变程序的内存布局，使得程序中的每个对象（变量、数组等）周围都有一些额外的“红色区域”（redzones）。这些红色区域用于检测内存访问越界。例如，如果一个数组的访问越过了它的边界并访问了红色区域，ASan就会报告一个缓冲区溢出错误。</p></li><li><p>影子内存：ASan使用影子内存（shadow memory）来跟踪程序中的每个内存字节的状态。影子内存是程序内存的一个映射，用于存储有关内存状态的元数据，如内存是否已分配、是否已初始化等。当程序访问内存时，ASan会检查对应的影子内存，以确定访问是否合法。</p></li><li><p>编译器插桩：ASan通过编译器插桩（instrumentation）在程序中插入检查代码。这些检查代码在内存访问发生时执行，以检测潜在的内存错误。例如，ASan会在堆分配和释放函数（如malloc和free）中插入代码，以检测内存泄漏和使用已释放的内存。</p></li></ul><p><strong>工具使用</strong></p><p>ASan是一个C/C++的内存错误检测工具，它能够检测：</p><ul><li>Use after free，悬空指针引用，也叫野指针引用，即对free后的内存进行存取操作。</li><li>Heap buffer overflow，堆溢出访问，即对堆的操作越界了。</li><li>Stack buffer overflow，栈溢出访问，即对栈的操作越界了。</li><li>Global buffer overflow，全局缓冲区溢出，例如全局的数组这些，反正都是越界访问，只不过位于程序的不同segment。</li><li>Use after return，即栈的野指针，例如A函数调用B函数，A函数有个指针传入到B中，B把它赋值指向了B的一个局部变量，即栈变量，B返回到A后，A操作该指针的错误。</li><li>Use after scope，和Use after return有点类似，C/C++的{}表示一个scope。</li><li>Initialization order bugs</li><li>Memory leaks，内存泄露，AddressSanitizer集成了LeakSanitizer的功能。</li></ul><blockquote><p><strong>Use after free</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -fsanitize=address main.cpp -fpermissive</span><br><span class="line">main.cpp: In <span class="keyword">function</span> ‘int main(int, char**)’:</span><br><span class="line">main.cpp:5:21: warning: invalid conversion from ‘void*’ to ‘char*’ [-fpermissive]</span><br><span class="line">    5 |     char *p = malloc(10);</span><br><span class="line">      |               ~~~~~~^~~~</span><br><span class="line">      |                     |</span><br><span class="line">      |                     void*</span><br></pre></td></tr></table></figure><p>Note：<code>-g</code>是一个选项，用来为生成的可执行文件添加调试信息。</p><p>查看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./a.out</span><br><span class="line">=================================================================</span><br><span class="line">==<span class="number">1336741</span>==ERROR: AddressSanitizer: heap-use-after-free on address <span class="number">0x602000000010</span> at pc <span class="number">0x55bced57822a</span> bp <span class="number">0x7ffc50d251d0</span> sp <span class="number">0x7ffc50d251c0</span></span><br><span class="line">WRITE of size <span class="number">1</span> at <span class="number">0x602000000010</span> thread T0</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x55bced578229</span> in main /home/sv/桌面/main.cpp:<span class="number">7</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x7faf0d998082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x55bced57810d</span> in _start (/home/sv/桌面/a.out+<span class="number">0x110d</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000000010</span> is located <span class="number">0</span> bytes inside of <span class="number">10</span>-byte region [<span class="number">0x602000000010</span>,<span class="number">0x60200000001a</span>)</span><br><span class="line">freed by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x7faf0dfbf40f</span> in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:<span class="number">122</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x55bced5781f5</span> in main /home/sv/桌面/main.cpp:<span class="number">6</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x7faf0d998082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line"></span><br><span class="line">previously allocated by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x7faf0dfbf808</span> in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:<span class="number">144</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x55bced5781e5</span> in main /home/sv/桌面/main.cpp:<span class="number">5</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x7faf0d998082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/sv/桌面/main.cpp:<span class="number">7</span> in main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff7fb0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fc0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fd0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fe0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7ff0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x0c047fff8000</span>: fa fa[fd]fd fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8010</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8020</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8030</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8040</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8050</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte <span class="built_in">legend</span> (one shadow byte represents <span class="number">8</span> application bytes):</span><br><span class="line">  Addressable:           <span class="number">00</span></span><br><span class="line">  Partially addressable: <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span></span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="keyword">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==<span class="number">1336741</span>==ABORTING</span><br></pre></td></tr></table></figure><p>显然，存在 heap-use-after-free。</p><p>仔细分析下上述信息：</p><p>1.进程号，错误类型，操作是读，还是写，操作的地址，线程号等，以及栈的回溯信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==1336741==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x55bced57822a bp 0x7ffc50d251d0 sp 0x7ffc50d251c0</span><br><span class="line">WRITE of size 1 at 0x602000000010 thread T0</span><br><span class="line">    <span class="comment">#0 0x55bced578229 in main /home/sv/桌面/main.cpp:7</span></span><br><span class="line">    <span class="comment">#1 0x7faf0d998082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x55bced57810d in _start (/home/sv/桌面/a.out+0x110d)</span></span><br></pre></td></tr></table></figure><p>2.对此块内存的操作的具体位置，对10字节的内存区域[0x602000000010,0x60200000001a),的第0个字节操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000000010 is located 0 bytes inside of 10-byte region [0x602000000010,0x60200000001a)</span><br><span class="line">freed by thread T0 here:</span><br><span class="line">    <span class="comment">#0 0x7faf0dfbf40f in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:122</span></span><br><span class="line">    <span class="comment">#1 0x55bced5781f5 in main /home/sv/桌面/main.cpp:6</span></span><br><span class="line">    <span class="comment">#2 0x7faf0d998082 in __libc_start_main ../csu/libc-start.c:308</span></span><br></pre></td></tr></table></figure><p>3.此块内存区域在那个线程，哪个地方分配的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">previously allocated by thread T0 here:</span><br><span class="line">    <span class="comment">#0 0x7faf0dfbf808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144</span></span><br><span class="line">    <span class="comment">#1 0x55bced5781e5 in main /home/sv/桌面/main.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x7faf0d998082 in __libc_start_main ../csu/libc-start.c:308</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Heap buffer overflow</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p[<span class="number">10</span>] =  <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -fsanitize=address main.cpp -fpermissive</span><br><span class="line">main.cpp: In <span class="keyword">function</span> ‘int main(int, char**)’:</span><br><span class="line">main.cpp:5:21: warning: invalid conversion from ‘void*’ to ‘char*’ [-fpermissive]</span><br><span class="line">    5 |     char *p = malloc(10);</span><br><span class="line">      |               ~~~~~~^~~~</span><br><span class="line">      |                     |</span><br><span class="line">      |                     void*</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./a.out</span><br><span class="line">=================================================================</span><br><span class="line">==1336960==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000001a at pc 0x5563af190226 bp 0x7fff4fbb4d30 sp 0x7fff4fbb4d20</span><br><span class="line">WRITE of size 1 at 0x60200000001a thread T0</span><br><span class="line">    <span class="comment">#0 0x5563af190225 in main /home/sv/桌面/main.cpp:6</span></span><br><span class="line">    <span class="comment">#1 0x7f88cfff5082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x5563af19010d in _start (/home/sv/桌面/a.out+0x110d)</span></span><br><span class="line"></span><br><span class="line">0x60200000001a is located 0 bytes to the right of 10-byte region [0x602000000010,0x60200000001a)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    <span class="comment">#0 0x7f88d061c808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144</span></span><br><span class="line">    <span class="comment">#1 0x5563af1901e5 in main /home/sv/桌面/main.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x7f88cfff5082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/sv/桌面/main.cpp:6 <span class="keyword">in</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">=&gt;0x0c047fff8000: fa fa 00[02]fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07</span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="built_in">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      <span class="built_in">fc</span></span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==1336960==ABORTING</span><br></pre></td></tr></table></figure><blockquote><p><strong>Stack buffer overflow</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> p[<span class="number">10</span>];</span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==26927==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffe0389d7a at pc 0x5577fcfd7289 bp 0x7fffe0389d30 sp 0x7fffe0389d20</span><br><span class="line">WRITE of size 1 at 0x7fffe0389d7a thread T0</span><br><span class="line">    <span class="comment">#0 0x5577fcfd7288 in main /home/thomas/test/ctest/main.c:5</span></span><br><span class="line">    <span class="comment">#1 0x7f97e9d0d082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x5577fcfd710d in _start (/home/thomas/test/ctest/a.out+0x110d)</span></span><br><span class="line"> </span><br><span class="line">Address 0x7fffe0389d7a is located <span class="keyword">in</span> stack of thread T0 at offset 42 <span class="keyword">in</span> frame</span><br><span class="line">    <span class="comment">#0 0x5577fcfd71d8 in main /home/thomas/test/ctest/main.c:3</span></span><br><span class="line"> </span><br><span class="line">  This frame has 1 object(s):</span><br><span class="line">    [32, 42) <span class="string">&#x27;p&#x27;</span> (line 4) &lt;== Memory access at offset 42 overflows this variable</span><br><span class="line">HINT: this may be a <span class="literal">false</span> positive <span class="keyword">if</span> your program uses some custom stack unwind mechanism, swapcontext or vfork</span><br><span class="line">      (longjmp and C++ exceptions *are* supported)</span><br><span class="line">SUMMARY: AddressSanitizer: stack-buffer-overflow /home/thomas/test/ctest/main.c:5 <span class="keyword">in</span> main</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p><strong>Global buffer overflow</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> p[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，运行输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==27271==ERROR: AddressSanitizer: global-buffer-overflow on address 0x5632b22930aa at pc 0x5632b2290213 bp 0x7ffeba0b5140 sp 0x7ffeba0b5130</span><br><span class="line">WRITE of size 1 at 0x5632b22930aa thread T0</span><br><span class="line">    <span class="comment">#0 0x5632b2290212 in main /home/thomas/test/ctest/main.c:5</span></span><br><span class="line">    <span class="comment">#1 0x7f90fd627082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x5632b229010d in _start (/home/thomas/test/ctest/a.out+0x110d)</span></span><br><span class="line"> </span><br><span class="line">0x5632b22930aa is located 0 bytes to the right of global variable <span class="string">&#x27;p&#x27;</span> defined <span class="keyword">in</span> <span class="string">&#x27;main.c:2:6&#x27;</span> (0x5632b22930a0) of size 10</span><br><span class="line">SUMMARY: AddressSanitizer: global-buffer-overflow /home/thomas/test/ctest/main.c:5 <span class="keyword">in</span> main</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>。。。</p><h2 id="LeakSanitizer">LeakSanitizer</h2><p>LeakSanitizer是一个强大的内存泄漏检测工具，主要用于C/C++程序的内存泄漏问题诊断。它通过在程序运行时监控动态内存分配和释放的行为，帮助开发者快速定位和解决内存泄漏问题。LeakSanitizer是Clang/LLVM编译器套件的一部分，与GCC编译器的内存泄漏检测工具Valgrind互为补充。</p><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="comment">// ptr没有被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ clang -g -fsanitize=leak main.cpp -fpermissive</span><br></pre></td></tr></table></figure><p>查看【Note:g++编译可能会出错~】</p><p>推荐阅读：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/357803433">详解三大编译器：gcc、llvm 和 clang - 知乎专栏</a></li><li><a href="https://zhuanlan.zhihu.com/p/682607611">GCC vs Clang: 两大编译器巨头的龙争虎斗 - 知乎专栏</a></li><li><a href="https://www.cnblogs.com/findumars/p/14213309.html">GCC与Clang / LLVM：C / C ++编译器的深度比较 - findumars - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/545695166">clang 与 GCC 的区别 - 知乎 - 知乎专栏</a></li><li><a href="https://zh.wikipedia.org/wiki/Clang">Clang - 维基百科，自由的百科全书</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./a.out</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==1338908==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x407925 in malloc (/home/sv/桌面/a.out+0x407925)</span></span><br><span class="line">    <span class="comment">#1 0x426dc1 in foo() /home/sv/桌面/main.cpp:4:23</span></span><br><span class="line">    <span class="comment">#2 0x426de3 in main /home/sv/桌面/main.cpp:9:5</span></span><br><span class="line">    <span class="comment">#3 0x7f0251d2e082 in __libc_start_main /build/glibc-e2p3jK/glibc-2.31/csu/../csu/libc-start.c:308:16</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>LeakSanitizer主要针对动态内存分配的检测，对于静态分配或全局分配的内存泄漏无能为力。</li><li>启用LeakSanitizer可能会对程序性能产生一定影响，因此通常在开发和测试阶段使用，而不推荐在生产环境中持续启用。</li><li>在使用LeakSanitizer时，可能会遇到各种问题，如初始化失败、缺少依赖库等。这些问题通常需要根据具体的错误信息进行排查和解决。</li></ol><p><strong>AddressSanitizer和LeakSanitizer的区别</strong></p><p>AddressSanitizer（ASan）和LeakSanitizer（LSan）都是用于内存错误检测的工具，它们的主要区别在于检测的问题类型和应用场景。</p><ol><li>AddressSanitizer（ASan）:<ul><li>ASan是一种用于检测内存错误的工具，包括内存访问越界、使用释放的内存、堆栈溢出等问题。</li><li>ASan能够在编译时插额外的运行时检查代码，对进行动态分析，提供详细的信息和错误的位置。</li><li>ASan要用于发现和调试内存相关的问题，可以帮助开发者早发现和修内存错误。</li></ul></li><li>LeakSanitizer（LS）:<ul><li>LSan是一种用于检测内存泄漏的工具，主要用于检测程序中的动态内存分配和没有释放的内存。</li><li>LSan通过追踪内存分配和释放操作，检测出未释放的内存并报告泄漏的位置和类型。</li><li>LSan主要用于发现内存泄漏问题，帮助开发者查找未释放的内存资源，优化内存使用效率。</li></ul></li></ol><p>ASan主要用于检测内存错误，如越界访问和释放后，而LSan主用于检测内存泄漏问题。它们都能够在编译时插入额外的运行时检查代码，帮助开发者发现修复内存相关问题。</p><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/thammer/p/17117286.html">Sanitizers使用介绍</a></li><li><a href="https://blog.csdn.net/zjtimef/article/details/138415276">LeakSanitizer概述与使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/508470880">[C++]🤓Mac下C++内存检查指北(Valgrind VS Asan)</a></li><li><a href="https://zhuanlan.zhihu.com/p/37515148">内存检测工具AddressSanitizer</a></li><li><a href="https://zhuanlan.zhihu.com/p/28117513">AddressSanitizer算法及源码分析</a></li></ul>]]></content>
    
    
    <summary type="html">内存检测-Sanitizer</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Valgrind</title>
    <link href="https://penge666.github.io/posts/41691f83.html"/>
    <id>https://penge666.github.io/posts/41691f83.html</id>
    <published>2024-05-14T02:30:16.000Z</published>
    <updated>2024-05-15T01:40:43.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Valgrind的介绍">Valgrind的介绍</h2><blockquote><p><strong>介绍</strong></p></blockquote><p>Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。Valgrind的体系结构如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240514111938295.png" alt="image-20240514111938295"></p><p>通俗的说：</p><p>Valgrind是一个由多个组件构成的内存调试工具套件。这些组件可以分为两类：内核和基于内核的其他工具。</p><ol><li><strong>内核</strong>：内核在这里可以被理解为Valgrind的核心部分，它提供了一个虚拟的CPU环境，并且提供一些基本的服务，比如内存管理、错误检测等。你可以把它想象成一个工厂的骨架或者框架，提供了基础设施和一些常用的功能。</li><li><strong>其他工具</strong>：这些工具则类似于插件，它们利用内核提供的服务，完成各种特定的内存调试任务。比如Memcheck就是其中一个工具，它可以检测内存泄漏、数组越界等问题。你可以把这些工具想象成工厂的流水线，每个流水线都负责完成特定的任务。</li></ol><p><strong>Valgrind检测一个可执行程序是否存在内存泄漏的工作原理</strong></p><p>它的工作原理主要是通过插桩技术，也就是在程序运行时动态地插入一些检查代码来监视内存的使用情况。</p><p>当我们使用Valgrind运行一个程序时，Valgrind会首先加载自己的内核，然后把我们的程序加载到自己的虚拟内存空间中。在这个虚拟内存空间中，Valgrind可以完全控制程序的执行流程，并且可以检测到所有的内存访问。</p><p>Valgrind使用一种称为影子内存的技术来跟踪每个字节的内存状态，包括该字节是否已被分配、是否已被释放、是否已被初始化等。每当程序进行一次内存操作（如malloc、free、read、write等）时，Valgrind都会更新影子内存的状态，并检查这次操作是否合法。</p><p>如果Valgrind检测到一次非法的内存操作，比如访问了未被初始化的内存，或者访问了已经被释放的内存，它就会立即报告一个错误。当程序退出时，Valgrind会检查是否所有的内存都已经被正确释放，如果有任何内存泄漏，它也会报告一个错误。</p><blockquote><p><strong>valgrind工具</strong></p></blockquote><p>（1）Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</p><p>（2）Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</p><p>（3）Cachegrind。它主要用来检查程序中缓存使用出现的问题。</p><p>（4）Helgrind。它主要用来检查多线程程序中出现的竞争问题。</p><p>（5）Massif。它主要用来检查程序中堆栈使用中出现的问题。</p><p>（6）Extension。可以利用core提供的功能，自己编写特定的内存调试工具。</p><blockquote><p><strong>Memcheck检查的原理</strong></p></blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/510362477">Valgrind笔记（二）：MemCheck基本原理</a></li></ul><p>Memcheck检测内存问题的原理如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240514112408569.png" alt="image-20240514112408569"></p><p>Memcheck是Valgrind的一个组件，它用于检测C和C++程序中的内存管理问题。它通过在程序运行期间拦截所有内存访问和管理请求，来检测内存泄漏、使用未初始化的内存、访问已经释放的内存等问题。</p><p>Memcheck的工作原理主要依赖于两个全局表：</p><ol><li><strong>A-bit（Addressability bit）表</strong>：A-bit表用于标记哪些内存是可访问的。对于每个字节的内存，A-bit表都有一个对应的位。如果该位被设置，那么对应的内存字节就是可访问的。否则，该字节是不可访问的。当程序试图读写一个不可访问的内存字节时，Memcheck会报告一个错误。</li><li><strong>V-bit（Validity bit）表</strong>：V-bit表用于标记哪些内存是已初始化的。对于每个字节的内存，V-bit表都有一个对应的位。如果该位被设置，那么对应的内存字节就是已经被初始化的。否则，该字节是未初始化的。当程序试图读取一个未初始化的内存字节时，Memcheck会报告一个错误。</li></ol><h2 id="内存泄漏示例">内存泄漏示例</h2><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ sudo apt-get install valgrind</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2</span><br><span class="line">$ bzip2 -d valgrind-3.13.0.tar.bz2</span><br><span class="line">$ tar -xf valgrind-3.13.0.tar</span><br><span class="line">$ <span class="built_in">cd</span> valgrind-3.13.0</span><br><span class="line">$ ./configure &amp;&amp; make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>这里主要演示memcheck的示例。其他更多工具的示例请看：<a href="https://blog.csdn.net/weixin_45518728/article/details/119865117">valgrind基本功能介绍、基础使用方法说明</a></p><h3 id="未即时释放">未即时释放</h3><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *array = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序时，需要加上<code>-g</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o main_c main.cpp</span><br></pre></td></tr></table></figure><p>使用 Valgrind 检测内存使用情况：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --tool=memcheck --leak-check=full  ./main_c</span><br><span class="line">==<span class="number">31416</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">31416</span>== Copyright (C) <span class="number">2002</span>-<span class="number">2017</span>, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==<span class="number">3141</span>6== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==<span class="number">3141</span>6== Command: ./main_c</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== HEAP SUMMARY:</span><br><span class="line">==<span class="number">3141</span>6==     in use at exit: 4 bytes in 1 blocks</span><br><span class="line">==<span class="number">3141</span>6==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==<span class="number">3141</span>6==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==<span class="number">3141</span>6==    by 0x<span class="number">400537</span>: main (main.c:5)</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== LEAK SUMMARY:</span><br><span class="line">==<span class="number">3141</span>6==    definitely lost: 4 bytes in 1 blocks</span><br><span class="line">==<span class="number">3141</span>6==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==<span class="number">3141</span>6== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>看看输出信息中的<code>HEAP SUMMARY</code>，它表示程序在堆上分配内存的情况，其中的<code>1 allocs</code>表示程序分配了 1 次内存，<code>0 frees</code>表示程序释放了 0 次内存，<code>4 bytes allocated</code>表示分配了 4 个字节的内存。<br>　另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是<code>main.c</code>文件的第 5 行。</p><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Valgrind 分析这段程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp</span><br><span class="line">==31438== Memcheck, a memory error detector</span><br><span class="line">==31438== Copyright (C) 2002-2017, and GNU GPL<span class="string">&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31438== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==31438==     in use at exit: 72,704 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1</span></span><br><span class="line"><span class="string">==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span></span><br><span class="line"><span class="string">==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)</span></span><br><span class="line"><span class="string">==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)</span></span><br><span class="line"><span class="string">==31438==    by 0x40105FA: call_init (dl-init.c:30)</span></span><br><span class="line"><span class="string">==31438==    by 0x40105FA: _dl_init (dl-init.c:120)</span></span><br><span class="line"><span class="string">==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== LEAK SUMMARY:</span></span><br><span class="line"><span class="string">==31438==    definitely lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==    indirectly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==      possibly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==    still reachable: 72,704 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31438==         suppressed: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== For counts of detected and suppressed errors, rerun with: -v</span></span><br><span class="line"><span class="string">==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span></span><br></pre></td></tr></table></figure><p>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从<code>HEAP SUMMARY</code>可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？</p><p>解释：</p><p>你的这段代码中，<code>new std::string(&quot;Hello, World!&quot;)</code> 这行代码实际上进行了两次内存分配：</p><ol><li>第一次分配是创建 <code>std::string</code> 对象本身，这会在堆上分配一块内存用来存储 <code>std::string</code> 对象的元数据，如长度、容量等。</li><li>第二次分配是在 <code>std::string</code> 对象初始化时，对字符串 “Hello, World!” 进行分配，存储实际的字符串内容。</li></ol><p>因此，你的程序实际上进行了两次内存分配。</p><p>然后在 <code>delete ptr;</code> 这行代码执行时，会调用 <code>std::string</code> 的析构函数，自动释放用于存储字符串内容的内存，然后再释放 <code>std::string</code> 对象本身的内存。所以虽然你只写了一次 <code>delete</code>，但实际上进行了两次内存释放。</p><p>然而，Valgrind 报告的 “frees” 数量可能只计算了你直接调用的 <code>delete</code> 操作，而没有计算 <code>std::string</code> 析构函数中自动进行的内存释放，因此它显示 “1 frees”。这也是为什么你的代码显示 “2 allocs, 1 frees”。</p><h3 id="检测越界访问">检测越界访问</h3><p>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">10</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">11</span> -g -o main_cpp main.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./main_cpp</span><br><span class="line">==<span class="number">31523</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">31523</span>== <span class="built_in">Copyright</span> (C) <span class="number">2002</span><span class="number">-2017</span>, <span class="keyword">and</span> GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31523== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31523==</span></span><br><span class="line"><span class="string">==31523== Invalid read of size 4</span></span><br><span class="line"><span class="string">==31523==    at 0x400AD7: main (main.cpp:7)</span></span><br><span class="line"><span class="string">==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc&#x27;</span>d</span><br><span class="line">==<span class="number">31523</span>==    at <span class="number">0x4C2E216</span>: <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="type">unsigned</span> <span class="type">long</span>) (vg_replace_malloc.c:<span class="number">334</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x4010D3</span>: __gnu_cxx::new_allocator&lt;<span class="type">int</span>&gt;::<span class="built_in">allocate</span>(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">void</span> <span class="type">const</span>*) (new_allocator.h:<span class="number">104</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x401040</span>: std::allocator_traits&lt;std::allocator&lt;<span class="type">int</span>&gt; &gt;::<span class="built_in">allocate</span>(std::allocator&lt;<span class="type">int</span>&gt;&amp;, <span class="type">unsigned</span> <span class="type">long</span>) (alloc_traits.h:<span class="number">491</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400F91</span>: std::_Vector_base&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::_M_allocate(<span class="type">unsigned</span> <span class="type">long</span>) (stl_vector.h:<span class="number">170</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400E7E</span>: std::_Vector_base&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::_M_create_storage(<span class="type">unsigned</span> <span class="type">long</span>) (stl_vector.h:<span class="number">185</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400D1E</span>: std::_Vector_base&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::_Vector_base(<span class="type">unsigned</span> <span class="type">long</span>, std::allocator&lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp;) (stl_vector.h:<span class="number">136</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400C11</span>: std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::<span class="built_in">vector</span>(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">int</span> <span class="type">const</span>&amp;, std::allocator&lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp;) (stl_vector.h:<span class="number">291</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400AB9</span>: <span class="built_in">main</span> (main.cpp:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><code>Invalid read of size 4</code>表示越界读取 4 个字节，这个操作出现在<code>main.cpp</code>文件的第 7 行。另外可以看到，<code>vector</code>分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><h3 id="检测未初始化的内存">检测未初始化的内存</h3><p>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;X is zero&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Valgrind 检测这个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">11</span> -g -o main_cpp main.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./main_cpp</span><br><span class="line">==<span class="number">31554</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">31554</span>== <span class="built_in">Copyright</span> (C) <span class="number">2002</span><span class="number">-2017</span>, <span class="keyword">and</span> GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31554== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31554==</span></span><br><span class="line"><span class="string">==31554== Conditional jump or move depends on uninitialised value(s)</span></span><br><span class="line"><span class="string">==31554==    at 0x400852: main (main.cpp:6)</span></span><br></pre></td></tr></table></figure><p>输出中提示了<code>main.cpp</code>文件的第 6 行访问了未初始化的内存。</p><p>即学即用一波【<a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="comment">// 3[a2[c]]</span></span><br><span class="line"><span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">deque&lt;string&gt; str;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">string ans=<span class="string">&quot;&quot;</span>,cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">num=num*<span class="number">10</span>+(<span class="type">int</span>)(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">q.<span class="built_in">push_back</span>(num);</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cur.<span class="built_in">size</span>()&gt;<span class="number">0</span>) str.<span class="built_in">push_back</span>(cur);</span><br><span class="line">cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur.<span class="built_in">size</span>())</span><br><span class="line">str.<span class="built_in">push_back</span>(cur); </span><br><span class="line">string str_tmp=str.<span class="built_in">back</span>();str.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="type">int</span> num_tmp=q.<span class="built_in">back</span>();q.<span class="built_in">pop_back</span>();</span><br><span class="line">string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num_tmp;j++)&#123;</span><br><span class="line">res=res+str_tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">string tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">tmp=str.<span class="built_in">back</span>();</span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br><span class="line">str.<span class="built_in">push_back</span>(tmp+res);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ans=ans+res;</span><br><span class="line">&#125;</span><br><span class="line">cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">cur=cur+s[i];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ans=ans+s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;3[z]2[2[y]pq4[2[jk]e1[f]]]ef&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用内存检测工具检测</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ vim main.<span class="built_in">cpp</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -o main_c main.<span class="built_in">cpp</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ valgrind --tool=memcheck --leak-check=full  ./main_c</span><br><span class="line">==<span class="number">1335995</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">1335995</span>== <span class="built_in">Copyright</span> (C) <span class="number">2002</span><span class="number">-2017</span>, <span class="keyword">and</span> GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==1335995== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==1335995== Command: ./main_c</span></span><br><span class="line"><span class="string">==1335995==</span></span><br><span class="line"><span class="string">3[z]2[2[y]pq4[2[jk]e1[f]]]ef</span></span><br><span class="line"><span class="string">==1335995== Use of uninitialised value of size 8</span></span><br><span class="line"><span class="string">==1335995==    at 0x49ACC38: std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28)</span></span><br><span class="line"><span class="string">==1335995==    by 0x10A87C: main (main.cpp:32)</span></span><br><span class="line"><span class="string">==1335995==</span></span><br><span class="line"><span class="string">==1335995== Invalid read of size 8</span></span><br><span class="line"><span class="string">==1335995==    at 0x49ACC38: std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28)</span></span><br><span class="line"><span class="string">==1335995==    by 0x10A87C: main (main.cpp:32)</span></span><br><span class="line"><span class="string">==1335995==  Address 0x1e8 is not stack&#x27;</span>d, malloc<span class="number">&#x27;</span>d <span class="built_in">or</span> (recently) free<span class="number">&#x27;</span>d</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== Process terminating with <span class="keyword">default</span> action of signal <span class="number">11</span> (SIGSEGV): dumping core</span><br><span class="line">==<span class="number">1335995</span>==  Access <span class="keyword">not</span> within mapped region at address <span class="number">0x1E8</span></span><br><span class="line">==<span class="number">1335995</span>==    at <span class="number">0x49ACC38</span>: std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt;::<span class="built_in">basic_string</span>(std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt; <span class="type">const</span>&amp;) (in /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.28</span>)</span><br><span class="line">==<span class="number">1335995</span>==    by <span class="number">0x10A87C</span>: <span class="built_in">main</span> (main.cpp:<span class="number">32</span>)</span><br><span class="line">==<span class="number">1335995</span>==  If you believe <span class="keyword">this</span> happened as a result of a stack</span><br><span class="line">==<span class="number">1335995</span>==  overflow in your program<span class="number">&#x27;</span>s main <span class="built_in">thread</span> (unlikely but</span><br><span class="line">==<span class="number">1335995</span>==  possible), you can <span class="keyword">try</span> to increase the size of the</span><br><span class="line">==<span class="number">1335995</span>==  main thread stack <span class="keyword">using</span> the --main-stacksize= flag.</span><br><span class="line">==<span class="number">1335995</span>==  The main thread stack size used in <span class="keyword">this</span> run was <span class="number">8388608.</span></span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== HEAP SUMMARY:</span><br><span class="line">==<span class="number">1335995</span>==     in use at exit: <span class="number">1</span>,<span class="number">183</span> bytes in <span class="number">5</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==   total heap usage: <span class="number">7</span> allocs, <span class="number">2</span> frees, <span class="number">74</span>,<span class="number">911</span> bytes allocated</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== LEAK SUMMARY:</span><br><span class="line">==<span class="number">1335995</span>==    definitely lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==    indirectly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==      possibly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==    still reachable: <span class="number">1</span>,<span class="number">183</span> bytes in <span class="number">5</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==         suppressed: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>== Reachable <span class="built_in">blocks</span> (those to which a pointer was found) are <span class="keyword">not</span> shown.</span><br><span class="line">==<span class="number">1335995</span>== To see them, rerun with: --leak-check=full --show-leak-kinds=all</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== Use --track-origins=yes to see where uninitialised values come from</span><br><span class="line">==<span class="number">1335995</span>== For lists of detected <span class="keyword">and</span> suppressed errors, rerun with: -s</span><br><span class="line">==<span class="number">1335995</span>== ERROR SUMMARY: <span class="number">2</span> errors from <span class="number">2</span> <span class="built_in">contexts</span> (suppressed: <span class="number">0</span> from <span class="number">0</span>)</span><br><span class="line">段错误</span><br></pre></td></tr></table></figure><p>一下就知道，问题在这</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>str.back()<span class="comment">;</span></span><br><span class="line">str.pop_back()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://www.it.uc3m.es/pbasanta/asng/course_notes/memory_profiler_en.html#memcheck_tool">Chapter 17. The memory profiler Valgrind</a></li><li><a href="https://senlinzhan.github.io/2017/12/31/valgrind/">使用 Valgrind 检测 C++ 内存泄漏</a></li><li><a href="https://zhuanlan.zhihu.com/p/643271982">【C/C++ 集成内存调试、内存泄漏检测和性能分析的工具 Valgrind 】Linux 下 Valgrind 工具的全面使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/56538645">内存检测王者之剑—valgrind</a></li></ul>]]></content>
    
    
    <summary type="html">内存检测-Valgrind</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp面经</title>
    <link href="https://penge666.github.io/posts/680a3d55.html"/>
    <id>https://penge666.github.io/posts/680a3d55.html</id>
    <published>2024-05-13T12:35:09.000Z</published>
    <updated>2024-05-14T02:18:32.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-98"><a href="#C-98" class="headerlink" title="C++98"></a>C++98</h2><h3 id="1-在main执行的前后需要处理什么工作？"><a href="#1-在main执行的前后需要处理什么工作？" class="headerlink" title="1. 在main执行的前后需要处理什么工作？"></a>1. 在main执行的前后需要处理什么工作？</h3><p><strong>Main函数之前</strong></p><p>(1) 设置栈指针</p><p>(2) 全局对象初始化，在main之前调用构造函数</p><p>(3) 将main函数的参数argc，argv等传递给main函数</p><p><strong>Main函数之后</strong></p><p>全局对象的析构函数</p><h3 id="2-什么是内存对齐？"><a href="#2-什么是内存对齐？" class="headerlink" title="2.什么是内存对齐？"></a>2.什么是内存对齐？</h3><p>学习自：<a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解</a></p><p>还是得看例子：【从例子解释概念】</p><p>还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(s);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。</p><p>精简：</p><p>(1) 在计算机中，内存是按字节划分的，而CPU在读取数据时，并不是一个字节一个字节的读取，实际上是<strong>按块的大小读取</strong>，块大小可以是2，4，8，16等等，称为内存访问粒度。</p><p>(2) 内存对齐则是将特定的数据类型按照一定的规则摆放在内存上，具体规则是按照变量的声明顺序，依次安排内存，其偏移量为变量大小的整数倍。</p><h3 id="3-为什么要做内存对齐？"><a href="#3-为什么要做内存对齐？" class="headerlink" title="3. 为什么要做内存对齐？"></a>3. 为什么要做内存对齐？</h3><p>这个的话展开说就是：</p><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204345153.png" alt="image-20240513204345153"></p><p>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204405396.png" alt="image-20240513204405396"></p><p>精简：</p><p>(1) <strong>平台原因(移植原因)：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p><p>(2) <strong>性能原因：</strong>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p><h3 id="4-说说内存对齐规则？"><a href="#4-说说内存对齐规则？" class="headerlink" title="4. 说说内存对齐规则？"></a>4. 说说内存对齐规则？</h3><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(3) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p>下面给出几个例子以便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2; </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上测试都是在Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节，下面根据上面所说的规则以s2来分析其内存布局：</p><p>首先使用规则1，对成员变量进行对齐：</p><p>sizeof(c1) = 1 &lt;= 4(有效对齐位)，按照1字节对齐，占用第0单元；</p><p>sizeof(i) = 4 &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为4的倍数，占用第4，5，6，7单元；</p><p>sizeof(c2) = 1 &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元；</p><p>然后使用规则2，对结构体整体进行对齐：</p><p>s2中变量i占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到s2占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。</p><p>根据上面的分析，不难得出上面例子三个结构体的内存布局如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204725927.png" alt="image-20240513204725927"></p><p><strong>#pragma pack(n)</strong></p><p>不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数。</p><p>例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204744215.png" alt="image-20240513204744215"></p><p>如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204752271.png" alt="image-20240513204752271"></p><p>经过上面的实例分析，大家应该对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。</p><p>精简：</p><p>(1) 每个特定平台上的编译器都有自己的默认<strong>“对齐系数”（也叫对齐模数）</strong>。32位系统，gcc中默认#pragma pack(4)，即对齐系数默认为4。可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>(2) 有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中<strong>较小</strong>的那个。<strong>有效对齐值也叫对齐单位</strong>。</p><p>(3) 结构体第一个成员的偏移量为0，以后每个成员相对于结构体首地址的偏移量都是该成员大小与有效对齐值中<strong>较小</strong>数的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(4) 结构体的总大小为<strong>有效对齐值的整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><h3 id="5-指针和引用的区别？"><a href="#5-指针和引用的区别？" class="headerlink" title="5. 指针和引用的区别？"></a>5. 指针和引用的区别？</h3><p>(1) 指针是一个变量，存储的是一个地址。引用跟原来的变量实质上是同一个东西，是原变量的别名</p><p>(2) 指针可以有多级，引用只有一级</p><p>(3) 指针可以为空，引用不能为NULL且在定义时必须初始化</p><p>(4) 指针在初始化后可以改变指向，而引用在初始化之后不可再改变</p><p>(5) sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</p><ul><li><a href="https://zhuanlan.zhihu.com/p/140966943">C++中指针与引用的区别</a></li></ul><h3 id="6-堆和栈的区别？"><a href="#6-堆和栈的区别？" class="headerlink" title="6. 堆和栈的区别？"></a>6. 堆和栈的区别？</h3><p>(1) 栈由系统自动分配，堆是自己申请和释放的。</p><p>(2) 堆向上，向高地址方向增长。栈向下，向低地址方向增长。</p><p>(3) 在空间连续性上，栈区的空间是连续的；但堆的空间是不连续的。</p><p>(4) 堆只能动态分配。栈有静态分配和动态分配，静态分配由编译器完成，动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</p><p>(5) 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p><p>(6) 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p><h3 id="7-new-delete-与-malloc-free的异同？"><a href="#7-new-delete-与-malloc-free的异同？" class="headerlink" title="7. new / delete 与 malloc / free的异同？"></a>7. new / delete 与 malloc / free的异同？</h3><p>(1) 都可用于内存的动态申请和释放</p><p>(2) 前者是C++运算符，后者是C/C++语言标准库函数</p><p>(3) new自动计算要分配的空间大小，malloc需要手工计算</p><p>(4) new是类型安全的，malloc不是。</p><p>(5) new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始类型的内存，接下来在该内存上调用构造函数初始化对象；最后返回该内存指针。</p><p>(6) delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存</p><p>(7) malloc/free可重载，new/delete不可重载，operator new/operator delete可重载</p><h3 id="8-被free回收的内存是立即返还给操作系统吗？"><a href="#8-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="8. 被free回收的内存是立即返还给操作系统吗？"></a>8. 被free回收的内存是立即返还给操作系统吗？</h3><p>不会，new或者malloc申请内存是向内存管理器申请，内存管理器再向操作系统申请，这里面涉及到系统调用，如果频繁的申请释放，效率会很低，所以一般进程申请了内存后，释放资源后并不会立即将内存还给操作系统，而是放到一个类似于内存缓存池的地方，下次申请的时候首先会在内存缓存池中查找合适的内存，减少了大量的系统调用，提高速度。</p><h3 id="9-宏函数和普通函数有何区别？"><a href="#9-宏函数和普通函数有何区别？" class="headerlink" title="9. 宏函数和普通函数有何区别？"></a>9. 宏函数和普通函数有何区别？</h3><p>(1) 宏函数作用在预编译期，进行文本替换，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；普通函数调用在运行时需要跳转到具体调用函数。</p><p>(2) 宏函数属于在结构中插入代码，没有返回值；普通函数调用具有返回值。</p><p>(3) 宏函数参数没有类型，不进行类型检查；普通函数参数具有类型，需要检查类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义，没有类型检查</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，有类型检查</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.5</span>;</span><br><span class="line">    <span class="comment">// 使用宏，虽然y的类型不是整数，但仍然可以计算</span></span><br><span class="line">    <span class="type">double</span> r1 = <span class="built_in">SQUARE</span>(y);  <span class="comment">// 结果是2.25</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数，如果尝试将y作为参数，编译器会报错，因为y的类型与函数期望的类型不匹配</span></span><br><span class="line">    <span class="type">int</span> r2 = <span class="built_in">square</span>(y);  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>SQUARE(x)</code>是一个宏，它接受任何类型的参数<code>x</code>，并返回<code>x</code>的平方。因为宏没有类型检查，所以你可以传递任何类型的参数给宏，编译器不会报错。</p><p>但是，<code>square(x)</code>是一个函数，它期望一个整数类型的参数<code>x</code>。如果你尝试将一个非整数类型的值（如<code>double</code>类型的值）传递给这个函数，编译器会报错，因为函数参数的类型检查失败。</p><h3 id="10-宏定义和typedef有何区别？"><a href="#10-宏定义和typedef有何区别？" class="headerlink" title="10. 宏定义和typedef有何区别？"></a>10. 宏定义和typedef有何区别？</h3><p>(1) 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p><p>(2) 宏替换发生在预编译期，属于文本插入替换；typedef是编译的一部分。</p><p>(3) 宏不检查类型；typedef会检查数据类型。</p><h3 id="11-宏定义和const的区别？"><a href="#11-宏定义和const的区别？" class="headerlink" title="11. 宏定义和const的区别？"></a>11. 宏定义和const的区别？</h3><p>(1) 宏定义发生在预编译期。const是在编译、运行的时候起作用</p><p>(2) 宏定义只做替换，不做类型检查和计算。const常量有数据类型，编译器做类型检查。</p><p>(3) define只是将宏名称进行文本替换，占用代码段内存。const在程序运行中只有一份备份，占用数据段内存。</p><h3 id="12-内联函数和宏函数的区别？"><a href="#12-内联函数和宏函数的区别？" class="headerlink" title="12. 内联函数和宏函数的区别？"></a>12. 内联函数和宏函数的区别？</h3><p>(1) 宏函数在预处理阶段进行文本替换，inline函数在编译阶段进行替换</p><p>(2) inline函数有类型检查，相比宏函数比较安全</p><p>(3) Inline函数具有返回值，宏函数没有</p><h3 id="13-变量声明和定义的区别？"><a href="#13-变量声明和定义的区别？" class="headerlink" title="13. 变量声明和定义的区别？"></a>13. 变量声明和定义的区别？</h3><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间。只有在定义处才为其分配存储空间。<strong>相同变量可以在多处声明，但只能在一处定义</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>isOK!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-strlen和sizeof的区别？"><a href="#14-strlen和sizeof的区别？" class="headerlink" title="14. strlen和sizeof的区别？"></a>14. strlen和sizeof的区别？</h3><p>(1) sizeof是C/C++操作符，并不是函数，结果在编译时得到。strlen是字符处理的库函数。</p><p>(2) sizeof参数可以是任何数据的类型或者数据。strlen的参数只能是字符指针，它指向了一个结尾是’\0’的字符串。</p><h3 id="15-常量指针和指针常量的区别？"><a href="#15-常量指针和指针常量的区别？" class="headerlink" title="15. 常量指针和指针常量的区别？"></a>15. 常量指针和指针常量的区别？</h3><p>(1) 指针常量（底层const）是一个指针，它指向了一个只读值。它实际上只是限制了指针的拥有者不能通过指针修改它所指向的值，对这个值的属性没有限制，这个值是可以是常量也可以变量，均不影响。</p><p>(2) 常量指针（顶层const）是一个不能给改变指向的指针，即我们可以通过指针修改它所指向的值，但不能修改指针的指向。</p><p>详细说明：</p><p><strong>指针常量</strong></p><p>指针常量：顾名思义它就是一个常量，但是是指针修饰的。</p><p>格式为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> p <span class="comment">//指针常量</span></span><br><span class="line">在这个例子下定义以下代码：</span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a，b；</span><br><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</span></span><br></pre></td></tr></table></figure><p><strong>常量指针</strong></p><p>常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> *p = &amp;a; <span class="comment">//常量指针</span></span><br><span class="line">在这个例子下定义以下代码：</span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a，b；</span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><h3 id="16-指针常量能不能赋值给非指针常量？"><a href="#16-指针常量能不能赋值给非指针常量？" class="headerlink" title="16. 指针常量能不能赋值给非指针常量？"></a>16. 指针常量能不能赋值给非指针常量？</h3><p>不能，指针常量限制了指针的拥有者不能通过指针修改它所指向的值，如果指针常量可以赋值给非指针常量，那就意味着拥有者可以使用这种方法获取写权限，这在语义上是冲突的。</p><h3 id="17-C-和Python的区别？"><a href="#17-C-和Python的区别？" class="headerlink" title="17. C++和Python的区别？"></a>17. C++和Python的区别？</h3><p>(1) Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。</p><p>(2) python可以很方便的跨平台，但是效率没有C++高。</p><p>(3) C++中需要事先定义变量的类型，而Python不需要</p><p>(4) Python的库函数比C++的多，调用起来很方便</p><h3 id="18-C-中struct和class的区别？"><a href="#18-C-中struct和class的区别？" class="headerlink" title="18. C++中struct和class的区别？"></a>18. C++中struct和class的区别？</h3><p>(1) 两者都拥有成员函数、公有和私有部分</p><p>(2) 任何可以使用class完成的工作，同样可以使用struct完成</p><p>(3) 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p><p>(4) class默认是private继承，而struct模式是public继承</p><h3 id="19-C-和C的struct的区别？"><a href="#19-C-和C的struct的区别？" class="headerlink" title="19. C++和C的struct的区别？"></a>19. C++和C的struct的区别？</h3><p>C语言：struct是用户自定义数据类型（UDT），不能设置权限，成员不可以是函数，不能被继承。</p><p>C++：struct是抽象数据类型（ADT）支持成员函数的定义，能设置权限，能被继承与实现多态。</p><h3 id="20-C-中const和static的作用？"><a href="#20-C-中const和static的作用？" class="headerlink" title="20. C++中const和static的作用？"></a>20. C++中const和static的作用？</h3><p><strong>(1) Static（类外）：</strong></p><p>①　隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他模块中使用，加了之后只能在该文件所在的编译模块中使用</p><p>②　静态变量没有定义初始值时，会初始化为0。</p><p>③　静态变量在函数内定义，生命周期跟随程序（同全局变量），且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</p><p><strong>(2) Static（类内）：</strong></p><p>①　static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化， 必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</p><p>②　static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问</p><p><strong>(3) Const（类外）：</strong></p><p>①　const常量在定义时必须初始化，之后无法更改</p><p>②　const形参可以接收const和非const类型的实参</p><p><strong>(4) Const（类内）：</strong></p><p>①　const成员变量：只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</p><p>②　const成员函数：const类对象不可以调用类中的非const成员函数；非const类对象则均可调用；const成员函数不可以改变类中非mutable数据成员的值。</p><p>举例说明</p><p>在C++中，<code>const</code>和<code>static</code>都是修饰符，它们可以用来修改变量、函数或对象的行为。</p><ul><li><code>const</code>: <code>const</code>关键字可以用来修饰变量，表示这个变量的值是常量，不能被修改。在类中，如果一个成员函数被声明为<code>const</code>，那么这个函数不能修改类的任何成员变量（除非这个变量是<code>mutable</code>的）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x = a;  // Error, can&#x27;t modify x in a const function</span></span><br><span class="line">        y = a;  <span class="comment">// OK, y is mutable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>static</code>: <code>static</code>关键字在类中有两种用法。一种是修饰成员变量，这样这个变量就变成了一个静态成员变量，它不属于类的任何对象，而是属于类本身，所有的对象都共享这一个变量。另一种是修饰成员函数，这样这个函数就变成了一个静态成员函数，它可以在不创建对象的情况下被调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::x = <span class="number">0</span>;  <span class="comment">// Define static member variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">setX</span>(<span class="number">10</span>);  <span class="comment">// Call static member function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类外部来看，<code>const</code>和<code>static</code>修饰的成员变量或函数可以通过类名直接访问（对于<code>static</code>），或者通过对象访问但不能修改（对于<code>const</code>）。</p><h3 id="21-数组名和指针（这里为指向数组首元素的指针）的区别？"><a href="#21-数组名和指针（这里为指向数组首元素的指针）的区别？" class="headerlink" title="21.数组名和指针（这里为指向数组首元素的指针）的区别？"></a>21.数组名和指针（这里为指向数组首元素的指针）的区别？</h3><p>(1) 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</p><p>(2) 二者均可通过增减偏移量来访问数组中的元素。</p><p>(3) 数组名不是真正意义上的指针，实际上是一个常量指针，所以不能进行自增自减操作。</p><p>(4) 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作， 但sizeof运算符不能再得到原数组的大小了。</p><h3 id="22-C代码使用C语言编译和C-编译有什么不同？"><a href="#22-C代码使用C语言编译和C-编译有什么不同？" class="headerlink" title="22. C代码使用C语言编译和C++编译有什么不同？"></a>22. C代码使用C语言编译和C++编译有什么不同？</h3><p>(1) C++虽然语法上支持和兼容C语言，但为了支持多种特性，在编译上却做了很多C语言所没有的其他处理。</p><p>(2) 比如说现在有一个C语言函数库，而我们用C++去调用该函数库，在编译链接时链接器会报错。因为<strong>C++为了支持函数重载，会在编译时给每个函数进行“改名”</strong>，但是C语言在编译时则不会改名，C函数库中的函数名都保持原样，这就会使链接器在函数库中找不到改名后的对应函数地址，然后报错。<strong>extern “C”可以很好地解决这个问题</strong>。</p><p>(3) 因为C++的函数改名规则，<strong>C++代码在使用其他模块的函数前必须包含其头文件或显式声明函数</strong>，不然它无法识别该函数是C函数还是C++函数，是否需要进行改名。<strong>C语言编译器即使不提前声明函数也可以调用函数，因为C编译器没有改名规则</strong>。</p><h3 id="23-extern”C”的用法？"><a href="#23-extern”C”的用法？" class="headerlink" title="23. extern”C”的用法？"></a>23. extern”C”的用法？</h3><p>在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++，在以下情况时会用到该语法：</p><p>(1) <strong>C++代码中调用C语言函数库</strong>；</p><p>(2) <strong>在多个人协同开发时，可能有人擅长C语言，而有人擅长C++</strong></p><h3 id="24-说说野指针和悬空指针？"><a href="#24-说说野指针和悬空指针？" class="headerlink" title="24. 说说野指针和悬空指针？"></a>24. 说说野指针和悬空指针？</h3><p>(1) <strong>野指针：</strong>指的是没有被初始化过的指针。解决方法：定义指针变量要及时初始化或者置空。（保持良好的编码规范）</p><p>(2) <strong>悬空指针：</strong>指针最初指向的内存已经被释放了的一种指针。解决方法：释放操作后立即置空，或者使用智能指针</p><p>野指针和空悬指针的区别是野指针是指向未知地址的指针，而空悬指针是指向已经被释放的地址的指针</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *p;</span><br><span class="line">// 此时 p 是“野指针”</span><br></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *p <span class="operator">=</span> malloc(size)<span class="comment">;</span></span><br><span class="line">assert(p)<span class="comment">;</span></span><br><span class="line">free(p)<span class="comment">; </span></span><br><span class="line">// 现在 p 是“悬空指针”</span><br><span class="line">// 避免“悬空指针”</span><br><span class="line"><span class="attribute">p</span> <span class="operator">=</span> NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="25-C-中的重载、重写（覆盖）和隐藏的区别？"><a href="#25-C-中的重载、重写（覆盖）和隐藏的区别？" class="headerlink" title="25. C++中的重载、重写（覆盖）和隐藏的区别？"></a>25. C++中的重载、重写（覆盖）和隐藏的区别？</h3><p>(1) 重载是指在<strong>同一范围定义中的同名函数</strong>才存在重载关系。主要特点是<strong>函数名相同，参数类型和数目有所不同</strong>，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</p><p>(2) 重写指的是在派生类中重写父类的函数体，<strong>要求基类函数必须是虚函数</strong>，且重写的函数签名<strong>（返回值、函数名、参数列表）</strong>必须完全一致。</p><p>(3) 隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数。</p><p>(4) <strong>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</strong></p><p>(5) <strong>隐藏和重写的区别在于基类函数是否是虚函数</strong>。</p><h3 id="26-浅拷贝和深拷贝的区别？"><a href="#26-浅拷贝和深拷贝的区别？" class="headerlink" title="26. 浅拷贝和深拷贝的区别？"></a>26. 浅拷贝和深拷贝的区别？</h3><p>(1) 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。如果原来的指针所指向的资源释放了，那么使用新指针就会出现错误。</p><p>(2) 深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><h3 id="27-public，protected和private权限的区别？"><a href="#27-public，protected和private权限的区别？" class="headerlink" title="27. public，protected和private权限的区别？"></a>27. public，protected和private权限的区别？</h3><p><strong>(1) 访问权限：</strong></p><p>①　public的变量和函数在类的内部外部都可以访问。</p><p>②　protected的变量和函数只能在类的内部和其派生类中访问。</p><p>③　private修饰的元素只能在类内访问。</p><p><strong>(2) 继承权限：</strong></p><p>①　Public:基类的公有成员和保护成员作为派生类的成员时，都保持原有的访问权限，基类的私有成员任然是私有的</p><p>②　Protected：基类的公有成员和保护成员都成为派生类的保护成员，基类的私有成员仍然是私有的</p><p>③　private：基类的公有成员和保护成员都成为派生类的私有成员，基类的私有成员任然是私有的</p><p><strong>对于继承权限而言，它所针对的是类外的访问权限。对于类内来说，不管是何种继承，派生类均可访问基类的公用和保护成员，但不可访问基类的私有成员。</strong></p><h3 id="28-如何用代码判断大小端存储？"><a href="#28-如何用代码判断大小端存储？" class="headerlink" title="28. 如何用代码判断大小端存储？"></a>28. 如何用代码判断大小端存储？</h3><p>(1) <strong>大端存储：</strong>字数据的高字节存储在低地址中</p><p>(2) <strong>小端存储：</strong>字数据的高字节存储在高地址中</p><p>(3) <strong>方式一：使用强制类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0x1234</span>;</span><br><span class="line"><span class="type">char</span> c=(<span class="type">char</span>)(a);</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">0x12</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;big&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;small&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) <strong>方式二：使用union联合体</strong></p><ul><li><a href="https://blog.csdn.net/sxg226273531/article/details/135996096">如何使用联合体判断大小端，详细介绍其内存原理（附完整代码）</a></li></ul><h3 id="29-volatile、mutable和explicit关键字的用法？"><a href="#29-volatile、mutable和explicit关键字的用法？" class="headerlink" title="29. volatile、mutable和explicit关键字的用法？"></a>29. volatile、mutable和explicit关键字的用法？</h3><p>(1) volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示它可能被某些编译器未知的因素更改</strong>，所以系统总是重新从它所在的内存读取数据而不会去使用内存读取优化（使用寄存器），即使它前面的指令刚刚从该处读取过数据。</p><p>【防止编译的时候被优化！每次都得从内存中读取！】</p><p>(2) mutable关键字是一种类型修饰符，<strong>被mutable修饰的数据成员表示他可以被const成员函数所修改（const成员函数无法修改类中的普通数据成员）</strong>，它的修改不会影响整个类对象的状态。</p><p>(3) <strong>explicit关键字用来修饰类的构造函数，</strong>加上该关键字，表示该类不能发生相应的隐式类型转换（函数调用传参时的类型转换），只能以显式地进行类型转换（调用构造函数） 。</p><h3 id="30-C-中有几种类型的new？"><a href="#30-C-中有几种类型的new？" class="headerlink" title="30. C++中有几种类型的new？"></a>30. C++中有几种类型的new？</h3><p>【未看】</p><p>在C++中，new有三种典型的使用方法：<strong>plain new，nothrow new和placement new</strong></p><p>(1) <strong>plain new</strong>：最普通的new，它在分配内存失败时会抛出std::bad_alloc异常而不是返回NULL</p><p>(2) <strong>nothrow new</strong> ：不会抛出异常的new，分配内存失败时返回NULL</p><p>(3) <strong>placement new</strong>：不分配内存，只在一块分配好了的内存上调用类的构造函数</p><h3 id="31-形参与实参的区别？"><a href="#31-形参与实参的区别？" class="headerlink" title="31. 形参与实参的区别？"></a>31. 形参与实参的区别？</h3><p>(1) <strong>形参在定义时不分配内存，只有在被调用时才分配内存</strong></p><p>(2) 实参可以任意形式的表达式，但在进行函数调用时，它们都必须具有确定的值</p><p>(3) 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生<strong>“类型不匹配”</strong>的错误</p><p>(4) <strong>函数调用中发生的数据传送是单向的。</strong> 即只能把实参的值传送给形参。</p><h3 id="32-值传递、指针传递、引用传递的区别和效率？"><a href="#32-值传递、指针传递、引用传递的区别和效率？" class="headerlink" title="32. 值传递、指针传递、引用传递的区别和效率？"></a>32. 值传递、指针传递、引用传递的区别和效率？</h3><p>(1) 值传递：实参的值向形参进行值拷贝，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。</p><p>(2) 指针传递：同样有实参的值向形参进行值拷贝，但拷贝的数据是一个固定大小的地址。</p><p>(3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。</p><p>(4) <strong>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰</strong>。</p><h3 id="33-C-有哪几种的构造函数？"><a href="#33-C-有哪几种的构造函数？" class="headerlink" title="33. C++有哪几种的构造函数？"></a>33. C++有哪几种的构造函数？</h3><p>(1) 默认构造函数（无参数）</p><p>(2) 初始化构造函数（有参数）</p><p>(3) 拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-什么情况下会调用拷贝构造函数？"><a href="#34-什么情况下会调用拷贝构造函数？" class="headerlink" title="34. 什么情况下会调用拷贝构造函数？"></a>34. 什么情况下会调用拷贝构造函数？</h3><p>(1) 用类的一个实例对象去初始化构造一个类的新对象的时候</p><p>(2) 函数的参数是类的对象时（值传递）</p><p>(3) 函数的返回值是函数体内局部对象的类的对象时</p><h3 id="35-说说C-中的初始化？"><a href="#35-说说C-中的初始化？" class="headerlink" title="35. 说说C++中的初始化？"></a>35. 说说C++中的初始化？</h3><p>C++中变量的初始化有很多种方式，如：默认初始化，值初始化，直接初始化，拷贝初始化。下面一一介绍。</p><p>(1) <strong>默认初始化</strong></p><p>①　默认初始化是指定义变量时 没有指定初值时进行的初始化操作。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>②　对于内置类型变量（如int，double，bool等），<strong>如果是全局变量或静态变量，则初始化为0，如果是栈或者堆变量，则将拥有未定义的值</strong>。</p><p>③　对于类类型的变量（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发错误。因此，建议为每个类都定义一个默认构造函数（=default）。</p><p>④　注意：默认初始化的值并不是绝对的，在一些情况下会产生未知的错误，<strong>一般定义变量时最好都要为它设定初始值，这是一种良好的编程习惯。</strong></p><p>(2) <strong>值初始化</strong></p><p>①　值初始化是指使用了初始化器（即使用了圆括号或花括号）但却没有提供初始值的情况。</p><p>②　特别的，采用动态分配内存的方式（即采用new关键字）创建的变量，不加括号时，如int <em>p=new int，是默认初始化，加了括号，如int </em>p=new int()，为值初始化。</p><p>③　若不采用动态分配内存的方式（即不采用new运算符），写成int a();是错误的值初始化方式，因为这种方式是声明了一个函数而不是进行值初始化。如果一定要进行值初始化，必须结合拷贝初始化使用，即写成int a=int()。</p><p>④　值初始化和默认初始化一样，对于内置类型初始化为0，对于类类型则调用其默认构造函数，如果没有默认构造函数，则不能进行初始化。</p><p>(3) <strong>直接初始化</strong></p><p>①　直接初始化是指采用小括号的方式进行变量初始化（小括号里一定要有初始值，如果没提供初始值，那就是值初始化了！）</p><p>②　<strong>对于类类型来说，直接初始化会直接调用与实参匹配的构造函数。</strong></p><p>(4) <strong>拷贝初始化</strong></p><p>①　拷贝初始化是指采用等号（=）进行初始化的方式，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p><p>②　拷贝初始化首先使用指定构造函数创建一个临时对象，然后用<strong>拷贝构造函数</strong>将那个临时对象拷贝到正在创建的对象。</p><h3 id="36-直接初始化、拷贝初始化、赋值的差别？"><a href="#36-直接初始化、拷贝初始化、赋值的差别？" class="headerlink" title="36. 直接初始化、拷贝初始化、赋值的差别？"></a>36. 直接初始化、拷贝初始化、赋值的差别？</h3><p>(1) 这三种操作非常类似，语法上也很相像，<strong>区分这三者主要看他们的最终调用的函数</strong>。</p><p>(2) 直接初始化：<strong>要创建的对象不存在</strong>，主要利用<strong>初始化器（圆括号）</strong>使用其他的初始值进行初始化操作，一般这个初始值是别的对象或数据类型，<strong>直接初始化调用类的构造函数（调用参数类型最佳匹配的那个）</strong>。</p><p>(3) 拷贝初始化：<strong>要创建的对象不存在</strong>，使用已有的对象（与创建的对象类型一致）来进行初始化，这个已有的对象既可以是临时对象也可以是其他对象。<strong>既可以使用初始化器（圆括号），也可以使用赋值号（“=”）来进行初始化操作，但他们的背后都会调用类的拷贝构造函数</strong>。</p><p>(4) 赋值：<strong>要创建的对象已存在</strong>，用已存在的对象给它赋值，这属于重载“=”号运算符的范畴，他并不是一种初始化操作，<strong>背后调用类的重载“=”运算符函数</strong>。</p><p>(5) 对于内置类型变量（如int，double，bool等），直接初始化与拷贝初始化差别可以忽略不计。</p><h3 id="37-静态变量什么时候初始化？"><a href="#37-静态变量什么时候初始化？" class="headerlink" title="37. 静态变量什么时候初始化？"></a>37. 静态变量什么时候初始化？</h3><p>视编译器而定，有些可能在代码执行之前就初始化，有些则可能直到代码执行时才初始化。</p><h3 id="38-delete、delete-的区别？"><a href="#38-delete、delete-的区别？" class="headerlink" title="38. delete、delete []的区别？"></a>38. delete、delete []的区别？</h3><p>delete只会调用一次析构函数，delete [] 会根据数组元素的数量，对数组中的每个元素调用析构函数。</p><h3 id="39-malloc、calloc、realloc的区别？"><a href="#39-malloc、calloc、realloc的区别？" class="headerlink" title="39. malloc、calloc、realloc的区别？"></a>39. malloc、calloc、realloc的区别？</h3><p>(1) <strong>malloc函数</strong>：void* malloc(unsigned int num_size); 需要手动计算分配大小，申请的空间的值是随机初始化的</p><p>(2) <strong>calloc函数</strong>：void* calloc(size_t n,size_t size);无需手动计算分配大小，申请的空间的值是初始化为0的</p><p>(3) <strong>realloc函数</strong> ：给动态分配的空间分配额外的空间，用于扩充容量。</p><p>详细解释：</p><p><code>malloc</code>, <code>calloc</code> 和 <code>realloc</code> 都是 C 和 C++ 语言中用来动态分配内存的函数，但它们各有不同的用途和行为。</p><ul><li><code>malloc</code>: 这是最常用的动态内存分配函数。<code>malloc</code> 接受一个参数，即要分配的字节数，然后返回一个指向新分配内存的指针，或者在无法分配内存时返回 NULL。需要注意的是 <code>malloc</code> 不会清零新分配的内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存</span></span><br></pre></td></tr></table></figure><ul><li><code>calloc</code>: 这个函数与 <code>malloc</code> 类似，但它接受两个参数：要分配的元素数量和每个元素的大小。<code>calloc</code> 会返回一个指向新分配内存的指针，或者在无法分配内存时返回 NULL。与 <code>malloc</code> 不同，<code>calloc</code> 会清零新分配的内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存，并将内存清零</span></span><br></pre></td></tr></table></figure><ul><li><code>realloc</code>: 这个函数用于改变已分配的内存大小。<code>realloc</code> 接受两个参数：一个指向已分配内存的指针和新的内存大小（以字节为单位）。<code>realloc</code> 会返回一个指向新内存的指针，或者在无法分配内存时返回 NULL。如果新的内存大小大于原来的大小，<code>realloc</code> 会保留原来内存的内容，并可能将新的内存部分初始化为零。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存</span></span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 扩大内存以存储20个整数</span></span><br></pre></td></tr></table></figure><p>在使用这些函数时，一定要记住在不再需要内存时使用 <code>free</code> 函数释放它，以防止内存泄漏。</p><h3 id="40-说说类成员的初始化方式？"><a href="#40-说说类成员的初始化方式？" class="headerlink" title="40. 说说类成员的初始化方式？"></a>40. 说说类成员的初始化方式？</h3><p>(1) <strong>构造函数初始化：</strong>在构造函数体中初始化,在所有的数据成员被分配内存空间后，才进行赋值操作。背后会调用一次数据成员的构造函数和赋值函数。</p><p>(2) <strong>初始化列表：</strong>给数据成员分配内存空间时就进行初始化，相比起构造函数初始化，少了一次调用赋值函数的操作，因此效率会更高一些。</p><h3 id="41-构造函数的执行顺序？"><a href="#41-构造函数的执行顺序？" class="headerlink" title="41. 构造函数的执行顺序？"></a>41. 构造函数的执行顺序？</h3><p>(1) 基类的构造函数</p><p>(2) 派生类的数据成员的构造函数</p><p>(3) 派生类自己的构造函数</p><h3 id="42-析构函数的执行顺序？"><a href="#42-析构函数的执行顺序？" class="headerlink" title="42. 析构函数的执行顺序？"></a>42. 析构函数的执行顺序？</h3><p>(1) 调用派生类的析构函数；</p><p>(2) 调用派生类的数据成员的析构函数；</p><p>(3) 调用基类的析构函数。</p><h3 id="43-有哪些情况必须使用初始化列表？"><a href="#43-有哪些情况必须使用初始化列表？" class="headerlink" title="43. 有哪些情况必须使用初始化列表？"></a>43. 有哪些情况必须使用初始化列表？</h3><p>要不然进入到括号里面就对象就构造完成了。</p><p>(1) 当初始化一个引用成员时</p><p>(2) 当初始化一个常量成员时</p><p>(3) 当调用一个基类的构造函数，而它拥有一组参数时</p><p>(4) 当调用一个成员类的构造函数，而它拥有一组参数时</p><h3 id="44-初始化列表的初始化顺序？"><a href="#44-初始化列表的初始化顺序？" class="headerlink" title="44. 初始化列表的初始化顺序？"></a>44. 初始化列表的初始化顺序？</h3><p>这和对象内存有关。</p><p>初始化列表中出现的顺序并不是真正的初始化顺序，初始化顺序只取决于成员变量在类中的声明顺序。我们应尽可能保证成员变量的声明顺序与初始化列表顺序一致，才能真正保证其效率。</p><h3 id="45-C-中新增的string与C中的-char-有什么区别？"><a href="#45-C-中新增的string与C中的-char-有什么区别？" class="headerlink" title="45. C++中新增的string与C中的 char *有什么区别？"></a>45. C++中新增的string与C中的 char *有什么区别？</h3><p>(1) string对char*进行了封装，包含了字符串的属性以及对外提供了通用方法。</p><p>(2) string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p><h3 id="46-什么是内存泄露，如何检测与避免？"><a href="#46-什么是内存泄露，如何检测与避免？" class="headerlink" title="46. 什么是内存泄露，如何检测与避免？"></a>46. 什么是内存泄露，如何检测与避免？</h3><p>(1) 内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的内存块，使用完后必须显式释放的内存，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。</p><p>(2) 检测方法：有专门的内存泄漏检测工具，Linux下可以使用Valgrind工具 ，Windows下可以使用CRT库。</p><p>(3) 避免方法：使用智能指针，良好的编程习惯。</p><h3 id="47-什么是内存溢出和内存越界？"><a href="#47-什么是内存溢出和内存越界？" class="headerlink" title="47. 什么是内存溢出和内存越界？"></a>47. 什么是内存溢出和内存越界？</h3><p>(1) 内存溢出指的是程序在申请内存时，没有足够的内存空间供其使用。</p><p>(2) 内存越界指的是申请了一块内存，使用的时候超出了这块内存区域。</p><h3 id="48-介绍C-面向对象的三大特性？"><a href="#48-介绍C-面向对象的三大特性？" class="headerlink" title="48. 介绍C++面向对象的三大特性？"></a>48. 介绍C++面向对象的三大特性？</h3><p>(1) <strong>继承</strong></p><p>让某个类获得另一个类的属性和方法。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展，是代码复用的一种机制。</p><p>常见的继承有两种方式：</p><p><strong>实现继承：</strong>指使用基类的属性和方法而无需额外编码的能力</p><p><strong>接口继承：</strong>指仅使用属性和方法的名称、但是子类必须提供实现的能力</p><p>(2) <strong>封装</strong></p><p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。在C++中借以权限机制实现这一特性，利用三种访问权限控制外界对对象数据的访问。</p><p>(3) <strong>多态</strong></p><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>常见的多态有两种方式：</p><p><strong>编译时多态（重载）：</strong>是指允许存在多个同名函数，而这些函数的参数表不同</p><p><strong>运行时多态（重写）：</strong>是指子类重新定义父类的虚函数的做法</p><h3 id="49-说说C-的四种强制转换？"><a href="#49-说说C-的四种强制转换？" class="headerlink" title="49. 说说C++的四种强制转换？"></a>49. 说说C++的四种强制转换？</h3><p>(1) <strong>reinterpret_cast：</strong>reinterpret_cast 用以处理互不相关的类型之间的转换，reinterpret_cast 操作执行的是比特位拷贝，即编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去。这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。</p><p>(2) <strong>const_cast：</strong>该运算符用来修改类型的const属性，可以使指向常量的指针被转化成指向非常量的指针，并且仍然指向原来的对象，使拥有者可以通过指针修改对象。</p><p>(3) <strong>static_cast：</strong>static_cast 用于进行比较“自然”和低风险的转换，如<strong>整型和浮点型、字符型与整型</strong>之间的互相转换。static_cast <strong>不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。</strong>因为这些属于风险比较高的转换。他的安全性比起reinterpret_cast 更高，但是由于该操作符没有运行时类型检查机制，在进行下行转换（把基类指针或引用转换成派生类指针或引用）时仍然是不安全的。</p><p>(4) <strong>dynamic_cast：</strong>dynamic_cast主要用于类层次间的上行转换和下行转换，因为有动态类型检测，在进行下行转换时比static_cast更安全。</p><p>举例</p><p>C++中有四种类型的强制类型转换，分别是 <code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p><ol><li><code>static_cast</code>：这是最常用的类型转换符。它可以在任何的数据类型之间进行转换，但是转换的类型需要是相关的，否则可能会产生意外的结果。</li></ol><p>例如，将整数转换为浮点数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(a);  <span class="comment">// b = 10.0</span></span><br></pre></td></tr></table></figure><ol><li><code>dynamic_cast</code>：这个类型转换符主要用在类的继承体系中，用于进行上行转换和安全的下行转换。当我们试图将父类指针转换为子类指针时，可以使用 <code>dynamic_cast</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  <span class="comment">// 安全的下行转换</span></span><br></pre></td></tr></table></figure><ol><li><code>const_cast</code>：这个类型转换符用于移除常量性。如果我们有一个 <code>const</code> 变量，但我们需要修改它，可以使用 <code>const_cast</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">20</span>;  <span class="comment">// a现在是20，但这样做是危险的，因为a本来是const的</span></span><br></pre></td></tr></table></figure><ol><li><code>reinterpret_cast</code>：这个类型转换符用于进行低级别的类型转换，它可以在任何指针或整数类型之间进行转换。但是使用这个转换符需要非常小心，因为它可能会产生意外的结果。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">char</span>* c = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(p);  <span class="comment">// 将int*转换为char*</span></span><br></pre></td></tr></table></figure><p>注意：尽管 C++ 提供了这些强制类型转换，但应尽量避免使用它们，除非你非常确定你知道自己在做什么。在很多情况下，使用强制类型转换可能会导致未定义的行为。</p><h3 id="50-如何获得结构成员相对于结构开头的字节偏移量？"><a href="#50-如何获得结构成员相对于结构开头的字节偏移量？" class="headerlink" title="50. 如何获得结构成员相对于结构开头的字节偏移量？"></a>50. 如何获得结构成员相对于结构开头的字节偏移量？</h3><p>使用<stddef.h>头文件中的，offsetof宏</p><p>offsetof用法：offsetof(S, x)，S为结构体对象，x为结构体数据成员之一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s, m) (reinterpret_cast<span class="string">&lt;size_t&gt;</span>(&amp;reinterpret_cast<span class="string">&lt;const volatile char&amp;&gt;</span>(static_cast<span class="string">&lt;s*&gt;</span>(nullptr)-&gt;m)))</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the first element is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, a)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the second is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, b)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the third element is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, c)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>此处，通过 <code>static_cast&lt;s*&gt;(nullptr)</code>，编译器相信在 <code>nullptr</code> 处（<code>0x0</code>）有一个真实存在的 <code>s</code> 类型的对象。</p><p>此处使用 <code>static_cast</code> 而非 <code>reinterpret_cast</code> 是因为 C++ 标准不允许将 <code>nullptr</code> 通过 <code>reinterpret_cast</code> 转换成其他类型的指针；</p><p>此类转换应用 <code>static_cast</code>。由于 <code>static_cast&lt;s*&gt;(nullptr)</code> 返回指向 <code>s</code> 类型对象的指针，因此 <code>static_cast&lt;s*&gt;(nullptr)-&gt;m</code> 就是一个虚拟但在编译器看来可用的成员变量 <code>m</code>。</p><p>为了求得以字节为单位的 <code>ptrdiff_t</code>，实现中通过 <code>&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)</code> 获得一个 <code>const volatile char*</code> 类型的变量。</p><p>由于在该实现中，虚拟的变量位于 <code>0x0</code> 位置，故而 <code>&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)</code> 即是 <code>m</code> 在 <code>s</code> 类型对象当中相对对象起始地址的偏移量。</p><p>最后，只需将它转换为 <code>size_t</code> 类型的值即可。</p><p>具体：<a href="https://zhuanlan.zhihu.com/p/677486774">理解C/C++ 中的offsetof 宏原理</a></p><h3 id="51-静态类型和动态类型，静态绑定和动态绑定的介绍？"><a href="#51-静态类型和动态类型，静态绑定和动态绑定的介绍？" class="headerlink" title="51. 静态类型和动态类型，静态绑定和动态绑定的介绍？"></a>51. 静态类型和动态类型，静态绑定和动态绑定的介绍？</h3><p>(1) 静态类型：对象在声明时采用的类型，在编译期既已确定；</p><p>(2) 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</p><p>(3) 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p><p>(4) 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</p><h3 id="52-全局变量和局部变量有什么区别？"><a href="#52-全局变量和局部变量有什么区别？" class="headerlink" title="52. 全局变量和局部变量有什么区别？"></a>52. 全局变量和局部变量有什么区别？</h3><p>(1) 生命周期：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p>(2) 作用域：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用</p><h3 id="53-指针加减计算要注意什么？"><a href="#53-指针加减计算要注意什么？" class="headerlink" title="53. 指针加减计算要注意什么？"></a>53. 指针加减计算要注意什么？</h3><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，即内存越界。</p><h3 id="54-怎样判断两个浮点数是否相等？"><a href="#54-怎样判断两个浮点数是否相等？" class="headerlink" title="54. 怎样判断两个浮点数是否相等？"></a>54. 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</p><h3 id="55-类如何实现只能静态分配和只能动态分配？"><a href="#55-类如何实现只能静态分配和只能动态分配？" class="headerlink" title="55. 类如何实现只能静态分配和只能动态分配？"></a>55. 类如何实现只能静态分配和只能动态分配？</h3><p>(1) 实现只能静态分配：把operator new运算符重载为private属性。</p><p>(2) 实现只能动态分配：把构造函数设为private属性</p><h3 id="56-知道C-中的组合吗-它与继承相比有什么优缺点吗？"><a href="#56-知道C-中的组合吗-它与继承相比有什么优缺点吗？" class="headerlink" title="56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？"></a>56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？</h3><p>继承有以下几个缺点：</p><p>(1) 父类的内部细节对子类是可见的，破坏了封装性。</p><p>(2) 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p><p>(3) 子类与父类是一种高耦合，违背了面向对象思想。</p><p>使用组合的目的即为了克服这几个缺点，但也因此产生了另一些缺点，如：容易产生过多的对象、为了能组合多个对象，必须仔细对接口进行定义。</p><h3 id="57-为什么模板类一般都是放在一个头文件中？"><a href="#57-为什么模板类一般都是放在一个头文件中？" class="headerlink" title="57. 为什么模板类一般都是放在一个头文件中？"></a>57. 为什么模板类一般都是放在一个头文件中？</h3><p>模板定义很特殊，编译器在遇到任何的模板定义时不会为它分配内存空间，它一直处于等待状态直到被一个模板实例告知才会分配内存空间。如果在分离式编译环境下，编译器编译某一个源文件时并不知道另一个源文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器），同时由于模板定义没有被分配空间，链接器也无法查找到函数的入口地址。</p><h3 id="58-你了解重载运算符吗？"><a href="#58-你了解重载运算符吗？" class="headerlink" title="58. 你了解重载运算符吗？"></a>58. 你了解重载运算符吗？</h3><p>C++预定义中的运算符的操作对象只局限于基本的内置数据类型，但是对于我们自定义的类型（类）是没有办法操作的。但是大多时候我们需要对我们定义的类型进行类似的运算，这个时候就需要我们对这么运算符进行重新定义，赋予其新的功能，以满足自身的需求。<strong>这就是运算符重载，它的实质就是函数重载。</strong></p><p>运算符重载规则：</p><p>(1) 为了防止用户对标准类型进行运算符重载，C++规定重载后的运算符的操作对象必须至少有一个是用户定义的类型。</p><p>(2) 使用运算符不能违法运算符原来的句法规则。如不能将‘+’重载为一个操作数。</p><p>(3) 不能修改运算符原先的优先级。</p><p>(4) 不能创建一个新的运算符</p><p>(5) 不能进行重载的运算符：成员运算符，作用域运算符，条件运算符，sizeof运算符，typeid运算符，const_cast、dynamic_cast、reinterpret_cast、static_cast强制类型转换运算符。</p><p>(6) 大多数运算符可以通过成员函数和非成员函数进行重载，但是下面这四种运算符只能通过成员函数进行重载：= 赋值运算符，（）函数调用运算符，[ ]下标运算符，-&gt;通过指针访问类成员的运算符。</p><p>(7) 一般来说，单目运算符重载为类的成员函数，双目运算符重载为类的友元函数</p><h3 id="59-前-和后-重载的区别？"><a href="#59-前-和后-重载的区别？" class="headerlink" title="59. 前++和后++重载的区别？"></a>59. 前++和后++重载的区别？</h3><p>(1) 前++重载函数参数列表不需要带参数，后++参数列表需要带参数，这个参数仅仅只是区分前++和后++用，没有实际意义。</p><p>(2) 前++返回一个引用，后++返回一个临时对象，后++效率比较高。</p><h3 id="60-当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#60-当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？</h3><p>(1) 名字查找</p><p>(2) 确定候选函数</p><p>(3) 寻找最佳匹配</p><h3 id="61-条件编译的作用？"><a href="#61-条件编译的作用？" class="headerlink" title="61. 条件编译的作用？"></a>61. 条件编译的作用？</h3><p>(1) 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”<strong>。</strong></p><p>(2) 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用条件编译即可避免该错误。</p><h3 id="62-隐式转换是什么，如何消除类的隐式转换？"><a href="#62-隐式转换是什么，如何消除类的隐式转换？" class="headerlink" title="62. 隐式转换是什么，如何消除类的隐式转换？"></a>62. 隐式转换是什么，如何消除类的隐式转换？</h3><p>(1) C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换。<strong>最常见的隐式转换为函数传参。</strong></p><p>(2) C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p><h3 id="63-如何在不使用额外空间的情况下，交换两个数？"><a href="#63-如何在不使用额外空间的情况下，交换两个数？" class="headerlink" title="63. 如何在不使用额外空间的情况下，交换两个数？"></a>63. 如何在不使用额外空间的情况下，交换两个数？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line"><span class="attribute">x</span>=x+y</span><br><span class="line"><span class="attribute">y</span>=x-y</span><br><span class="line"><span class="attribute">x</span>=x-y</span><br><span class="line">(2)</span><br><span class="line"><span class="attribute">x</span>=x^y</span><br><span class="line"><span class="attribute">y</span>=x^y</span><br><span class="line"><span class="attribute">x</span>=x&amp;y</span><br></pre></td></tr></table></figure><h3 id="64-你知道strcpy和memcpy的区别是什么？"><a href="#64-你知道strcpy和memcpy的区别是什么？" class="headerlink" title="64. 你知道strcpy和memcpy的区别是什么？"></a>64. 你知道strcpy和memcpy的区别是什么？</h3><p>(1) <strong>复制的内容不同。</strong>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类对象等。</p><p>(2) <strong>复制的方法不同。</strong>strcpy不需要指定长度，它遇到被复制字符串的结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度，更加安全。</p><p>(3) <strong>用途不同。</strong>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p><h3 id="65-如果有一个空类，它会默认添加哪些函数？"><a href="#65-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="65. 如果有一个空类，它会默认添加哪些函数？"></a>65. 如果有一个空类，它会默认添加哪些函数？</h3><p>(1) 默认构造函数</p><p>(2) 拷贝构造函数</p><p>(3) 析构函数</p><p>(4) 赋值运算符函数</p><h3 id="66-static-cast比C语言中的转换强在哪里？"><a href="#66-static-cast比C语言中的转换强在哪里？" class="headerlink" title="66. static_cast比C语言中的转换强在哪里？"></a>66. static_cast比C语言中的转换强在哪里？</h3><p>(1) 更加安全</p><p>(2) 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误</p><h3 id="67-成员函数里memset-this-0-sizeof-this-会发生什么？"><a href="#67-成员函数里memset-this-0-sizeof-this-会发生什么？" class="headerlink" title="67. 成员函数里memset(this,0,sizeof(*this))会发生什么？"></a>67. 成员函数里memset(this,0,sizeof(*this))会发生什么？</h3><p>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。</p><p><strong>对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</strong></p><p>(1) 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</p><p>(2) 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</p><h3 id="68-你知道回调函数吗-它的作用？"><a href="#68-你知道回调函数吗-它的作用？" class="headerlink" title="68. 你知道回调函数吗?它的作用？"></a>68. 你知道回调函数吗?它的作用？</h3><p>(1) 回调函数就是一个通过函数指针调用的函数。回调的函数的定义由程序员实现，但无需程序员调用，可将函数指针作为参数传递给某个函数库中的函数，由函数库去调用。</p><p>(2) 回调函数是在<strong>“你想让别人的代码执行你的代码，而别人的代码你又不能动”</strong>这种需求下产生的。</p><p>(3) 可以做回调函数的函数有两种，一种是普通函数，一种是静态成员函数。<strong>普通成员函数不能做回调函数</strong>，因为普通成员函数自带this指针参数，会导致函数声明与调用不匹配的情况发生。</p><p>(4) 回调函数是一种设计系统的思想，能够解决系统架构中的部分问题，但是系统中不能过多使用回调函数，因为回调函数会改变整个系统的运行轨迹和执行顺序，耗费资源，而且会使得代码晦涩难懂。</p><p><strong>回调函数的本质确实是函数指针。通过函数指针，我们可以将函数作为参数传递给另一个函数，这就是所谓的“回调”。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef int(*callback)(int);//定义回调函数的原型（接收参数、返回值、名称等）</span></span><br><span class="line"><span class="keyword">using</span>  callback = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,callback cb)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">cb</span>(x); &#125;<span class="comment">//接收回调函数指针的函数（需要使用回调功能的地方）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callbackImpl1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;<span class="comment">//第一个回调函数实现示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callbackImpl2</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;<span class="comment">//第二个回调函数实现示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result1=<span class="built_in">func</span>(<span class="number">2</span>, &amp;callbackImpl1);<span class="comment">//注意传入的是第一个回调函数实现的（地址）指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result1);</span><br><span class="line"><span class="type">int</span> result2 = <span class="built_in">func</span>(<span class="number">2</span>, &amp;callbackImpl2);<span class="comment">//注意传入的是第一个回调函数实现的（地址）指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result2);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="69-C-从代码到可执行程序经历了什么？"><a href="#69-C-从代码到可执行程序经历了什么？" class="headerlink" title="69. C++从代码到可执行程序经历了什么？"></a>69. C++从代码到可执行程序经历了什么？</h3><p><strong>(1) 预编译</strong></p><p>主要处理源代码文件中的以“#”开头的预编译指令。</p><p><strong>(2) 编译</strong></p><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><p><strong>(3) 汇编</strong></p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来。</p><p><strong>(4) 链接</strong></p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。</p><h3 id="70-类的对象存储空间？"><a href="#70-类的对象存储空间？" class="headerlink" title="70. 类的对象存储空间？"></a>70. 类的对象存储空间？</h3><p>(1) 非静态成员的数据类型大小之和。</p><p>(2) 编译器加入的额外成员变量（如指向虚函数表的指针）。</p><p>(3) 为了内存对齐而补入的额外空间。</p><p>(4) 空类大小为1，但若是作为基类，则大小为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="71-静态链接和动态链接的区别？"><a href="#71-静态链接和动态链接的区别？" class="headerlink" title="71. 静态链接和动态链接的区别？"></a>71. 静态链接和动态链接的区别？</h3><p>静态链接和动态链接是针对函数库来说的，现在的函数库分为两种：<strong>静态库和动态库</strong>。他们分别对应静态链接和动态链接。</p><p>(1) <strong>静态链接：</strong>所有的函数和数据都被编译进一个文件中。在使用静态库的情况下，在编译链接可执行文件时，链接器从函数库中复制函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。静态链接有以下特点：</p><p>①　空间浪费：因为每个可执行程序中都拥有函数库数据的一份副本，所以如果多个程序对同一个目标文件都有依赖，当他们同时运行在计算机上，会出现同一个函数库在内存中有多个副本，浪费内存空间；</p><p>②　更新困难：每当库函数的代码修改了，所有依赖该库的程序都需要重新进行编译链接。</p><p>③　运行速度快：因为在可执行程序中已经具备了所有执行程序所需要的任何东西，所以在执行的时候运行速度快。</p><p>(2) <strong>动态链接：</strong>动态链接会在程序运行时才将函数库与源程序执行链接，而不是像静态链接一样把所有模块都链接成一个单独的可执行文件。动态链接有以下特点：</p><p>①　共享库：如果多个程序都依赖同一个库，该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p><p>②　更新方便：更新时只需要替换原来的库文件，依赖它的程序无需重新编译。当程序下一次运行时，新库会被自动加载到内存并且与其他程序执行链接，程序就完成了升级迭代。</p><p>性能损耗：因为把链接推迟到了程序运行时，每次执行程序都需要进行链接，所以性能会有一定损失。</p><h3 id="72-为什么不能把所有的函数写成内联函数？"><a href="#72-为什么不能把所有的函数写成内联函数？" class="headerlink" title="72. 为什么不能把所有的函数写成内联函数？"></a>72. 为什么不能把所有的函数写成内联函数？</h3><p>(1) 首先，不管是什么函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，<strong>编译器并不一定真正的内联</strong>。</p><p>(2) 内联函数以代码复杂为代价，省去了函数调用的开销来提高执行效率。如果内联函数体内代码执行时间相比起函数调用开销更大，则没有太大的意义。<strong>一般来说若是函数体代码比较长或者内部带有循环，则不推荐使用内联函数。</strong></p><p>(3) <strong>将构造函数和析构函数声明为inline是没有什么意义的，</strong>即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。</p><p>(4) <strong>将虚函数声明为inline，要分情况讨论。</strong>当指向派生类的指针（多态性）调用声明为inline的虚函数时，由于inline是编译期决定的，而虚函数是运行期决定的，在不知道将要调用哪个函数的情况下，编译器不会内联展开；当对象本身调用虚函数时，编译器能决议出会调用哪个函数时，就会内联展开，当然前提依然是函数并不复杂的情况下。</p><h3 id="73-为什么C-没有垃圾回收机制？"><a href="#73-为什么C-没有垃圾回收机制？" class="headerlink" title="73. 为什么C++没有垃圾回收机制？"></a>73. 为什么C++没有垃圾回收机制？</h3><p>(1) 实现一个垃圾回收器会带来额外的空间和时间开销。</p><p>(2) 垃圾回收会使得C++不适合进行很多底层的操作。</p><h3 id="74-说说C-的内存分区？"><a href="#74-说说C-的内存分区？" class="headerlink" title="74. 说说C++的内存分区？"></a>74. 说说C++的内存分区？</h3><p>在C++中，内存分成5个区，他们分别是<strong>堆、栈、全局/静态存储区和常量存储区和代码区</strong>。</p><p>(1) <strong>栈：</strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈工作效率很高，但是分配的内存容量有限。</p><p>(2) <strong>堆：</strong>就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>(3) <strong>全局/静态存储区：</strong>这块内存在编译时已经分配好，且在程序运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量。</p><p>(4) <strong>常量存储区：</strong>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p><p>(5) <strong>代码区：</strong>存放程序的二进制代码。</p><h3 id="75-说说友元函数和友元类的特性？"><a href="#75-说说友元函数和友元类的特性？" class="headerlink" title="75. 说说友元函数和友元类的特性？"></a>75. 说说友元函数和友元类的特性？</h3><p>友元提供了<strong>不同类的成员函数之间、类的成员函数和一般函数之间</strong>进行数据共享的机制。通过友元，外部的普通函数或者另一个类中的成员函数可以访问本类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。友元具有以下特性：</p><p>(1) <strong>友元关系不能被继承。</strong></p><p>(2) <strong>友元关系是单向的，不具有交换性。</strong>若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p><p><strong>友元关系不具有传递性。</strong>若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的声明。</p><h3 id="76-关于this指针你知道什么？"><a href="#76-关于this指针你知道什么？" class="headerlink" title="76. 关于this指针你知道什么？"></a>76. 关于this指针你知道什么？</h3><p>(1) this指针是类的指针，指向对象的首地址。</p><p>(2) this指针只能在普通成员函数中使用，在全局函数、静态成员函数中都不能用this。</p><p>(3) this在成员函数的开始执行前构造，在成员的执行结束后清除。</p><p>(4) this指针只有在普通成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p><p>(5) this指针主要可用于返回类对象本身的时候，直接使用 return *this。或者当形参数与成员变量名相同时用于区分，如this-&gt;n = n。</p><h3 id="77-在成员函数中调用delete-this会出现什么问题？"><a href="#77-在成员函数中调用delete-this会出现什么问题？" class="headerlink" title="77. 在成员函数中调用delete this会出现什么问题？"></a>77. 在成员函数中调用delete this会出现什么问题？</h3><p>当调用delete this时，类对象的内存空间被释放。因为类成员函数并没有存放在类对象的内存空间中，所以在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，因为内存被释放，所以就会出现不可预期的问题。</p><h3 id="78-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#78-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="78. 如果在类的析构函数中调用delete this，会发生什么？"></a>78. 如果在类的析构函数中调用delete this，会发生什么？</h3><p>会导致堆栈溢出。因为delete会调用析构函数，导致递归。</p><h3 id="79-C-中类的数据成员和成员函数内存分布情况？"><a href="#79-C-中类的数据成员和成员函数内存分布情况？" class="headerlink" title="79. C++中类的数据成员和成员函数内存分布情况？"></a>79. C++中类的数据成员和成员函数内存分布情况？</h3><p>(1) 普通数据成员存放在对象内存空间中</p><p>(2) 静态数据成员存放在全局/静态存储区中</p><p>(3) 普通成员函数和静态成员函数都存放在代码区中</p><h3 id="80-C-的多态怎么实现？"><a href="#80-C-的多态怎么实现？" class="headerlink" title="80. C++的多态怎么实现？"></a>80. C++的多态怎么实现？</h3><p>C++的多态机制有两种，分为编译时多态和运行时多态，下面分别介绍这两种多态。</p><p><strong>编译时多态</strong></p><p>(1) 主要通过模板和函数重载实现，在编译期发生，由编译器进行推断决议。</p><p>(2) 优点：</p><p>①　它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。</p><p>②　在编译器完成多态，提高运行期效率。</p><p>③　具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。</p><p>(3) 缺点：</p><p>①　程序可读性降低，代码调试带来困难。</p><p>②　无法实现模板的分离编译，当工程很大时，编译时间不可小觑。</p><p><strong>运行时多态</strong></p><p>(1) 运行期多态的设计思想要归结到类继承体系的设计上去。对于有相关功能的对象集合，我们总希望能够抽象出它们共有的功能集合，在基类中将这些功能声明为虚接口（虚函数），然后由子类继承基类去重写这些虚接口，以实现子类特有的具体功能。</p><p>(2) 在C++中，主要由虚表和虚表指针实现运行时多态。运行时多态实现细节如下：</p><p>①　编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。</p><p>②　编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p><p>③　在派生类定义对象时，会先调用父类的构造函数，此时，编译器只“看到了父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p><p>④　当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p><p>(3) 优点：</p><p>面向对象设计中重要的特性，对客观世界直觉认识。</p><p>(4) 缺点：</p><p>①　运行期间进行虚函数绑定，提高了程序运行开销。</p><p>②　庞大的类继承层次，对接口的修改易影响类继承层次。</p><p>③　由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。</p><p>④　虚表指针增大了对象体积，类也多了一张虚函数表。</p><h3 id="81-为什么要把析构函数写成虚函数？"><a href="#81-为什么要把析构函数写成虚函数？" class="headerlink" title="81. 为什么要把析构函数写成虚函数？"></a>81. 为什么要把析构函数写成虚函数？</h3><p>由于类的多态性，基类指针可以指向派生类的对象。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p><h3 id="82-虚函数表存放在内存的什么区域？"><a href="#82-虚函数表存放在内存的什么区域？" class="headerlink" title="82. 虚函数表存放在内存的什么区域？"></a>82. 虚函数表存放在内存的什么区域？</h3><p>C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；</p><p>虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</p><h3 id="83-模板偏特化了解吗？"><a href="#83-模板偏特化了解吗？" class="headerlink" title="83. 模板偏特化了解吗？"></a>83. 模板偏特化了解吗？</h3><p>(1) 通过编写模板，能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化（模板偏特化）。</p><p>(2) 所谓的模板偏特化对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上。</p><p>(3) 特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以<strong>最佳匹配</strong>为原则。</p><p>(4) 可以特例化类中的部分成员函数而不是整个类。</p><p>举例：</p><p>模板偏特化是C++模板编程中的一个重要概念。简单来说，模板偏特化就是对模板进行部分特化，也就是将模板的部分参数具体化。模板偏特化可以让我们为特定的类型或条件提供特化的实现。</p><p>举例来说，假设我们有一个模板类用于存储数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    T data[N];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们想要对<code>bool</code>类型的数组进行特化，因为<code>bool</code>类型的数组可以通过位操作进行压缩存储，从而节省空间。我们可以通过模板偏特化来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">bool</span>, N&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用位操作进行压缩存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[(N+<span class="number">7</span>)/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Array&lt;bool, N&gt;</code>是<code>Array&lt;T, N&gt;</code>的一个偏特化版本。当我们创建一个<code>Array&lt;bool, 100&gt;</code>对象时，编译器会使用偏特化版本的模板，从而实现对<code>bool</code>类型数组的优化存储。</p><h3 id="84-哪些函数不能被定义为虚函数？"><a href="#84-哪些函数不能被定义为虚函数？" class="headerlink" title="84. 哪些函数不能被定义为虚函数？"></a>84. 哪些函数不能被定义为虚函数？</h3><p>(1) <strong>构造函数。</strong>每一个声明了虚函数的类对象都有一个指向虚表(vtable)的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的,假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？再者，虚函数主要是在调用对象不确定的情况下使用的，然而构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。</p><p>(2) <strong>静态函数。</strong>静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p><p>(3) <strong>友元函数。</strong>友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p><p>(4) <strong>普通函数。</strong>普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p><h3 id="85-构造函数和析构函数可以调用虚函数吗，为什么？"><a href="#85-构造函数和析构函数可以调用虚函数吗，为什么？" class="headerlink" title="85. 构造函数和析构函数可以调用虚函数吗，为什么？"></a>85. 构造函数和析构函数可以调用虚函数吗，为什么？</h3><p>(1) <strong>构造函数调用虚函数没有意义</strong>，因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编。</p><p>(2) <strong>析构函数调用虚函数没有意义，</strong>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p><h3 id="86-构造函数和析构函数可否抛出异常？"><a href="#86-构造函数和析构函数可否抛出异常？" class="headerlink" title="86. 构造函数和析构函数可否抛出异常？"></a>86. 构造函数和析构函数可否抛出异常？</h3><p>(1) <strong>构造函数不可抛出异常：</strong>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，<strong>如果某个对象的构造函数中发生异常，则该对象的析构函数不会被调用。因此会造成内存泄漏。</strong></p><p>(2) <strong>析构函数不可抛出异常：</strong>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。再者，通常异常发生时，C++ 的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p><h3 id="87-模板类和模板函数的区别是什么？"><a href="#87-模板类和模板函数的区别是什么？" class="headerlink" title="87. 模板类和模板函数的区别是什么？"></a>87. 模板类和模板函数的区别是什么？</h3><p>函数模板的实例化是由编译器在处理函数调用时自动完成的，而类模板的实例化必须由程序员在代码中显式地指定。即函数模板允许隐式调用和显式调用，而类模板只能显式调用。</p><h3 id="88-什么是虚继承？"><a href="#88-什么是虚继承？" class="headerlink" title="88. 什么是虚继承？"></a>88. 什么是虚继承？</h3><p>(1) 由于C++支持多继承，因此除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承。</p><p>(2) 多继承有可能引发一直特别情况：B和C公有继承A，D又公有继承B和C，这种方式是一种菱形继承或者钻石继承，如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513220826075.png" alt="image-20240513220826075"></p><p>(3) 如果D调用了A的方法，则会引发数据的二义性和冗余，编译器不知道是要调用B所继承的A，还是C所继承的A。</p><p>(4) 为了解决这个问题，C++引入了虚拟继承，在虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</p><h3 id="89-抽象基类为什么不能创建对象？纯虚函数又是什么？"><a href="#89-抽象基类为什么不能创建对象？纯虚函数又是什么？" class="headerlink" title="89. 抽象基类为什么不能创建对象？纯虚函数又是什么？"></a>89. 抽象基类为什么不能创建对象？纯虚函数又是什么？</h3><p>(1) 带有纯虚函数的类为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的。抽象类会将所有派生类中有关的操作抽象成一个通用接口且不做具体实现（纯虚函数），具体实现由派生类实现，因此抽象基类不可以创建对象。</p><p>(2) 纯虚函数是一种特殊的虚函数，该类函数没有函数体。因为在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><h3 id="90-说说RTTI？"><a href="#90-说说RTTI？" class="headerlink" title="90. 说说RTTI？"></a>90. 说说RTTI？</h3><p><strong>运行时类型识别（Run-time type identification , RTTI）</strong>，是指在只有一个指向基类的指针或引用时，确定所指对象的准确类型的操作。其常被说成是C++的四大扩展之一（其他三个为异常、模板和名字空间）。使用RTTI有两种方法：</p><p>1、typeid()</p><p>第一种就像sizeof()，它看上像一个函数，但实际上它是由编译器实现的。typeid()带有一个参数，它可以是一个对象引用或指针，返回全局typeinfo类的常量对象的一个引用。可以用运算符“= =”和“!=”来互相比较这些对象，也可以用name()来获得类型的名称。同时，我们也可以用typeid 检查基本类型和非多态类型。如果想知道一个指针所指对象的精确类型，我们必须逆向引用这个指针。比如：</p><p>2、dynamic_cast (expression)</p><p>该运算符为强制类型转换符，上文第49条有提及</p><h3 id="91-多继承的优缺点，作为一个开发者怎么看待多继承？"><a href="#91-多继承的优缺点，作为一个开发者怎么看待多继承？" class="headerlink" title="91. 多继承的优缺点，作为一个开发者怎么看待多继承？"></a>91. 多继承的优缺点，作为一个开发者怎么看待多继承？</h3><p>多重继承的优点很明显，就是一个对象可以调用多个基类中的接口。多继承容易导致菱形继承问题，虽然可以用虚继承解决该问题，但也会造成内存结构复杂，效率降低，继承体系过于复杂化的缺点。</p><h3 id="92-为什么拷贝构造函数必须传引用不能传值？"><a href="#92-为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="92. 为什么拷贝构造函数必须传引用不能传值？"></a>92. 为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数的作用就是用来拷贝对象的，使用一个已存在的对象来初始化一个新的对象。如果使用传值方式，那么在拷贝构造函数被调用时，<strong>在进行参数传递的时候就会调用拷贝构造函数，这样会导致递归溢出。</strong></p><h3 id="93-为什么在C-C-中要将代码分为头文件和源文件，不能写到一起吗？"><a href="#93-为什么在C-C-中要将代码分为头文件和源文件，不能写到一起吗？" class="headerlink" title="93. 为什么在C/C++中要将代码分为头文件和源文件，不能写到一起吗？"></a>93. 为什么在C/C++中要将代码分为头文件和源文件，不能写到一起吗？</h3><p>(1) <strong>将所有代码写入一个文件中当然可以，同样可以通过编译且正常运行</strong>。</p><p>(2) <strong>分开写的目的是方便未来。</strong>有时候我们写的代码会给别人去用，如果是非开源代码，可以将源文件封装起来并生成库文件（<strong>库文件是二进制文件，无法查阅代码</strong>）。只对外开放头文件和库文件，那么别人就无法看到代码的具体实现了。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="1-auto、decltype的用法？"><a href="#1-auto、decltype的用法？" class="headerlink" title="1. auto、decltype的用法？"></a>1. auto、decltype的用法？</h3><p>(1) auto：C++11引入了auto类型说明符，它可以让编译器通过初始值来进行类型推演，使得程序员无需知道类型名称就可以定义变量，所以auto 定义的变量必须有初始值。</p><p>(2) decltype: auto定义的变量必须初始化，如果我们不想要初始化就可以使用decltype，它会返回参数的数据类型，并定义新的变量，而且新变量的值不会被初始化。</p><h3 id="2-C-中NULL和nullptr的区别？"><a href="#2-C-中NULL和nullptr的区别？" class="headerlink" title="2. C++中NULL和nullptr的区别？"></a>2. C++中NULL和nullptr的区别？</h3><p>(1) NULL是一个宏定义，C中NULL为（void*)0，C++中NULL为整数0。</p><p>(2) 将NULL定义为0带来的一个问题是无法与整数的0区分，因为C++中允许有函数重载，若是有个a、b两个重载函数，参数分别为整数和指针，那么在传入NULL参数时，会把NULL当做整数0来看，导致错误调用了参数为整数的函数。</p><p>(3) nullptr可以解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p><h3 id="3-说说final和override关键字？"><a href="#3-说说final和override关键字？" class="headerlink" title="3. 说说final和override关键字？"></a>3. 说说final和override关键字？</h3><p>(1) Override指定了子类的这个虚函数是对父类虚函数的重写，如果函数名不小心打错了的话，编译器会进行报错。</p><p>(2) 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后如果被继承或重写，编译器会报错。</p><p>举例：</p><p>在C++中，<code>final</code> 和 <code>override</code> 是两个非常有用的关键字，它们主要用于类和成员函数的继承。</p><ol><li><code>final</code> 关键字可以用于阻止类的进一步继承，或者阻止虚函数的进一步覆盖。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;   <span class="comment">// 这个类不能被继承</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;   <span class="comment">// 这个函数不能被子类覆盖</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>override</code> 关键字用于明确表示一个虚函数覆盖了基类中的虚函数。这有助于编译器检查我们的代码，如果基类中没有对应的虚函数，使用 <code>override</code> 将导致编译错误。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;   <span class="comment">// 明确表示这个函数覆盖了基类的虚函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是 <code>final</code> 和 <code>override</code> 在C++中的基本用法。这两个关键字都可以帮助我们编写出更清晰、更安全的代码。</p><h3 id="4-C-中的智能指针？"><a href="#4-C-中的智能指针？" class="headerlink" title="4. C++中的智能指针？"></a>4. C++中的智能指针？</h3><p>(1) 智能指针会管理程序员申请的内存，在使用结束后会自动释放，防止堆内存泄漏。</p><p>(2) <strong>auto_ptr：</strong>最原始的智能指针。auto_ptr采用的是<strong>独享所有权语义</strong>，一个非空的auto_ptr总是拥有它所指向的资源，转移一个auto_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空。由于支持拷贝语义，拷贝后源对象变得无效，如果程序员忽视了这点，这可能引发很严重的问题。<strong>在C++11中该指针已被弃用</strong>。</p><p>(3) <strong>unique_ptr：</strong>与auto_ptr类似，采用<strong>独享所有权语义</strong>。<strong>unique_ptr提供移动语义</strong>，这在很大程度上避免了auto_ptr的错误，因为很明显必须使用std::move()进行转移，提醒程序员在这个地方发生了移动。</p><p>(4) <strong>shared_ptr：</strong>采用<strong>引用计数器</strong>的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。引用计数器的变化依据如下所示。</p><p>①　每次创建类的新对象时，初始化指针并将引用计数置为1</p><p>②　当对象作为另一对象的副本而创建时，拷贝构造函数会拷贝指针并增加与之相应的引用计数</p><p>③　对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</p><p>④　调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</p><p>(5) <strong>weak_ptr：</strong> 由于shared_ptr引用计数存在的问题，即互相引用形成环（环形引用），使得两个指针指向的内存都无法释放，如下所示。</p><p>①　为了解决这个问题，C++引入了weak_ptr(弱引用)，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，<strong>它只引用，不计数</strong>。</p><p>②　如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。</p><p>③　weak_ptr不保证它指向的内存一定是有效的，在使用之前应先检查weak_ptr是否为空指针，避免访问非法内存，也因此weak_ptr并不能直接访问对象，他只能通过转化为shared_ptr来使用对象。</p><blockquote><p><strong>share_ptr手写</strong></p></blockquote><p><strong>share_ptr-double free问题</strong>：double free 问题就是一块内存空间或者资源被释放两次。</p><p>double free 可能是下面这些原因造成的：</p><ul><li>直接使用原始指针创建多个 shared_ptr，而没有使用 shared_ptr 的 make_shared 工厂函数，从而导致多个独立的引用计数。</li><li>循环引用，即两个或多个 shared_ptr 互相引用，导致引用计数永远无法降为零，从而无法释放内存。</li></ul><p>case1:举例</p><p>在C++中，std::shared_ptr 是一个智能指针，它可以自动管理对象的生命周期。它通过引用计数来确保当没有任何 shared_ptr 指向一个对象时，该对象会被自动删除。</p><p>然而，直接使用原始指针创建多个 shared_ptr，而没有使用 shared_ptr 的 make_shared 工厂函数，可能会导致多个独立的引用计数，进而导致double-free的问题。</p><p>下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// 创建一个原始指针指向一个新的int对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个独立的shared_ptr，它们都指向同一个对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当sp1和sp2离开其作用域时，它们都会试图删除同一个对象，导致double-free的问题</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了两个独立的 shared_ptr，它们都指向同一个对象。当它们离开其作用域时，它们都会试图删除同一个对象，导致double-free的问题。</p><p>正确的做法是使用 make_shared 工厂函数来创建 shared_ptr，或者只使用一个原始指针来初始化一个 shared_ptr，然后使用这个 shared_ptr 来初始化其他的 shared_ptr。这样，所有的 shared_ptr 都会共享同一个引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 使用原始指针初始化一个shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">// 使用sp1初始化sp2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 使用make_shared创建一个shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">// 使用sp1初始化sp2</span></span><br></pre></td></tr></table></figure><p>在上述正确的做法中，所有的 shared_ptr 都会共享同一个引用计数，因此不会出现double-free的问题。</p><p>case2:</p><p>循环引用问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;b_ptr = b; <span class="comment">// A 指向 B</span></span><br><span class="line">        b-&gt;a_ptr = a; <span class="comment">// B 指向 A</span></span><br><span class="line">    &#125; <span class="comment">// a 和 b 离开作用域，但由于循环引用，它们的析构函数不会被调用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用weak_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 替代 shared_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;b_ptr = b; <span class="comment">// A 指向 B</span></span><br><span class="line">        b-&gt;a_ptr = a; <span class="comment">// B 对 A 使用 weak_ptr</span></span><br><span class="line">    &#125; <span class="comment">// a 和 b 离开作用域，它们的析构函数会被正确调用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enable_shared_from_this</strong><br>从名字可以看出几个关键词：enable: 允许 shared 指 shared_ptr, from_this 则是指从类自身this 构造 shared_ptr。</p><p>想象这样一个场景:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这段代码需要在NeedCallSomeAPI函数中调用SomeAPI，而SomeAPI需要的是一个std::shared_ptr的实参。这个时候应该怎么做？ 这样吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的做法是错误的，因为SomeAPI调用结束后std::shared_ptr对象的引用计数会降为0，导致 this 被意外释放。</p><p>这种情况下，我们需要使用std::enable_shared_from_this ，使用方法很简单，只需要让SomeData继承std::enable_shared_from_this，然后调用shared_from_this，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> shared_ptr&lt;st&gt; &amp;d)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span> : enable_shared_from_this&lt;st&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;st&gt; <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;st&gt;(<span class="keyword">new</span> st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">66</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> shared_ptr&lt;st&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; d-&gt;num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = st::<span class="built_in">New</span>();</span><br><span class="line">    p-&gt;<span class="built_in">f1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，当下面👇这些场景用到 shared_ptr 时，需要搭配上 enable_shared_from_this:</p><ul><li>当你需要将this指针传递给其他函数或方法，而这些函数或方法需要一个std::shared_ptr，而不是裸指针。</li><li>当你需要在类的成员函数内部创建指向当前对象的std::shared_ptr，例如在回调函数或事件处理中。</li></ul><p>手敲智能指针是面试常见的题目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr), count_(ptr ? new size_t(<span class="number">1</span>) : nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr_</span>(other.ptr_), <span class="built_in">count_</span>(other.count_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count_) &#123;</span><br><span class="line">            ++(*count_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr_ = other.ptr_;</span><br><span class="line">            count_ = other.count_;</span><br><span class="line">            <span class="keyword">if</span> (count_) &#123;</span><br><span class="line">                ++(*count_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_ ? *count_ : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count_ &amp;&amp; --(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* ptr_;</span><br><span class="line">    <span class="type">size_t</span>* count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass 构造函数\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass 析构函数\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyClass::do_something() 被调用\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SimpleSharedPtr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            SimpleSharedPtr&lt;MyClass&gt; ptr2 = ptr1;</span><br><span class="line">            ptr1-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">            ptr2-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr">https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr</a></li></ul><h3 id="5-说说STL容器中的智能指针？"><a href="#5-说说STL容器中的智能指针？" class="headerlink" title="5. 说说STL容器中的智能指针？"></a>5. 说说STL容器中的智能指针？</h3><p>具备<strong>独占所有权语义</strong>的智能指针不能在STL的容器中使用，如auto_ptr和unique_ptr，因为STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，容易导致错误，而unique_ptr又不支持普通的拷贝和赋值操作，也不能用在STL标准容器中。</p><h3 id="6-说说lambda函数？"><a href="#6-说说lambda函数？" class="headerlink" title="6. 说说lambda函数？"></a>6. 说说lambda函数？</h3><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象。每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，该实例是一个右值。lambda的优点有以下几点：</p><p>(1) <strong>距离</strong>：很多人认为，让定义位于使用的地方附近很有用。这样，就无需翻阅很多页的源代码，以了解函数。另外，如果需要修改代码，设计的内容就在附近，就很好修改。</p><p>(2) <strong>简洁</strong>：函数符代码要比lambda代码更加繁琐，函数和lambda的简洁程度相当。</p><p>(3) <strong>功能</strong>：lambda可以访问作用域内的任何动态变量，可以采用取值、引用的形式进行捕获。</p><h3 id="7-什么是声明时初始化？"><a href="#7-什么是声明时初始化？" class="headerlink" title="7. 什么是声明时初始化？"></a>7. 什么是声明时初始化？</h3><p>C++11新增了<strong>类成员初始化新机制</strong>——声明时初始化，可以直接在类中声明数据成员时就进行初始化操作，而不用借助构造函数或者初始化列表。</p><h3 id="8-C-11添加哪几种构造函数关键字？"><a href="#8-C-11添加哪几种构造函数关键字？" class="headerlink" title="8. C++11添加哪几种构造函数关键字？"></a>8. C++11添加哪几种构造函数关键字？</h3><p>(1) default关键字可以显式要求编译器生成默认构造函数，防止在调用时相关构造函数没有定义而报错。</p><p>(2) delete关键字可以删除构造函数、赋值运算符函数等，在使用时编译器会报错</p><h3 id="9-说说C-的左值和右值？"><a href="#9-说说C-的左值和右值？" class="headerlink" title="9. 说说C++的左值和右值？"></a>9. 说说C++的左值和右值？</h3><p>(1) 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。</p><p>(2) 在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p><p>(3) 纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和字面量值；将亡值则是C++11新增的新右值，它表示该对象的内存空间接下来会被其他对象接管。通过这种接管空间的方式可以避免内存空间的释放和分配，延长变量值的生命期。</p><p>(4) C++11对于引用了也有了新的解释。传统的C++引用被称为<strong>左值引用</strong>，符号为&amp;，他关联的是左值。C++11中增加了<strong>右值引用</strong>，符号为&amp;&amp;。<strong>右值引用会关联到右值</strong>，右值被存储到特定位置，右值引用会指向该特定位置，也就是说，<strong>右值虽然无法获取地址，但是右值引用是可以获取地址的</strong>，该地址表示临时对象的存储位置。使用std::move可以使一个左值转换为右值引用。</p><h3 id="10-说说移动构造函数？"><a href="#10-说说移动构造函数？" class="headerlink" title="10. 说说移动构造函数？"></a>10. 说说移动构造函数？</h3><p>(1) 移动构造是C++11标准中提供的一种新的构造方法，用来给予程序员新的构造选择，用以替换拷贝构造。</p><p>(2) 拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，拷贝的内存越大越耗费时间，并且进行了深拷贝，就需要给对象分配地址空间。</p><p>(3) 移动构造函数会直接接管源对象空间，既不会产生额外的拷贝开销，也不会给新对象分配内存空间。提高程序的执行效率，节省内存消耗。</p><p>(4) 移动构造函数的参数必须是<strong>自身类型的右值引用</strong>，也就是说能调用移动构造函数的参数必然是个右值（纯右值和将亡值）。</p><h3 id="11-什么是列表初始化？"><a href="#11-什么是列表初始化？" class="headerlink" title="11. 什么是列表初始化？"></a>11. 什么是列表初始化？</h3><p>列表初始化是C++ 11新引进的初始化方式，它采用一对花括号（即<strong>｛｝</strong>）进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化。</p><h3 id="12-初始化列表和列表初始化的区别？"><a href="#12-初始化列表和列表初始化的区别？" class="headerlink" title="12.初始化列表和列表初始化的区别？"></a>12.初始化列表和列表初始化的区别？</h3><p>(1) 初始化列表是在创建类对象时，对类对象内部的数据成员进行的一种初始化方式，具体用在类的构造函数中。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="1-什么是STL？"><a href="#1-什么是STL？" class="headerlink" title="1.什么是STL？"></a>1.什么是STL？</h3><p>Standard Template Library（标准模板库），是C++的标准库之一，它是一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。STL包含6大部件：<strong>容器、迭代器、算法、仿函数、适配器和空间配置器</strong>。</p><h3 id="2-SGI的二级空间配置器了解吗？"><a href="#2-SGI的二级空间配置器了解吗？" class="headerlink" title="2.SGI的二级空间配置器了解吗？"></a>2.SGI的二级空间配置器了解吗？</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/331809729">5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码</a></li><li><a href="https://blog.csdn.net/xiajun07061225/article/details/8807890">【STL深入学习】SGI STL空间配置器详解（二）-第二级空间配置器</a></li></ul><p>(1) 对象构造前的空间配置和对象析构后的空间释放，由<stl_alloc.h>负责，SGI设计了<strong>双层级配置器</strong>：</p><p>①　第一级空间配置器直接使用malloc和free，如果在申请动态内存时找不到足够大的内存块，将返回NULL 指针，宣告内存申请失败。</p><p>②　第二级空间配置器视情况使用不同的策略，当申请内存大于128字节时，调用第一级配置器。当申请内存小于128b字节时，采用内存池方式，维护16个（128/8）自由链表，每个链表维护8字节大小的内存块，从中进行内存分配，如果内存不足转第一级配置器处理。</p><p>(2) <strong>二级空间配置器存在的问题</strong>：</p><p>①　自由链表所挂区块都是8的整数倍，因此当我们需要非8倍数的区块，往往会导致浪费。</p><p>②　由于配置器的链表都是静态变量，他们存放在全局/静态区，其释放时机就是程序结束，这样子会导致自由链表一直占用内存。</p><h3 id="3-traits技法"><a href="#3-traits技法" class="headerlink" title="3.traits技法?"></a>3.traits技法?</h3><p>入门案例：</p><p>在C++中，traits（特性）是一种常用的技术，主要用于在编译期间获取类型的信息。通过traits，我们可以编写出更加通用、灵活的代码。</p><p>下面是一个简单的traits的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个traits模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTraits</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，我们假设类型T不是一个指针</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_pointer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针类型进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTraits</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="comment">// 对于指针类型，我们设定is_pointer为true</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_pointer = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MyTraits&lt;<span class="type">int</span>&gt;::is_pointer &lt;&lt; endl;  <span class="comment">// 输出0，表示int不是指针</span></span><br><span class="line">    cout &lt;&lt; MyTraits&lt;<span class="type">int</span>*&gt;::is_pointer &lt;&lt; endl; <span class="comment">// 输出1，表示int*是指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们定义了一个名为 <code>MyTraits</code> 的模板，并对指针类型进行了特化。通过 <code>MyTraits</code>，我们可以在编译期间判断一个类型是否是指针类型。</p><p>除了这个简单的例子，traits还有很多其他的应用，例如获取一个类型的大小、判断一个类型是否是const类型、获取一个容器的迭代器类型等等。通过traits，我们可以更好地抽象和封装代码，提高代码的复用性和灵活性。</p><h3 id="4-说说STL中的容器？"><a href="#4-说说STL中的容器？" class="headerlink" title="4.说说STL中的容器？"></a>4.说说STL中的容器？</h3><p>(1) <strong>vector</strong></p><p>①　vector底层是一个动态数组，包含三个迭代器：start、finish、end_of_storage。start和finish之间是已经被使用的空间范围，表示当前vector中有多少个元素，即有效空间size。start和end_of_storage是整块连续空间包括备用空间的大小，表示它分配的内存中可以容纳多少元素，即容量capacity。</p><p>②　<strong>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍）</strong>，然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间。之所以是1.5倍或者2倍，是因为考虑到可能产生的堆空间浪费，增长倍数不能太大，使用1.5或者2是比较合理的倍数。</p><p>③　当释放或者删除（vec.clear()）里面的数据时，其<strong>存储空间不释放</strong>，仅仅是清空了里面的数据。</p><p>④　对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器都会失效。</p><p>⑤　reserve函数的作用：将vector直接扩充到确定的大小，可以减少多次开辟和释放空间的效率问题（优化push_back），还可以减少拷贝数据的次数，<strong>它直接更改capacity</strong>。</p><p>⑥　resize()函数的作用：<strong>可以改变vector有效空间的大小，即size的大小</strong>。如果size大于capacity，capacity的大小也会随着改变。</p><p>⑦　vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此<strong>vector的元素类型不能是引用</strong>。</p><p>⑧　当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。<strong>erase方法会返回下一个有效的迭代器</strong>。</p><p>⑨　释放vector内存的方法：</p><p><strong>vec.clear()：</strong>清空内容，但是不释放内存。</p><p><strong>vector().swap(vec)：</strong>清空内容，且释放内存，想得到一个全新的vector。</p><p><strong>vec.shrink_to_fit()：</strong>请求容器降低其capacity和size匹配。</p><p><strong>vec.clear();vec.shrink_to_fit();：</strong>清空内容，且释放内存。</p><p>(2) <strong>List</strong></p><p>①　list的底层是一个双向链表，以结点为单位存放数据，<strong>结点的地址在内存中不一定连续</strong>，每次插入或删除一个元素，就配置或释放一个元素空间。</p><p>②　list不支持随机存取，如果需要大量的插入和删除，而不关心随机存取，则可以使用list。</p><p>(3) <strong>Deque</strong></p><p>①　deque的是一个<strong>双向开口的连续线性空间（双端队列）</strong>，在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</p><p>②　deque的底层并不是真正连续的空间，而是由一段段连续的小空间拼接而成，实际<strong>deque类似于一个动态的二维数组</strong>，由一个map（中控指针数组）和多个连续的缓冲区组成。</p><p>③　当deque不断增加元素时，一旦map（中控指针数组）满了，那么会增容，不过<strong>map增容的代价非常低，因为只需要拷贝存储数据的buffer数组的指针，不需要拷贝buffer中的内容</strong>。</p><p>④　双端队列底层是一段假象的连续空间，实际是<strong>分段连续</strong>的，为了维护其“整体连续”以及随机访问的假象，deque的迭代器设计就比较复杂。<strong>由cur、first、last指向当前遍历buffer数组，node指向map中的元素</strong>，遍历deque的操作由这几个指针进行维护。</p><p>⑤　deque并不是从map的第一个位置就开始存放元素，而是从中间开始存放，这样在头部和尾部插入元素就会变得容易。</p><p>⑥　与vector比较：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。</p><p>⑦　与list比较：其底层是连续空间，空间利用率比较高，不需要存储额外字段。</p><p>⑧　不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下。不适合大量的中间插入删除，也不适合大量的随机访问。</p><p>(4) <strong>map 、set、multiset、multimap</strong></p><p>①　底层数据结构都是红黑树，是一种自平衡的二叉搜索树</p><p>②　set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。</p><p>③　map和multimap将key和value组成的键值对作为元素，根据key的排序准则自动将元素排序，map中元素的key不允许重复，multimap可以重复。</p><p>④　map和set的增删改查速度为都是logn，是比较高效的。</p><p>⑤　map和set的插入删除效率比序列容器高，而且每次insert之后，以前保存的iterator不会失效。因为存储的是结点，不需要内存拷贝和内存移动。</p><p>(5) <strong>unordered_map、unordered_set</strong></p><p>①　底层数据结构是一个防冗余的哈希表（采用除留余数法）。其数据的存储和查找的效率很高，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。</p><p>②　使用开链法解决哈希冲突。</p><p>③　数据的存放是无序的</p><h3 id="5-什么是STL的顺序容器和关联式容器？"><a href="#5-什么是STL的顺序容器和关联式容器？" class="headerlink" title="5. 什么是STL的顺序容器和关联式容器？"></a>5. 什么是STL的顺序容器和关联式容器？</h3><p>(1) 关联容器(Associative Container)与顺序容器(Sequential Container)的本质区别在于：<strong>关联容器是通过键(key)存储和读取元素的，而顺序容器则通过元素在容器中的位置顺序存储和访问元素</strong>。</p><p>(2) 在STL中，这里的“顺序”和“关联”指的是<strong>上层接口表现出来的访问方式</strong>，并非底层存储方式。为什么这样划分呢？因为对STL的用户来说，他们并不需要知道容器的底层实现机制，只要知道如何通过上层接口访问容器元素就可以了，否则违背了泛型容器设计的初衷。</p><p>(3) 顺序容器主要采用向量和链表及其组合作为基本存储结构，如堆栈和各种队列。而关联式容器采用平衡二叉搜索树作为底层存储结构。</p><h3 id="6-说说STL的容器适配器？"><a href="#6-说说STL的容器适配器？" class="headerlink" title="6. 说说STL的容器适配器？"></a>6. 说说STL的容器适配器？</h3><p>容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现都是通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。</p><p>(1) <strong>stack</strong></p><p>①　stack（栈）是一种<strong>先进后出（First In Last Out）</strong>的数据结构，只有一个出入口，那就是栈顶，除了对栈顶元素进行操作外，没有其他方法可以操作内部的其他元素。</p><p>②　C++的栈是一种<strong>容器适配器</strong>，其底层数据结构一般用<strong>list或deque</strong>实现，只开放一部分的接口和方法即可完成对栈的支持。</p><p>(2) <strong>queue</strong></p><p>①　queue（队列）是一种<strong>先进先出（First In First Out）</strong>的数据结构，只有一个入口和一个出口，分别位于队头与队尾，只能在队尾插入元素，在队头取出元素，没有其他方法可以操作内部的其他元素。</p><p>②　C++的队列是一种<strong>容器适配器</strong>，其底层数据结构一般用<strong>list或deque</strong>实现，只开放一部分的接口和方法即可完成对队列的支持。</p><p>(3) <strong>priority_queue</strong></p><p>①　priority_queue，优先级队列，是一个<strong>拥有权值观念的queue</strong>，它跟queue一样只能在队尾插入元素，在队头取出元素。在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面。</p><p>②　priority queue（优先队列）的底层实现机制实际上是<strong>堆</strong>，因为大根堆总是最大值位于堆的根部，优先级最高。</p><p>③　C++中的堆是容器适配器，一般是vector为底层容器，以堆的处理规则来进行管理。</p><h3 id="7-说说STL的迭代器？"><a href="#7-说说STL的迭代器？" class="headerlink" title="7. 说说STL的迭代器？"></a>7. 说说STL的迭代器？</h3><p>(1) <strong>迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。</strong></p><p>(2) 在遍历容器的时候，不可避免的要对遍历的容器内部有所了解，所以，干脆把迭代器的开发工作交给容器的设计者好了，如此以来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种 STL 容器都提供有专属迭代器的缘故。</p><p>(3) 迭代器种类分为5类：</p><p>①　<strong>输入迭代器：</strong>是只读迭代器，在每个被遍历的位置上只能读取一次。</p><p>②　<strong>输出迭代器：</strong>是只写迭代器，在每个被遍历的位置上只能被写一次。</p><p>③　<strong>前向迭代器：</strong>兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持operator–，所以只能向前移动。</p><p>④　<strong>双向迭代器：</strong>很像前向迭代器，只是它向后移动和向前移动同样容易。</p><p>⑤　<strong>随机访问迭代器：</strong>有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置， 包含指针的所有操作，可进行随机访问，随意移动指定的步数。</p><p>(5) 通过traits技法，我们可以获取到迭代器一些特性，STL规定，每一个迭代器至少包含以下几种特性供外界获取，方便算法使用迭代器。</p><p>①　<strong>value_type：</strong>迭代器所指对象的类型</p><p>②　<strong>difference_type：</strong>两个迭代器之间的距离</p><p>③　<strong>pointer：</strong>迭代器所指对象的指针类型</p><p>④　<strong>reference：</strong>迭代器所指对象的引用类型</p><p>⑤　<strong>iterator_category：</strong>迭代器种类</p><p>(6) 迭代器失效问题</p><p>①　<strong>数组型数据结构（vector）：</strong>该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert( <em> iter)(或erase( </em> iter))，然后再iter++，是没有意义的。解决方法：erase( * iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter)。</p><p>②　<strong>链表型数据结构：</strong>对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase( * iter)会返回下一个有效迭代器的值，或者erase(iter++)。</p><p>③　<strong>树形数据结构：</strong> 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p><p>④　<strong>Deque：</strong>插入头尾会使<strong>迭代器全部失效但是引用不失效</strong>。其原因在于插入头尾可能会进行扩容，由于map的重新分配，迭代器的node失效，但是原map指向的连续数组并没有重新分配。因此，对整个迭代器来说是失效的，但对于元素的指针和引用仍然是有效的。<strong>删除头尾会使被删除的元素迭代器和引用失效，插入和删除中间会使迭代器和引用全部失效。</strong></p><p>⑤　<strong>unodered_map/unordered_set：</strong>由于底层是哈希表，迭代器是否失效主要看哈希表的实现策略，对于使用<strong>除留余数法和开链法</strong>的哈希表来说，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p><h3 id="8-说说STL容器的线程安全性？"><a href="#8-说说STL容器的线程安全性？" class="headerlink" title="8. 说说STL容器的线程安全性？"></a>8. 说说STL容器的线程安全性？</h3><p><strong>STL只保证最低限度的线程安全性，即：</strong>多个读者是安全的，多线程可以同时读取一个容器的内容，但如果有多个写者，则必须使用同步互斥机制保证线程安全。</p><h3 id="9-STL容器的使用场景？"><a href="#9-STL容器的使用场景？" class="headerlink" title="9. STL容器的使用场景？"></a>9. STL容器的使用场景？</h3><p>(1) vector的使用场景：只查看，而不频繁插入删除的</p><p>(2) deque的使用场景：头尾需要频繁插入删除</p><p>(3) list的使用场景：频繁的插入删除的场景，且位置不固定</p><p>(4) Set：针对单一值的增删查改操作都要有，且要求数据有序</p><p>(5) Map：针对键值对的增删查改操作都要有，且要求数据有序</p><p>(6) unordered_set：针对单一值的增删查改操作都要有，数据排列无要求。</p><p>(7) unordered_map：针对键值对的增删查改操作都要有，数据排列无要求。</p>]]></content>
    
    
    <summary type="html">Cpp基础部分</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>tinyxml:解析XML格式文件</title>
    <link href="https://penge666.github.io/posts/60c6b3ce.html"/>
    <id>https://penge666.github.io/posts/60c6b3ce.html</id>
    <published>2024-05-13T08:58:25.000Z</published>
    <updated>2024-05-13T08:58:31.967Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>gdb调试总结</title>
    <link href="https://penge666.github.io/posts/df73e2d8.html"/>
    <id>https://penge666.github.io/posts/df73e2d8.html</id>
    <published>2024-05-13T08:18:27.000Z</published>
    <updated>2024-05-13T08:54:18.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>GDB</strong> (全称为GNU Debuger) 是一款由 GNU 开源组织发布、基于 UNIX/LINUX 操作系统的<strong>命令行程序调试工具</strong>。对于一名 Linux 下工作的 C++ 程序员，GDB 是必不可少的工具。</p><h2 id="GDB常用调试命令">GDB常用调试命令</h2><p>为了便于讲解，将通过以下 demo 进行举例说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>１．启动 GDB</strong></p><p>对于 C/C++ 程序调试，<strong>需要在编译前加入 -g 参数选项，表示加入一些调试信息。这样在编译后生成的可执行文件才能使用 GDB 进行调试</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g main.cpp -o demo  <span class="comment">// 生成可执行文件</span></span><br></pre></td></tr></table></figure><p>启动 GDB 命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb demo  <span class="comment">// 启动 GDB 调试</span></span><br></pre></td></tr></table></figure><p>效果如图 1 所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ gdb main</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p><strong>2. 终端列出源代码</strong></p><p>我们可以在终端列出要调试的代码，这样可以不用打开源文件查看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list  <span class="comment">// 执行一次列出 10 行代码，再执行一次列出后面 10 行代码</span></span><br></pre></td></tr></table></figure><p>效果如图 2 所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) list</span><br><span class="line">1       <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">2       using namespace std;</span><br><span class="line">3       int add(int a,int b)&#123;</span><br><span class="line">4           int <span class="built_in">sum</span> = 0;</span><br><span class="line">5           <span class="built_in">sum</span> = a + b;</span><br><span class="line">6           <span class="built_in">return</span> <span class="built_in">sum</span>;</span><br><span class="line">7       &#125;</span><br><span class="line">8       int main(int argc,char *argv[])&#123;</span><br><span class="line">9           int <span class="built_in">sum</span> = 0;</span><br><span class="line">10          <span class="built_in">sum</span> = add(1, 2);</span><br><span class="line">(gdb)</span><br><span class="line">11          cout &lt;&lt; <span class="string">sum &lt;&lt; endl;</span></span><br><span class="line"><span class="string">12          return 0;</span></span><br><span class="line"><span class="string">13      &#125;</span></span><br></pre></td></tr></table></figure><p><strong>3. 设置断点</strong></p><p>断点是程序调试的关键所在，随心所欲地设置断点使我们调试程序变得高效。</p><p>断点打在源程序第 n 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> n  <span class="comment">// 在源程序第 n 行设置一个断点，break 可以用 b 缩写替代</span></span><br></pre></td></tr></table></figure><p>断点打在源程序 main() 函数入口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> main  <span class="comment">// 在 main() 函数入口打断点，也就是第 9 行，break 可以用 b 缩写替代</span></span><br></pre></td></tr></table></figure><p>上面是打在源文件的函数入口，<strong>若要将断点打在其他文件的函数入口或者其他文件的特定行号应该怎么做呢？</strong></p><p>下面的命令可以解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> otherfile:func  <span class="comment">// 断点打在其他文件的函数入口</span></span><br><span class="line"><span class="keyword">break</span> otherfile:n     <span class="comment">// 断点打在其他文件的第 n 行</span></span><br><span class="line"><span class="comment">// 注：otherfile 为其他文件，例如 sort.cpp，而 n 代表行号</span></span><br></pre></td></tr></table></figure><p>我们还可以查看我们所有打的断点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="keyword">break</span>  <span class="comment">// 列出我们所有打的断点的信息，break 可以用 b 缩写替代</span></span><br></pre></td></tr></table></figure><p>除了设置断点外，我们还能删除指定断点或者删除全部断点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>    <span class="comment">// 删除全部断点</span></span><br><span class="line"><span class="keyword">delete</span> n  <span class="comment">// 删除指定断点，n 表示断点号</span></span><br></pre></td></tr></table></figure><p>还有使能和失能断点，失能表示这个断点不会删除，只是暂时失作用，可以理解为屏蔽。若想再次启用可以直接使能，断点功能恢复，不用去重新打断点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable n  <span class="comment">// 失能第 n 个断点</span></span><br><span class="line">enable n   <span class="comment">// 使能第 n 个断点</span></span><br></pre></td></tr></table></figure><p>效果如图 3 所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x11ce: file main.cpp, line 8.</span><br><span class="line">(gdb) b 10</span><br><span class="line">Breakpoint 2 at 0x11e8: file main.cpp, line 10.</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000000011ce <span class="keyword">in</span> main(int, char**) at main.cpp:8</span><br><span class="line">2       breakpoint     keep y   0x00000000000011e8 <span class="keyword">in</span> main(int, char**) at main.cpp:10</span><br><span class="line">(gdb) delete</span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) info b</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure><p><strong>4. 运行程序</strong></p><p>运行程序命令与我们 IDE 调试程序类似，两者可以作对比。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run  <span class="comment">// 类比于 IDE 的全速运行，遇到断点会停下，run 可以用 r 缩写替代</span></span><br><span class="line">next <span class="comment">// 类比于 IDE 不进入函数的单步调试，next 可以用 n 缩写替代</span></span><br><span class="line">step <span class="comment">// 类比于 IDE 进入函数的单步调试，step 可以用 s 缩写替代</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 继续执行直到遇到下一个断点停下，没有断点直接结束，可以用 c 缩写替代</span></span><br><span class="line">until n  <span class="comment">// 直接跳转到指定行号程序，n 表示行号</span></span><br><span class="line">finish   <span class="comment">// 当程序运行在函数中时，直接执行完当前函数并打印函数返回信息</span></span><br><span class="line">kill  <span class="comment">// 直接结束当前进程，程序可以从头运行</span></span><br><span class="line">quit  <span class="comment">// 退出 GDB，quit 可以用 q 缩写替代</span></span><br></pre></td></tr></table></figure><p><strong>5.打印信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print x  <span class="comment">// 可以打印变量、地址、表达式值等，x 表示需要打印的东西，print 可以用 p 替代</span></span><br><span class="line">bt  <span class="comment">// 打印当前调用堆栈的信息，后面会继续讲</span></span><br></pre></td></tr></table></figure><p>GDB 的常用调试命令基本上就这些，而且都有缩写表示，非常好记忆的！</p><h2 id="GDB调试core文件">GDB调试core文件</h2><p>Linux应用程序发生<code>Segmentation fault</code>段错误时，需要利用<code>core dump</code>文件定位错误。</p><p>段错误segmentation fault，信号SIGSEGV，是由于访问内存管理单元MMU异常所致，通常由于无效内存引用，如指针引用了一个不属于当前进程地址空间中的地址，操作系统便会进行干涉引发SIGSEGV信号产生段错误。</p><p><strong>段错误产生的原因</strong></p><ul><li>空指针</li><li>野指针</li><li>堆栈越界</li><li>…</li></ul><p><strong>核心转储</strong></p><p>在 Linux 系统中，常<strong>将“主内存”称为核心(<code>core</code>)，<strong>而</strong>核心映像(<code>core image</code>) 就是 “进程”(process)执行当时的内存内容。</strong></p><p>当进程发生错误或收到“信号”(signal) 而终止执行时，<strong>系统会将核心映像写入一个文件</strong>，以作为调试之用，这就是所谓的<strong>核心转储(<code>core dump</code>)。</strong></p><p>【简单解释】当在一个程序崩溃时，系统会在指定目录下生成一个<code>core</code>文件，我们就可以通过<code> core</code>文件来对造成程序崩贵的原因进行调试定位。</p><p><strong>1. 产生 Segmentation fault 程序</strong></p><p>下面是一个<strong>没有递归终止条件</strong>的程序，显然会发生 Segmentation fault 错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -o main main.cpp -lpthread -fpermissive</span><br><span class="line">main.cpp: In <span class="keyword">function</span> ‘int recursion(int)’:</span><br><span class="line">main.cpp:5:1: warning: no <span class="built_in">return</span> statement <span class="keyword">in</span> <span class="keyword">function</span> returning non-void [-Wreturn-<span class="built_in">type</span>]</span><br><span class="line">    5 | &#125;</span><br><span class="line">      | ^</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./main</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>此时编译运行的时候是没有 core 文件的，是因为我们没有配置生成 core 文件。</p><p><strong>2. 生成 core 文件</strong></p><p>**Core 文件是一种特殊的文件类型，通常在程序崩溃时由操作系统生成。它包含了程序崩溃时的内存镜像和程序状态信息，**比如程序计数器、堆栈指针、寄存器状态等。这些信息可以用来调试程序，找出导致程序崩溃的原因。</p><p>Core 文件的名字通常为 “core”，但也可以通过操作系统的设置来改变。在 Unix 和类 Unix 系统（比如 Linux）中，你可以使用 <code>ulimit</code> 命令来控制是否生成 core 文件，以及 core 文件的大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们先使用如下命令查看 core 文件大小，若结果为 0 表示还没有生成 core 文件。</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulimit</span> -c  // 查看 core 文件大小</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="meta">@sv</span>-NF5280M5:/home/sv/桌面$ ulimit -c</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(base) sv<span class="meta">@sv</span>-NF5280M5:/home/sv/桌面$ ulimit -a</span><br><span class="line">core file <span class="title function_">size</span>          <span class="params">(blocks, -c)</span> <span class="number">0</span></span><br><span class="line">data seg <span class="title function_">size</span>           <span class="params">(kbytes, -d)</span> unlimited</span><br><span class="line">scheduling <span class="title function_">priority</span>             <span class="params">(-e)</span> <span class="number">0</span></span><br><span class="line">file <span class="title function_">size</span>               <span class="params">(blocks, -f)</span> unlimited</span><br><span class="line">pending <span class="title function_">signals</span>                 <span class="params">(-i)</span> <span class="number">255799</span></span><br><span class="line">max locked <span class="title function_">memory</span>       <span class="params">(kbytes, -l)</span> <span class="number">65536</span></span><br><span class="line">max memory <span class="title function_">size</span>         <span class="params">(kbytes, -m)</span> unlimited</span><br><span class="line">open <span class="title function_">files</span>                      <span class="params">(-n)</span> <span class="number">1024</span></span><br><span class="line">pipe <span class="title function_">size</span>            <span class="params">(<span class="number">512</span> bytes, -p)</span> <span class="number">8</span></span><br><span class="line">POSIX message <span class="title function_">queues</span>     <span class="params">(bytes, -q)</span> <span class="number">819200</span></span><br><span class="line">real-time <span class="title function_">priority</span>              <span class="params">(-r)</span> <span class="number">0</span></span><br><span class="line">stack <span class="title function_">size</span>              <span class="params">(kbytes, -s)</span> <span class="number">8192</span></span><br><span class="line">cpu <span class="title function_">time</span>               <span class="params">(seconds, -t)</span> unlimited</span><br><span class="line">max user <span class="title function_">processes</span>              <span class="params">(-u)</span> <span class="number">255799</span></span><br><span class="line">virtual <span class="title function_">memory</span>          <span class="params">(kbytes, -v)</span> unlimited</span><br><span class="line">file <span class="title function_">locks</span>                      <span class="params">(-x)</span> unlimited</span><br></pre></td></tr></table></figure><p>使用如下命令修改 core 文件大小不受限制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited  <span class="comment">// 修改 core 文件大小不受限制</span></span><br></pre></td></tr></table></figure><p>但是以下并未查找到core文件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>g++ -g -o main main.cpp -lpthread -fpermissive</span><br><span class="line">main.<span class="symbol">cpp:</span> <span class="title class_">In</span> function ‘int recursion(int)’:</span><br><span class="line">main.<span class="symbol">cpp:</span><span class="number">5</span><span class="symbol">:</span><span class="number">1</span>: <span class="symbol">warning:</span> no <span class="keyword">return</span> statement <span class="keyword">in</span> function returning non-void [-<span class="title class_">Wreturn</span>-type]</span><br><span class="line">    <span class="number">5</span> |<span class="params"> &#125;</span></span><br><span class="line"><span class="params">      </span>| ^</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>./main</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>ls</span><br><span class="line"><span class="string">&#x27;未命名 1.ods&#x27;</span>  <span class="string">&#x27;未命名 2.odt&#x27;</span>   lu3018gtmnzo.tmp   main.c     params.odt</span><br><span class="line"><span class="string">&#x27;未命名 1.odt&#x27;</span>   index.html      main               main.cpp   proxy.txt</span><br></pre></td></tr></table></figure><p>但是当前目录下<strong>没有看到core文件的生成</strong>。</p><p>这是因为<strong>core文件的默认生成路径不对</strong>，只要发生段错误时，括号里出现了<code>core dumped</code>就代表<code>core</code>文件已生成。</p><p>可以通过以下命令查看<code>core</code>文件的存放路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>sys<span class="regexp">/kernel/</span>core_pattern</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ <span class="built_in">cat</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p><strong>修改<code>core</code>文件生成路径为当前目录下</strong>，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">&quot;echo core &gt; /proc/sys/kernel/core_pattern &quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意使用root用户权限</p></blockquote><p>修改后，<code>core</code>文件就会在当前目录下生成。</p><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base) sv@sv-NF5280M5:/home/sv/桌面$ <span class="built_in">ls</span></span><br><span class="line"><span class="string">&#x27;未命名 1.ods&#x27;</span>  <span class="string">&#x27;未命名 2.odt&#x27;</span>   index.html         main     main.cpp     proxy.txt</span><br><span class="line"><span class="string">&#x27;未命名 1.odt&#x27;</span>   core            lu3018gtmnzo.tmp   main.c   params.odt</span><br></pre></td></tr></table></figure><p><strong>3.调试 core 文件</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>gdb main core</span><br></pre></td></tr></table></figure><p>接下来可以打印当前堆栈信息分析问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtrace  <span class="comment">// 打印当前堆栈信息，backtrace 可以用 bt 的缩写替代</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>           <span class="selector-tag">recursion</span>(n - <span class="number">1</span>);</span><br><span class="line">(gdb) <span class="selector-tag">bt</span></span><br><span class="line"><span class="selector-id">#0</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74180</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261907</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#1</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261906</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#2</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261905</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#3</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261904</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#4</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261903</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#5</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261902</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#6</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261901</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#7</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261900</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#8</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261899</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#9</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261898</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#10</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261897</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#11</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261896</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#12</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261895</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#13</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261894</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#14</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261893</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#15</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261892</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#16</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261891</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#17</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261890</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#18</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261889</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#19</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261888</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#20</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261887</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure><p>常使用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bt 或 backtrace: 显示当前线程的调用栈跟踪。</span><br><span class="line">info threads: 列出所有线程。</span><br><span class="line">thread n: 切换到指定的线程号，n为指定的线程号</span><br><span class="line">list: 显示当前执行的源代码。</span><br><span class="line"><span class="built_in">print</span> x: 打印变量或表达式的值，x为变量或表达式</span><br><span class="line">frame f: 切换到特定的栈帧。f为指定的栈帧号</span><br><span class="line">thread apply all bt: 打印所有堆栈信息</span><br></pre></td></tr></table></figure><p>参考文献</p><ul><li><a href="https://blog.csdn.net/weixin_44046545/article/details/138252207">一篇文章轻松学会使用gdb调试程序的core文件（调试全过程）</a></li><li><a href="https://www.kancloud.cn/wizardforcel/gdb-tips-100">https://www.kancloud.cn/wizardforcel/gdb-tips-100</a></li><li>[<a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/08/19/cpluscplus-gdbusage_part2">GDB调试多线程及多进程</a>](<a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/08/19/cpluscplus-gdbusage_part2">GDB调试多线程及多进程</a>)</li></ul>]]></content>
    
    
    <summary type="html">GDB调试</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux实战技能</title>
    <link href="https://penge666.github.io/posts/a9ea3099.html"/>
    <id>https://penge666.github.io/posts/a9ea3099.html</id>
    <published>2024-05-10T14:29:26.000Z</published>
    <updated>2024-05-11T09:39:55.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>发烧了2天，掉了一天的水，烧的快见太奶了。</p><p>Last，纵使人生百般滋味，也要笑对！！！</p><h2 id="Linux背景介绍">Linux背景介绍</h2><h3 id="Linux版本">Linux版本</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内核版本：</span><br><span class="line"></span><br><span class="line"><span class="symbol">https:</span>//www.kernel<span class="meta">.org</span> </span><br></pre></td></tr></table></figure><p>内核版本分为三个部分，主版本号、次版本号、末版本号，次版本号是奇数为开发板，偶数为稳定版</p><p>发行版本</p><p>RedHat：经过专业测试</p><p>Fedora：社区发行，版本较新，但是没有经过专业测试。（也是redhat发行）</p><p>CentOS：用RedHat的源代码编译，但是把RedHat的商标等去掉。但是没有一些技术支持</p><p>桌面安装：Debian，Ubuntu</p><h3 id="常见目录">常见目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/  根目录</span><br><span class="line">/root  root用户的家目录</span><br><span class="line">/home/username  普通用户的家目录</span><br><span class="line">/etc  配置文件目录</span><br><span class="line">/bin  命令目录</span><br><span class="line">/sbin  管理命令目录</span><br><span class="line">/usr/bin/usr/sbin  系统预装的其他命令</span><br></pre></td></tr></table></figure><p><strong>sbin和bin命令的区别</strong></p><p><code>sbin</code>和<code>bin</code>都是Linux文件系统中的重要目录，它们分别存放了系统的重要可执行文件。这两个目录的主要区别在于，它们各自存放的命令的使用者不同。</p><ul><li><code>bin</code>目录：这个目录存放的是所有用户都可以运行的命令。这些命令包括很多基本的Linux命令，如ls、cp、rm等。<code>bin</code>是“binary”的缩写，意为二进制，表示这个目录下存放的都是可执行的二进制文件。</li><li><code>sbin</code>目录：这个目录存放的是系统管理员（root用户）才能运行的命令。这些命令一般都是和系统管理有关的，如fdisk、ifconfig等。<code>sbin</code>是“system binary”的缩写，表示这个目录下存放的都是系统命令的二进制文件。</li></ul><p>总的来说，<code>bin</code>和<code>sbin</code>的区别在于，<code>bin</code>目录下的命令是给所有用户使用的，而<code>sbin</code>目录下的命令则是给系统管理员使用的。</p><p>另外，除了根目录下的<code>/bin</code>和<code>/sbin</code>，在<code>/usr</code>目录下也有<code>/usr/bin</code>和<code>/usr/sbin</code>两个目录。它们的作用和根目录下的<code>/bin</code>、<code>/sbin</code>类似，只不过<code>/usr/bin</code>和<code>/usr/sbin</code>中的命令是非必需的，也就是说，系统可以在没有这些命令的情况下正常运行。</p><h2 id="系统操作">系统操作</h2><h3 id="帮助命令">帮助命令</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span> 是 manual 的缩写</span><br><span class="line"><span class="keyword">man</span> 帮助用法演示</span><br><span class="line">    #<span class="keyword">man</span> <span class="keyword">ls</span></span><br><span class="line"><span class="keyword">man</span> 也是一条命令，分为9章，可以使用<span class="keyword">man</span>命令获得<span class="keyword">man</span>的帮助</span><br><span class="line">    #<span class="keyword">man</span> 7 <span class="keyword">man</span></span><br></pre></td></tr></table></figure><p><strong>man命令</strong></p><p><code>man 1 kill</code>、<code>man 2 kill</code>，这些命令都是查看 kill 命令的手册，但是文档却大不相同。</p><p><strong>因为 kill 是一个命令行的工具，<code>which kill</code> 看到 /usr/bin/kill 是一个二进制文件；其实，也有一个系统调用叫做 kill。</strong></p><p>man 1 kill 显示的是命令行工具 kill 的手册；</p><p>man 2 kill 显示系统调用 kill 的手册；</p><p>显示什么类型的手册，由 man 和命令中间的数字决定，目前共有 9 个 man 支持的数字。</p><table><thead><tr><th>数字</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>可执行程序或 Shell 命令</td></tr><tr><td>2</td><td>系统调用（内核提供的函数）</td></tr><tr><td>3</td><td>库调用</td></tr><tr><td>4</td><td>特殊文件（通常位于 /dev 目录）</td></tr><tr><td>5</td><td>文件格式和约定（比如 /etc/passwd）</td></tr><tr><td>6</td><td>游戏</td></tr><tr><td>7</td><td>杂项（包和一些约定）Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)</td></tr><tr><td>8</td><td>系统管理命令（通常是 root 用户执行的命令）</td></tr><tr><td>9</td><td>内核相关的文件 Kernel routines [Non standard]</td></tr></tbody></table><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">help</span></span><br><span class="line"><span class="keyword">shell</span>（命令解释器）自带的命令成为内部命令，其他的是外部命令</span><br><span class="line">内部命令使用 <span class="keyword">help</span> 帮助</span><br><span class="line">    #<span class="keyword">help</span> <span class="keyword">cd</span></span><br><span class="line">外部命令使用<span class="keyword">help</span>帮助</span><br><span class="line">    #<span class="keyword">ls</span> --<span class="keyword">help</span></span><br><span class="line"></span><br><span class="line">可以通过<span class="keyword">type</span>来判断一个命令是内部还是外部命令</span><br><span class="line">    #<span class="keyword">type</span> <span class="keyword">ls</span></span><br><span class="line">    #<span class="keyword">type</span> <span class="keyword">cd</span></span><br></pre></td></tr></table></figure><p>Linux的命令可以分为内部命令和外部命令：</p><ul><li>内置命令在系统启动时就调入内存，是常驻内存的，所以执行效率高。</li><li>外部命令是系统的软件功能，用户需要时才从硬盘中读入内存。</li></ul><h3 id="文件管理">文件管理</h3><p>显示当前的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> 显示当前的目录名称</span><br></pre></td></tr></table></figure><p>更改当前的操作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 更改当前的操作目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path/to/... 绝对路径</span><br><span class="line"><span class="built_in">cd</span> ./path/to/... 相对路径</span><br><span class="line"><span class="built_in">cd</span> ../path/to/... 相对路径</span><br></pre></td></tr></table></figure><p>文件查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 查看当前目录下的文件</span><br><span class="line"><span class="built_in">ls</span> /  /root    这样会同时查看根目录和 /root目录下的文件</span><br><span class="line">常用参数</span><br><span class="line">    -l 长格式显示文件</span><br><span class="line">    -a 显示隐藏文件</span><br><span class="line">    -r 逆序显示（默认按照文件名排序）</span><br><span class="line">    -t 按照时间顺序显示   <span class="built_in">ls</span> -l -r -t （会按照时间逆向排序）</span><br><span class="line">    -R 递归显示    -h 人性化显示、    -d 只显示目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/$ sudo <span class="built_in">ls</span> /  /root</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">/:</span><br><span class="line">bin   cdrom  data_old  etc   lib    lib64   lost+found  mmkv.default      mnt  proc  run   snap  swapfile  tmp  var</span><br><span class="line">boot  data   dev       home  lib32  libx32  media       mmkv.default.crc  opt  root  sbin  srv   sys       usr</span><br><span class="line"></span><br><span class="line">/root:</span><br><span class="line">snap</span><br></pre></td></tr></table></figure><p>目录文件的创建与删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>  建立空目录</span><br><span class="line"><span class="built_in">mkdir</span> a</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -p  递归创建多级文件夹</span><br><span class="line"></span><br><span class="line"><span class="built_in">rmdir</span> 删除空文件夹</span><br><span class="line"><span class="built_in">rmdir</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> 可以删除非空目录及文件</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -r 删除目录</span><br><span class="line">    -f 强制删除，不提示</span><br><span class="line">    需要注意，<span class="built_in">rm</span> -rf 后面可以跟多个目录，不要出现 <span class="built_in">rm</span> -rf / usr 这种，会从根目录开始删除</span><br></pre></td></tr></table></figure><p>复制和移动目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 复制文件和目录</span><br><span class="line"><span class="built_in">cp</span> /root/a /tmp（临时文件）</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -r/R 递归复制目录</span><br><span class="line">    -v 显示过程</span><br><span class="line">    -p 保留文件原有更新时间（属性）</span><br><span class="line">    -a 时间戳+所有权+复制连接文件属性而非档案本身    -f 强行覆盖    -i 覆盖之前先行提示</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 移动文件或者重命名</span><br><span class="line"><span class="built_in">mv</span> /a /othera</span><br><span class="line"><span class="built_in">mv</span> /a /tmp</span><br><span class="line"><span class="built_in">mv</span> /a /tmp/b（移动+重命名）</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -i 覆盖文件前提示</span><br></pre></td></tr></table></figure><h3 id="通配符">通配符</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义：<span class="built_in">shell</span> 内建的符号</span><br><span class="line">用途：操作多个相似（有简单规律的）文件</span><br><span class="line">常用通配符：</span><br><span class="line">　　* 匹配任何字符串</span><br><span class="line">　　？ 匹配<span class="number">1</span>个字符串</span><br><span class="line">　　[<span class="built_in">xyz</span>] 匹配<span class="built_in">xyz</span>任意一个字符</span><br><span class="line">　　[a-z] 匹配一个范围</span><br><span class="line">　　[!<span class="built_in">xyz</span>]或者[^<span class="built_in">xyz</span>] 不匹配</span><br></pre></td></tr></table></figure><h3 id="文本内容查看">文本内容查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文本内容显示到终端</span><br><span class="line">    显示全部</span><br><span class="line"><span class="built_in">head</span> 查看文件开头</span><br><span class="line">    <span class="built_in">head</span> test.txt  默认查看前10行</span><br><span class="line">    <span class="built_in">head</span> -5 test.txt </span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> 查看文件结尾</span><br><span class="line">    <span class="built_in">tail</span> -1000f catalina.out</span><br><span class="line">    常用参数 </span><br><span class="line">    -f 文件内容更新后，显示信息同步更新</span><br><span class="line"></span><br><span class="line"><span class="built_in">wc</span> 统计文件内容信息    </span><br><span class="line">    <span class="built_in">wc</span> -l /tmp/test.txt    查看文件有多少行</span><br><span class="line">    -c或--bytes或——chars：只显示Bytes数；</span><br><span class="line">    -l或——lines：只显示列数；</span><br><span class="line">    -w或——words：只显示字数。</span><br><span class="line">more 分行显示 </span><br><span class="line">less</span><br></pre></td></tr></table></figure><p>Note:可以使用tail -f 查看日志内容。</p><h3 id="打包和压缩">打包和压缩</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">最早的Linux备份介质是磁带，使用的命令是tar</span><br><span class="line">可以打包后的磁带文件进行压缩储存，压缩的命令是 gzip 和 bzip2</span><br><span class="line">经常使用的扩展名是 <span class="string">.tar.gz</span>  <span class="string">.tar.bz2</span>  <span class="string">.tgz</span></span><br><span class="line">tar 打包命令</span><br><span class="line">常用参数</span><br><span class="line">    c 打包</span><br><span class="line">    x 解包</span><br><span class="line">    f 指定操作类型为文件    　　 v 显示进度    P 使用绝对路径</span><br><span class="line">打包</span><br><span class="line">tar cf <span class="string">/tmp/etc-backup.tar</span> <span class="string">/etc</span>      把  <span class="string">/etc</span> 这个文件夹打包放在<span class="string">/tmp/etc-backup.tar</span>会提示，但是也能成功：tar: Removing leading `/&#x27; from member names</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar cPf /tmp/etc-backup.tar /etc      使用绝对路径 （没有提示）</span><br><span class="line">tar czf /tmp/etc-backup.tar.gz /etc  （tar集成了gzip和bzip2）</span><br><span class="line">tar cjf /tmp/etc-backup.tar.bz2 /etc  （压缩比例更高）</span><br><span class="line"></span><br><span class="line">解包</span><br><span class="line">tar xf /tmp/etc-backup.tar -C /root  把 tar包解压到 /root 目录下</span><br><span class="line">tar zxf /tmp/etc-backup.tar.gz -C /etc</span><br><span class="line">tar zjf /tmp/etc-backup.tar.gz -C /etc</span><br></pre></td></tr></table></figure><h3 id="VI">VI</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">多模式产生的原因</span><br><span class="line">四种模式：</span><br><span class="line">    正常模式（<span class="title class_">Normal</span>-mode）</span><br><span class="line">    插入模式（<span class="title class_">Insert</span>-mode）</span><br><span class="line">    命令模式（<span class="title class_">Command</span>-mode）</span><br><span class="line">    可视模式（<span class="title class_">Visual</span>-mode）</span><br><span class="line"></span><br><span class="line">i 进入插入模式</span><br><span class="line">i是当前光标</span><br><span class="line">I是光标当行开头</span><br><span class="line">a是光标后一位</span><br><span class="line">A是光标当行结尾</span><br><span class="line">o下一行，会产生一个空行</span><br><span class="line">O上一行，会产生一个空行</span><br><span class="line"></span><br><span class="line">v进入可视模式</span><br><span class="line"></span><br><span class="line"><span class="symbol">:</span>进入命令模式</span><br><span class="line"></span><br><span class="line">esc返回正常模式</span><br><span class="line"></span><br><span class="line">正常模式下：</span><br><span class="line">hjkl可以控制上下左右</span><br><span class="line"></span><br><span class="line">yy表示复制当行，p可以粘贴</span><br><span class="line"><span class="number">3</span>yy表示复制三行</span><br><span class="line">y<span class="variable">$ </span>表示复制从光标到当行结尾</span><br><span class="line">dd d<span class="variable">$表</span>示剪切</span><br><span class="line"></span><br><span class="line">操作错误，u可以撤销，ctrl+r重做</span><br><span class="line">x表示删除当前光标的字符</span><br><span class="line">r可以替换当前字符</span><br><span class="line"></span><br><span class="line"><span class="symbol">:set</span> nu 可以查看目前是第几行</span><br><span class="line">数字 + G可以到数字对应的行</span><br><span class="line">g移动到第一行</span><br><span class="line">G移动到最后一行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">^来到光标所在行的开头，<span class="variable">$来</span>到光标所在行的结尾</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 命令模式</span><br><span class="line"><span class="symbol">:w</span> /root/test.txt   文件新建的，可以保存一个新文件</span><br><span class="line"><span class="symbol">:w</span> 文件已经存在的情况下，保存</span><br><span class="line"><span class="symbol">:wq</span> 保存退出</span><br><span class="line"><span class="symbol">:q!</span> 强制退出</span><br><span class="line"></span><br><span class="line"><span class="symbol">:</span>! 执行linux命令，看完后回车重新回到vim</span><br><span class="line">/x  查找x字符，n查找下一个，shift+n上一个</span><br><span class="line"><span class="symbol">:s/old/new</span> 用新字符替换旧字符（只正对光标所在的行）</span><br><span class="line"><span class="symbol">:%s/old/new</span> 用新字符替换旧字符（整个文本，但只替换一个）</span><br><span class="line"><span class="symbol">:%s/old/new/g</span> 用新字符替换旧字符（整个文本，全部替换）</span><br><span class="line"><span class="symbol">:</span><span class="number">3</span>,<span class="number">5</span>s/x/X/g <span class="number">3</span><span class="number">-5</span>行内全部替换，替换一个就去掉g</span><br><span class="line"></span><br><span class="line"><span class="symbol">:set</span> nu 显示行号</span><br><span class="line"><span class="symbol">:set</span> nonu 不显示行号</span><br><span class="line"></span><br><span class="line">以上是单次修改的，如果要修改默认配置</span><br><span class="line">vim /etc/vimrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可视模式</span><br><span class="line">三种进入可视模式的方式</span><br><span class="line">v 字符可视模式</span><br><span class="line">V 行可视模式</span><br><span class="line">ctrl + v 块可视模式</span><br><span class="line">    配合d和I（大写i）命令可以进行块的便利操作</span><br><span class="line"></span><br><span class="line">需要在块的所有行之前加入一些字符，选中块，I的时候会在选中的块的第一行的第一个光标处，输入字符，连续两次esc。</span><br><span class="line">选中块，d，然后选中的块就会被删除</span><br></pre></td></tr></table></figure><h3 id="用户与权限管理">用户与权限管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">useradd 新建用户</span><br><span class="line">    useradd dongye（可以用 <span class="built_in">id</span> dongye 来验证是否存在）</span><br><span class="line">    创建一个用户后，自动在 /home建立家目录，并且创建一些隐藏文件。同时，在 /etc/passwd 这个文件里会加入新用户dongye的数据，/etc/shadow里面也有会相关数据（密码相关）。如果没有组的话，创建一个同名的组。</span><br><span class="line">userdel 删除用户</span><br><span class="line">    userdel dongye</span><br><span class="line">    userdel -r dongye 同时删除家目录</span><br><span class="line">passwd 修改用户密码</span><br><span class="line">    passwd dongye</span><br><span class="line">    passwd更改当前用户密码</span><br><span class="line">    /etc/passwd 和 /etc/shadow 里面的数据也被删除</span><br><span class="line">usermod 修改一个用户账户</span><br><span class="line">    usermod -d /home/other dongye  家目录从 /home/dongye 改成 /home/other</span><br><span class="line">chage 修改用户生命周期    设置用户密码的过期时间，甚至用户本身的过期时间</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>奇怪的现象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@penge-<span class="keyword">virtual</span>-machine:/home<span class="meta"># useradd test</span></span><br><span class="line">root@penge-<span class="keyword">virtual</span>-machine:/home<span class="meta"># ls</span></span><br><span class="line">penge</span><br></pre></td></tr></table></figure><p><strong>GPT解答</strong></p><p>在Linux中，当你创建一个新的用户时，系统会默认在 <code>/home</code> 目录下创建一个与用户名同名的家目录。你可以使用 <code>useradd</code> 命令来创建新用户。下面是一些示例：</p><ul><li>创建一个新用户并指定家目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m username</span><br></pre></td></tr></table></figure><p>这里的 <code>-m</code> 选项表示创建家目录。</p><ul><li>如果你想指定家目录的路径，你可以使用 <code>-d</code> 选项：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -d /home/custom_directory username</span><br></pre></td></tr></table></figure><p>这里，<code>-d</code> 选项后面跟的是你想要设定的家目录的路径。</p><ul><li>记得，创建新用户后，你需要为新用户设置密码，这样新用户才能登录。你可以使用 <code>passwd</code> 命令来设置密码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>不过请注意，这些操作需要管理员权限，所以在命令前可能需要加上 <code>sudo</code>。</p><p>如果你已经创建了用户但忘记了设置家目录，你可以使用 <code>usermod</code> 命令来修改用户的家目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -d /home/new_directory username</span><br></pre></td></tr></table></figure><p>这里，<code>-d</code> 选项后面跟的是你想要设定的新的家目录的路径。</p><p><strong>使用<code>/etc/passwd</code>查看</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">root@penge-virtual-machine:/home<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">messagebus:x:103:106::/nonexistent:/usr/sbin/nologin</span><br><span class="line">syslog:x:104:110::/home/syslog:/usr/sbin/nologin</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">tcpdump:x:108:115::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">usbmux:x:110:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">rtkit:x:111:117:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">dnsmasq:x:112:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin</span><br><span class="line">cups-pk-helper:x:113:120:user <span class="keyword">for</span> cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin</span><br><span class="line">speech-dispatcher:x:114:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">kernoops:x:116:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin</span><br><span class="line">saned:x:117:123::/var/lib/saned:/usr/sbin/nologin</span><br><span class="line">nm-openvpn:x:118:124:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin</span><br><span class="line">hplip:x:119:7:HPLIP system user,,,:/run/hplip:/bin/false</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">colord:x:121:126:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin</span><br><span class="line">geoclue:x:122:127::/var/lib/geoclue:/usr/sbin/nologin</span><br><span class="line">pulse:x:123:128:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin</span><br><span class="line">gnome-initial-setup:x:124:65534::/run/gnome-initial-setup/:/bin/false</span><br><span class="line">gdm:x:125:130:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">sssd:x:126:131:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologin</span><br><span class="line">penge:x:1000:1000:penge,,,:/home/penge:/usr/bin/zsh</span><br><span class="line">systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin</span><br><span class="line">sshd:x:127:65534::/run/sshd:/usr/sbin/nologin</span><br><span class="line">fwupd-refresh:x:128:135:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">mysql:x:129:137:MySQL Server,,,:/nonexistent:/bin/false</span><br><span class="line"><span class="built_in">test</span>:x:1001:1002::/home/test:/bin/sh</span><br></pre></td></tr></table></figure><p><strong>id test</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@penge-virtual-machine:/home<span class="comment"># id test</span></span><br><span class="line">uid=1001(<span class="built_in">test</span>) gid=1002(<span class="built_in">test</span>) <span class="built_in">groups</span>=1002(<span class="built_in">test</span>)</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="selector-attr">[-gGnru]</span><span class="selector-attr">[--help]</span><span class="selector-attr">[--version]</span><span class="selector-attr">[用户名称]</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-g 或 --group 　显示用户所属群组的ID。</li><li>-G 或 --groups 　显示用户所属附加群组的ID。</li><li>-n 或 --name 　显示用户，所属群组或附加群组的名称。</li><li>-r 或 --real 　显示实际ID。</li><li>-u 或 --user 　显示用户ID。</li><li>-help 　显示帮助。</li><li>-version 　显示版本信息。</li></ul><h3 id="组管理命令">组管理命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd 新建用户组</span><br><span class="line">    groupadd group1</span><br><span class="line">    useradd user1</span><br><span class="line">    usermod -g group1 user1 把user1这个用户的组改成group1</span><br><span class="line">    useradd -g group1 user2 新建用户user2时就把它放到group1组下</span><br><span class="line">groupdel 删除用户组    groupdel group1 删除组group1</span><br></pre></td></tr></table></figure><h3 id="用户切换">用户切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su 切换用户</span><br><span class="line">    su - USERNAME 使用 login shell 方式切换用户</span><br><span class="line">    su USERNAME 不完全切换，比如还是在 /root下而不会自动跳转到用户家目录</span><br><span class="line"></span><br><span class="line">sudo 以其他用户身份执行命令</span><br><span class="line">    visudo 设置需要使用sudo的用户（组）。下图设置 user3用户拥有shutdown -c权限，需要输入 user3自己的密码</span><br></pre></td></tr></table></figure><p><strong>su和sudo的区别</strong></p><p><code>su</code>和<code>sudo</code>都是Linux系统中用于权限管理的命令，它们的主要区别在于使用方式和权限控制：</p><ul><li><code>su</code>命令：<code>su</code>是“Switch User”的缩写，主要用于切换到其他用户。当你输入<code>su</code>命令后，系统会提示你输入目标用户的密码，输入正确后，你就切换到了那个用户，拥有了那个用户的全部权限。如果没有指定用户名，那么默认切换到root用户。</li><li><code>sudo</code>命令：<code>sudo</code>是“Super User DO”的缩写，主要用于临时获取root权限。当你在命令前加上<code>sudo</code>后，那个命令就会以root用户的身份运行，但之后的操作还是以普通用户的身份进行。使用<code>sudo</code>需要输入当前用户的密码，并且当前用户需要在sudoers文件中（一般位于/etc/sudoers）。</li></ul><p>总的来说，<code>su</code>是切换到其他用户，拥有目标用户的全部权限；而<code>sudo</code>则是临时获取root权限，执行完命令后仍然保持原用户身份。使用哪个命令主要取决于你的需求，如果你需要连续执行多条需要root权限的命令，可能使用<code>su</code>切换到root用户会更方便；如果你只是临时需要执行一条需要root权限的命令，那么使用<code>sudo</code>可能更安全，更符合权限最小化的原则。</p><h3 id="用户和用户组的配置文件介绍">用户和用户组的配置文件介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd 用户配置文件，7个字段</span><br><span class="line"></span><br><span class="line">user3:x:1003:1003::/home/user3:bin/bash</span><br><span class="line">user3：用户名称</span><br><span class="line">x：是否需要密码验证，x表示需要，空表示不需要</span><br><span class="line">1003：用户的uid，用户的<span class="built_in">id</span>信息，唯一识别用户的标识。root是0。</span><br><span class="line">1003：用户的gid，表示组<span class="built_in">id</span>信息</span><br><span class="line">第五个字段：注释</span><br><span class="line">/home/user3：家目录</span><br><span class="line">/bin/bash：用户登录后的命令解释器。/sbin/nologin 表示不能登录</span><br><span class="line"></span><br><span class="line">/etc/shadow 保存用户和用户密码相关信息的</span><br><span class="line">第一个字段：用户名称</span><br><span class="line">第二个字段：用户加密过后的密码（看到也没用，经过处理，即使相同的密码也会显示不同）</span><br><span class="line"></span><br><span class="line">/etc/group 用户组相关的配置文件，4个字段</span><br><span class="line">group:x:10:another</span><br><span class="line">group：组的名称</span><br><span class="line">x：是否需要密码验证</span><br><span class="line">10：gid</span><br><span class="line">another：其他组设置，说明another这个用户的第二个组是group比如输入 <span class="built_in">id</span> user1uid=1001(user1) gid=1001(group1) 组=1001(group1)<span class="built_in">id</span> anotheruid=1002(another) gid=1002(another) 组=1003(group)  查找another信息，发现他的第二个组是group</span><br></pre></td></tr></table></figure><h3 id="文件与目录权限表示方法">文件与目录权限表示方法</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240509110036508.png" alt="image-20240509110036508"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">文件类型</span><br><span class="line">-    普通文件</span><br><span class="line">d   目录文件</span><br><span class="line">b   块特殊文件</span><br><span class="line">c   字符特殊文件</span><br><span class="line">l    符号链接</span><br><span class="line">f    命名管道</span><br><span class="line">s    套接字文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件权限的表示方法</span><br><span class="line"></span><br><span class="line">    字符权限表示方法</span><br><span class="line">    r    读</span><br><span class="line">    w    写</span><br><span class="line">    x    执行</span><br><span class="line"></span><br><span class="line">    数字权限的表示方法</span><br><span class="line">    r=4</span><br><span class="line">    w=2</span><br><span class="line">    x=1</span><br><span class="line"></span><br><span class="line">文件权限的表示方法</span><br><span class="line">rwxrwxrwx</span><br><span class="line">第一个表示文件属主的权限，第二个表示文件属组的权限，第三个表示其他用户的权限</span><br><span class="line"></span><br><span class="line">创建新文件有默认权限，根据<span class="built_in">umask</span>值计算，属主和属组根据当前进程的用户来设定</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目录权限的标识方法</span><br><span class="line">x    进入目录</span><br><span class="line">rx   显示目录内的文件名</span><br><span class="line">wx  修改目录内的文件名</span><br></pre></td></tr></table></figure><h3 id="文件权限的修改方法和数字表示方法">文件权限的修改方法和数字表示方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">修改权限命令(测试的时候别用root，root不受限制）</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span>    修改文件、目录权限</span><br><span class="line">    <span class="built_in">chmod</span> u+x /tmp/testfile    u表示属主</span><br><span class="line">    <span class="built_in">chmod</span> u=rwx /tmp/testfile  </span><br><span class="line">    <span class="built_in">chmod</span> g-r  /tmp/testfile   g表示属组</span><br><span class="line">    <span class="built_in">chmod</span> 0-r /tmp/testfile    o表示其他用户</span><br><span class="line">    <span class="built_in">chmod</span> a+r /tmp/testfile   a表示所有</span><br><span class="line">    <span class="built_in">chmod</span> 755 /tmp/testfile如果属主没有权限，所属的组有权限，以属主为准，还是没有权限。</span><br><span class="line"><span class="built_in">chown</span>    更改属主、属组</span><br><span class="line">    <span class="built_in">chown</span> user1 /test   把<span class="built_in">test</span>这个目录的属主改成user1</span><br><span class="line">    <span class="built_in">chown</span> :group /test   把<span class="built_in">test</span>这个目录的属组给成group    <span class="built_in">chown</span> user1:group /test   一起修改</span><br><span class="line"><span class="built_in">chgrp</span>    可以单独更改属组、不常用</span><br><span class="line"></span><br><span class="line">linux一般创建一个文件默认会赋予666权限，然后根据用的<span class="built_in">umask</span>值来计算。</span><br><span class="line">用户默认<span class="built_in">umask</span>值为022，所以一般是 666-022=644，对应rw-r--r--</span><br></pre></td></tr></table></figure><h3 id="特殊权限">特殊权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUID  用于二进制可执行文件，执行命令时取得文件属主权限</span><br><span class="line">    如，/usr/bin/passwd</span><br><span class="line"></span><br><span class="line">SGID  用于目录，在该目录下创建新的文件和目录，权限自动更改为该目录的属组</span><br><span class="line">    文件共享时使用</span><br><span class="line">SBIT  用于目录，该目录下新建的文件和目录，仅root和自己可以删除</span><br><span class="line">    如 /tmp</span><br></pre></td></tr></table></figure><h2 id="网络管理">网络管理</h2><p><strong>网卡介绍</strong></p><p>网卡，也被称为网络接口卡（Network Interface Card，NIC），是一种硬件设备，它允许计算机通过网络与其他计算机进行连接和通信。一般来说，网卡被安装在计算机或其他网络设备的扩展插槽中。</p><p>网卡的主要工作是将数据包发送和接收到网络上。它把计算机中的数字信息转化为可以在网络上传输的信号，同时也能把网络上的信号转化为计算机可以理解的数字信息。这个过程被称为“调制”和“解调”。</p><p>每个网卡都有一个全球唯一的物理地址，也叫作MAC地址。这个地址在网卡生产时被厂家写入，用于在网络上唯一标识这个网卡。</p><p>网卡可以按照连接方式分类，有有线网卡和无线网卡两种。有线网卡一般使用以太网线缆（Ethernet Cable）进行连接，而无线网卡则使用无线信号，如Wi-Fi进行连接。</p><h3 id="网络状态查看">网络状态查看</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span>-tools VS iproute</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="built_in">net</span>-tools</span><br><span class="line">    ifconfig</span><br><span class="line">    route</span><br><span class="line">    netstat</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. iproute2</span><br><span class="line">    ip</span><br><span class="line">    ss</span><br></pre></td></tr></table></figure><p>网卡名称</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">ifconfig</span>查看网卡名称</span><br><span class="line">        · <span class="variable">eth0</span> 第一块网卡（网络接口）</span><br><span class="line">        · 你的第一个网络接口可能叫做下面的名字</span><br><span class="line">            · <span class="variable">eno1</span> 板载网卡</span><br><span class="line">            · <span class="variable">ens33</span> <span class="variable">PCI</span><span class="operator">-</span><span class="built_in">E</span>网卡</span><br><span class="line">            · <span class="variable">enp0s3</span> 无法获取物理信息的 <span class="variable">PCI</span><span class="operator">-</span><span class="built_in">E</span> 网卡</span><br><span class="line">            · <span class="variable">CentOS7</span>使用了一致性网络设备命名，以上都不匹配则使用<span class="variable">eth0</span></span><br></pre></td></tr></table></figure><p>PCI-E网卡：</p><p>PCI-E网卡是一种使用PCI Express接口的网络适配器，它是计算机硬件的重要组成部分，负责处理计算机的网络连接。以下是关于PCI-E网卡的一些重点介绍：</p><ol><li><strong>高速性能</strong>：PCI Express接口（也被称为PCI-E或PCIe）是一种高速硬件接口，它提供了比传统的PCI接口更快的数据传输速率。这使得PCI-E网卡在处理大量数据流时，如视频流或大型文件传输等场景，表现出更好的性能。</li><li><strong>向下兼容</strong>：PCI-E网卡可以在所有支持PCI-E接口的主板上使用，无论其它硬件接口版本如何。这使得PCI-E网卡在多种系统配置中具有很好的兼容性。</li><li><strong>易于升级</strong>：由于PCI-E接口采用串行连接方式，它可以很容易地通过增加信道数量来提升带宽，因此，PCI-E网卡在未来的升级中具有很大的潜力。</li><li><strong>多种形式</strong>：PCI-E网卡有多种形式，包括台式机网卡、便携式网卡、无线网卡等，可以满足不同用户的需求。</li></ol><p>请注意，虽然PCI-E网卡具有许多优点，但它可能不适合所有的应用场景。例如，对于一些只需要基本网络连接功能的用户，更便宜、更简单的网络解决方案可能更合适。</p><p>ifconfig看看</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">eno1</span>: flags=<span class="number">4099</span>&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        <span class="attribute">ether</span> <span class="number">9</span>c:c2:c4:<span class="number">04</span>:<span class="number">8</span>a:<span class="number">78</span>  txqueuelen <span class="number">1000</span>  (以太网)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">eno2</span>: flags=<span class="number">4099</span>&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        <span class="attribute">ether</span> <span class="number">9</span>c:c2:c4:<span class="number">04</span>:<span class="number">8</span>a:<span class="number">79</span>  txqueuelen <span class="number">1000</span>  (以太网)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">eno4</span>: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        <span class="attribute">inet</span>【网络地址】 <span class="number">10.168.157.251</span>  netmask【掩码】 <span class="number">255.255.255.0</span>  broadcast <span class="number">10.168.127.255</span></span><br><span class="line">        <span class="attribute">inet6</span> fe80::<span class="number">9</span>ec2:c4ff:fe04:<span class="number">8</span>a7b  prefixlen <span class="number">64</span>  scopeid <span class="number">0</span>x20&lt;link&gt;</span><br><span class="line">        <span class="attribute">ether</span>【mac地址】 <span class="number">9</span>c:c2:c4:<span class="number">04</span>:<span class="number">8</span>a:<span class="number">7</span>b  txqueuelen <span class="number">1000</span>  (以太网)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">404748669</span>  bytes <span class="number">62270812330</span> (<span class="number">62</span>.<span class="number">2</span> GB)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">45412</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">89401903</span>  bytes <span class="number">29846981462</span> (<span class="number">29</span>.<span class="number">8</span> GB)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"><span class="attribute">lo</span>: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        <span class="attribute">inet</span> <span class="number">127.0.0.1</span>  netmask <span class="number">255.0.0.0</span></span><br><span class="line">        <span class="attribute">inet6</span> ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0</span>x10&lt;host&gt;</span><br><span class="line">        <span class="attribute">loop</span>  txqueuelen <span class="number">1000</span>  (本地环回)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">216531961</span>  bytes <span class="number">57623160675</span> (<span class="number">57</span>.<span class="number">6</span> GB)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">216531961</span>  bytes <span class="number">57623160675</span> (<span class="number">57</span>.<span class="number">6</span> GB)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure><p>修改网卡命名</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当工作中大量管理网卡，所有设备的网卡最好都是以 eth0 命名，这样可以批量操作。</span><br><span class="line">网络接口命名修改</span><br><span class="line">网卡命名规则受 biosdevname 和 net.ifnames 两个参数影响</span><br><span class="line">编辑 /etc/default/grup 文件，增加 <span class="attribute">biosdevname</span>=0 net.<span class="attribute">ifnames</span>=0</span><br><span class="line">更新 grub</span><br><span class="line">    # grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">重启</span><br><span class="line">    # reboot</span><br><span class="line"></span><br><span class="line">组合，<span class="attribute">biosdevname</span>=0 net.<span class="attribute">ifnames</span>=0，则网卡名为 eth0</span><br><span class="line">     <span class="attribute">biosdevname</span>=1 net.<span class="attribute">ifnames</span>=0，则网卡名为 em1</span><br><span class="line">     <span class="attribute">biosdevname</span>=0 net.<span class="attribute">ifnames</span>=1，则网卡名为 ens33</span><br></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mii-tool eth0  查看网卡物理连接情况</span><br><span class="line">route -<span class="built_in">n</span> 查看网关（路由），使用 -<span class="built_in">n</span> 参数不解析主机名（把ip解析成域名）</span><br></pre></td></tr></table></figure><p>网关基本理解：<a href="https://zhuanlan.zhihu.com/p/165142303">什么是网关，网关的作用是什么？</a>【里面的例子蛮有趣的】</p><p>动手实操：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ route -n</span><br><span class="line">内核 IP 路由表</span><br><span class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</span><br><span class="line">0.0.0.0         10.168.147.10    0.0.0.0         UG    100    0        0 eno4</span><br><span class="line">10.168.147.0    0.0.0.0         255.255.255.0   U     100    0        0 eno4</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 eno4</span><br></pre></td></tr></table></figure><p>网络配置命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig <span class="tag">&lt;<span class="name">接口</span>&gt;</span> <span class="tag">&lt;<span class="name">IP地址</span>&gt;</span> [netmask 子网掩码]      设置网卡的ip地址</span><br><span class="line">ifup <span class="tag">&lt;<span class="name">接口</span>&gt;</span>    启用网卡</span><br><span class="line">ifdown <span class="tag">&lt;<span class="name">接口</span>&gt;</span>    禁用网卡</span><br></pre></td></tr></table></figure><p>网关配置命令</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加网关</span><br><span class="line"><span class="keyword">route</span> add <span class="keyword">default</span> gw <span class="variable">&lt;网关ip&gt;</span></span><br><span class="line"><span class="keyword">route</span> add -host <span class="variable">&lt;指定ip&gt;</span> gw <span class="variable">&lt;网关ip&gt;</span></span><br><span class="line"><span class="keyword">route</span> add -net <span class="variable">&lt;指定网段&gt;</span> netmask <span class="variable">&lt;子网掩码&gt;</span> gw <span class="variable">&lt;网关ip&gt;</span></span><br></pre></td></tr></table></figure><p>网络命令集合：ip命令</p><h3 id="网络故障排除">网络故障排除</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ping 检测是否连接到主机</span><br><span class="line">    ping www<span class="selector-class">.baidu</span><span class="selector-class">.com</span> </span><br><span class="line">traceroute  跟踪当前主机到目标主机的网络状态，-w <span class="number">1</span>超时最多等<span class="number">1</span>秒</span><br><span class="line">    traceroute -w <span class="number">1</span> www<span class="selector-class">.baidu</span><span class="selector-class">.com</span></span><br><span class="line">    </span><br><span class="line">mtr  显示自己主机的网络状态</span><br><span class="line"></span><br><span class="line">nslookup  域名解析成ip</span><br><span class="line">    nslooup www<span class="selector-class">.baidu</span><span class="selector-class">.com</span></span><br><span class="line"></span><br><span class="line">telnet  检测端口</span><br><span class="line">    telnet www<span class="selector-class">.baidu</span><span class="selector-class">.com</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line">tcpdump  网络抓包   -<span class="selector-tag">i</span> any 抓取所有网卡里的数据包，-n 把域名解析成 ip ，port <span class="number">80</span> 抓取指定端口  host <span class="number">10.0</span>.<span class="number">0.1</span> 抓取当前主机到某个主机的数据包</span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n port <span class="number">80</span></span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n host <span class="number">10.0</span>.<span class="number">0.1</span></span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n host <span class="number">10.0</span>.<span class="number">0.1</span> and port <span class="number">80</span></span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n host <span class="number">10.0</span>.<span class="number">0.1</span> and port <span class="number">80</span> -w /tmp/filename 捕获并且保存</span><br><span class="line"></span><br><span class="line">netstat 监听地址 -n 域名转换，-t 显示tcp ，-<span class="selector-tag">p</span> 进程 ，-l  tcp状态 listen</span><br><span class="line">    netstat -ntpl</span><br><span class="line"></span><br><span class="line">ss 跟netstat一样，参数也一样，显示的格式不一样</span><br></pre></td></tr></table></figure><p><strong>ping</strong></p><p>Ping是用来测试网络连接质量的工具。它通过发送ICMP（Internet Control Message Protocol）回显请求消息到目标主机，并等待回显应答。通过测量这个过程的时间，Ping可以帮助我们了解数据包从一台计算机传输到另一台计算机所需要的时间，从而了解网络的延迟情况。此外，Ping还能帮助我们找出丢包的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$<span class="built_in"> ping </span>www.baidu.com<span class="built_in"></span></span><br><span class="line"><span class="built_in">PING </span>www.a.shifen.com (183.2.172.42) 56(84) bytes of data.</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=50 时间=32.6 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=50 时间=33.1 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=50 时间=32.5 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=4 <span class="attribute">ttl</span>=50 时间=32.8 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=5 <span class="attribute">ttl</span>=50 时间=32.6 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=6 <span class="attribute">ttl</span>=50 时间=32.8 毫秒</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com<span class="built_in"> ping </span>统计 ---</span><br><span class="line">已发送 6 个包， 已接收 6 个包, 0% 包丢失, 耗时 5008 毫秒</span><br><span class="line">rtt min/avg/max/mdev = 32.530/32.750/33.089/0.189 ms</span><br></pre></td></tr></table></figure><p><strong>traceout</strong></p><p>Traceroute是用来追踪数据包在网络上从源主机到目标主机的路径的工具。它通过发送一系列的ICMP请求消息，并记录每一跳的IP地址和传输时间，从而找出数据包在网络中的完整路径。Traceroute对于诊断网络中的路由问题非常有用。</p><p><a href="https://zhuanlan.zhihu.com/p/36811672">traceout原理</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ traceroute -w <span class="number">1</span> www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (<span class="number">183.2</span>.<span class="number">172.42</span>), <span class="number">30</span> hops max, <span class="number">60</span> byte packets</span><br><span class="line"> <span class="number">1</span>  <span class="number">10.168</span>.<span class="number">157.1</span> (<span class="number">10.168</span>.<span class="number">157.1</span>)  <span class="number">0.264</span> <span class="keyword">ms</span>  <span class="title">0</span>.<span class="number">245</span> <span class="keyword">ms</span>  <span class="title">0</span>.<span class="number">235</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">2</span>  * * *</span><br><span class="line"> <span class="number">3</span>  <span class="number">10.168</span>.<span class="number">82.2</span> (<span class="number">10.168</span>.<span class="number">82.2</span>)  <span class="number">1.305</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">775</span> <span class="keyword">ms</span>  <span class="title">2</span>.<span class="number">248</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">4</span>  <span class="number">172.16</span>.<span class="number">255.254</span> (<span class="number">172.16</span>.<span class="number">255.254</span>)  <span class="number">0.897</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">018</span> <span class="keyword">ms</span>  <span class="title">0</span>.<span class="number">795</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">5</span>  <span class="number">113.140</span>.<span class="number">11.1</span> (<span class="number">113.140</span>.<span class="number">11.1</span>)  <span class="number">2.604</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">501</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">590</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">6</span>  <span class="number">10.224</span>.<span class="number">27.5</span> (<span class="number">10.224</span>.<span class="number">27.5</span>)  <span class="number">1.483</span> <span class="keyword">ms</span> <span class="title">10</span>.<span class="number">224.27</span>.<span class="number">9</span> (<span class="number">10.224</span>.<span class="number">27.9</span>)  <span class="number">1.658</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">715</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">7</span>  <span class="number">1.85</span>.<span class="number">253.45</span> (<span class="number">1.85</span>.<span class="number">253.45</span>)  <span class="number">1.777</span> <span class="keyword">ms</span> <span class="title">1</span>.<span class="number">85.253</span>.<span class="number">53</span> (<span class="number">1.85</span>.<span class="number">253.53</span>)  <span class="number">1.764</span> <span class="keyword">ms</span> <span class="title">*</span></span><br><span class="line"><span class="title"> 8</span>  * <span class="number">202.97</span>.<span class="number">36.109</span> (<span class="number">202.97</span>.<span class="number">36.109</span>)  <span class="number">31.468</span> <span class="keyword">ms</span> <span class="title">202</span>.<span class="number">97.13</span>.<span class="number">253</span> (<span class="number">202.97</span>.<span class="number">13.253</span>)  <span class="number">29.065</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">9</span>  <span class="number">113.96</span>.<span class="number">4.74</span> (<span class="number">113.96</span>.<span class="number">4.74</span>)  <span class="number">33.720</span> <span class="keyword">ms</span> <span class="title">* *</span></span><br><span class="line"><span class="title">10</span>  * * *</span><br><span class="line"><span class="number">11</span>  <span class="number">14.29</span>.<span class="number">117.178</span> (<span class="number">14.29</span>.<span class="number">117.178</span>)  <span class="number">31.263</span> <span class="keyword">ms</span> <span class="title">14</span>.<span class="number">29.117</span>.<span class="number">170</span> (<span class="number">14.29</span>.<span class="number">117.170</span>)  <span class="number">39.950</span> <span class="keyword">ms</span>  <span class="title">37</span>.<span class="number">211</span> <span class="keyword">ms</span></span><br><span class="line"><span class="title">12</span>  * * *</span><br><span class="line"><span class="number">13</span>  * * *</span><br><span class="line"><span class="number">14</span>  * * *</span><br><span class="line"><span class="number">15</span>  * * *</span><br></pre></td></tr></table></figure><p><strong>Ping与Traceroute的区别</strong>：<br>主要区别在于Ping主要用于测试网络连接的质量（如延迟和丢包），而Traceroute主要用于追踪数据包的路径。Ping只告诉你数据包是否能够到达目标主机，以及这个过程需要多长时间，但它不能告诉你数据包到达目标主机的具体路径。而Traceroute则能详细地展示数据包从源主机到目标主机的每一跳路径，有助于我们了解网络的结构和找出可能存在的路由问题。</p><p><strong>mtr</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv</span><span class="variable">$ </span>mtr                                                       <span class="title class_">My</span> traceroute  [v0.<span class="number">93</span>]</span><br><span class="line">sv-<span class="variable constant_">NF5280M5</span> (<span class="number">127.0</span>.<span class="number">0.1</span>)                                                                                     <span class="number">2024</span>-<span class="number">05</span>-10<span class="symbol">T16:</span><span class="number">29</span><span class="symbol">:</span><span class="number">13</span>+0800</span><br><span class="line"><span class="title class_">Keys</span>:  <span class="title class_">Help</span>   <span class="title class_">Display</span> mode   <span class="title class_">Restart</span> statistics   <span class="title class_">Order</span> of fields   quit</span><br><span class="line">                                                                                            <span class="title class_">Packets</span>               <span class="title class_">Pings</span></span><br><span class="line"> <span class="title class_">Host</span>                                                                                     <span class="title class_">Loss</span>%   <span class="title class_">Snt</span>   <span class="title class_">Last</span>   <span class="title class_">Avg</span>  <span class="title class_">Best</span>  <span class="title class_">Wrst</span> <span class="title class_">StDev</span></span><br><span class="line"> <span class="number">1</span>. localhost                                                                              <span class="number">0.0</span>%     <span class="number">9</span>    <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><strong>netstat</strong></p><p>netstat是一个非常实用的命令，它可以帮助我们了解我们的系统网络状态。以下是一些基本的使用方法：</p><ol><li><strong>显示网络状态</strong>：netstat 命令可以显示网络状态，它通常用于问题确定而不是性能测量。但是，netstat 命令可用于确定网络上的流量，以确定性能问题是否是由于网络拥塞引起的。在 netstat 关于所配置的网络接口，诸如以下的流量命令显示信息：与所有sockets关联的信息。详情请参考<a href="https://zhuanlan.zhihu.com/p/367635200">此链接</a>。</li><li><strong>网络统计工具</strong>：netstat 是一个网络分析工具，用于显示网络连接、路由表、接口统计、伪装连接和多播成员资格等信息。然而随着时间的推移，一些Linux发行版已经开始用像ss, ip这样的更现代的工具代替netstat。详情请参考<a href="https://blog.csdn.net/u012964600/article/details/137612961">此链接</a>。</li><li><strong>显示端口和网络统计数据</strong>：netsta命令是一个CLI工具，用于网络统计。它提供了网络活动的概览，并显示哪些端口是开放的或已建立连接。netstat 工具对于发现网络问题至关重要。详情请参考<a href="https://phoenixnap.com/kb/netstat-command">此链接</a>。</li></ol><p>在使用 netstat 命令时，需要注意的是，由于其强大的功能，可能需要管理员权限才能获取完整的网络状态信息。</p><p>网络管理和配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网络服务管理程序分为两种，分别是 SysV 和 systemd(centos7)</span><br><span class="line">service network status|start|stop|restart</span><br><span class="line"></span><br><span class="line">网络配置文件</span><br><span class="line"></span><br><span class="line"><span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0 （网卡配置项）</span><br><span class="line"><span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>常用命令</p><p>下面是一些常见的<code>netstat</code>操作：</p><ol><li>显示所有活动的网络连接：<code>netstat</code>命令默认就可以显示当前系统的所有网络连接信息。</li><li>显示监听的服务器套接字：<code>netstat -l</code>可以显示所有正在监听的服务器套接字。</li><li>显示路由表：<code>netstat -r</code>可以显示路由表，这对于诊断网络问题非常有用。</li><li>显示每个协议的统计信息：<code>netstat -s</code>可以显示每个网络协议的统计信息，如TCP、UDP、ICMP等。</li><li>显示网络接口的统计信息：<code>netstat -i</code>可以显示每个网络接口的统计信息，如发送和接收的数据包数量等。</li></ol><h3 id="软件包管理">软件包管理</h3><p><strong>软件包管理器</strong></p><p>包管理器是方便软件安装、卸载，解决软件依赖关系的重要工具。</p><ul><li>CentOS 和 RedHat 使用 yum 包管理器，软件安装包格式为 rpm</li><li>Debian、Ubuntu使用 apt 包管理器，软件安装包格式为 deb</li></ul><p><strong>使用rpm命令安装软件包</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240510193643483.png" alt="image-20240510193643483"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm 命令常用参数</span><br><span class="line">    -<span class="selector-tag">q</span> 查询软件包　　　　rpm -qa 查询所有软件包　　　　rpm -<span class="selector-tag">q</span> vim-common 查询某个软件包</span><br><span class="line">    -<span class="selector-tag">i</span>  安装软件包　　　　rpm -<span class="selector-tag">i</span> vim-enhanced-<span class="number">7.4</span>.<span class="number">160</span>-<span class="number">5</span><span class="selector-class">.el7</span><span class="selector-class">.x84_64</span><span class="selector-class">.rpm</span>  （要全称）</span><br><span class="line">    -e 卸载软件包　　　　rpm -e vim-enhanced   （只要名字，不需要版本号等）用 rpm 安装的问题：如果一个软件包依赖其他软件包，那么就会安装失败。需要操作者自己解决依赖关系。</span><br></pre></td></tr></table></figure><p><strong>使用yum包管理器安装软件包</strong></p><p>rpm 包的问题</p><ul><li>需要自己解决依赖关系</li><li>软件包来源不可靠</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CentOS yum源</span><br><span class="line">    http:<span class="regexp">//mi</span>rror.centos.org<span class="regexp">/centos/</span><span class="number">7</span>/</span><br><span class="line">国内镜像</span><br><span class="line">    https:<span class="regexp">//</span>opsx.alibaba.com/mirror</span><br><span class="line">yum 配置文件</span><br><span class="line">    <span class="regexp">/etc/yum</span>.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">可以修改配置文件</span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base -mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">            http:<span class="regexp">//mi</span>rrors.aliyuncs.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">             http:<span class="regexp">//mi</span>rrors.cloud.aliyuncs.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/centos/</span>RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br><span class="line">或者直接用别人已经写好的配置文件</span><br><span class="line">wget -O <span class="regexp">/etc/yum</span>.repo.d<span class="regexp">/CentOS-Base.repo http:/</span><span class="regexp">/mirrors.aliyun.com/</span>repo/Centos-<span class="number">7</span>.repo需要清除缓存yum makecache</span><br></pre></td></tr></table></figure><p>yum 命令常用选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用选项</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span> 安装软件包</span><br><span class="line"><span class="keyword">remove</span> 卸载软件包</span><br><span class="line"><span class="keyword">list</span> |grouplist 查看软件包</span><br><span class="line">update 升级软件包</span><br></pre></td></tr></table></figure><h3 id="其他方式安装">其他方式安装</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二进制安装</span><br><span class="line">源代码编译安装</span><br><span class="line"></span><br><span class="line">wget https:<span class="comment">//openresty.org/download/openresty-1.15.8.1.tar.gz</span></span><br><span class="line">tar zxf openresty-<span class="keyword">VERSION</span>.tar.gz</span><br><span class="line"><span class="keyword">cd</span> openresty-<span class="keyword">VERSION</span>/</span><br><span class="line">./configure --prefix=/usr/<span class="keyword">local</span>/openresty</span><br><span class="line">make -j2   （用2核编译）</span><br><span class="line">make isntall</span><br></pre></td></tr></table></figure><h3 id="升级内核">升级内核</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">rpm 格式内核</span><br><span class="line">    查看内核版本</span><br><span class="line">        uname -r</span><br><span class="line">    升级内核版本</span><br><span class="line">        yum install kernel-<span class="number">3.10</span>.<span class="number">0</span>   这种方式一般不能升级到最新</span><br><span class="line">        epel软件仓库会有较高的软件版本。yum install epel-release -<span class="keyword">y</span></span><br><span class="line">    升级已安装的其他软件包和补丁</span><br><span class="line">        yum <span class="keyword">update</span>    除了升级内核，还会升级软件包。正常不要使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">源代码编译安装内核</span><br><span class="line">yum install gcc gcc-<span class="keyword">c</span>++ <span class="keyword">make</span> ncurses-devel openssl-devel elfutils-libelf-devel</span><br><span class="line"></span><br><span class="line">下载并解压缩内核</span><br><span class="line">https://www.kernel.org</span><br><span class="line">tar xvf linux-<span class="number">5.1</span>.<span class="number">10</span>.tar.xz -C /usr/src/kernels</span><br><span class="line"></span><br><span class="line">配置内核编译参数</span><br><span class="line"><span class="keyword">cd</span> /usr/src/kernels/linux-<span class="number">5.1</span>.<span class="number">10</span>/</span><br><span class="line"><span class="keyword">make</span> menuconfig | allyesconfig | allnoconfig</span><br><span class="line"><span class="keyword">make</span> allyesconfig （无脑全选）</span><br><span class="line"></span><br><span class="line">使用当前系统内核配置</span><br><span class="line"><span class="keyword">cp</span> /boot/config-kernelversion.platform /usr/src/kernels/linux-<span class="number">5.1</span>.<span class="number">10</span>/.config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看cpu</span><br><span class="line">lscpu</span><br><span class="line"></span><br><span class="line">编译</span><br><span class="line"><span class="keyword">make</span> j2 <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">安装内核</span><br><span class="line"><span class="keyword">make</span> modules_install</span><br><span class="line"><span class="keyword">make</span> install</span><br></pre></td></tr></table></figure><p>这篇教程详细记录了每个步骤：<a href="https://blog.csdn.net/weixin_42888638/article/details/127288997?spm=1001.2014.3001.5501">linux内核编译记录</a></p><h2 id="进程管理">进程管理</h2><h3 id="进程的概念与进程查看">进程的概念与进程查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进程-运行中的程序，从程序开始运行到终止的整个生命周期是可管理的</span><br><span class="line"></span><br><span class="line">查看命令</span><br><span class="line">ps</span><br><span class="line">    -e 表示所有的终端运行的进程</span><br><span class="line">    -f  显示更多信息，比如 UID、PPID（父进程）、CMD（命令的完整路径）</span><br><span class="line">    -L  多显示 LWP ，线程信息</span><br><span class="line">    ps -eLf  常用命令</span><br><span class="line"></span><br><span class="line">pstree  查看进程树</span><br><span class="line">    </span><br><span class="line">top  动态查看进程信息top -p 进程号</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">进程也是树形结构</span><br><span class="line">进程和权限有着密不可分的关系</span><br></pre></td></tr></table></figure><p>ps</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv</span><span class="variable">$ </span>ps</span><br><span class="line">    <span class="variable constant_">PID</span> <span class="variable constant_">TTY</span>          <span class="variable constant_">TIME</span> <span class="variable constant_">CMD</span></span><br><span class="line"><span class="number">1221450</span> pts/<span class="number">1</span>    <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">03</span> bash</span><br><span class="line"><span class="number">1247704</span> pts/<span class="number">1</span>    <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> ps</span><br></pre></td></tr></table></figure><p>“pts/1” 是一种特殊的终端设备文件，表示的是一种伪终端（Pseudo-Terminal Slave）。在这里，“pts” 是伪终端的缩写，数字 “1” 是这个伪终端的编号。</p><ul><li><a href="https://linux265.com/course/linux-command-ps.html#:~:text=ps%E5%91%BD%E4%BB%A4%20-%20Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%20%7C%20linux%E6%95%99%E7%A8%8B%20ps%E5%91%BD%E4%BB%A4,protoize%E5%91%BD%E4%BB%A4%20pssh%E5%91%BD%E4%BB%A4%20ps%E5%91%BD%E4%BB%A4%E6%98%AF%E2%80%9Cprocess%20status%E2%80%9D%E7%9A%84%E7%BC%A9%E5%86%99%EF%BC%8Cps%E5%91%BD%E4%BB%A4%E7%94%A8%E4%BA%8E%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E3%80%82%20%E5%8F%AF%E4%BB%A5%E6%90%AD%E9%85%8Dkill%E6%8C%87%E4%BB%A4%E9%9A%8F%E6%97%B6%E4%B8%AD%E6%96%AD%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%82%20ps%E5%91%BD%E4%BB%A4%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E5%90%8C%E6%97%B6%E4%B9%9F%E6%98%AF%E9%9D%9E%E5%B8%B8%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E7%A1%AE%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%81%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%93%E6%9D%9F%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9C%89%E6%B2%A1%E6%9C%89%E5%83%B5%E6%AD%BB%E3%80%81%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E4%BA%86%E8%BF%87%E5%A4%9A%E7%9A%84%E8%B5%84%E6%BA%90%E7%AD%89%E7%AD%89%EF%BC%8C%E6%80%BB%E4%B9%8B%E5%A4%A7%E9%83%A8%E5%88%86%E4%BF%A1%E6%81%AF%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%BE%97%E5%88%B0%E7%9A%84%E3%80%82">ps命令</a></li></ul><p><strong>top</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240510195736332.png" alt="image-20240510195736332"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一行 </span><br><span class="line">    <span class="number">34</span><span class="built_in">min</span> 表示这台机器已经启动<span class="number">34</span>分钟没有关机了</span><br><span class="line">    <span class="number">2</span>users 表示有<span class="number">2</span>个用户登录</span><br><span class="line">    平均负载：<span class="number">1</span>分钟，<span class="number">5</span>分钟，<span class="number">15</span>分钟</span><br><span class="line"></span><br><span class="line">第二行</span><br><span class="line">    一共运行的任务，几个在running ，几个在sleeping</span><br><span class="line"></span><br><span class="line">第三行（平均值，按 <span class="number">1</span> 会把所有 逻辑cpu 的使用情况列出来）</span><br><span class="line">    <span class="number">2.8</span> us  <span class="number">1.8</span> <span class="keyword">sy</span> <span class="number">97.7</span> id <span class="number">0.0</span> <span class="keyword">wa</span></span><br><span class="line">    us 表示用户计算，<span class="keyword">sy</span>表示进程之间状态交互，id表示空闲，<span class="keyword">wa</span>表示磁盘等待</span><br><span class="line"></span><br><span class="line">第四行</span><br><span class="line">    内存状态</span><br><span class="line">第五行</span><br><span class="line">    交换分区（虚拟内存）</span><br></pre></td></tr></table></figure><p>进程的优先级调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">调整优先级</span><br><span class="line">    <span class="built_in">nice</span> 范围从 -20 到 19，值越小优先级越高，抢占资源就越多</span><br><span class="line">        <span class="built_in">nice</span> -n 10 ./rest.sh  启动的时候调整为 10</span><br><span class="line">    renice 重新设置优先级</span><br><span class="line">        renice -n 15 19312  已经处于启动的情况下进行调整。根据进程号</span><br><span class="line">进程的作业控制</span><br><span class="line">    &amp;符号，后台运行</span><br><span class="line">        ./test.sh &amp;</span><br><span class="line">    <span class="built_in">jobs</span> 把处于后台运行的程序调到前台显示</span><br><span class="line">        <span class="built_in">jobs</span> 能得到一个编号</span><br><span class="line">        <span class="built_in">fg</span> 编号，可以调到前台</span><br><span class="line">    ctrl +z，把已经处于前台的程序调到后台，状态会stop</span><br></pre></td></tr></table></figure><h3 id="进程的通信方式-信号">进程的通信方式-信号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">信号是进程间通信方式之一，典型用法是：终端用户输入中断命令，通过信号机制停止一个程序的运行。</span><br><span class="line">使用信号的常用快捷键和命令</span><br><span class="line"><span class="built_in">kill</span> -l 查看所有的信号</span><br><span class="line">    SIGINT 通知前台进程组终止进程 ctrl + c，2号信号</span><br><span class="line">    SIGKILL 立即结束程序，不能被阻塞和处理 <span class="built_in">kill</span> -9 pid ，9号信号 </span><br></pre></td></tr></table></figure><h3 id="守护进程和系统日志">守护进程和系统日志</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">守护进程（精灵进程）</span><br><span class="line"></span><br><span class="line">使用 nohup 与 &amp; 符号配合运行一个命令 （nohup进程不是守护进程）</span><br><span class="line">    nohup 命令使进程忽略 hangup（挂起）信号。关掉终端这个进程依然可以运行，忽略输入并且把输出打印到 nohup.out</span><br><span class="line">守护进程（daemon）和一般进程有什么差别呢？</span><br><span class="line">    开机自启，守护进程不需要终端，输出可以打印到特殊的文件中，进程所占用的目录是根目录。<span class="keyword">cd</span> /<span class="keyword">proc</span>/ 这个目录是内存信息，相应的进程会有进程号同名的目录。</span><br><span class="line"></span><br><span class="line">使用<span class="title"> screen</span> 命令，进入screen环境后，如果远程连接断掉了，可以通过screen恢复工作现场<span class="title"></span></span><br><span class="line"><span class="title">    screen</span> 进入<span class="title"> screen</span> 环境<span class="title"></span></span><br><span class="line"><span class="title">    ctrl</span> +a然后再单独按d退出（detached）screen 环境<span class="title"></span></span><br><span class="line"><span class="title">    screen</span> -ls 查看<span class="title"> screen</span> 的会话<span class="title"></span></span><br><span class="line"><span class="title">    screen</span> -r<span class="title"> sessionid</span> 恢复会话系统日志文件 /var/log系统常规日志：messages内核运行情况：dmesg安全日志<span class="title">  secure定时任务日志</span> cron</span><br></pre></td></tr></table></figure><h3 id="服务管理工具systermctl">服务管理工具systermctl</h3><p>服务（提供常见功能的守护进程）集中管理工具</p><ul><li>service</li><li>systemctl（centos7以后的，可以看做service进化版）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">service 启动脚本</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/ 目录下</span><br><span class="line">vim network 可以查看network的启动脚本，200多行，完全由编写人员自己控制，比较复杂；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl 启动脚本</span><br><span class="line"><span class="built_in">cd</span> /usr/lib/systemd/system/</span><br><span class="line">vim sshd.service</span><br><span class="line"></span><br><span class="line">原有的init，linux的1号进程</span><br><span class="line">init 0 关机 （不能用<span class="built_in">kill</span> -9杀掉这个进程，只能0结束这个进程，进而关机）</span><br><span class="line">init 6 重启</span><br><span class="line">init  3 字符终端</span><br><span class="line">init 5 图形界面</span><br><span class="line"></span><br><span class="line">systemctl 常见操作</span><br><span class="line">systemctl status|start|stop|restart|reload|<span class="built_in">enable</span>|<span class="built_in">disable</span> 服务名称  </span><br><span class="line">1、restart 和reload差别，reload不停服务，直接重启</span><br><span class="line">2、<span class="built_in">enable</span>开机启动，<span class="built_in">disable</span>不开机启动</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/qq_41308872/article/details/133743091">完全指南：systemctl命令及服务管理技巧</a></li></ul><p>启动Docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><h3 id="SELinux">SELinux</h3><p>MAC（强制访问控制）和DAC（自主访问控制）。SELinux就是 MAC，生产环境不太用，比较麻烦。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">根据进程pid查端口</span><br><span class="line"><span class="title">lsof</span> -i |grep pid</span><br><span class="line"></span><br><span class="line">根据端口<span class="keyword">port</span>查进程</span><br><span class="line">lsof -i:<span class="keyword">port</span></span><br><span class="line"></span><br><span class="line">根据进程pid查端口</span><br><span class="line">netstat -nap |grep pid</span><br><span class="line"></span><br><span class="line">根据端口<span class="keyword">port</span>查进程</span><br><span class="line">netstat -nap |grep <span class="keyword">port</span></span><br></pre></td></tr></table></figure><h2 id="内存和磁盘管理">内存和磁盘管理</h2><h3 id="内存和磁盘使用率查看">内存和磁盘使用率查看</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存使用率查看</span><br><span class="line">free</span><br><span class="line">    -m  以兆的方式显示</span><br><span class="line">    -g   以G的方式显示，但是会被四舍五入。一般不用</span><br><span class="line"><span class="built_in">top</span></span><br></pre></td></tr></table></figure><p>看看电脑先</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free -m apport.log</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：      <span class="number"> 64029 </span>     <span class="number"> 20697 </span>      <span class="number"> 2641 </span>       <span class="number"> 789 </span>     <span class="number"> 40690 </span>      41890</span><br><span class="line">交换：       <span class="number"> 2047 </span>       <span class="number"> 894 </span>       1153</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：   <span class="number"> 65566072 </span>  <span class="number"> 21394584 </span>   <span class="number"> 2503952 </span>    <span class="number"> 808044 </span>  <span class="number"> 41667536 </span>   42695292</span><br><span class="line">交换：    <span class="number"> 2097148 </span>    <span class="number"> 916176 </span>    1180972</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free -g</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：         <span class="number"> 62 </span>        <span class="number"> 20 </span>         <span class="number"> 2 </span>         <span class="number"> 0 </span>        <span class="number"> 39 </span>         40</span><br><span class="line">交换：          <span class="number"> 1 </span>         <span class="number"> 0 </span>          1</span><br></pre></td></tr></table></figure><p>交换空间（Swap Space）是硬盘上的一块区域，它被操作系统用作虚拟内存，用来临时存放内存中的数据。当系统的物理内存用完时，操作系统会将一些不常用的数据移动到交换空间，从而释放出物理内存给需要的程序使用。</p><p>不用Swap的话就随机杀掉。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">磁盘使用率的查看</span><br><span class="line">fdisk</span><br><span class="line">    -l 查看</span><br><span class="line">    磁盘分区一块硬盘最多分15个分区</span><br></pre></td></tr></table></figure><p>实操</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo fdisk -l</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">Disk /dev/loop1：4 KiB，4096 字节，8 个扇区</span><br><span class="line">单元：扇区 /<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/loop2：6.77 MiB，7081984 字节，13832 个扇区</span><br><span class="line">单元：扇区 /<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/loop3：40.44 MiB，42393600 字节，82800 个扇区</span><br><span class="line">单元：扇区 /<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 /<span class="number"> 512 </span>字节</span><br></pre></td></tr></table></figure><blockquote><p>问个问题，为什么要对磁盘分区？</p></blockquote><p>磁盘分区基本上是把一个磁盘分成一个或多个逻辑磁盘。每个分区都像一个独立的硬盘一样，有自己的文件系统。在操作系统中，磁盘分区通常被表示为不同的驱动器，如C盘、D盘等。对磁盘进行分区的原因主要有以下几点：</p><ol><li><strong>提高磁盘效率</strong>：文件系统通常会在磁盘上留有一些空间，这样可以提高读写速度。如果你只有一个大的分区，那么这个空间可能就会浪费很多。如果你有多个小的分区，那么每个分区的空间都会更加合理地利用。</li><li><strong>数据安全</strong>：如果你的操作系统崩溃，那么可能会损坏整个文件系统。如果你有多个分区，那么一个分区的损坏不会影响其他分区。这样，你的数据就更安全了。</li><li><strong>多操作系统</strong>：如果你想在一台计算机上安装多个操作系统，那么你需要为每个操作系统创建一个分区。这样，每个操作系统都可以在自己的分区上运行，互不干扰。</li><li><strong>文件组织</strong>：分区可以帮助你更好地组织文件。例如，你可以在一个分区上存储系统文件，在另一个分区上存储个人文件。这样，即使系统分区出现问题，你的个人文件也不会受到影响。</li></ol><p>以上就是对磁盘进行分区的主要原因。</p><p><strong>每个磁盘分区都可以被格式化为一个独立的文件系统。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> 既能够看到分区，又能够看到挂载到的目录</span><br><span class="line">    -h 人性化可读</span><br><span class="line">系统中各个文件系统的磁盘使用情况</span><br></pre></td></tr></table></figure><p>实操</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="symbol">NF5280M5:</span>/dev<span class="variable">$ </span>df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev             <span class="number">32</span>G     <span class="number">0</span>   <span class="number">32</span>G    <span class="number">0</span>% <span class="regexp">/dev</span></span><br><span class="line"><span class="regexp">tmpfs           6.3G  2.8M  6.3G    1% /run</span></span><br><span class="line"><span class="regexp">/dev/sda</span>2       <span class="number">439</span>G  <span class="number">253</span>G  <span class="number">165</span>G   <span class="number">61</span>% <span class="regexp">/</span></span><br><span class="line"><span class="regexp">tmpfs            32G  396K   32G    1% /dev</span><span class="regexp">/shm</span></span><br><span class="line"><span class="regexp">tmpfs           5.0M  4.0K  5.0M    1% /run</span><span class="regexp">/lock</span></span><br><span class="line"><span class="regexp">tmpfs            32G     0   32G    0% /sys</span><span class="regexp">/fs/cgroup</span></span><br><span class="line"><span class="regexp">/dev/loop</span>1      <span class="number">128</span>K  <span class="number">128</span>K     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/bare</span><span class="regexp">/5</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop4       56M   56M     0  100% /snap</span><span class="regexp">/core18/</span><span class="number">2812</span></span><br><span class="line"><span class="regexp">/dev/loop</span>5       <span class="number">64</span>M   <span class="number">64</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/core</span>20/<span class="number">2182</span></span><br><span class="line"><span class="regexp">/dev/loop</span>6       <span class="number">75</span>M   <span class="number">75</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/core</span>22/<span class="number">1122</span></span><br><span class="line"><span class="regexp">/dev/loop</span>18     <span class="number">350</span>M  <span class="number">350</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">38</span>-<span class="number">2004</span>/<span class="number">140</span></span><br><span class="line"><span class="regexp">/dev/loop</span>17      <span class="number">13</span>M   <span class="number">13</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snap</span>-store/<span class="number">959</span></span><br><span class="line"><span class="regexp">/dev/loop</span>13     <span class="number">350</span>M  <span class="number">350</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">38</span>-<span class="number">2004</span>/<span class="number">143</span></span><br><span class="line"><span class="regexp">/dev/loop</span>19      <span class="number">92</span>M   <span class="number">92</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gtk</span>-common-themes/<span class="number">1535</span></span><br><span class="line"><span class="regexp">/dev/loop</span>14     <span class="number">219</span>M  <span class="number">219</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">34</span>-<span class="number">1804</span>/<span class="number">90</span></span><br><span class="line"><span class="regexp">/dev/loop</span>12      <span class="number">82</span>M   <span class="number">82</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gtk</span>-common-themes/<span class="number">1534</span></span><br><span class="line"><span class="regexp">/dev/loop</span>10     <span class="number">219</span>M  <span class="number">219</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">34</span>-<span class="number">1804</span>/<span class="number">93</span></span><br><span class="line"><span class="regexp">/dev/sda</span>1       <span class="number">511</span>M  <span class="number">6.1</span>M  <span class="number">505</span>M    <span class="number">2</span>% <span class="regexp">/boot/efi</span></span><br><span class="line"><span class="regexp">/dev/sdb</span>2       <span class="number">3.6</span>T  <span class="number">420</span>G  <span class="number">3.0</span>T   <span class="number">13</span>% <span class="regexp">/data</span></span><br><span class="line"><span class="regexp">tmpfs           6.3G   76K  6.3G    1% /run</span><span class="regexp">/user/</span><span class="number">1000</span></span><br><span class="line"><span class="regexp">/dev/loop</span>21      <span class="number">40</span>M   <span class="number">40</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snapd</span><span class="regexp">/21184</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop2      6.9M  6.9M     0  100% /snap</span><span class="regexp">/ngrok/</span><span class="number">138</span></span><br><span class="line"><span class="regexp">/dev/loop</span>9      <span class="number">505</span>M  <span class="number">505</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">42</span>-<span class="number">2204</span>/<span class="number">172</span></span><br><span class="line"><span class="regexp">/dev/loop</span>16      <span class="number">13</span>M   <span class="number">13</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snap</span>-store/<span class="number">1113</span></span><br><span class="line"><span class="regexp">/dev/loop</span>20      <span class="number">64</span>M   <span class="number">64</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/core</span>20/<span class="number">2264</span></span><br><span class="line"><span class="regexp">/dev/loop</span>11     <span class="number">506</span>M  <span class="number">506</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">42</span>-<span class="number">2204</span>/<span class="number">176</span></span><br><span class="line"><span class="regexp">/dev/loop</span>22     <span class="number">7.0</span>M  <span class="number">7.0</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/ngrok</span><span class="regexp">/148</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop15      75M   75M     0  100% /snap</span><span class="regexp">/core22/</span><span class="number">1380</span></span><br><span class="line"><span class="regexp">/dev/loop</span>8       <span class="number">39</span>M   <span class="number">39</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snapd</span><span class="regexp">/21465</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop23      56M   56M     0  100% /snap</span><span class="regexp">/core18/</span><span class="number">2823</span></span><br></pre></td></tr></table></figure><ul><li><p>在Linux系统中，<code>tmpfs</code>、<code>udev</code>和<code>/dev/sda2</code>都是你的系统挂载点上的文件系统。</p><ol><li><p><strong>tmpfs</strong>：tmpfs是一种基于内存的文件系统，它将一部分RAM作为一个挂载点，允许你像操作磁盘分区一样操作内存。因为它存储在内存中，所以读写速度非常快。然而，一旦系统重启，存储在tmpfs中的所有数据都会丢失。</p></li><li><p><strong>udev</strong>：udev文件系统是一个动态设备管理器，它管理<code>/dev</code>目录下的设备节点。udev允许设备管理工作在用户空间中完成，提供了一种灵活的方式来管理设备节点，并允许通过设备的物理属性或者热插拔事件来改变设备的配置。</p><ul><li><p>udev就是这样的一个动态设备管理器。当一个设备被接入到系统中，udev会根据设备的类型和属性，动态地在<code>/dev</code>目录下创建一个设备节点，这样应用程序就可以通过这个设备节点来访问设备。当设备被移除时，udev会删除对应的设备节点。</p><p>例如，当你插入一个USB设备时，udev会在<code>/dev</code>下创建一个像是<code>sdb1</code>的设备节点，你就可以通过这个设备节点来访问你的USB设备。当你移除USB设备时，<code>/dev/sdb1</code>这个设备节点就会被删除。</p></li></ul></li><li><p><strong>/dev/sdaX</strong>：<code>/dev/sda2</code> 和 <code>/dev/sdb2</code> 这两个设备。这里的 <code>sda</code> 和 <code>sdb</code> 分别代表系统中的第一块和第二块硬盘，而后面的数字 <code>2</code> 表示的是这个硬盘上的第二个分区。</p></li></ol><p>至于为什么你在<code>fdisk -l</code>的输出中看不到这些分区，<strong>这是因为<code>fdisk</code>只显示物理磁盘分区</strong>，而不显示基于内存的文件系统（如tmpfs）或特殊的文件系统（如udev）。你可以使用<code>df -h</code>或<code>mount</code>命令来查看所有的挂载点和文件系统，包括<code>tmpfs</code>和<code>udev</code>。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> （实际占用的空间）</span><br><span class="line">    -h 人性化显示</span><br><span class="line">    -s  只显示总计</span><br></pre></td></tr></table></figure><p>挂载点就是这些物理设备在文件系统中的位置。当一个设备被&quot;挂载&quot;到一个挂载点时，这个设备的内容就可以通过访问这个挂载点来访问了。</p><p>举个例子，如果你插入一个USB驱动器，系统可能会自动将这个驱动器挂载到<code>/media/your_username/usb_drive</code>这个目录下，那么你就可以通过访问这个目录来查看和操作这个USB驱动器的内容。</p><p><strong>du与ls的区别</strong><br><strong>du 是实际占用的，ls算上空洞数据。</strong></p><h3 id="常见文件系统">常见文件系统</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux 支持多种文件系统，常见的有</span><br><span class="line">ext4（centos6）</span><br><span class="line">xfs（centos7）</span><br><span class="line">NTFS（需安装额外软件，<span class="built_in">window</span>常用，有版权）</span><br></pre></td></tr></table></figure><p>ext4文件系统</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ext4文件系统基本结构比较复杂</span><br><span class="line">超级块</span><br><span class="line">超级块副本</span><br><span class="line"><span class="selector-tag">i</span>节点（inode）</span><br><span class="line">数据块（datablock）</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>du -h utils.py</span><br><span class="line"><span class="number">4</span>.0K    utils.py</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -l utils.py</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">3322</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">15</span><span class="symbol">:</span><span class="number">51</span> utils.py</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -li utils.py</span><br><span class="line"><span class="number">19200499</span> -rw-r--r-- <span class="number">1</span> root root <span class="number">3322</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">15</span><span class="symbol">:</span><span class="number">51</span> utils.py</span><br></pre></td></tr></table></figure><blockquote><p>为社么vim会改变i节点，echo不会改变i节点</p></blockquote><p>Vim和echo命令在处理文件时的行为确实有所不同。</p><p>当你使用Vim编辑并保存一个文件时，Vim实际上是创建了一个新的文件来替代旧的文件。这个新文件会有一个新的i节点，所以你会看到i节点的数值发生了变化。</p><p>这样做的好处是，如果在保存文件时发生错误（比如磁盘空间不足），你仍然可以保留原来的文件，不会丢失数据。同时，Vim还会记录下每次修改的时间和用户等信息。</p><p>相比之下，echo命令则更简单。它直接将输出追加到文件中，不会创建新的文件，因此i节点的数值不会改变。</p><p>另外，文件的权限也可能影响i节点的变化。如果文件没有写权限，Vim在保存时会创建新的文件，从而改变i节点。如果你给文件添加了写权限（比如使用<code>chmod o+w filename</code>命令），则Vim在保存时不会改变i节点。</p><p>总的来说，这两个命令在处理文件时的行为差异，反映了它们的设计理念和使用场景的不同。Vim是一个功能强大的文本编辑器，它提供了丰富的编辑功能和数据保护机制；而echo更多地被用来在脚本中输出文本或者简单地向文件中追加内容。</p><p><strong>rm只是将i节点和数据块断开</strong></p><p>因此有了ln命令，看个例子，硬链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 1 root root 3322 11月 17 15:51 utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 1 root root 3322 11月 17 15:51 utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ln</span> utils.py utils1.py</span><br><span class="line"><span class="built_in">ln</span>: 无法创建硬链接 <span class="string">&#x27;utils1.py&#x27;</span> =&gt; <span class="string">&#x27;utils.py&#x27;</span>: 不允许的操作</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 1 root root 3322 11月 17 15:51 utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ sudo <span class="built_in">ln</span> utils.py utils1.py</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 2 root root 3322 11月 17 15:51 utils.py</span><br></pre></td></tr></table></figure><p>软连接：不同分区</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -li utils.py</span><br><span class="line"><span class="number">19200499</span> -rw-r--r-- <span class="number">1</span> root root <span class="number">3322</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">15</span><span class="symbol">:</span><span class="number">51</span> utils.py</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -li utils1.py</span><br><span class="line"><span class="number">19200215</span> lrwxrwxrwx <span class="number">1</span> sv sv <span class="number">8</span> <span class="number">5</span>月  <span class="number">10</span> <span class="number">21</span><span class="symbol">:</span><span class="number">19</span> utils1.py -&gt; utils.py</span><br></pre></td></tr></table></figure><blockquote><p><strong>硬链接和软链接的区别</strong></p></blockquote><p>硬链接和软链接（也被称为符号链接）都是Unix和Linux文件系统中的概念，它们是文件的两种不同类型的链接。</p><ol><li><strong>硬链接</strong>：硬链接是一个指向文件的i节点的引用。i节点是文件系统中存储文件元数据（如文件大小、创建日期等）的数据结构。硬链接可以看作是同一文件的不同名字，它们可以位于同一文件系统的不同位置，但都指向同一i节点。删除一个硬链接不会影响到其他的硬链接，因为它们都直接指向同一i节点。【取别名】</li><li><strong>软链接</strong>：软链接（或符号链接）则类似于Windows中的快捷方式。它是一个独立的文件，包含了指向另一个文件或目录的路径。软链接可以跨越不同的文件系统，但如果目标文件被删除，软链接就会变为无效。【存路径】</li></ol><p>下面是它们之间的主要区别：</p><ul><li><strong>存储方式</strong>：硬链接是在文件系统中创建一个新的i节点，它与原文件共享i节点，而软链接是创建一个新的文件，该文件中包含了指向原文件的路径。</li><li><strong>跨文件系统</strong>：硬链接仅限于在同一文件系统中，而软链接可以链接到其他文件系统的文件。</li><li><strong>链接目录</strong>：通常，硬链接不能链接目录，而软链接可以。</li><li><strong>删除原文件</strong>：当原文件被删除后，硬链接仍然可以访问文件的内容，而软链接则会失效。</li></ul><p>这就是硬链接和软链接的基本区别。在实际使用中，你可以根据需要选择使用硬链接或软链接。</p><h3 id="磁盘分区和挂载">磁盘分区和挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line">fdisk</span><br><span class="line">mkfs</span><br><span class="line">parted</span><br><span class="line">mount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常见配置文件</span><br><span class="line">/etc/fstab</span><br><span class="line"></span><br><span class="line">用fdisk创建分区（一个硬盘设备可以创建多个分区，也可以创建一个）</span><br><span class="line">1：fdisk -l 查看有几个硬盘设备及分区</span><br><span class="line">2：fdisk /dev/sdc    （比如有设备sdc，则可以针对sdc进行分区）</span><br><span class="line">3：之后 m 键是帮助</span><br><span class="line">4：n 表示新建一个分区</span><br><span class="line">5：新建分区时，需要选择主分区和扩展分区，其中 p表示主分区，最多有4个。e表示扩展分区（里面可以建立逻辑分区）。一般把一块硬盘划分为一个主分区。使用扩展分区时，只能建立3个主分区。</span><br><span class="line">6：选择区分编号1-4</span><br><span class="line">7：指定分区扇区大小，默认2048</span><br><span class="line">8：指定分区大小。默认全部。可以 + 20G等可以选择分区大小</span><br><span class="line">9：q 表示退出，分区不生效。w 表示生效</span><br><span class="line"></span><br><span class="line">建立完分区后，需要对分区进行格式化。</span><br><span class="line"></span><br><span class="line">mkfs.ext4  mkfs.xfs等命令</span><br><span class="line">mkfs.ext4 /dev/sdc1</span><br><span class="line"></span><br><span class="line">然后要进行操作，linux里都是文件级别的操作，需要挂载到某个目录下</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/sdc1</span><br><span class="line">mount /dev/sdc1 /mnt/sdc1 挂载上去</span><br><span class="line">对/mnt/sdc1的读写就会落入sdc1设备上</span><br><span class="line"></span><br><span class="line">1、一个硬盘</span><br><span class="line">2、进行分区</span><br><span class="line">3、格式化</span><br><span class="line">4、挂载</span><br><span class="line">5、对指定目录进行操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要注意的事情：</span><br><span class="line">如果一个硬盘大于 2T ，不能使用 fdisk 进行分区，需要使用 parted</span><br><span class="line">parted /dev/sdd</span><br><span class="line"><span class="built_in">help</span> 获取帮助</span><br><span class="line"></span><br><span class="line">mount 进行挂载是临时的，不是固化的</span><br><span class="line">vim /etc/fstab</span><br><span class="line">在文件中新增下面一句话</span><br><span class="line">/dev/sdc1 /mnt/sdc1 ext4 defaults（表示权限）0 0</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/qq_38028248/article/details/115524071">Linux虚拟机磁盘分区创建、挂载、卸载、删除</a></li></ul><h3 id="系统综合状态查询">系统综合状态查询</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="keyword">sar</span> 命令查看系统综合状态</span><br><span class="line">    <span class="keyword">sar</span> -u <span class="number">1</span> <span class="number">10</span> <span class="meta">CPU</span>的查看，每隔<span class="number">1</span>秒做采样，采样<span class="number">10</span>次，</span><br><span class="line">    <span class="keyword">sar</span> -r <span class="number">1</span> <span class="number">10</span> 看内存</span><br><span class="line">    <span class="keyword">sar</span> -b <span class="number">1</span> <span class="number">10</span> IO的情况（磁盘读写）</span><br><span class="line">    <span class="keyword">sar</span> -d <span class="number">1</span> <span class="number">10</span> 查看每块磁盘的读写</span><br><span class="line">    <span class="keyword">sar</span> -q <span class="number">1</span> <span class="number">10</span> 查看进程</span><br><span class="line">使用第三方命令查看网络流量</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install iftop （网络情况）</span><br><span class="line">iftop -p （默认eth0）</span><br></pre></td></tr></table></figure><h2 id="Shell">Shell</h2><h3 id="什么是Shell">什么是Shell</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span> 是命令解释器，用于解释用户对操作系统的操作。</span><br><span class="line"></span><br><span class="line"><span class="keyword">shell</span>有很多</span><br><span class="line">    <span class="keyword">cat</span> /etc/shells</span><br><span class="line"></span><br><span class="line">CentOS 7 默认使用的<span class="keyword">shell</span>是bash</span><br></pre></td></tr></table></figure><h3 id="Shell脚本">Shell脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNIX的哲学：一条命令只做一件事情</span><br><span class="line">为了组合命令和多次执行命令，使用脚本文件来保存需要执行的命令</span><br><span class="line">赋予该文件执行权限（<span class="built_in">chmod</span> u+rx filename）</span><br></pre></td></tr></table></figure><p>Shell和Bash的区别</p><p>Shell 和 Bash 都是命令行界面，但是它们之间存在一些主要的区别。</p><ol><li>Shell 是一个通用术语，用于描述一个命令行解释器（或脚本解释器）。它是用户与操作系统进行交互的接口。在 Unix 和类 Unix 系统（如 Linux）中，有多种不同的 shell 可供选择，如 Bourne shell（sh）、C shell（csh）、Korn shell（ksh）等等。</li><li>Bash（Bourne Again SHell）是 Bourne shell 的扩展，也是 Linux 默认的 shell。它增加了许多特性，如命令行编辑、命令历史记录等，使得用户在使用命令行时更加方便。</li></ol><p>所以，可以说所有的 Bash 都是 Shell，但并非所有的 Shell 都是 Bash。如果你在 Linux 系统中打开一个终端窗口，你通常会得到一个 Bash shell。如果你在编写 shell 脚本，你可以选择使用 Bourne shell 语法（这样脚本可以在所有的 Unix-like 系统上运行），或者使用 Bash 语法（这样你可以使用 Bash 提供的额外特性，但脚本可能无法在只有 Bourne shell 的系统上运行）。</p><p>标准的Shell脚本要包含哪些元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Sha-Bang</span><br><span class="line">命令</span><br><span class="line">“<span class="comment">#”号开头的注释</span></span><br><span class="line"><span class="built_in">chmod</span> u+x filename 可执行权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行命令</span><br><span class="line">bash ./filename.sh   会生成一个子进程（不需要执行权限）</span><br><span class="line">./filename.sh   会生成一个子进程，使用Sha-Bang （需要可执行权限）</span><br><span class="line"><span class="built_in">source</span> ./filename.sh  在当前进程运行</span><br><span class="line">. filename.sh （点之后会产生一个子进程）</span><br><span class="line"></span><br><span class="line">比如一个脚本如下：</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"></span><br><span class="line">在/home目录下运行</span><br><span class="line">bash ./filename.sh 运行，子进程运行<span class="built_in">cd</span>，然后子进程结束，此时<span class="built_in">pwd</span>，还是在 /home 而不是/tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ./filename.sh 或者 . filename.sh</span><br><span class="line"></span><br><span class="line">内建命令和外部命令的区别</span><br><span class="line">内建命令不需要创建子进程，内建命令比如<span class="built_in">source</span></span><br><span class="line">内建命令对当前shell生效</span><br></pre></td></tr></table></figure><p>Sha-Bang</p><p>用于指明执行这个脚本文件的解释器</p><ul><li><a href="https://blog.csdn.net/u012294618/article/details/78427864">释伴：Linux 上的 Shebang 符号(#!)</a></li></ul><h3 id="管道与重定向">管道与重定向</h3><p><strong>管道与管道符</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">管道和信号一样，也是进程通信的方式之一</span><br><span class="line">匿名管道（管道符）是 Shell 变成经常用到的通信工具</span><br><span class="line">管道符是“|<span class="type">”，将前一个命令执行的结果传递给后面的命令</span></span><br><span class="line"><span class="type">ps</span> | <span class="type">cat</span></span><br><span class="line">echo <span class="number">123</span> | <span class="type">psecho</span> <span class="number">123</span> |<span class="type">cat</span> |<span class="type">cmd</span> 可以连续使用</span><br></pre></td></tr></table></figure><p>可以看到 cat 和 ps 是两个进程，两个进程之间的通信被连接起来。</p><p><strong>重定向符号</strong></p><p>理解箭头的方向即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一个进程默认会打开标准输入、标准输出、错误输出三个文件描述符</span><br><span class="line">输入重定向符号 “&lt;”</span><br><span class="line">read var &lt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span></span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>wc -l  &lt; <span class="regexp">/etc/passwd</span></span><br><span class="line"><span class="number">53</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出重定向符号  <span class="string">&quot;&gt;&quot;</span>  <span class="string">&quot;&gt;&gt;&quot;</span>  <span class="string">&quot;2&gt;&quot;</span> <span class="string">&quot;&amp;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">echo <span class="number">123</span> &gt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span>   清空再输入</span><br><span class="line">echo <span class="number">123</span> &gt;&gt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span>  追加</span><br><span class="line"><span class="number">2</span>&gt; 命令执行过程中有错误则重定向</span><br><span class="line">&amp;&gt; 命令执行过程中无论正确错误都重定向 </span><br><span class="line"></span><br><span class="line">输入和输出重定向组合使用</span><br><span class="line">cat &gt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span>.sh &lt;&lt; <span class="variable constant_">EOF</span></span><br><span class="line">i am <span class="variable">$USER</span></span><br><span class="line"><span class="variable constant_">EOF</span></span><br><span class="line"></span><br><span class="line">运行以上三句话，会生成一个file.sh文件，文件里内容为i am $<span class="variable constant_">USER</span></span><br></pre></td></tr></table></figure><p>补充：echo 命令在Linux中用于在标准输出设备（通常是终端或屏幕）上显示一行文本</p><p>来看看这条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">cat</span> a.sh</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ./file.sh &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">i am $USER</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ vim a.sh</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ bash ./a.sh</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span></span><br><span class="line">a.sh  file.sh  README.md  tmp  train2017.zip  utils1.py  utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">cat</span> file.sh</span><br><span class="line">i am sv</span><br></pre></td></tr></table></figure><p>GPT解释：</p><p>这条命令是在 Unix/Linux 系统中使用的，用于向文件中写入内容。让我分解一下这条命令：</p><ol><li><code>cat &gt; /path/to/a/file.sh</code>: <code>cat</code> 是 “concatenate” 的缩写，通常用于输出一个或多个文件的内容。但是这里我们使用了 <code>&gt;</code> 这个重定向符，意思是把 <code>cat</code> 命令的输出重定向到 <code>/path/to/a/file.sh</code> 这个文件中。如果文件已经存在，这个操作会覆盖原有的内容。如果文件不存在，这个操作会创建一个新的文件。</li><li><code>&lt;&lt; EOF</code>: 这是一个叫做 “here document” 的技术。<code>&lt;&lt;</code> 是一个特殊的重定向符，意思是把后面的内容作为输入。<code>EOF</code> 是一个标志，它告诉 shell，这个输入会一直持续到遇到另一个 <code>EOF</code> 为止。</li><li><code>i am $USER</code>: 这是要写入文件的内容。<code>$USER</code> 是一个环境变量，代表当前的用户名。所以这一行的意思是 “我是 当前用户名”。</li><li><code>EOF</code>: 这是前面提到的那个结束标志。遇到这个标志，shell 就知道输入结束了。</li></ol><p>所以，总的来说，这条命令的意思是创建一个文件 <code>/path/to/a/file.sh</code>，并向其中写入 “我是 当前用户名” 这样的内容。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/638108440">如何在Linux系统中使用Cat命令 [22个典型示例]</a></li></ul><h3 id="变量">变量</h3><p><strong>变量的赋值</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">变量名的命名规则</span><br><span class="line"></span><br><span class="line">字母、数字、下划线</span><br><span class="line">不以数字开头</span><br><span class="line"></span><br><span class="line">变量的赋值</span><br><span class="line"></span><br><span class="line">为变量赋值的过程中，称为变量替换</span><br><span class="line">    变量名=变量值</span><br><span class="line">    <span class="attribute">a</span>=123  （不允许出现空格，shell会认为前面不是变量名而是一个命令，比如reboot =1），会重启</span><br><span class="line"></span><br><span class="line">使用let为变量赋值</span><br><span class="line">    let <span class="attribute">a</span>=10+20 （尽量少用，效率很低）</span><br><span class="line"></span><br><span class="line">将命令赋值给变量</span><br><span class="line">    <span class="attribute">l</span>=ls  （用处不大）</span><br><span class="line"></span><br><span class="line">将命令结果赋值给变量，使用$() 或者 <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attribute">letc</span>=$(ls -l /etc)</span><br><span class="line">    <span class="attribute">letc</span>=$&#x27;ls /root<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量值有空格等特殊字符可以包含在 &quot;&quot; 或 &#x27;</span><span class="string">&#x27; 中</span></span><br><span class="line"><span class="string">    srring1=&#x27;</span>hello bash<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    string2=&quot;hello I&#x27;</span>m name<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><strong>变量引用及作用范围</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">变量的引用</span><br><span class="line">    <span class="variable">$&#123;变量名&#125;</span>称作对变量的引用</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;变量名&#125;</span> 查看变量的值</span><br><span class="line">    <span class="variable">$&#123;变量名&#125;</span> 在部分情况下可以省略为 $变量名</span><br><span class="line"></span><br><span class="line">变量的作用范围</span><br><span class="line">    变量的默认作用范围</span><br><span class="line">        当前的shell，父进程的变量对子进程无效，子进程的对父进程也无效。</span><br><span class="line">        可以使用<span class="built_in">source</span></span><br><span class="line">    变量的导出</span><br><span class="line">        <span class="built_in">export</span> ，子进程可以获得父进程的变量，同时，父进程也能看到子进程的变量</span><br><span class="line">        <span class="built_in">export</span> demo_var1=<span class="string">&quot;hello subshell&quot;</span></span><br><span class="line">    变量的删除</span><br><span class="line">        <span class="built_in">unset</span></span><br><span class="line">        <span class="built_in">unset</span> demo_var1</span><br></pre></td></tr></table></figure><p>变量作用范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ bash</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">&quot;root&quot;</span>), use <span class="string">&quot;sudo &lt;command&gt;&quot;</span>.</span><br><span class="line">See <span class="string">&quot;man sudo_root&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">-------- freesurfer-linux-ubuntu18_x86_64-7.3.2-20220819-6354275 --------</span><br><span class="line">Setting up environment <span class="keyword">for</span> FreeSurfer/FS-FAST (and FSL)</span><br><span class="line">FREESURFER_HOME   /data/home/qulijun/freesurfer</span><br><span class="line">FSFAST_HOME       /data/home/qulijun/freesurfer/fsfast</span><br><span class="line">FSF_OUTPUT_FORMAT nii.gz</span><br><span class="line">SUBJECTS_DIR      /data/home/qulijun/freesurfer/subjects</span><br><span class="line">MNI_DIR           /data/home/qulijun/freesurfer/mni</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ a=2</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>变量的导出：export ，子进程可以获得父进程的变量，同时，父进程也能看到子进程的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$demo_var1</span></span><br><span class="line">hello subshell</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ bash</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">&quot;root&quot;</span>), use <span class="string">&quot;sudo &lt;command&gt;&quot;</span>.</span><br><span class="line">See <span class="string">&quot;man sudo_root&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">-------- freesurfer-linux-ubuntu18_x86_64-7.3.2-20220819-6354275 --------</span><br><span class="line">Setting up environment <span class="keyword">for</span> FreeSurfer/FS-FAST (and FSL)</span><br><span class="line">FREESURFER_HOME   /data/home/qulijun/freesurfer</span><br><span class="line">FSFAST_HOME       /data/home/qulijun/freesurfer/fsfast</span><br><span class="line">FSF_OUTPUT_FORMAT nii.gz</span><br><span class="line">SUBJECTS_DIR      /data/home/qulijun/freesurfer/subjects</span><br><span class="line">MNI_DIR           /data/home/qulijun/freesurfer/mni</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$demo_var1</span></span><br><span class="line">hello subshell</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$demo_var1</span></span><br><span class="line">hello subshell</span><br></pre></td></tr></table></figure><p><strong>系统环境变量，预定义变量与位置变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">环境变量：每个Shell打开都可以获得到的变量</span><br><span class="line">    <span class="built_in">set</span> 和 <span class="built_in">env</span> 命令</span><br><span class="line">        <span class="built_in">env</span> |  more 查看当前所有的环境变量</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$&#123;HOME&#125;</span>  查看单个环境变量</span><br><span class="line">    <span class="variable">$PATH</span> 当前命令的搜索路径</span><br><span class="line">        所以要在<span class="variable">$PATH</span> 中新增路径，使用PATH=<span class="variable">$PATH</span>:新加路径（只对当前终端生效，对子shell生效）</span><br><span class="line">    <span class="variable">$PS1</span>  当前提示终端</span><br><span class="line"></span><br><span class="line">预定义变量</span><br><span class="line">        <span class="built_in">echo</span> $?  $$ <span class="variable">$0</span>等</span><br><span class="line">        $?   指上一条命令是否正确执行，<span class="built_in">echo</span> $?，正确执行返回0，错误1</span><br><span class="line">        $$   显示当前进程 PID</span><br><span class="line">        <span class="variable">$0</span>   显示当前进程名称</span><br><span class="line"></span><br><span class="line">位置变量</span><br><span class="line">    <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$&#123;10&#125;</span>，需要有&#123;&#125;</span><br><span class="line"></span><br><span class="line">比如有脚本 test.sh]如下：</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line">pos1=<span class="variable">$1</span></span><br><span class="line">pos2=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos2</span></span><br><span class="line"></span><br><span class="line">执行的时候，./test.sh -a -l</span><br><span class="line">会传参进去，可以对脚本进行简化</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">考虑到<span class="built_in">echo</span> <span class="variable">$2</span> 的时候 <span class="variable">$2</span> 有可能是空值。所以写成下面这样</span><br><span class="line">pos1=<span class="variable">$1</span></span><br><span class="line">pos2=<span class="variable">$&#123;2&#125;</span>_</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos2</span></span><br><span class="line">如果没有传参，则<span class="variable">$2</span>默认为_，规避读入的值是空值。但是这么写，如果传参进去，后面会多一个_，所以可以改成下面这样：</span><br><span class="line">pos2=<span class="variable">$&#123;2-_&#125;</span></span><br></pre></td></tr></table></figure><p><strong>环境变量配置文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">配置文件</span><br><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc</span><br><span class="line">/etc/bashrc</span><br><span class="line"></span><br><span class="line">所以经常在 /etc/profile 中新增 <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/new/path</span><br><span class="line">su - 切换用户会加载4个文件</span><br><span class="line">su 切换用户只会加载~/.bashrc、/etc/bashrc</span><br></pre></td></tr></table></figure><p>在 Unix 和 Linux 中，以上这些文件都是环境配置文件，具体作用如下：</p><ol><li><code>/etc/profile</code>：这是系统的全局配置文件，对所有用户都有效。该文件设置了环境变量，包括用户的 shell 环境设置、程序路径等。</li><li><code>/etc/profile.d/</code>：这是一个目录，里面的脚本文件会被 <code>/etc/profile</code> 文件在启动时候执行。这样设计的目的是为了更好的模块化和管理系统环境变量。</li><li><code>~/.bash_profile</code>：这是针对单个用户的配置文件。每当用户登录时，这个文件就会执行一次。这个文件首先查找 <code>~/.bashrc</code> 文件，如果找到，就加载该文件。</li><li><code>~/.bashrc</code>：这也是针对单个用户的配置文件。但是与 <code>~/.bash_profile</code> 不同的是，<code>~/.bashrc</code> 文件在每次打开新的 shell 时都会执行。这意味着每次打开新的终端窗口或新的 shell 时，都会读取并执行这个文件。</li><li><code>/etc/bashrc</code>：这是系统级别的，对所有用户都有效。当 bash shell 被打开时，都会读取并执行这个文件。</li></ol><p>总的来说，这些文件都是用来配置用户的 shell 环境的。其中，<code>/etc/profile</code> 和 <code>/etc/bashrc</code> 是全局的，对所有用户都有效；而 <code>~/.bash_profile</code> 和 <code>~/.bashrc</code> 是针对每个用户的，只对当前用户有效。</p><h3 id="数组">数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定义数组</span><br><span class="line">    IPTS=(10.0.0.1 10.0.0.2 10.0.0.3)</span><br><span class="line"></span><br><span class="line">显示数组的所有元素</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;IPTS[@]&#125;</span></span><br><span class="line"></span><br><span class="line">显示数组元素个数</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;#IPTS[@]&#125;</span></span><br><span class="line"></span><br><span class="line">显示数组的第一个元素</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;IPTS[0]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="转义和引用">转义和引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：一个字符不仅有字面意义，还有元意（meta-meaning）</span><br><span class="line">    <span class="comment"># 注释</span></span><br><span class="line">    ; 分号</span><br><span class="line">    \ 转义符号</span><br><span class="line">    <span class="string">&quot; 和 &#x27; 引号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单个字符的转义</span></span><br><span class="line"><span class="string">    \n \r \t 单个字母的转义</span></span><br><span class="line"><span class="string">    \$ \&quot;  \\ 单个非字母的转义</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">引用</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot; 双引号，如果里面有变量，会进行解释</span></span><br><span class="line"><span class="string">&#x27;&#x27; 单引号不会进行解释</span></span><br><span class="line"><span class="string">` 反引号</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">赋值运算符</span><br><span class="line">= 赋值运算符，用于算数赋值和字符串赋值</span><br><span class="line">使用 <span class="built_in">unset</span> 取消为变量的赋值</span><br><span class="line">= 除了作为赋值运算符还可以作为测试操作符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算数运算符</span><br><span class="line"></span><br><span class="line">基本运算符</span><br><span class="line">+ - * / ** %</span><br><span class="line"></span><br><span class="line">使用<span class="built_in">expr</span>进行计算</span><br><span class="line"><span class="built_in">expr</span> 4 + 5 （要有空格，只能支持整数）</span><br><span class="line">num1=`<span class="built_in">expr</span> 4 + 5`</span><br><span class="line"></span><br><span class="line">数字常量的使用方法，如果不用特殊方法，a=4+5，其实把 “4+5”字符串赋值给a</span><br><span class="line"><span class="built_in">let</span> “变量名=变量值”</span><br><span class="line">变量值使用0开头为八进制，0x开头为十六进制</span><br><span class="line"></span><br><span class="line">双圆括号是<span class="built_in">let</span>命令的简化</span><br><span class="line">((a=<span class="number">4</span>+<span class="number">5</span>))</span><br><span class="line">((a++))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="number">10</span>+<span class="number">20</span>)）</span><br></pre></td></tr></table></figure><h3 id="特殊字符大全">特殊字符大全</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">引号</span><br><span class="line">    <span class="string">&#x27; 完全引用</span></span><br><span class="line"><span class="string">    &quot; 不完全引用</span></span><br><span class="line"><span class="string">    ` 执行命令</span></span><br><span class="line"><span class="string">括号</span></span><br><span class="line"><span class="string">    () (()) $() 圆括号</span></span><br><span class="line"><span class="string">        单独使用圆括号会产生一个子shell（xyz=123）</span></span><br><span class="line"><span class="string">        数组初始化 IPS=(ip1 ip2 ip3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    [] [[]] 方括号</span></span><br><span class="line"><span class="string">        单独使用方括号是测试（test）或数组元素功能</span></span><br><span class="line"><span class="string">        两个方括号表示测试表达式</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">    &lt;&gt; 尖括号 重定向符号</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &#123;&#125; 花括号</span></span><br><span class="line"><span class="string">        输出范围 echo&#123;0..9&#125;，会输出0-9所有数字</span></span><br><span class="line"><span class="string">        文件复制 cp -v /etc/passwd /etc/passwd.bak </span></span><br><span class="line"><span class="string">        等同于 cp -v /etc/passwd&#123;,.bak&#125;</span></span><br><span class="line"><span class="string">运算和逻辑符号</span></span><br><span class="line"><span class="string">    +-*/% 算数运算符</span></span><br><span class="line"><span class="string">    &gt;&lt;= 比较运算符</span></span><br><span class="line"><span class="string">    &amp;&amp; || ！逻辑运算符</span></span><br><span class="line"><span class="string">        (( 5 &gt; 4 &amp;&amp; 6&gt; 5))，然后通过 echo $? 判断</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">转义符号</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其他符号</span></span><br><span class="line"><span class="string">    # 注释符</span></span><br><span class="line"><span class="string">    ;  命令分隔符</span></span><br><span class="line"><span class="string">        case 语句的分隔符要转义 ;;</span></span><br><span class="line"><span class="string">    ：空指令</span></span><br><span class="line"><span class="string">    .  和source命令相同</span></span><br><span class="line"><span class="string">    ~  家目录</span></span><br><span class="line"><span class="string">    ,  分隔目录</span></span><br><span class="line"><span class="string">    * 通配符</span></span><br><span class="line"><span class="string">    ? 条件测试或通配符</span></span><br><span class="line"><span class="string">    $ 取值符号</span></span><br><span class="line"><span class="string">    | 管道符</span></span><br><span class="line"><span class="string">    &amp; 后台运行</span></span><br><span class="line"><span class="string">       空格</span></span><br></pre></td></tr></table></figure><h3 id="测试与判断">测试与判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">退出程序命令</span><br><span class="line">    <span class="built_in">exit</span> 判断上一条命令是否正常，0或者非0</span><br><span class="line">    <span class="built_in">exit</span> 1或者0 返回10 给shell ，返回值非0位不正常退出</span><br><span class="line">    $? 判断当前shell前一个进程是否正常退出</span><br><span class="line"></span><br><span class="line">测试命令<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>命令用于检查文件或者比较值</span><br><span class="line"><span class="built_in">test</span>可以做以下测试</span><br><span class="line">    文件测试 </span><br><span class="line">    整数比较测试</span><br><span class="line">    字符串测试</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>测试语句可以简化为[]符号</span><br><span class="line">    <span class="built_in">test</span> -f /etc/passwd2 判断文件是否存在并且是个普通文件，-e是文件或者目录，-d目录</span><br><span class="line">    [ -d /etc/ ]</span><br><span class="line">[]符号还有扩展写法 [[]] 支持 &amp;&amp; || &lt; &gt;</span><br></pre></td></tr></table></figure><p>if判断语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if-then 语句的基本用法</span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ] 或 命令返回值是否为0</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">fi</span> 结束</span><br><span class="line"></span><br><span class="line">if-then-else 语句可以在条件不成立时也运行相应的命令</span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">else</span> 测试条件不成立，执行相应命令</span><br><span class="line">    <span class="keyword">fi</span> 结束</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">elif</span>  [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">else</span> 测试条件不成立，执行相应命令</span><br><span class="line">    <span class="keyword">fi</span> 结束</span><br><span class="line"></span><br><span class="line">嵌套 <span class="keyword">if</span> 的使用</span><br><span class="line"><span class="keyword">if</span> 条件测试中可以再嵌套 <span class="keyword">if</span> 条件测试</span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">        <span class="keyword">if</span> [测试条件成立]</span><br><span class="line">        <span class="keyword">then</span> 执行相应命令</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case分支">case分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 语句和 <span class="keyword">select</span> 语句可以构成分支</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;$变量&quot;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;情况1&quot;</span> )</span><br><span class="line">    命令...;;;</span><br><span class="line">    <span class="string">&quot;情况2&quot;</span> )</span><br><span class="line">    命令...;;;</span><br><span class="line">    * )</span><br><span class="line">     命令...;;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="循环">循环</h3><p><strong>for循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环的语法</span><br><span class="line">    <span class="keyword">for</span>  参数 <span class="keyword">in</span> 列表</span><br><span class="line">    <span class="keyword">do</span> 执行的命令</span><br><span class="line">    <span class="keyword">done</span> 封闭一个循环</span><br><span class="line"></span><br><span class="line">使用反引号或 $() 方式执行命令，命令的结果当做列表进行处理</span><br><span class="line">列表中包含多个变量，变量用空格分隔</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..9&#125;</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> <span class="string">&#x27;ls *.mp3&#x27;</span></span><br><span class="line">对文本处理，要使用文本查看命令取出文本内容</span><br><span class="line">默认逐行处理，如果文本出现空格会当做多行处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C 语言风格的 <span class="keyword">for</span> 命令</span><br><span class="line"><span class="keyword">for</span>((变量的初始化;循环判断条件;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">test</span>测试是否成立</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    命令</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> 循环 与<span class="keyword">while</span> 循环相反，循环测试为假时，执行循环，为真实循环停止</span><br></pre></td></tr></table></figure><p><strong>break和continue</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> 退出</span><br><span class="line"><span class="built_in">continue</span> 结束本轮循环</span><br></pre></td></tr></table></figure><p><strong>使用循环处理位置参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">命令行参数可以使用 <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$&#123;10&#125;</span>..<span class="variable">$n</span> 进行读取</span><br><span class="line"><span class="variable">$0</span> 代表脚本名称</span><br><span class="line">$* 和 <span class="variable">$@</span> 代表所有位置参数</span><br><span class="line"><span class="variable">$#</span> 代表位置参数的数量</span><br><span class="line"></span><br><span class="line">有脚本test.sh如下：</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># help display help help</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$pos</span>&quot;</span> = <span class="string">&quot;help&quot;</span>]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$pos</span> <span class="variable">$pos</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">运行语句：</span><br><span class="line">bash test.sh a b c <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 脚本如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -ge 1]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;help&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$1</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span>能够参数左移</span><br><span class="line">运行语句：</span><br><span class="line">bash test.sh a b c <span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><p><strong>自定义函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">函数用于“包含”重复使用的命令集合</span><br><span class="line"></span><br><span class="line">自定义函数</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">fname</span></span>()&#123;</span><br><span class="line">    命令</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">函数的执行</span><br><span class="line">    fname</span><br><span class="line"></span><br><span class="line">函数作用范围的变量</span><br><span class="line"><span class="built_in">local</span> 变量名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数的参数</span><br><span class="line"><span class="variable">$1</span> <span class="variable">$2</span>...<span class="variable">$n</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">checkpid</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">        [ -d <span class="string">&quot;/proc/<span class="variable">$i</span>&quot;</span> ] &amp;&amp; <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行时</span><br><span class="line">checkpid 1    或者 checkpid 1 2</span><br><span class="line"><span class="built_in">echo</span>  $?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>系统脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">系统自建了函数库，可以在脚本中引用</span><br><span class="line">/etc/init.d/functions</span><br><span class="line"></span><br><span class="line">自建函数库</span><br><span class="line">使用 <span class="built_in">source</span> 函数脚本文件“导入”函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/init.d/functions</span><br><span class="line">echo_success</span><br></pre></td></tr></table></figure><h3 id="脚本优先级控制">脚本优先级控制</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以使用 nice 和 renice 调整脚本优先级</span><br><span class="line">避免出现“不可控的”死循环</span><br><span class="line">死循环导致cpu占用过高</span><br><span class="line">死循环导致死机</span><br><span class="line"></span><br><span class="line">ulimit -a  可以查看当前终端的使用限制，root用户的话有些限制不会生效</span><br><span class="line"></span><br><span class="line">max <span class="keyword">user</span> <span class="title">processes</span> 用户的最大进程数</span><br></pre></td></tr></table></figure><h3 id="计划任务">计划任务</h3><h3 id="正则表达式与文本搜索">正则表达式与文本搜索</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">元字符</span><br><span class="line"></span><br><span class="line">. 匹配除换行符外的任意单个字符</span><br><span class="line">* 匹配任意一个跟在它前面的字符</span><br><span class="line">[] 匹配方括号中的字符类中的任意一个</span><br><span class="line">^ 匹配开头</span><br><span class="line">$ 匹配结尾</span><br><span class="line">\ 转义后面的特殊字符</span><br><span class="line"></span><br><span class="line">扩展元字符</span><br><span class="line">+ 匹配前面的正则表达式至少出现一次</span><br><span class="line">？ 匹配前面的正则表达式出现零次或一次</span><br><span class="line">| 匹配它前面或后面的正则表达式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">grep</span> 搜索</span><br><span class="line"><span class="keyword">grep</span> test <span class="regexp">/root/</span>test.txt</span><br></pre></td></tr></table></figure><h3 id="搜索文件">搜索文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">find passwd</span><br><span class="line">    -regex 区分大小写</span><br><span class="line">    -iregex 不区分大小写</span><br><span class="line"></span><br><span class="line">find /etc -regex .*wd</span><br><span class="line"></span><br><span class="line">find * txt -<span class="built_in">exec</span> <span class="built_in">rm</span> -v &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/54110864">如何高效地在 Linux 中搜索文件？</a></li></ul><h3 id="sed和awk行编辑器">sed和awk行编辑器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed 一般用于对文本内容做替换</span><br><span class="line"></span><br><span class="line">    sed <span class="string">&#x27;/user1/s/user1/u1&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">awk 基本用法</span><br><span class="line">awk 一般用于对文本内容进行统计，按需要的格式进行输出</span><br><span class="line">    <span class="built_in">cut</span> 命令：<span class="built_in">cut</span> -d:-f 1/etc/passwd</span><br><span class="line">    awk 命令：awk -F: <span class="string">&#x27;/wd$/&#123;print$1&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们看看快速启动muduo脚本的编写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash # 这行表示这个脚本文件将由 bash shell 来执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e <span class="comment"># 这行命令表示如果后面的命令返回非零退出状态，则立即退出脚本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的if语句表示如果当前目录下不存在名为build的文件夹，则创建这个文件夹。</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d `<span class="built_in">pwd</span>`/build ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> `<span class="built_in">pwd</span>`/build</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf `<span class="built_in">pwd</span>`/build/* <span class="comment"># 删除 build 文件夹下的所有文件和子目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 build 目录，然后使用 CMake 生成 Makefile 并使用 make 命令编译项目。</span></span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">pwd</span>`/build &amp;&amp;</span><br><span class="line">    cmake .. &amp;&amp;</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment"># 切换回项目的根目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的if语句表示如果 /usr/include/mymuduo 文件夹不存在，则创建这个文件夹。</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /usr/include/mymuduo ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">mkdir</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历当前目录下的所有 .h 文件，并将它们复制到 /usr/include/mymuduo 文件夹。</span></span><br><span class="line"><span class="keyword">for</span> header <span class="keyword">in</span> `<span class="built_in">ls</span> *.h`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$header</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> `<span class="built_in">pwd</span>`/lib/libmymuduo.so /usr/lib <span class="comment"># 将 libmymuduo.so 文件复制到 /usr/lib 文件夹。</span></span><br><span class="line"></span><br><span class="line">ldconfig <span class="comment"># 刷新动态链接库缓存</span></span><br></pre></td></tr></table></figure><p>这段脚本的主要目的是编译一个项目并将生成的头文件和库文件复制到系统的相应目录。</p>]]></content>
    
    
    <summary type="html">Linux实战技能</summary>
    
    
    
    <category term="Linux" scheme="https://penge666.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://penge666.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>无锁队列</title>
    <link href="https://penge666.github.io/posts/9131331a.html"/>
    <id>https://penge666.github.io/posts/9131331a.html</id>
    <published>2024-05-07T12:15:38.000Z</published>
    <updated>2024-05-07T13:19:17.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在上一篇博客中，介绍了通过指定原子变量的操作的内存顺序, 实现线程同步问题。本文看看原子变量和内存顺序的应用 – 无锁队列（Lock-Free Queue）。本文介绍单写单读和多写多读的无锁队列的简单实现，学习无锁队列设计的基本思路。对无锁队列有个入门的了解。</p><h2 id="单写单读队列">单写单读队列</h2><p>单写单读的队列比较简单, 这里我们使用循环队列实现. 如下图所示, 队列维护两个指针 <code>head</code> 和 <code>tail</code>, 分别指向队首和队尾. <code>tail</code> 始终指向 dummy 节点, 这样 <code>tail == head</code> 表示队列为空, <code>(tail + 1) % Cap == head</code> 表示队列已满, 不用维护 <code>size</code> 成员.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507202501356.png" alt="image-20240507202501356"></p><p>入队的时候移动 <code>tail</code> 指针, 而出队的时候移动 <code>head</code> 指针, 两个操作并无冲突. 不过, 出队前需要读取 <code>tail</code> 指针, 判断 <code>tail != head</code> 确认队列不为空; 同理入队时也要判断 <code>(tail + 1) % Cap != head</code> 以确认队列不满. 由于存在多个线程读写这两个指针, 因此它们都应该是原子变量.</p><p>此外, 由于两个操作在不同线程中执行, 我们还需考虑内存顺序. 如果初始队列为空, 线程 a 先执行入队操作, 线程 b 后执行出队操作, 则线程 a 入队操作的内容要对线程 b 可见.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507202552069.png" alt="image-20240507202552069"></p><p>为了做到这一点, 需要有 a(2) “happens-before” b(3). 而 a(3) 和 b(2) 分别修改了读取了 <code>tail</code>, 所以应该利用原子变量同步, 使得 a(3) “synchronizes-with” b(2). 可以在 a(3) 写入 <code>tail</code> 的操作中使用 release, b(2) 读取 <code>tail</code> 的操作中使用 acquire 实现同步.</p><p>同理, 如果初始队列满, 线程 a 先执行出队操作, 线程 b 后执行入队操作, 则线程 a 出队操作的结果要对线程 b 可见. 出队的时候需要调用出队元素的析构函数, 要保证出队元素正常销毁后才能在那个位置写入新元素, 否则会导致内存损坏. 可以在出队写入 <code>head</code> 的操作中使用 release, 入队读取 <code>head</code> 的操作中使用 acquire 实现出队 “synchronizes-with” 入队.</p><p>简单来说:</p><p>1.线程 a 先执行出队操作, 线程 b 后执行入队操作, 则线程 a 出队操作的结果要对线程 b 可见.</p><p>2.线程 a 先执行入队操作, 线程 b 后执行出队操作, 则线程 a 入队操作的结果要对线程 b 可见.</p><p>使用memory_order_acquire和memory_order_release实现线程同步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">spsc</span> : <span class="keyword">private</span> allocator&lt;T&gt; &#123;</span><br><span class="line">    T *data;</span><br><span class="line">    atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">spsc</span>(): <span class="built_in">data</span>(allocator&lt;T&gt;::<span class="built_in">allocate</span>(Cap)) &#123;&#125;</span><br><span class="line">    <span class="built_in">spsc</span>(<span class="type">const</span> spsc&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    spsc &amp;<span class="keyword">operator</span>=(<span class="type">const</span> spsc&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    spsc &amp;<span class="keyword">operator</span>=(<span class="type">const</span> spsc&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T &amp;&amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ...args)</span> </span>&#123; <span class="comment">// 入队操作</span></span><br><span class="line">        <span class="type">size_t</span> t = tail.<span class="built_in">load</span>(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">// (1)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        allocator&lt;T&gt;::<span class="built_in">construct</span>(data + t, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">// (2)  synchronizes-with (3)</span></span><br><span class="line">        tail.<span class="built_in">store</span>((t + <span class="number">1</span>) % Cap, memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;val)</span> </span>&#123; <span class="comment">// 出队操作</span></span><br><span class="line">        <span class="type">size_t</span> h = head.<span class="built_in">load</span>(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">// (3)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = std::<span class="built_in">move</span>(data[h]);</span><br><span class="line">        allocator&lt;T&gt;::<span class="built_in">destroy</span>(data + h);</span><br><span class="line">        <span class="comment">// (4) synchronizes-with (1)</span></span><br><span class="line">        head.<span class="built_in">store</span>((h + <span class="number">1</span>) % Cap, memory_order_release); <span class="comment">// (4)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种单写单读的无锁队列的两种操作可以同时执行, 且两种操作都只需要执行确定数量的指令, 因此数据 wait-free 结构, 性能很高.</p><p>给出完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type __sync_val_compare_and_swap(type *ptr, type oldval type newval, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">data</span>(<span class="keyword">new</span> T[Cap]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t = tail.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Producer: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">        data[t % Cap] = val;</span><br><span class="line">        tail.<span class="built_in">store</span>((t + <span class="number">1</span>) % Cap, std::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h % Cap];</span><br><span class="line">        head.<span class="built_in">store</span>((h + <span class="number">1</span>) % Cap, std::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="type">int</span>, <span class="number">5</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">pop</span>(val))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumer: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">push</span>(num))</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(Producer)</span></span>;</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS-操作">CAS 操作</h2><p><strong>CAS (compare and swap)</strong> 是一种原子操作, 在一个不可被中断的过程中执行比较和交换. C++ 的 <code>std::atomic</code> 中有两种 CAS 操作, <code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_weak</span>(T &amp;expected, T desired);</span><br><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired);</span><br></pre></td></tr></table></figure><p>这两种 CAS 操作基本上是相同的:</p><ul><li><p>如果原子变量与 <code>expected</code> 相等, 则将其赋值为 <code>desired</code> 并返回 <code>true</code>;</p></li><li><p>否则 <code>expected</code> 赋值成原子变量当前的值并返回 <code>false</code>.</p></li></ul><p>下面是 <code>compare_exchange_strong</code> 的一个伪实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_val == expected)</span><br><span class="line">        <span class="keyword">return</span> m_val = desired, <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> expected = m_val, <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然实际的实现不可能是这样的.</p><p><code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code> 的区别在于, <code>compare_exchange_weak</code> 有可能在当前值与 <code>expected</code> 相等时仍然不执行交换并返回 <code>false</code>; <code>compare_exchange_strong</code> 则不会有这个问题. weak 版本能让编译器在一些平台下生成一些更优的代码, 在 x86 下是没区别的.</p><p><code>compare_exchange_*</code> 支持指定两个内存顺序: 成功时的内存顺序和失败时的内存顺序.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order failure)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以利用 CAS 操作实现很多无锁数据结构. 下面我们来看如何实现多写多读的队列.</p><h2 id="多写多读队列">多写多读队列</h2><p>前面单读单写能否用到执行多写多读呢？答案是不可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h = head.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    val = std::<span class="built_in">move</span>(data[h]); <span class="comment">// (2)</span></span><br><span class="line">    allocator&lt;T&gt;::<span class="built_in">destroy</span>(data + h);</span><br><span class="line">    head.<span class="built_in">store</span>((h + <span class="number">1</span>) % Cap); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 a 和 b 同时调用 <code>pop</code>, 执行顺序是 a(1), b(1), b(2) a(2). 这种情况下, 线程 a 和线程 b 都读到相同的 <code>head</code> 指针, 存储在变量 <code>h</code> 中. 当 a(2) 尝试读取 <code>data[h]</code> 时, 其中的数据已经在 b(2) 中被 move 走了. 因此这样的队列不允许多个线程同时执行 pop 操作.</p><p>简单来说，就是2个线程都调用pop,但是只要一个data[h]可给val.</p><h3 id="解决抢占问题">解决抢占问题</h3><p>可以看到, 整个 <code>pop</code> 函数是一个非原子过程, 一旦这个过程别其他线程抢占, 就会出问题. 如何解决这个问题呢? 在无锁数据结构中, 一种常用的做法是<strong>不断重试</strong>. 具体的做法是, 在非原子过程的最后一步设计一个 CAS 操作, 如果过程被其他线程抢占, 则 CAS 操作失败, 并重新执行整个过程. 否则 CAS 操作成功, 完成整个过程的最后一步.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        h = head.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h]; <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先注意到我们不再使用 <code>std::move</code> 和 <code>allocator::destroy</code>, 而是直接复制, 使得循环体内的操作不会修改队列本身. (3) 是整个过程的最后一步, 也是唯一会修改队列的一步, 我们使用了一个 CAS 操作. 只有当 <code>head</code> 的值等于第 (1) 步获取的值的时候, 才会移动 <code>head</code> 指针, 并且返回 <code>true</code> 跳出循环; 否则就不断重试.【简单来说，就是只能有一个pop，其他的需要进入循环等待.利用CAS进行暴力美学】</p><p>这样如果多个线程并发执行 <code>pop</code>, 则只有成功执行 (3) 的线程被视为成功执行了整个过程, 其它的线程都会因为被抢占, 导致执行 (3) 的时候 <code>head</code> 被修改, 因而与局部变量 <code>h</code> 不相等, 导致 CAS 操作失败. 这样它们就要重试整个过程.</p><p>类似的思路也可以用在 <code>push</code> 上. 看看如果我们用同样的方式修改 <code>push</code> 会怎样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t = tail.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        data[t] = val; <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % Cap)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>pop</code> 操作不同, <code>push</code> 操作的第 (2) 步需要对 <code>data[t]</code> 赋值, 导致循环体内的操作会修改队列. 假设 a, b 两个线程的执行顺序是 a(1), a(2), b(1), b(2), a(3). a 可以成功执行到 (3), 但是入队的值却被 b(2) 覆盖掉了.【简单来说，就是2个线程push，但是可能后者线程会覆盖前者线程的值的这样的问题】</p><p>我们尝试将赋值操作 <code>data[t] = val</code> 移到循环的外面, 这样循环体内的操作就不会修改队列了. 当循环退出时, 能确保 <code>tail</code> 向后移动了一格, 且 <code>t</code> 指向 <code>tail</code> 移动前的位置. 这样并发的时候就不会有其他线程覆盖我们写入的值.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t = tail.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % Cap)); <span class="comment">// (2)</span></span><br><span class="line">    data[t] = val; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样做的问题是, 我们先移动 <code>tail</code> 指针再对 <code>data[t]</code> 赋值, 会导致 <code>push</code> 与 <code>pop</code> 并发不正确. 回顾下 <code>pop</code> 的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        h = head.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>()) <span class="comment">// (4)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h]; <span class="comment">// (5)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样假设有两个线程 a 和 b. 假设队列初始为空</p><ul><li>线程 a 调用 <code>push</code> , 执行 a(1), a(2). <code>tail</code> 被更新, 然后切换到线程 b</li><li>线程 b 调用 <code>pop</code> , 执行 b(4). 因为 <code>tail</code> 被更新, 因此判断队列不为空</li><li>执行到 b(5), 会读取到无效的值</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507205821012.png" alt="image-20240507205821012"></p><p>【简单来说，就是当满足pop条件，但是没有值的这样问题】</p><p>为了实现 <code>push</code> 与 <code>pop</code> 的并发, <code>push</code> 对 <code>data[t]</code> 的写入必须 “happens-before” <code>pop</code> 对 <code>data[h]</code> 的读取. 因此这就要求 <code>push</code> 操作先对 <code>data[t]</code> 赋值, 再移动 <code>tail</code> 指针. 可是前面为了实现 <code>push</code> 与 <code>push</code> 的并发我们又让 <code>push</code> 操作先移动 <code>tail</code> 再对 <code>data[t]</code> 赋值. 如何解决这一矛盾呢?</p><p>解决办法是引入一个新的指针 <code>write</code> , 用于 <code>push</code> 与 <code>pop</code> 同步. 它表示 <code>push</code> 操作<strong>写到了哪个位置</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ring_buffer</span> &#123;</span><br><span class="line">    T data[Cap];</span><br><span class="line">    atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;, write&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ring_buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ring_buffer</span>(<span class="type">const</span> ring_buffer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ring_buffer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ring_buffer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ring_buffer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ring_buffer&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t, w;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            t = tail.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_weak</span>(t, (t + <span class="number">1</span>) % Cap)); <span class="comment">// (1)</span></span><br><span class="line">        data[t] = val; <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            w = t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!write.<span class="built_in">compare_exchange_weak</span>(w, (w + <span class="number">1</span>) % Cap)); <span class="comment">// (3), (3) synchronizes-with (4)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = head.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span> (h == write.<span class="built_in">load</span>()) <span class="comment">// (4) 读 write 的值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            val = data[h]; <span class="comment">// (5)</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是暴力，多加个变量解决上述问题。</p><p><code>push</code> 操作的基本步骤是:</p><ol><li>移动 <code>tail</code>;</li><li>对 <code>data[t]</code> 赋值, <code>t</code> 等于 <code>tail</code> 移动前的位置;</li><li>移动 <code>write</code>. <code>write</code> 移动后等于 <code>tail</code>.</li></ol><p>而 <code>pop</code> 操作使用 <code>write</code> 指针判断队列中是否有元素. 因为有 (3) “synchronizes-with” (4), 所以 (2) “happens-before” (5), <code>pop</code> 能读到 <code>push</code> 写入的值. 在 <code>push</code> 函数中, 只有在当前的 <code>write</code> 等于 <code>t</code> 时才将 <code>write</code> 移动一格, 能确保最终 <code>write</code> 等于 <code>tail</code>.</p><p>这种多写多读的无锁队列的两种操作可以同时执行, 但是每种操作都有可能要重试, 因此属于 lock-free 结构.</p><h3 id="考虑内存顺序">考虑内存顺序</h3><p>前面例子使用默认的内存顺序, 也就是 memory_order_seq_cst . 为了优化性能, 可以使用更宽松的内存顺序. 而要考虑内存顺序, 就要找出其中的 happens-before 的关系.</p><p>前面分析了, <code>push</code> 中的赋值操作 <code>data[t] = val</code> 要 “happens-before” <code>pop</code> 中的读取操作 <code>val = data[h]</code>, 这是通过 <code>write</code> 原子变量实现的: <code>push</code> 中对 <code>write</code> 的修改要 “synchronizes-with” <code>pop</code> 中对 <code>write</code> 的读取. 因此 <code>push</code> 修改 <code>write</code> 的 CAS 操作应该使用 release, <code>pop</code> 读取 <code>write</code> 时则应使用 acquire.</p><p>同理, 当队列初始为满的时候, 先运行 <code>pop</code> 在运行 <code>push</code>, 要保证 <code>pop</code> 中的读取操作 <code>val = data[h]</code> “happens-before” <code>push</code> 中的赋值操作 <code>data[t] = val</code>. 这是通过 <code>head</code> 原子变量实现的: <code>pop</code> 中对 <code>head</code> 的修改要 “synchronizes-with” <code>push</code> 中对 <code>head</code> 的读取. 因此 <code>pop</code> 修改 <code>head</code> 的 CAS 操作应该使用 release, <code>push</code> 读取 <code>head</code> 时则应使用 acquire.</p><p>这部分和上面一样，就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ring_buffer&lt;T, Cap&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> t, w;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t = tail.<span class="built_in">load</span>(memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">//(2)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_weak</span>(t, (t + <span class="number">1</span>) % Cap, memory_order_relaxed)); <span class="comment">// (3)</span></span><br><span class="line">    data[t] = val; <span class="comment">// (4), (4) happens-before (8)</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        w = t;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!write.<span class="built_in">compare_exchange_weak</span>(w, (w + <span class="number">1</span>) % Cap,</span><br><span class="line">              memory_order_release, memory_order_relaxed)); <span class="comment">// (5), (5) synchronizes-with (7)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ring_buffer&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        h = head.<span class="built_in">load</span>(memory_order_relaxed); <span class="comment">// (6)</span></span><br><span class="line">        <span class="keyword">if</span> (h == write.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">// (7)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h]; <span class="comment">// (8), (8) happens-before (4)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap,</span><br><span class="line">              memory_order_release, memory_order_relaxed)); <span class="comment">// (9), (9) synchronizes-with (2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 与 <code>push</code> 并发移动 <code>tail</code> 指针的时候, 只影响到 <code>tail</code> 本身. 因此 (1) 和 (3) 对 <code>tail</code> 读写使用 relaxed 就可以了. 同样 <code>push</code> 与 <code>push</code> 并发移动 <code>write</code> 指针时, 也不需要利用它做同步, 因此 (5) 处的做法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write.<span class="built_in">compare_exchange_weak</span>(w, (w + <span class="number">1</span>) % Cap,</span><br><span class="line">                            memory_order_release, memory_order_relaxed)</span><br></pre></td></tr></table></figure><p>成功时使用 release, 为了与 <code>pop</code> 同步; 而失败时使用 relaxed 就可以了.</p><p>同理, <code>pop</code> 与 <code>pop</code> 并发移动 <code>head</code> 时, 也影响到 <code>head</code> 本身. 因此 (6) 读取 <code>head</code> 使用 relaxed 即可. 而 (9) 处为了与 <code>push</code> 同步, 成功时要使用 release, 失败时使用 relaxed 即可.</p><p>最后，给出完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type __sync_val_compare_and_swap(type *ptr, type oldval type newval, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">data</span>(<span class="keyword">new</span> T[Cap]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t, w;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = tail.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % Cap, memory_order_relaxed));</span><br><span class="line">        data[t % Cap] = val;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Producer:&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; data:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            w = t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!write.<span class="built_in">compare_exchange_strong</span>(w, (w + <span class="number">1</span>) % Cap, memory_order_release, memory_order_relaxed));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T val;</span><br><span class="line">        <span class="type">size_t</span> h;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span> (h == write.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            val = data[h % Cap];</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap,</span><br><span class="line">                                               memory_order_release, memory_order_relaxed));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Comsumer:&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; data:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;, write&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="type">int</span>, <span class="number">5</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">pop</span>())</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">push</span>(num))</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;thread&gt; p, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p.<span class="built_in">emplace_back</span>(Producer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">emplace_back</span>(Consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ci : c)</span><br><span class="line">        ci.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pi : p)</span><br><span class="line">        pi.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优劣势">优劣势</h2><h3 id="优势">优势</h3><ul><li>实现简单, 容易理解 (相比更复杂的链式结构)</li><li>无锁高并发. 虽然存在循环重试, 但是这只会在相同操作并发的时候出现. push 不会因为与 pop 并发而重试, 反之亦然.</li></ul><h3 id="缺陷">缺陷</h3><ul><li>这样队列只应该存储标量, 不应该存储对象 (但是可以存储指针), 原因有两点<ul><li>pop 中会循环执行 val = data[h] , 对象的拷贝会有性能开销</li><li>push 中执行 data[t] = val 类似, 如果拷贝时间过长, 可能会导致并发执行 push 的线程一直等待</li><li>如果 push 中 data[t] = val 抛出了异常, 可能会导致并发执行 push 的线程死锁</li></ul></li><li>不能存储智能指针. 因为出队后对象仍然在 data 数组里, 并没有销毁.</li><li>容量是固定的, 不能动态扩容.</li></ul><p>其中，简单的是直接使用boost库中的<code>boost::lockfree::queue</code>。这是一个线程安全的无锁队列，可以在多线程环境下使用。</p><p>本文学习自：<a href="https://luyuhuang.tech/2022/10/30/lock-free-queue.html#cas-%E6%93%8D%E4%BD%9C">C++ 实现无锁队列</a></p>]]></content>
    
    
    <summary type="html">Lock-Free Queue</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp内存顺序</title>
    <link href="https://penge666.github.io/posts/4c8902bb.html"/>
    <id>https://penge666.github.io/posts/4c8902bb.html</id>
    <published>2024-05-07T03:31:55.000Z</published>
    <updated>2024-05-07T13:27:13.984Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 将多线程纳入了标准. 一旦涉及到多线程, 就需要考虑<strong>并发</strong>, <strong>数据竞争 (date race)</strong>, <strong>线程同步</strong>等问题, 为此 C++ 提供了互斥锁 <code>std::mutex</code>, 原子变量 <code>std::atomic</code> 等标准库。</p><p>把博客中的例子理解清楚。</p><h2 id="1-原子变量">1. 原子变量</h2><p>我们不能在两个线程中同时访问修改一个变量, 这会导致数据竞争的问题. 程序的结果是未定义的. 从实现上来说, 我们不能保证读写操作是原子的, 例如 32 位机器上, 修改一个 64 位变量可能需要两条指令; 或者变量有可能只是在寄存器里, 对其的修改要在稍后才会写入内存. 解决数据竞争的方式除了使用 <code>std::mutex</code> 加锁, 还可以使用原子变量.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子展示了原子变量最简单的用法. 使用原子变量不用担心数据竞争, 对它的操作都是原子的. <strong>除此之外, 原子变量的操作可以指定内存顺序, 帮助我们实现线程同步, 这也是本文的重点</strong>. 上面的代码中, 线程 1 将值写入原子变量 <code>a</code>, 线程 2 则读取 <code>a</code> 中的值. 这便是原子变量最基础的两种操作。</p><h3 id="1-1-原子变量的操作">1.1 原子变量的操作</h3><p>对原子变量的操作可以分为三种</p><ol><li>store. 将一个值存到原子变量中.</li><li>load. 读取原子变量中的值.</li><li>read-modify-write (RMW). 原子地执行读取, 修改和写入. 如自增操作 <code>fetch_add</code>, 交换操作 <code>exchange</code> (返回变量当前的值并写入指定值) 等.</li></ol><p>每个原子操作都需要指定一个<strong>内存顺序 (memory order)</strong>. 不同的内存顺序有不同的语义, 会实现不同的顺序模型 (order model), 性能也各不相同. C++ 中有六种内存顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这六种内存顺序相互组合可以实现三种顺序模型 (ordering model)</strong></p><ul><li><strong>Sequencial consistent ordering. 实现同步, 且保证全局顺序一致 (single total order) 的模型. 是一致性最强的模型, 也是默认的顺序模型.</strong></li><li><strong>Acquire-release ordering. 实现同步, 但不保证保证全局顺序一致的模型.</strong></li><li><strong>Relaxed ordering. 不能实现同步, 只保证原子性的模型.</strong></li></ul><p>稍后我们会详细讨论这六种内存顺序. <code>atomic::store</code> 和 <code>atomic::load</code> 函数都有一个内存顺序的参数, 默认为 <code>memory_order_seq_cst</code>. 它们的声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">(T desired, std::memory_order order = std::memory_order_seq_cst)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>此外 <code>std::atomic</code> 重载了运算符, 我们可以像使用普通变量一样读写原子变量. 例如上面代码中两个线程的读写操作分别调用的是 <code>std::atomic&lt;int&gt;::operator=(int)</code> 和 <code>std::atomic&lt;int&gt;::operator int()</code>. 此时会使用默认的内存顺序, 也就是 <code>memory_order_seq_cst</code>。</p><h2 id="2-基础概念">2. 基础概念</h2><p>在开始讲这六种内存顺序之前, 有必要先了解一下几个最基础的概念.</p><h3 id="2-1-修改顺序-Modification-orders">2.1 修改顺序 (Modification orders)</h3><p>对一个原子变量的所有修改操作总是存在一定的先后顺序, 且所有线程都认可这个顺序, 即使这些修改操作是在不同的线程中执行的. 这个所有线程一致同意的顺序就称为<strong>修改顺序 (modification order)</strong>. 这意味着</p><ul><li>两个修改操作不可能同时进行, 一定存在一个先后顺序. 这很容易理解, 因为这是原子操作必须保证的, 否则就有数据竞争的问题.</li><li>即使每次运行的修改顺序可能都不同, 但所有线程看到的修改顺序总是一致的. 如果线程 a 看到原子变量 x 由 1 变成 2, 那么线程 b 就不可能看到 x 由 2 变成 1.</li></ul><p>无论使用哪种内存顺序, 原子变量的操作总能满足修改顺序一致性, 即使是最松散的 <code>memory_order_relaxed</code>. 我们来看一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">        a.<span class="built_in">store</span>(i, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">        a.<span class="built_in">store</span>(i, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        v-&gt;<span class="built_in">push_back</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread4</span><span class="params">(vector&lt;<span class="type">int</span>&gt; *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        v-&gt;<span class="built_in">push_back</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3, v4;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span>, <span class="title">t2</span><span class="params">(thread2)</span>, <span class="title">t3</span><span class="params">(thread3, &amp;v3)</span>, <span class="title">t4</span><span class="params">(thread4, &amp;v4)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(), t2.<span class="built_in">join</span>(), t3.<span class="built_in">join</span>(), t4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v3) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v4) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了 4 个线程. <code>thread1</code> 和 <code>thread2</code> 分别将偶数和奇数依次写入原子变量 <code>a</code>, <code>thread3</code> 和 <code>thread4</code> 则读取它们. 最后输出 <code>thread3</code> 和 <code>thread4</code> 每次读取到的值. 程序运行的结果可能是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-modification-order</span><br><span class="line"><span class="number">1</span> <span class="number">8</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">$ ./test-modification-order</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>虽然每次运行的修改顺序不同, 各个线程也不太可能看到每次修改的结果, 但是它们看到的修改顺序是一致的. 例如 <code>thread3</code> 看到 8 先于 9, <code>thread4</code> 也会看到 8 先于 9, 反之亦然.</p><h3 id="2-2-Happens-before">2.2 Happens-before</h3><p><strong>Happens-before</strong> 是一个非常重要的概念. 如果操作 a “happens-before” 操作 b, 则操作 a 的结果对于操作 b 可见. happens-before 的关系可以建立在用一个线程的两个操作之间, 也可以建立在不同的线程的两个操作之间.</p><h4 id="2-2-1-单线程的情况-sequenced-before">2.2.1 单线程的情况: sequenced-before</h4><p>单线程的情况很容易理解. 函数的语句按顺序依次执行, 前面的语句先执行, 后面的后执行. 正式地说, 前面的语句总是 <strong>“sequenced-before”</strong> 后面的语句. 显然, 根据定义, sequenced-before 具有传递性:</p><ul><li>如果操作 a “sequenced-before” 操作 k, 且操作 k “sequenced-before” 操作 b, 则操作 a “sequenced-before” 操作 b.</li></ul><p>Sequenced-before 可以直接构成 happens-before 的关系. 如果操作 a “sequenced-before” 操作 b, 则操作 a “happens-before” 操作 b. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">42</span>; <span class="comment">// (1)</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>语句 (1) 在语句 (2) 的前面, 因此语句 (1) “sequenced-before” 语句 (2), 也就是 (1) “happens-before” 语句 (2). 所以 (2) 可以打印出 (1) 赋值的结果.</p><h4 id="2-2-2-多线程的情况-synchronizes-with-和-inter-thread-happens-before">2.2.2 多线程的情况: synchronizes-with 和 inter-thread happens-before</h4><p>多线程的情况就稍微复杂些. 一般来说多线程都是并发执行的, 如果没有正确的同步操作, 就无法保证两个操作之间有 happens-before 的关系. 如果我们通过一些手段, 让不同线程的两个操作同步, 我们称这两个操作之间有 <strong>synchronizes-with</strong> 的关系. 稍后我们会详细讨论如何组合使用 6 种内存顺序, 让两个操作达成 synchronizes-with 的关系.</p><p>如果线程 1 中的操作 a “synchronizes-with” 线程 2 中的操作 b, 则操作 a <strong>“inter-thread happens-before”</strong> 操作 b. 此外 synchronizes-with 还可以 “后接” 一个 sequenced-before 关系组合成 inter-thread happens-before 的关系:</p><ul><li>如果操作 a “synchronizes-with” 操作 k, 且操作 k “sequenced-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li></ul><p>Inter-thread happens-before 关系则可以 “前接” 一个 sequenced-before 关系以延伸它的范围; 而且 inter-thread happens-before 关系具有传递性:</p><ul><li>如果操作 a “sequenced-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li><li>如果操作 a “inter-thread happens-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li></ul><p>正如它的名字暗示的, 如果操作 a “inter-thread happens-before” 操作 b, 则操作 a “happens-before” 操作 b. 下图展示了这几个概念之间的关系:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507143104191.png" alt=""></p><p>注意, 虽然 sequenced-before 和 inter-thread happens-before 都有传递性, 但是 <strong>happens-before 没有传递性</strong>. 后面我们会在 3.5 节中看到这个性质的重要性, 以及 C++ 为什么要定义这么多概念.</p><p>现在我们来看一个例子. 假设下面的代码中 <code>unlock()</code> 操作 “synchronizes-with” <code>lock()</code> 操作.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a += <span class="number">1</span> <span class="comment">// (1)</span></span><br><span class="line">    <span class="built_in">unlock</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(); <span class="comment">// (3)</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设直到 <code>thread1</code> 执行到 (2) 之前, <code>thread2</code> 都会阻塞在 (3) 处的 <code>lock()</code> 中. 那么可以推导出:</p><ul><li>根据语句顺序, 有 (1) “sequenced-before” (2) 且 (3) “sequenced-before” (4);</li><li>因为 (2) “synchronizes-with” (3) 且 (3) “sequenced-before” (4), 所以 (2) “inter-thread happens-before” (4);</li><li>因为 (1) “sequenced-before” (2) 且 (2) “inter-thread happens-before” (4), 所以 (1) “inter-thread happens-before” (4); 所以 (1) “happens-before” (4).</li></ul><p>因此 (4) 可以读到 (1) 对变量 <code>a</code> 的修改.</p><h3 id="2-3-Happens-before-不代表指令实际的执行顺序">2.3 Happens-before 不代表指令实际的执行顺序</h3><p>需要说明的是, happens-before 是 C++ 语义层面的概念, 它并不代表指令在 CPU 中实际的执行顺序. 为了优化性能, 编译器会在不破坏语义的前提下对指令重排. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有 <code>a++;</code> “happens-before” <code>b++;</code>, 但编译器实际生成的指令可能是先加载 <code>a</code>, <code>b</code> 两个变量到寄存器, 接着分别执行 “加一” 操作, 然后再执行 <code>a + b</code>, 最后才将自增的结果写入内存.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add():</span><br><span class="line">    movl    a(%rip), %eax   # 将变量 a 加载到寄存器</span><br><span class="line">    movl    b(%rip), %ecx   # 将变量 b 加载到寄存器</span><br><span class="line">    addl    $1, %eax        # a 的值加一</span><br><span class="line">    leal    1(%rcx), %edx   # b 的值加一</span><br><span class="line">    movl    %eax, a(%rip)   # 将 a 加一的结果写入内存</span><br><span class="line">    addl    %edx, %eax      # a + b</span><br><span class="line">    movl    %edx, b(%rip)   # 将 b 加一的结果写入内存</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>上面展示了 x86-64 下的一种可能的编译结果. 可以看到 C++ 的一条语句可能产生多条指令, 这些指令都是交错执行的. 其实编译器甚至还有可能先自增 <code>b</code> 再自增 <code>a</code>. 这样的重排并不会影响语义, 两个自增操作的结果仍然对 <code>return a + b;</code> 可见.</p><h2 id="3-内存顺序">3. 内存顺序</h2><p>前面我们提到 C++ 的六种内存顺序相互组合可以实现三种顺序模型. 现在我们来具体看看如何使用这六种内存顺序, 以及怎样的组合可以实现 synchronizes-with 的关系.</p><h3 id="3-1-memory-order-seq-cst">3.1 memory_order_seq_cst</h3><p><code>memory_order_seq_cst</code> 可以用于 store, load 和 read-modify-write 操作, 实现 sequencial consistent 的顺序模型. 在这个模型下, 所有线程看到的所有操作都有一个一致的顺序, 即使这些操作可能针对不同的变量, 运行在不同的线程. 2.1 节中我们介绍了修改顺序 (modification order), 即单一变量的修改顺序在所有线程看来都是一致的. Sequencial consistent 则将这种一致性扩展到了所有变量. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thread1</code> 和 <code>thread2</code> 分别修改原子变量 <code>x</code> 和 <code>y</code>. 运行过程中, 有可能先执行 (1) 再执行 (2), 也有可能先执行 (2) 后执行 (1). 但无论如何, 所有线程中看到的顺序都是一致的. 因此如果我们这样测试这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) ++z; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst)); <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) ++z; <span class="comment">// (6)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread1)</span>, <span class="title">b</span><span class="params">(thread2)</span>, <span class="title">c</span><span class="params">(read_x_then_y)</span>, <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(), b.<span class="built_in">join</span>(), c.<span class="built_in">join</span>(), d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">// (7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(7) 处的断言永远不会失败. <strong>因为 <code>x</code> 和 <code>y</code> 的修改顺序是全局一致的, 如果先执行 (1) 后执行 (2), 则 <code>read_y_then_x</code> 中循环 (5) 退出时, 能保证 <code>y</code> 为 <code>true</code>, 此时 <code>x</code> 也必然为 <code>true</code>, 因此 (6) 会被执行; 同理, 如果先执行 (2) 后执行 (1), 则循环 (3) 退出时 <code>y</code> 也必然为 <code>true</code>, 因此 (4) 会被执行. 无论如何, <code>z</code> 最终都不会等于 0.</strong></p><p>Sequencial consistent 可以实现 synchronizes-with 的关系. 如果一个 <code>memory_order_seq_cst</code> 的 load 操作在某个原子变量上读到了一个 <code>memory_order_seq_cst</code> 的 store 操作在这个原子变量中写入的值, 则 store 操作 “synchronizes-with” load 操作. 在上面的例子中, 有 (1) “synchronizes-with” (3) 和 (2) “synchronizes-with” (5).</p><p>实现 sequencial consistent 模型有一定的开销. 现代 CPU 通常有多核, 每个核心还有自己的缓存. 为了做到<strong>全局顺序一致</strong>, 每次写入操作都必须同步给其他核心. 为了减少性能开销, 如果不需要全局顺序一致, 我们应该考虑使用更加宽松的顺序模型.</p><h3 id="3-2-memory-order-relaxed">3.2 memory_order_relaxed</h3><p><code>memory_order_relaxed</code> 可以用于 store, load 和 read-modify-write 操作, 实现 relaxed 的顺序模型. 这种模型下, 只能保证操作的原子性和修改顺序 (modification order) 一致性, 无法实现 synchronizes-with 的关系. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thread1</code> 对不同的变量执行 store 操作. 那么在某些线程看来, 有可能是 <code>x</code> 先变为 <code>true</code>, y 后变为 <code>true</code>; 另一些线程看来, 又有可能是 <code>y</code> 先变为 <code>true</code>, <code>x</code> 后变为 <code>true</code>. 如果这样测试这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="built_in">assert</span>(x.<span class="built_in">load</span>()); <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) 处的断言就有可能失败. 因为 (2) 与 (3) 之间没有 synchronizes-with 的关系, 所以就不能保证 (1) “happens-before” (4). 因此 (4) 就有可能读到 <code>false</code>.</strong> 至于 relaxed 顺序模型能保证的修改顺序一致性的例子, 2.1 节中已经讨论过了, 这里就不多赘述了.</p><p>Relaxed 顺序模型的开销很小. 在 x86 架构下, <code>memory_order_relaxed</code> 的操作不会产生任何其他的指令, 只会影响编译器优化, 确保操作是原子的. Relaxed 模型可以用在一些不需要线程同步的场景, 但是使用时要小心. 例如 <code>std::shared_ptr</code> 增加引用计数时用的就是 <code>memory_order_relaxed</code>, 因为不需要同步; 但是减小应用计数不能用它, 因为需要与析构操作同步.</p><h3 id="3-3-Acquire-release">3.3 Acquire-release</h3><p>在 acquire-release 模型中, 会使用 <code>memory_order_acquire</code>, <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code> 这三种内存顺序. 它们的用法具体是这样的:</p><ul><li><p>对原子变量的 load 可以使用 <code>memory_order_acquire</code> 内存顺序. 这称为 <strong>acquire 操作</strong>.</p></li><li><p>对原子变量的 store 可以使用 <code>memory_order_release</code> 内存顺序. 这称为 <strong>release 操作</strong>.</p></li><li><p>read-modify-write 操作即读 (load) 又写 (store), 它可以使用 <code>memory_order_acquire</code>, <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code>:</p><ul><li>如果使用 <code>memory_order_acquire</code>, 则作为 acquire 操作;</li><li>如果使用 <code>memory_order_release</code>, 则作为 release 操作;</li><li>如果使用 <code>memory_order_acq_rel</code>, 则同时为两者.</li></ul></li></ul><p>Acquire-release 可以实现 synchronizes-with 的关系. 如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值, 则这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们来看一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="built_in">assert</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed)); <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中, 语句 (2) 使用 <code>memory_order_release</code> 在 <code>y</code> 中写入 <code>true</code>, 语句 (3) 中使用 <code>memory_order_acquire</code> 从 <code>y</code> 中读取值. 循环 (3) 退出时, 它已经读取到了 <code>y</code> 的值为 <code>true</code>, 也就是读取到了操作 (2) 中写入的值. 因此有 (2) “synchronizes-with” (3). 根据 2.2 节介绍的规则我们可以推导出:</p><ul><li>因为 (2) “synchronizes-with” (3) 且 (3) “sequenced-before” (4), 所以 (2) “inter-thread happens-before” (4);</li><li>因为 (1) “sequenced-before” (2) 且 (2) “inter-thread happens-before” (4), 所以 (1) “inter-thread happens-before” (4);</li></ul><p>所以 (1) “happens-before” (4). 因此 (4) 能读取到 (1) 中写入的值, 断言永远不会失败. 即使 (1) 和 (4) 用的是 <code>memory_order_relaxed</code>.</p><p>3.1 节我们提到 sequencial consistent 模型可以实现 synchronizes-with 关系. 事实上, 内存顺序为 <code>memory_order_seq_cst</code> 的 load 操作和 store 操作可以分别视为 acquire 操作和 release 操作. 因此对于两个指定了 <code>memory_order_seq_cst</code> 的 store 操作和 load 操作, 如果后者读到了前者写入的值, 则前者 “synchronizes-with” 后者.</p><p>为了实现 synchronizes-with 关系, acquire 操作和 release 操作应该成对出现. 如果 <code>memory_order_acquire</code> 的 load 读到了 <code>memory_order_relaxed</code> 的 store 写入的值, 或者 <code>memory_order_relaxed</code> 的 load 读到了 <code>memory_order_release</code> 的 store 写入的值, 都不能实现 synchronizes-with 的关系.</p><p><strong>虽然 sequencial consistent 模型能够像 acquire-release 一样实现同步, 但是反过来 acquire-release 模型不能像 sequencial consistent 一样提供全局顺序一致性.</strong> 如果将 3.1 节的例子中的 <code>memory_order_seq_cst</code> 换成 <code>memory_order_acquire</code> 和 <code>memory_order_release</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) ++z; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) ++z; <span class="comment">// (6)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则最终不能保证 <code>z</code> 不为 0. <strong>在同一次运行中, <code>read_x_then_y</code> 有可能看到先 (1) 后 (2), 而 <code>read_y_then_x</code> 有可能看到先 (2) 后 (1). 这样有可能 (4) 和 (6) 的 load 的结果都为 <code>false</code>, 导致最后 <code>z</code> 仍然为 0.</strong></p><p>Acquire-release 的开销比 sequencial consistent 小. 在 x86 架构下, <code>memory_order_acquire</code> 和 <code>memory_order_release</code> 的操作不会产生任何其他的指令, 只会影响编译器的优化: 任何指令都不能重排到 acquire 操作的前面, 且不能重排到 release 操作的后面; 否则会违反 acquire-release 的语义. 因此很多需要实现 synchronizes-with 关系的场景都会使用 acquire-release.</p><h3 id="3-4-Release-sequences">3.4* Release sequences</h3><p>到目前为止我们看到的, 无论是 sequencial consistent 还是 acquire-release, <strong>要想实现 synchronizes-with 的关系, acquire 操作必须在同一个原子变量上读到 release 操作的写入的值. 如果 acquire 操作没有读到 release 操作写入的值, 那么它俩之间通常没有 synchronizes-with 的关系</strong>. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="number">2</span>, std::memory_order_release); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (4)</span></span><br><span class="line">    <span class="built_in">assert</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">1</span>); <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中, 只要 <code>y</code> 的值非 0 循环 (4) 就会退出. 当它退出时, 有可能读到 (2) 写入的值, 也有可能读到 (3) 写入的值. 如果是后者, 则只能保证 (3) “synchronizes-with” (4), 不能保证与 (2) 与 (4) 之间有同步关系. 因此 (5) 处的断言就有可能失败.</p><p>但并不是只有在 acquire 操作读取到 release 操作写入的值时才能构成 synchronizes-with 关系. 为了说这种情况, 我们需要引入 <strong>release sequence</strong> 这个概念.</p><p>针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. <strong>如果这一连串操作是由</strong></p><ul><li><strong>同一线程上的写操作, 或者</strong></li><li><strong>任意线程上的 read-modify-write 操作</strong></li></ul><p>这两种构成的, 则称这一连串的操作为<strong>以 release 操作 A 为首的 release sequence</strong>. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序.</p><p>如果一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们来看个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>); <span class="comment">// (1)</span></span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_relaxed)) <span class="comment">// (3)</span></span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>); <span class="comment">// (4)</span></span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中, (3) 处的 <code>compare_exchange_strong</code> 是一种 read-modify-write 操作, 它判断原子变量的值是否与期望的值 (第一个参数) 相等, 如果相等则将原子变量设置成目标值 (第二个参数) 并返回 <code>true</code>, 否则将第一个参数 (引用传递) 设置成原子变量当前值并返回 <code>false</code>. 操作 (3) 会一直循环检查, 当 <code>flag</code> 当值为 1 时, 将其替换成 2. 所以 (3) 属于 (2) 的 release sequence. 而循环 (4) 退出时, 它已经读到了 (3) 写入的值, 也就是 release 操作 (2) 为首的 release sequence 写入的值. 所以有 (2) “synchronizes-with” (4). 因此 (1) “happens-before” (5), (5) 处的断言不会失败.</p><p>注意 (3) 处的 <code>compare_exchange_strong</code> 的内存顺序是 <code>memory_order_relaxed</code>, 所以 (2) 与 (3) 并不构成 synchronizes-with 的关系. 也就是说, 当循环 (3) 退出时, 并不能保证 <code>thread2</code> 能读到 <code>data.at(0)</code> 为 42. 但是 (3) 属于 (2) 的 release sequence, 当 (4) 以 <code>memory_order_acquire</code> 的内存顺序读到 (2) 的 release sequence 写入的值时, 可以与 (2) 构成 synchronizes-with 的关系.</p><h3 id="3-5-memory-order-consume">3.5* memory_order_consume</h3><p><code>memory_order_consume</code> 其实是 acquire-release 模型的一部分, 但是它比较特殊, 它涉及到数据间相互依赖的关系. 为此我们又要提出两个新概念: <strong>carries dependency</strong> 和 <strong>dependency-ordered before</strong>.</p><p>如果操作 a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 一般来说, 如果 a 的值用作 b 的一个操作数, 或者 b 读取到了 a 写入的值, 都可以称为 b 依赖于 a. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p++;  <span class="comment">// (1)</span></span><br><span class="line">i++;  <span class="comment">// (2)</span></span><br><span class="line">p[i]; <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><p>有 (1) “sequenced-before” (2) “sequenced-before” (3); (1) 和 (2) 的值作为 (3) 的下标运算符 <code>[]</code> 的操作数, 所以有 (1) “carries a dependency into” (3) 和 (2) “carries a dependency into” (3). 但是 (1) 和 (2) 并没有相互依赖, 它们之间没有 carries dependency 的关系. 类似于 sequenced-before, carries dependency 关系具有传递性.</p><p><code>memory_order_consume</code> 可以用于 load 操作. 使用 <code>memory_order_consume</code> 的 load 称为 consume 操作. 如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值, 或以其为首的 release sequence 写入的值, 则这个 release 操作 “dependency-ordered before” 这个 consume 操作.</p><p>Dependency-ordered before 可以 “后接” 一个 carries dependency 的关系以延伸它的范围: 如果 a “dependency-ordered before” k 且 k “carries a dependency into” b, 则 a “dependency-ordered before” b. Dependency-ordered before 可以直接构成 inter-thread happens-before 的关系: 如果 a “dependency-ordered before” b 则 a “inter-thread happens-before” b.</p><p>概念很复杂, 但是基本思路是:</p><ul><li>release 操作和 acquire 操作构成的 synchronizes-with 可以后接 sequenced-before 构成 inter-thread happens-before 的关系;</li><li>release 操作和 consume 操作构成的 dependency-ordered before 则只能后接 carries dependency 构成 inter-thread happens-before 的关系.</li><li>无论 inter-thread happens-before 是怎么构成的, 都可以前接 sequenced-before 以延伸其范围.</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507150744160.png" alt="image-20240507150744160"></p><p>我们来看一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// (1)</span></span><br><span class="line">    data = <span class="number">42</span>; <span class="comment">// (2)</span></span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume))); <span class="comment">// (4)</span></span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// (5)</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// (6)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 处的循环退出时, consume 操作 (4) 读取到 release 操作 (3) 写入的值, 因此 (3) “dependency-ordered before” (4). 由此可以推导出:</p><ul><li><code>p2</code> 的值作为 (5) 的操作数, 因此 (4) “carries a dependency into” (5);</li><li>因为 (3) “dependency-ordered before” (4) 且 (4) “carries a dependency into” (5), 所以 (3) “inter-thread happens-before” (5);</li><li>因为 (1) “sequenced-before” (3) 且 (3) “inter-thread happens-before” (5), 所以 (1) “inter-thread happens-before” (5);</li></ul><p>所以 (1) “happens-before” (5). 因此 (5) 可以读到 (1) 写入的值, 断言 (5) 不会失败. 但是操作 (6) 并不依赖于 (4), 所以 (3) 和 (6) 之间没有 inter-thread happens-before 的关系, 因此断言 (6) 就有可能失败. 回想 2.2 节强调过的, happens-before 没有传递性. 所以不能说因为 (3) “happens-before” (4) 且 (4) “happens-before” (6) 所以 (2) “happens-before” (6).</p><p>与 acquire-release 类似, 在 x86 下使用 <code>memory_order_consume</code> 的操作不会产生任何其他的指令, 只会影响编译器优化. 与 consume 操作有依赖关系的指令都不会重排到 consume 操作前面. 它对重排的限制比 acquire 宽松些, acquire 要求所有的指令都不能重排到它的前面, 而 consume 只要求有依赖关系的指令不能重排到它的前面. 因此在某些情况下, consume 的性能可能会高一些.</p><h2 id="4-例子">4. 例子</h2><blockquote><p><strong>自旋锁</strong></p></blockquote><p>在一些场景下, 如果锁被占用的时间很短, 我们会选择自旋锁, 以减少上下文切换的开销. 锁一般用来保护临界数据的读写, 我们希望同一时间只有一个线程能获取到锁, 且获取到锁后, 被锁保护的数据总是最新的. 前者通过原子操作即可保证, 而后者就需要考虑内存顺序了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">spinlock mu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> ((val = <span class="built_in">read_from_remote</span>())) &#123;</span><br><span class="line">        mu.<span class="built_in">lock</span>(); <span class="comment">// (1)</span></span><br><span class="line">        queue.<span class="built_in">push_back</span>(val); <span class="comment">// (2)</span></span><br><span class="line">        mu.<span class="built_in">unlock</span>(); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        mu.<span class="built_in">lock</span>(); <span class="comment">// (4)</span></span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        queue.<span class="built_in">pop_front</span>(); <span class="comment">// (5)</span></span><br><span class="line">        mu.<span class="built_in">unlock</span>(); <span class="comment">// (6)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个线程并发运行, <code>thread1</code> 往队列里写入数据, <code>thread2</code> 从队列里读出数据. 入队操作 (2) 可能需要复制数据, 移动指针, 甚至 resize 队列, 因此我们要保证获取到锁时, 这些操作的结果完全可见. 出队操作也是同理. 所以自旋锁要保证 unlock 操作 “synchronizes-with” lock 操作, 保证锁保护的数据是完整的.</p><p>我们可以用 acquire-release 模型实现自旋锁. 下面是一个简单的实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">exchange</span>(<span class="literal">true</span>, std::memory_order_acquire)); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的实现中, (1) 处加锁用到的 <code>exchange</code> 是一种 read-modify-write 操作, 它将目标值 (第一个参数) 写入原子变量, 并返回写入前的值. 在这个实现中, 锁被占用时 <code>flag</code> 为 <code>true</code>. 如果锁被占用, (1) 处的 exchange 操作会一直返回 <code>true</code>, 线程阻塞在循环中; 直到锁被释放, <code>flag</code> 为 <code>false</code>, exchange 操作将 <code>flag</code> 重新置为 <code>true</code> 以抢占锁, 并且返回其原来的值 <code>false</code>, 循环退出, 加锁成功. 解锁则很简单, 将 <code>flag</code> 置为 <code>false</code> 即可.</p><p>由于解锁操作使用 <code>memory_order_release</code> 且加锁操作使用 <code>memory_order_acquire</code>, 所以能保证加锁成功时与上一次解锁操作构成 “synchronizes-with” 的关系, 也就是 unlock 操作 “synchronizes-with” lock 操作.</p><p>加锁时的 exchange 操作是一个 read-modify-write 操作, 它既读又写. 当它使用 <code>memory_order_acquire</code> 时, 只能保证它读的部分是一个 acquire 操作. 如果有两个线程抢占同一个锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spinlock mu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some operations</span></span><br><span class="line">    mu.<span class="built_in">lock</span>(); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu.<span class="built_in">lock</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 和 (2) 之间没有任何同步关系, 假设先执行操作 (1) 后执行操作 (2), 那么 <code>thread1</code> 中 (1) 之前的操作结果不一定对 <code>thread2</code> 可见. 但能确定的是, 只会有一个线程得到锁, 这是由原子变量的修改顺序 (modification order) 所保证的. 要么 <code>thread1</code> 先将 <code>flag</code> 置为 <code>true</code>, 要么 <code>thread2</code> 先将 <code>flag</code> 置为 <code>true</code>, 这个顺序是全局一致的.</p><h2 id="5-总结">5. 总结</h2><p>总结一下这几种内存顺序模型:</p><ul><li><code>memory_order_relaxed</code>: 最宽松的内存顺序, 只保证操作的<strong>原子性</strong>和<strong>修改顺序 (modification order)</strong>.</li><li><code>memory_order_acquire</code>, <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code>: 实现 <strong>acquire 操作</strong>和 <strong>release 操作</strong>, 如果 acquire 操作读到了 release 操作写入的值, 或其 release sequence 写入的值, 则构成 <strong>synchronizes-with 关系</strong>, 进而可以推导出 <strong>happens-before 的关系</strong>.</li><li><code>memory_order_consume</code>: 实现 <strong>consume 操作</strong>, 能实现数据依赖相关的同步关系. 如果 consume 操作读到了 release 操作写入的值, 或其 release sequence 写入的值, 则构成 <strong>dependency-ordered before 的关系</strong>, 对于有数据依赖的操作可以进而推导出 <strong>happens-before 的关系</strong>.</li><li><code>memory_order_seq_cst</code>: 加强版的 acquire-release 模型, 除了可以实现 <strong>synchronizes-with 关系</strong>, 还保证<strong>全局顺序一致</strong>.</li></ul><h2 id="6-资料">6. 资料</h2><ul><li><a href="https://nj.gitbooks.io/c/content/">《C++并发编程实战》</a></li><li><a href="https://www.zhihu.com/question/24301047">内存模型</a></li></ul><p>本文转载自：<a href="https://luyuhuang.tech/2022/06/25/cpp-memory-order.html#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F">谈谈 C++ 中的内存顺序 (Memory Order)</a></p><p>参考资料：</p><ul><li><a href="https://blog.51cto.com/quantfabric/2588193">C++性能优化（十三）——无锁队列</a></li><li><a href="%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">无锁队列的几种实现及其性能对比</a></li><li><a href="https://blog.csdn.net/xin_hen/article/details/108142403">C++11实现基于循环数组的无锁队列LockFreeArrayQueue</a></li><li><a href="https://zhuanlan.zhihu.com/p/638443455">揭秘C++无锁队列的几种实现及性能对比</a></li><li><a href="https://zhuanlan.zhihu.com/p/678154776">C++性能优化——无锁队列的原理与实现</a></li></ul>]]></content>
    
    
    <summary type="html">Memory Order</summary>
    
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CMake快速上手</title>
    <link href="https://penge666.github.io/posts/48ea1a6e.html"/>
    <id>https://penge666.github.io/posts/48ea1a6e.html</id>
    <published>2024-05-06T14:38:59.000Z</published>
    <updated>2024-05-06T15:23:10.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>CMake 不再使你在构建项目时郁闷地想自杀了。</p><p>插曲：之前在研究所做项目的时候，刘总总是暴力的使用sh脚本编译[狗头保命一波]，狠狠的暴力美学。但是，这对写lab的我有点难泵，于是乎，全给重写CMakeLists.txt文件的形式编译。</p><p>好了，基本文件的CMakeList.txt学习清楚后，就应该学习实际项目中CMakeLists.txt是如何规范书写，到实践中学习。</p><h2 id="介绍">介绍</h2><h3 id="跨平台设计原理">跨平台设计原理</h3><p>在大型C/C++项目中，跨平台设计是一个重要的考虑因素。跨平台设计的目标是使得源代码能够在多种操作系统和硬件架构上编译和运行，而无需进行大量的修改。这样可以大大提高代码的可移植性和复用性，降低维护成本。</p><p>CMake（Cross-platform Make）是一个开源的、跨平台的自动化建构系统，它允许开发者编写一份通用的CMakeList.txt文件来控制编译过程，而不需要修改特定平台下的编译配置，从而实现真正意义上的跨平台编译。</p><p>CMake支持多种编译器，包括GCC，Clang，Visual Studio等，并且可以生成各种类型的项目文件，如Makefile，Ninja，Visual Studio解决方案等。这使得CMake成为了跨平台C/C++项目的首选构建工具。</p><p>在CMake中，跨平台设计的实现主要依赖于以下几个原理：</p><ol><li><strong>抽象层</strong>：CMake为各种操作系统和编译器提供了一套抽象层，开发者只需要关注源代码和依赖库，而无需关心具体的编译器和操作系统。这是通过在CMakeList.txt文件中设置目标（target）和属性（property）来实现的。</li><li><strong>模块系统</strong>：CMake提供了一套模块系统，用于查找库和包，检查编译器和系统特性，以及管理测试等。这些模块大大简化了跨平台开发的复杂性。</li><li><strong>生成器</strong>：CMake通过生成器（generator）将CMakeList.txt文件转换为特定平台下的构建文件。生成器根据目标系统的特性，自动处理平台相关的编译和链接问题。</li><li><strong>变量和条件</strong>：CMake支持变量和条件语句，使得开发者可以根据不同的平台和编译器，选择不同的源文件和编译选项。</li></ol><p>以上就是CMake实现跨平台设计的基本原理，接下来我们将深入探讨CMake在跨平台设计中的应用。</p><h3 id="跨平台设计">跨平台设计</h3><p>在大型C/C++项目中，跨平台设计是必不可少的一环。这主要涉及到如何使用CMake来配置和管理不同平台的编译环境。</p><p><strong>CMake的跨平台特性</strong></p><p>CMake本身就是一个跨平台的构建工具，它可以在Windows、Linux、Mac等多种操作系统上运行。CMake通过生成平台相关的构建文件（如Unix的Makefile，Windows的nmake文件或Visual Studio项目文件等）来实现跨平台构建。这意味着，我们可以编写一套CMake构建脚本，然后在不同的平台上生成相应的构建文件，从而实现跨平台构建。</p><p><strong>使用CMake进行跨编译</strong></p><p>跨编译是指在一个平台上生成另一个平台的可执行代码。例如，我们可能需要在Linux平台上编译出运行在嵌入式设备上的ARM架构的代码。CMake支持跨编译，我们可以通过设置CMake的工具链文件（Toolchain File）来指定交叉编译器和相关的编译选项。</p><p>在CMake的工具链文件中，我们可以设置如下变量：</p><ul><li><code>CMAKE_SYSTEM_NAME</code>：目标系统的名称，如Linux、Windows、Android等。</li><li><code>CMAKE_SYSTEM_PROCESSOR</code>：目标系统的处理器架构，如x86、arm等。</li><li><code>CMAKE_C_COMPILER</code>、<code>CMAKE_CXX_COMPILER</code>：C和C++的交叉编译器的路径。</li><li><code>CMAKE_FIND_ROOT_PATH</code>：在查找库和头文件时，CMake应该查找的路径。</li></ul><p>通过设置这些变量，我们可以告诉CMake我们要编译的目标平台是什么，以及应该使用哪些工具进行编译。</p><p><strong>处理平台相关的代码</strong></p><p>在大型C/C++项目中，通常会有一些平台相关的代码。例如，Windows平台和Linux平台的系统调用是不同的，处理文件路径的方式也是不同的。我们需要在CMake构建脚本中检测目标平台，然后根据目标平台来决定编译哪些源文件。</p><p>CMake提供了<code>if</code>命令来进行条件判断。我们可以使用<code>CMAKE_SYSTEM_NAME</code>变量来判断目标平台。例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    <span class="comment"># 编译Linux平台的源文件</span></span><br><span class="line">    <span class="keyword">add_library</span>(mylib linux_specific_code.c)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">    <span class="comment"># 编译Windows平台的源文件</span></span><br></pre></td></tr></table></figure><p>以下是跨平台设计的流程图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240506230531403.png" alt="image-20240506230531403"></p><p>在大型C/C++项目中，我们需要考虑到跨平台设计。这主要涉及到如何使用CMake来配置和管理不同平台的编译环境。CMake本身就是一个跨平台的构建工具，它可以在Windows、Linux、Mac等多种操作系统上运行。CMake通过生成平台相关的构建文件（如Unix的Makefile，Windows的nmake文件或Visual Studio项目文件等）来实现跨平台构建。</p><p>跨编译是指在一个平台上生成另一个平台的可执行代码。例如，我们可能需要在Linux平台上编译出运行在嵌入式设备上的ARM架构的代码。CMake支持跨编译，我们可以通过设置CMake的工具链文件（Toolchain File）来指定交叉编译器和相关的编译选项。</p><p>在大型C/C++项目中，通常会有一些平台相关的代码。例如，Windows平台和Linux平台的系统调用是不同的，处理文件路径的方式也是不同的。我们需要在CMake构建脚本中检测目标平台，然后根据目标平台来决定编译哪些源文件。CMake提供了<code>if</code>命令来进行条件判断。我们可以使用<code>CMAKE_SYSTEM_NAME</code>变量来判断目标平台。</p><h3 id="跨平台设计案例">跨平台设计案例</h3><p>在实践中，跨平台设计是一个复杂的过程，需要考虑到各种因素。以下是一些实践和案例，帮助我们更好地理解跨平台设计的过程和挑战。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240506230621696.png" alt="image-20240506230621696"></p><p>首先，我们需要理解平台差异（Understanding Platform Differences）。不同的操作系统和硬件平台有不同的特性和限制。例如，Windows和Linux在文件系统、线程管理和网络编程等方面有显著的差异。理解这些差异是设计跨平台应用的第一步。</p><p>其次，选择合适的工具和库（Choosing Appropriate Tools and Libraries）也是非常重要的。有些工具和库是跨平台的，可以在多种操作系统和硬件平台上运行。例如，CMake就是一个跨平台的构建工具，可以在Windows、Linux和MacOS上使用。使用这些工具和库可以大大简化跨平台设计的复杂性。</p><p>然后，编写可移植的代码（Writing Portable Code）是另一个关键步骤。可移植的代码是指可以在多种平台上编译和运行的代码。为了实现代码的可移植性，我们需要避免使用特定平台的特性和API，或者使用预处理器指令来处理平台差异。</p><p>最后，进行全面的测试（Comprehensive Testing）是确保跨平台应用正确运行的重要步骤。我们需要在所有目标平台上测试应用，确保它在各种环境中都能正常工作。</p><p>以上就是跨平台设计的一些基本步骤和实践。在实际的项目中，我们可能还需要考虑到其他的因素，如性能、安全性和用户体验等。但是，只要我们遵循这些基本原则，我们就可以设计出高质量的跨平台应用。</p><h2 id="基本使用">基本使用</h2><h3 id="常用命令">常用命令</h3><p><strong>1. 指定 cmake 的最小版本</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这行命令是可选的，当然可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p><p><strong>2. 设置项目名称</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">project</span>(demo)</span><br></pre></td></tr></table></figure><p>这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p><p><strong>3. 设置编译类型</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(demo demo.cpp) # 生成可执行文件</span><br><span class="line"><span class="built_in">add_library</span>(common STATIC util.cpp) # 生成静态库</span><br><span class="line"><span class="built_in">add_library</span>(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></table></figure><p>add_library 默认生成是静态库，通过以上命令生成文件名字，</p><ul><li>在 Linux 下是：<br>demo<br>libcommon.a<br><a href="http://libcommon.so">libcommon.so</a></li><li>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</li></ul><p><strong>4. 指定编译包含的源文件</strong></p><p>4.1 明确指定包含哪些源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(demo demo.cpp test.cpp util.cpp)</span><br></pre></td></tr></table></figure><p>4.2 搜索所有的 cpp 文件</p><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST) # 搜索当前目录下的所有<span class="selector-class">.cpp</span>文件</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>4.3 自定义搜索规则</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span>(GLOB SRC_LIST &quot;*.cpp&quot; &quot;protocol/*.cpp&quot;)</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125;)</span><br><span class="line"># 或者</span><br><span class="line"><span class="built_in">file</span>(GLOB SRC_LIST &quot;*.cpp&quot;)</span><br><span class="line"><span class="built_in">file</span>(GLOB SRC_PROTOCOL_LIST &quot;protocol/*.cpp&quot;)</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br><span class="line"># 或者</span><br><span class="line"><span class="built_in">file</span>(GLOB_RECURSE SRC_LIST &quot;*.cpp&quot;) #递归搜索</span><br><span class="line"><span class="built_in">FILE</span>(GLOB SRC_PROTOCOL RELATIVE &quot;protocol&quot; &quot;*.cpp&quot;) # 相对protocol目录下搜索</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br><span class="line"># 或者</span><br><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="built_in">aux_source_directory</span>(protocol SRC_PROTOCOL_LIST)</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br></pre></td></tr></table></figure><p><strong>5. 查找指定的库文件</strong></p><p>find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。<br>默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              <span class="keyword">log</span>-lib</span><br><span class="line"> </span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              <span class="keyword">log</span> )</span><br></pre></td></tr></table></figure><p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p><p><strong>6. 设置包含的目录</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>7. 设置链接库搜索目录</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">link_directories</span>(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>8. 设置 target 需要链接的库</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>( # 目标库</span><br><span class="line">                       demo</span><br><span class="line"> </span><br><span class="line">                       # 目标库需要链接的库</span><br><span class="line">                       # log-lib 是上面 find_library 指定的变量名</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 <a href="http://xxx.so">xxx.so</a> 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p><p>8.1 指定链接动态库或静态库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(demo libface.a) # 链接libface.<span class="function">a</span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(demo libface.so)</span> # 链接libface.so</span></span><br></pre></td></tr></table></figure><p>8.2 指定全路径</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.a)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.so)</span><br></pre></td></tr></table></figure><p>8.3 指定链接多个库</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(demo</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.a</span><br><span class="line">    boost_system.a</span><br><span class="line">    boost_thread</span><br><span class="line">    pthread)</span><br></pre></td></tr></table></figure><p><strong>9. 设置变量</strong></p><p>9.1 set 直接设置变量的值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(SRC_LIST main.cpp test.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>9.2 set 追加设置变量的值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(SRC_LIST main.cpp)</span><br><span class="line"><span class="built_in">set</span>(SRC_LIST $&#123;SRC_LIST&#125; test.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>9.3 list 追加或者删除变量的值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(SRC_LIST main.cpp)</span><br><span class="line"><span class="built_in">list</span>(APPEND SRC_LIST test.cpp)</span><br><span class="line"><span class="built_in">list</span>(REMOVE_ITEM SRC_LIST main.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p><strong>10. 条件控制</strong></p><p>10.1 if…elseif…else…endif</p><p>逻辑判断和比较：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (expression)：expression 不为空（<span class="number">0</span>,N,NO,OFF,FALSE,NOTFOUND）时为真</span><br><span class="line">if (not exp)：与上面相反</span><br><span class="line">if (var1 AND var2)</span><br><span class="line">if (var1 OR var2)</span><br><span class="line">if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真</span><br><span class="line">if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真</span><br><span class="line">if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径</span><br><span class="line">if (IS_DIRECTORY dir)：当 dir 是目录时为真</span><br><span class="line">if (DEFINED var)：如果变量被定义为真</span><br><span class="line">if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 <span class="selector-tag">var</span> 可以用 <span class="selector-tag">var</span> 名，也可以用 $&#123;<span class="selector-tag">var</span>&#125;</span><br><span class="line">if (string MATCHES regex)</span><br></pre></td></tr></table></figure><p>数字比较：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (variable LESS number)：LESS 小于</span><br><span class="line">if (string LESS number)</span><br><span class="line">if (variable GREATER number)：GREATER 大于</span><br><span class="line">if (string GREATER number)</span><br><span class="line">if (variable EQUAL number)：EQUAL 等于</span><br><span class="line">if (string EQUAL number)</span><br></pre></td></tr></table></figure><p>字母表顺序比较：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (variable STRLESS string)</span><br><span class="line">if (string STRLESS string)</span><br><span class="line">if (variable STRGREATER string)</span><br><span class="line">if (string STRGREATER string)</span><br><span class="line">if (variable STREQUAL string)</span><br><span class="line">if (string STREQUAL string)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if(MSVC)</span><br><span class="line">    set(LINK_LIBS common)</span><br><span class="line">else()</span><br><span class="line">    set(boost_thread boost_log.a boost_system.a)</span><br><span class="line">endif()</span><br><span class="line">target_link_libraries(demo $&#123;LINK_LIBS&#125;)</span><br><span class="line"># 或者</span><br><span class="line">if(UNIX)</span><br><span class="line">    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -fpermissive -g&quot;)</span><br><span class="line">else()</span><br><span class="line">    add_definitions(-D_SCL_SECURE_NO_WARNINGS</span><br><span class="line">    D_CRT_SECURE_NO_WARNINGS</span><br><span class="line">    -D_WIN32_WINNT=0x601</span><br><span class="line">    -D_WINSOCK_DEPRECATED_NO_WARNINGS)</span><br><span class="line">endif()</span><br><span class="line"> </span><br><span class="line">if($&#123;CMAKE_BUILD_TYPE&#125; MATCHES &quot;debug&quot;)</span><br><span class="line">    ...</span><br><span class="line">else()</span><br><span class="line">    ...</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>10.2 while…endwhile</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span>(condition)</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">endwhile</span>()</span><br></pre></td></tr></table></figure><p>10.3 foreach…endforeach</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foreach</span>(loop_var RANGE start stop [step])</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">endforeach</span>(loop_var)</span><br></pre></td></tr></table></figure><p>start 表示起始数，stop 表示终止数，step 表示步长，示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foreach</span>(i RANGE <span class="number">1</span> <span class="number">9</span> <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">message</span>($&#123;i&#125;)</span><br><span class="line"><span class="built_in">endforeach</span>(i)</span><br><span class="line"># 输出：<span class="number">13579</span></span><br></pre></td></tr></table></figure><p><strong>11. 打印信息</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">message</span>($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class="line"><span class="built_in">message</span>(&quot;build with debug mode&quot;)</span><br><span class="line"><span class="built_in">message</span>(WARNING &quot;this is warnning message&quot;)</span><br><span class="line"><span class="built_in">message</span>(FATAL_ERROR &quot;this build has many error&quot;) # FATAL_ERROR 会导致编译失败</span><br></pre></td></tr></table></figure><p><strong>12. 包含其它 cmake 文件</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include</span>(./common.cmake) # 指定包含文件的全路径</span><br><span class="line"><span class="built_in">include</span>(def) # 在搜索路径中搜索def<span class="selector-class">.cmake</span>文件</span><br><span class="line"><span class="built_in">set</span>(CMAKE_MODULE_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake) # 设置include的搜索路径</span><br></pre></td></tr></table></figure><h3 id="常用信息">常用信息</h3><p><strong>1.预定义变量</strong></p><ul><li>PROJECT_SOURCE_DIR：工程的根目录</li><li>PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build</li><li>PROJECT_NAME：返回通过 project 命令定义的项目名称</li><li>CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径</li><li>CMAKE_CURRENT_BINARY_DIR：target 编译目录</li><li>CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径</li><li>CMAKE_CURRENT_LIST_LINE：当前所在的行</li><li>CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH</li><li>${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块</li><li>EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置</li><li>LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</li></ul><p><strong>2. 环境变量</strong></p><p>使用环境变量</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ENV</span>&#123;Name&#125;</span><br></pre></td></tr></table></figure><p>写入环境变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;Name&#125; <span class="keyword">value</span>) <span class="meta"># 这里没有“$”符号</span></span><br></pre></td></tr></table></figure><p>3.系统信息</p><ul><li>CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3</li><li>CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4</li><li>CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1</li><li>CMAKE_SYSTEM：系统名称，比如 Linux-­2.6.22­</li><li>CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux­</li><li>CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22</li><li>CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686</li><li>UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin</li><li>WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin</li></ul><p>4.主要开关选项</p><ul><li>BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库</li><li>CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加</li><li>CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DENABLE_DEBUG -DABC) <span class="comment"># 参数之间用空格分隔</span></span><br></pre></td></tr></table></figure><h2 id="实战">实战</h2><p>在实践之前，先看份去年写的CMakeList.txt，截取部分。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 打印CMake模块路径</span><br><span class="line"><span class="built_in">message</span>(&quot;CMake module path: $&#123;CMAKE_MODULE_PATH&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 设置CMake的最低版本要求为<span class="number">2.8</span></span><br><span class="line"><span class="built_in">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line"># 设置C++编译器的标志，启用C++<span class="number">11</span>标准</span><br><span class="line"><span class="built_in">SET</span>(CMAKE_CXX_FLAGS &quot;-std=c++<span class="number">11</span>&quot;)</span><br><span class="line"></span><br><span class="line"># 添加编译选项，启用-Wformat警告</span><br><span class="line"><span class="built_in">add_compile_options</span>(-Wformat)</span><br><span class="line"></span><br><span class="line"># 设置项目名称为&quot;task&quot;</span><br><span class="line"><span class="built_in">project</span>(task)</span><br><span class="line"></span><br><span class="line"># 设置OpenCV的路径，并查找OpenCV库</span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR &quot;/usr/local/include/opencv2&quot;)</span><br><span class="line"><span class="built_in">find_package</span>( OpenCV <span class="number">2</span>  REQUIRED )</span><br><span class="line"></span><br><span class="line"># 将OpenCV的头文件目录添加到包含目录中</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 查找libtiff库，并将其头文件目录添加到包含目录中</span><br><span class="line"><span class="built_in">find_package</span>(TIFF REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;TIFF_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 设置libgdal库的路径，并将其头文件目录添加到包含目录中</span><br><span class="line"><span class="built_in">set</span>(LIBGDAL_INCLUDE_DIR &quot;/usr/local/include&quot;)</span><br><span class="line"><span class="built_in">set</span>(LIBGDAL_LIBRARY &quot;/usr/local/lib64/libgdal.so&quot;)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;LIBGDAL_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 将libgdal库添加到链接库中</span><br><span class="line"><span class="built_in">link_libraries</span>($&#123;LIBGDAL_LIBRARY&#125;)</span><br><span class="line"></span><br><span class="line"># 添加一个名为&quot;task&quot;的可执行文件目标，设置其源文件</span><br><span class="line"><span class="built_in">add_executable</span>( </span><br><span class="line">    task </span><br><span class="line">    src/main.cpp</span><br><span class="line">    include/XmlParse/tinyxml.cpp</span><br><span class="line">    include/XmlParse/tinyxmlparser.cpp</span><br><span class="line">    include/XmlParse/tinyxmlerror.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 将OpenCV库、libtiff库和libraw库添加到&quot;task&quot;目标的链接库中</span><br><span class="line"><span class="built_in">target_link_libraries</span>(task  $&#123;OpenCV_LIBS&#125; $&#123;TIFF_LIBRARIES&#125; $&#123;LIBRAW_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 将pthread库添加到&quot;task&quot;目标的链接库中</span><br><span class="line"><span class="built_in">target_link_libraries</span>(task  -lpthread)</span><br><span class="line"></span><br><span class="line"># 将openmp库添加到&quot;task&quot;目标的链接库中</span><br><span class="line"><span class="built_in">target_link_libraries</span>(task  -fopenmp)</span><br></pre></td></tr></table></figure><h3 id="单个源文件">单个源文件</h3><p>(源代码所在目录：Demo1)</p><p>假设现在我们的项目中只有一个源文件<a href="https://link.zhihu.com/?target=http%3A//main.cc">http://main.cc</a>，该程序的用途是计算一个数的指数幂。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * power - Calculate the power of number.</span><br><span class="line"> * @param base: Base value.</span><br><span class="line"> * @param exponent: Exponent value.</span><br><span class="line"> *</span><br><span class="line"> * @return base raised to the power exponent.</span><br><span class="line"> */</span><br><span class="line">double power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    int result = base;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if (exponent == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(i = 1; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先编写 CMakeLists.txt 文件，并保存在与<a href="https://link.zhihu.com/?target=http%3A//mian.cc">http://mian.cc</a>源文件同个目录下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo1)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc)</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p><p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><ol><li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li><li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li><li><code>add_executable</code>： 将名为 <a href="http://main.cc">main.cc</a> 的源文件编译成一个名称为 Demo 的可执行文件。</li></ol><p>之后，在当前目录执行<code>cmake .</code>，得到 Makefile 后再使用<code>make</code>命令编译得到 Demo1 可执行文件。</p><h3 id="多个源文件">多个源文件</h3><p>(源代码所在目录Demo2)</p><p>上面的例子只有单个源文件。现在假如把<code>power</code>函数单独写进一个名为<code>MathFunctions.c</code>的源文件里，使得这个工程变成如下的形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure><p>这个时候，CMakeLists.txt 可以改成如下的形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure><p>唯一的改动只是在<code>add_executable</code>命令中增加了一个<code>MathFunctions.cc</code>源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用<code>aux_source_directory</code>命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><p>因此，可以修改 CMakeLists.txt 如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量<code>DIR_SRCS</code>，再指示变量<code>DIR_SRCS</code>中的源文件需要编译成一个名称为 Demo 的可执行文件。</p><h3 id="多个目录，多个源文件">多个目录，多个源文件</h3><p>(源代码所在目录Demo3)</p><p>现在进一步将 MathFunctions.h 和<a href="https://link.zhihu.com/?target=http%3A//MathFunctions.cc">http://MathFunctions.cc</a>文件移动到 math 目录下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure><p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p><p>根目录中的 CMakeLists.txt ：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo3)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 添加 math 子目录</span><br><span class="line">add_subdirectory(math)</span><br><span class="line"></span><br><span class="line"># 指定生成目标 </span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line"># 添加链接库</span><br><span class="line">target_link_libraries(Demo MathFunctions)</span><br></pre></td></tr></table></figure><p>该文件添加了下面的内容: 第3行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p><p>子目录中的 CMakeLists.txt：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"># 生成链接库</span><br><span class="line">add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>在该文件中使用命令<code>add_library</code>将 src 目录中的源文件编译为静态链接库。</p><h2 id="资料">资料</h2><ul><li><a href="https://gavinliu6.github.io/CMake-Practice-zh-CN/#/acquaintance">cmake实战</a></li><li><a href="https://zhuanlan.zhihu.com/p/661284252">CMake构建大型C_C++项目：跨平台设计与高级应用</a></li><li><a href="https://blog.csdn.net/afei__/article/details/81201039">CMakeLists.txt 语法介绍与实例演练</a></li></ul>]]></content>
    
    
    <summary type="html">CMake快速上手</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模型</title>
    <link href="https://penge666.github.io/posts/161dcf21.html"/>
    <id>https://penge666.github.io/posts/161dcf21.html</id>
    <published>2024-05-06T13:47:26.000Z</published>
    <updated>2024-05-06T13:49:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>这个仓库主记录了生产者和消费者模式中经典的案例。</p><h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>完整代码见仓库：<a href="https://github.com/Penge666/Producer-Consumer-Pattern">https://github.com/Penge666/Producer-Consumer-Pattern</a></p><p><strong>1.CPU轮询等待版单生产者单消费者：</strong>（basic.cpp）</p><p>该版本使用了简单的轮询机制，生产者不断地检查消费者是否已经消费完数据。这种模式简单直接，但效率较低，因为生产者在没有数据时仍然在忙等待。</p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">           data_ = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;生产data:&quot;</span> &lt;&lt; data_ &lt;&lt; endl;</span><br><span class="line">           ready_ = <span class="literal">true</span>;</span><br><span class="line">           lock.<span class="built_in">unlock</span>();</span><br><span class="line">           <span class="keyword">while</span> (ready_)</span><br><span class="line">           &#123;</span><br><span class="line">               this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span> (!ready_)</span><br><span class="line">           &#123;</span><br><span class="line">               this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;消费data:&quot;</span> &lt;&lt; data_ &lt;&lt; endl;</span><br><span class="line">           ready_ = <span class="literal">false</span>;</span><br><span class="line">           lock.<span class="built_in">unlock</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>2.等待通知版单生产者单消费者：</strong>（single.cpp）</p><p>该版本引入了等待通知机制，生产者在没有数据时会等待消费者的通知。这种模式避免了忙等待，提高了效率，同时减少了资源消耗。</p><p><strong>实现</strong></p><p>在这个版本我们借助condition_variable，完成多线程之间的同步操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv_;</span><br><span class="line"><span class="type">bool</span> ready_&#123;<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure><p>生产者会不断生成一个随机数并将其存储在 data<em> 变量中，然后将 ready</em> 标志设置为 true，表示有可用的数据。接着，它通知等待的消费者线程，然后自己等待消费者线程处理完数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !ready_; &#125;);</span><br></pre></td></tr></table></figure><p>消费者将会在一个无限循环中等待生产者通知数据的可用性。当 ready<em> 标志为 true 时，它会从 data</em> 变量中获取数据并进行处理，然后将 ready_ 标志设置为 false，表示数据已经被消费。接着，它通知生产者线程，然后自己等待生产者线程生成新的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> ready_; &#125;);</span><br></pre></td></tr></table></figure><p><strong>3.等待通知版单生产者多消费者：</strong>（mutiple.cpp）</p><p>在这个版本中，引入了多个消费者，它们共享生产者的数据。生产者在产生数据后，通知所有消费者进行处理。</p><p><strong>实现</strong></p><p>前面的版本中，我们还是单生产，单个消费者，如何做到多个消费者抢占消费？</p><p>此时需要引入队列，我们将任务丢到队列中去，随后多个消费者进行消费即可，与上述等待条件不同点在于队列的状态。</p><p>对于生产者：如果队列大小未达到 max<em>queue_size</em> 的限制，如果队列已满，则生产者线程将等待消费者线程从队列中取走一些数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> queue_.<span class="built_in">size</span>() &lt; max_queue_size_; &#125;); </span><br></pre></td></tr></table></figure><p>对于消费者：队列有数据就消费，否则等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure><p><strong>4.等待通知版多生产者多消费者：</strong>（mutiple_mutiple.cpp）</p><p>这个版本支持多个生产者和多个消费者，生产者之间和消费者之间共享数据。生产者在产生数据后，通知所有消费者进行处理。</p><p><strong>实现</strong></p><p>对于这个版本比较简单，基于第三个版本继续优化，创建n个生产者线程即可。</p><p><strong>5.单生产者多消费者并行版：</strong>（mutiple_sync.cpp）</p><p>在这个版本中，引入了并行处理机制，多个消费者可以同时处理数据。生产者产生数据后，多个消费者并行处理，提高了整体处理速度。</p><p><strong>实现</strong></p><p>对于以上版本有个比较大的问题，当生产者生产的数据到达上限时，消费者此时在消费，而生产者并没有动起来，它在等待消费者消费完才能进行，如何让生产者与消费者同时运转呢？</p><p>改进点在于使用多个cv，来回切换通知。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv_producer_;</span><br><span class="line">std::condition_variable cv_consumer_;</span><br></pre></td></tr></table></figure><p><strong>6.多生产者多消费者并行版：</strong>（mutiple_mutiple_sync.cpp）</p><p>这个版本支持多个生产者和多个消费者，并且允许并行处理。多个生产者并行产生数据，多个消费者并行处理数据，提高了整体并发能力。</p><p><strong>实现</strong></p><p>基于5进行改造，支持多个生产者即可。</p><p><strong>7.支持Lambda回调的优雅停止版：</strong>（mutiple_mutiple_stop.cpp）</p><p>在这个版本中，引入了Lambda回调函数，用于优雅地停止并发处理。可以通过调用回调函数来停止生产者和消费者的处理，并进行清理工作。</p><p><strong>实现</strong></p><p>简单来说，就是加回调函数</p><p>最后运行【比较简朴~】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  mutiple_mutiple_stop.cpp -o mutiple_mutiple_stop -lpthread</span><br></pre></td></tr></table></figure><p>本文字学习自：<a href="https://github.com/LHCyGan/Concurrent_Programming">https://github.com/LHCyGan/Concurrent_Programming</a></p>]]></content>
    
    
    <summary type="html">Producer-Consumer Pattern</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Mutex</title>
    <link href="https://penge666.github.io/posts/c07087b4.html"/>
    <id>https://penge666.github.io/posts/c07087b4.html</id>
    <published>2024-05-06T11:45:59.000Z</published>
    <updated>2024-05-06T12:06:06.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>互斥锁在并发编程中经常碰到，因此对其需要有个更加深入的理解。这篇博客将使用信号量实现的互斥锁。</p><p>简易互斥锁（SimpleMutex）是一个基于原子变量和信号量的互斥锁实现，用于保护并管理多线程环境下的共享资源访问。它提供了一种简单而有效的方式来确保在多线程并发访问时，只有一个线程可以同时访问受保护的资源，从而避免数据竞争和不一致性。基于 POSIX 标准的信号量库实现，包含 Catch2 单元测试，附带了基于 Catch2 框架的单元测试，用于验证互斥锁的正确性和稳定性，使用bazel编译，google编码规范。</p><p>其中涉及C++知识（RAII、信号量、lock_guard、线程安全编程）</p><h2 id="前置知识">前置知识</h2><blockquote><p><strong>信号量API</strong></p></blockquote><ul><li><p>信号量的类型：<code>sem_t</code></p></li><li><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p><ul><li>功能：初始化信号量</li><li>参数<ul><li><code>sem</code>：信号量变量的地址</li><li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li><li><code>value </code>：信号量中的值，代表容器大小</li></ul></li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p></li><li><p>功能：释放资源</p></li><li><p><code>int sem_wait(sem_t *sem);</code></p></li><li><p>功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</p></li><li><p><code>int sem_trywait(sem_t *sem);</code></p></li><li><p><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></p></li><li><p>int sem_post(sem_t *sem);</p><ul><li>功能：对信号量解锁，调用一次对信号量的值+1</li></ul></li><li><p><code>int sem_getvalue(sem_t *sem, int *sval);</code></p></li></ul><h2 id="核心逻辑">核心逻辑</h2><blockquote><p><strong>Semaphore类</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Semaphore</span>(<span class="type">int</span> init_count = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(init_count &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sema_, <span class="number">0</span>, init_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        rc = <span class="built_in">sem_wait</span>(&amp;sema_);</span><br><span class="line">    &#125; <span class="keyword">while</span> (rc == <span class="number">1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sema_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较核心就是以上函数，需要注意的是，这里信号量初始化设置成0是因为只处理需要等待的线程。</p><p>当需要等待的线程进入到wait函数中，sem_wait函数将检查sema是否大于0，如果没有，则等待，等待时该线程为阻塞状态。当其他线程调用post增强sem的值的时候,即大于0的时候，线程将解除阻塞， 解除阻塞后sem值会减去1。</p><p>sem_post 则是 用来增加信号量的值。</p><blockquote><p><strong>SimpleMutex 类</strong></p></blockquote><p><strong>lock() 和 unlock()</strong></p><p>SimpleMutex 类包含一个名为 count_ 的 std::atomic 变量和一个名为 sema_ 的 Semaphore 对象。</p><p>在构造函数中，count_ 被初始化为 0。</p><ul><li>lock() 函数用于获取互斥锁。它使用 fetch_add 操作和 std::memory_order_acquire 参数对 count_ 进行原子增加，并获取锁。 如果在增加之前 count_ 的值大于 0，说明互斥锁已经被其他线程锁定。在这种情况下，函数调用 sema_.wait() 来阻塞当前线程，直到信号量被发信号，表示互斥锁可用。</li><li>unlock() 函数用于释放互斥锁。它使用 fetch_sub 操作和 std::memory_order_release 参数对 count_ 进行原子减少，并释放锁。 如果减少之前的 count_ 值仍大于 1，说明其他线程正在等待互斥锁。在这种情况下，函数调用 sema_.signal() 发信号给信号量，允许一个等待的线程获取互斥锁。</li></ul><p>通过结合原子变量 count_ 和信号量 sema_，该实现确保等待获取互斥锁的线程能够高效地阻塞，直到当前持有者释放锁。</p><p>Note:</p><h2 id="代码">代码</h2><p>代码仓库：<a href="https://github.com/Penge666/Mutex.git">https://github.com/Penge666/Mutex.git</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ src/mutex/test.cpp -std=c++11 -Ithird/catch2/ -o <span class="built_in">test</span> -lpthread</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基于信号量实现的互斥锁</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>muduo网络库</title>
    <link href="https://penge666.github.io/posts/d0543761.html"/>
    <id>https://penge666.github.io/posts/d0543761.html</id>
    <published>2024-05-03T05:14:14.000Z</published>
    <updated>2024-05-04T03:42:31.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>网络编程是一个比较难码的模块，也是相对其他编程进阶的模块，特别是各种回调函数的理解调用以及其中会遇到各式各样难以解决的Bug。</p><p>借着学习陈硕大神muduo库的机会阅读了这本经典的网络编程教材《Linux多线程服务端编程》，这本也是这学期一直想学习的一本书，PS：就像研一下一直想学习Mit6.824一样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502214205866.png" alt="image-20240502214205866"></p><p>开始整体部分！</p><p>muduo网络库是Multi-Reactor架构，具体可以分为3个部分：</p><ul><li>网络相关模块：如Socket、InetAddress、TcpConnection、Acceptor、TcpServer等</li><li>事件循环相关模块：如EventLoop、Channel、Poller、EPollPoller等</li><li>线程相关模块：如Thread、EventLoopThread、EventLoopThreadPool等</li><li>基础模块：如用户态缓冲区Buffer、时间戳Timestamp、日志类Logger等</li></ul><p>本文参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/495016351">万字长文梳理Muduo库核心代码及优秀编程细节思想剖析</a></li><li><a href="https://www.cnblogs.com/S1mpleBug/p/16712003.html#231-%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88pollerchannel%E5%92%8Ceventloop%E5%9C%A8%E6%95%B4%E4%B8%AAmulti-reactor%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2">长文梳理muduo网络库核心代码、剖析优秀编程细节</a></li><li><a href="https://www.cnblogs.com/fortunely/p/15998209.html">muduo笔记</a></li></ul><h2 id="原理篇">原理篇</h2><h3 id="Multi-Reactor">Multi-Reactor</h3><p>Muduo库是基于Reactor模式实现的TCP网络编程库。</p><p>Multi-Reactor模型如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502220126199.png" alt="image-20240502220126199"></p><h3 id="事件循环模块">事件循环模块</h3><p>muduo库基于三个关键组件来实现一个reactor，这个reactor可以持续地监听一组文件描述符（fd），并根据每个fd上发生的事件来调用相应的处理函数。这三个核心组件包括Channel类、Poller/EpollPoller类以及EventLoop类。</p><p>可以先看下整体的架构，先有个整体的了解。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502224744115.png" alt="image-20240502224744115"></p><h4 id="Channel类">Channel类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>在TCP网络编程中，要想使用IO多路复用来监听某个文件描述符（fd），需要通过epoll_ctl将这个fd及其关心的事件注册到IO多路复用模块（也可以称之为事件监听器）上。当事件监听器检测到该fd发生了某个事件时，它会返回一个包含发生事件的fd集合，以及每个fd都发生了什么事件。</p><p>Channel类就是这样一个封装，它包含了一个文件描述符（fd），这个fd关心的事件，以及事件监听器实际检测到的事件。除此之外，Channel类还提供了一些方法，允许你设置这个fd的关心的事件，将这个fd及其关心的事件注册到事件监听器中或者从事件监听器中移除，以及保存这个fd的每种事件所对应的处理函数。</p><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li>int fd_：Channel对象关心的文件描述符。</li><li>int events_：fd感兴趣的事件类型集合。</li><li>int revents_：代表事件监听器实际监听到该fd发生的事件类型集合。当事件监听器监听到一个fd发生了什么事件，通过Channel::set_revents()函数来设置revents值。</li><li>EventLoop* loop：表示当前的Channel是在哪个loop中。</li><li>read_callback_ 、write_callback_、close_callback_、error_callback_：这些是std::function类型，代表着这个Channel为这个文件描述符保存的各事件类型发生时的处理函数。比如这个fd发生了可读事件，需要执行可读事件处理函数，Channel类都替你保管好了这些可调用函数。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><p>成员函数的设计是根据成员变量和这个类的功能设计，在设计之前我们自己也可以先想想作者为什么这么设计。</p><ul><li><p>向Channel对象注册各类事件的处理函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123;read_callback_ = std::<span class="built_in">move</span>(cb);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(Eventcallback cb)</span> </span>&#123;write_callback_ = std::<span class="built_in">move</span>(cb);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span> </span>&#123;close_callback_ = std::<span class="built_in">move</span>(cb);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span> </span>&#123;error_callback_ = std::<span class="built_in">move</span>(cb);&#125; </span><br></pre></td></tr></table></figure><p>简单来说，就是事件监听器监听到描述符发生的事件的时候，相应的处理函数来处理。处理函数保存在Channel类中，这样调用也比较方便。第二点所示。</p></li><li><p>根据poller通知的channel发生的具体事件， 由channel负责调用具体的回调操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>, revents_);</span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用epoll_wait()后，可以得知事件监听器上哪些Channel（文件描述符）发生了哪些事件，事件发生后自然就要调用这些Channel对应的处理函数。</p></li><li><p>将这个文件描述符实际发生的事件封装进这个Channel中</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span> </span>&#123;revents_ = revt;&#125;</span><br></pre></td></tr></table></figure><p>这个函数是在EPollPoller::fillActiveChannels调用，即获取活跃的连接的时候设置给Channel。</p></li><li><p>将Channel中的文件描述符及其感兴趣事件注册事件监听器上或从事件监听器上移除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成后会跟新epoll中的fd为当前需要监听[设置]的事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;events_ |= kReadEvent; <span class="built_in">upadte</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123;events_ &amp;= ~kReadEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;events_ |= kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;events_ &amp;= ~kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;events_ |= kNonEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void Channel::update()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // 通过channel所属的EventLoop，调用poller的相应方法，注册fd的events事件</span></span><br><span class="line"><span class="comment">    loop_-&gt;updateChannel(this);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个update的调用过程是Channel=&gt;EventLoop=&gt;Poller。update本质上就是调用了epoll_ctl()。</p></li></ul><h4 id="EpollPoller类">EpollPoller类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>负责监听文件描述符事件是否触发以及返回发生事件的文件描述符以及具体事件的模块就是Poller。一个Poller对象对应一个事件监听器。其中，1个reactor中有1个Poller，也就是说有多少reactor就有多少Poller。</p><p>目前，项目中muduo库只支持epoll。</p><p>Poller是个抽象虚类，由EpollPoller和PollPoller继承实现，与监听文件描述符和返回监听结果的具体方法也基本上是在这两个派生类中实现。EpollPoller就是封装了用epoll方法实现的与事件监听有关的各种方法，PollPoller就是封装了poll方法实现的与事件监听有关的各种方法。</p><blockquote><p><strong>成员变量</strong></p></blockquote><p>这里将Poller/EpollPoller成员变量放在一起。</p><ul><li>epollfd_：用epoll_create方法返回的epoll句柄。</li><li>channels_：这个变量是std::unordered_map&lt;int, Channel*&gt;类型，负责记录 文件描述符 —&gt; Channel的映射，也帮忙保管所有注册在这个Poller上的Channel。</li><li>ownerLoop_：表示当前epollfd在哪个loop。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li><p>获取监听发生事件的描述符的Channel集合</p><p>核心是以下2个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeStamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span></span></span><br></pre></td></tr></table></figure><p>具体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timestamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// events_每次传入都是初始化过的，也就说里面没有数据，等待epoll_wait获取数据。</span></span><br><span class="line">    <span class="type">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_, &amp;*events_.<span class="built_in">begin</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">    <span class="built_in">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填写活跃的连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Channel *channel = <span class="built_in">static_cast</span>&lt;Channel *&gt;(events_[i].data.ptr);</span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);</span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel); <span class="comment">// EventLoop就拿到了它的poller给它返回的所有发生事件的channel列表了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个问题：fillActiveChannels中遍历numEvents为什么就能得到channel对象？</p><p>这是因为在将EPollPoller::update中（也就是在将文件描述符交给epoll监听的时候，将channel对象也放进去便于传递方便后期使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure></li><li><p>更新文件描述符监听的事件</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关系：channel update remove =&gt; EventLoop updateChannel removeChannel =&gt; Poller updateChannel removeChannel</span></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == kNew || index == kDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == kNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">            channels_[fd] = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// channel已经在poller上注册过了</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新channel通道 epoll_ctl add/mod/del</span></span><br><span class="line"><span class="type">void</span> EPollPoller::<span class="built_in">update</span>(<span class="type">int</span> operation, Channel *channel)</span><br><span class="line">&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码比较清楚了，调用updateChannel其中再调用update。本质还是调用epoll_ctl，只不过层层封装适合框架。</p></li></ul><h4 id="EventLoop类">EventLoop类</h4><p>EventLoop类就是将Channel类和EpollPoller类进行统一管理。</p><p>EventLoop就是负责实现**“循环”<strong>，负责驱动</strong>“循环”**的重要模块。</p><p>这里循环也就是while循环不断检测是否存在监听事件的发生，然后使用传入的回调函数处理对应的事件。</p><p>可以看下下面这张图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502224744115.png" alt="image-20240502224744115"></p><ul><li><p>开启事件循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 监听两类fd   一种是client的fd，一种wakeupfd</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainLoop accept fd《=channel subloop</span></span><br><span class="line"><span class="comment">         * mainLoop 事先注册一个回调cb（需要subloop来执行）    wakeup subloop后，执行下面的方法，执行之前mainloop注册的cb操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------执行回调----------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> <span class="comment">// 执行回调</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Functor &amp;functor : functors)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">functor</span>(); <span class="comment">// 执行当前loop需要执行的回调操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，刚开始的时候对应为什么还会执行doPendingFunctors有点迷惑？这里给出我的理解：用于loop之间通信使用，比如：mainloop要将客户端交给一个loop处理请求。</p></li><li><p>子loop唤醒</p><p>接着上面的问题，当主loop要将连接的客户端交给一个subloop子loop监听处理，但是子loop怎么唤醒呢？</p><p>这里muduo库是先创建一个wakeup描述符，专门用于唤醒描述符，加入到epoll中监听。那么对于唤醒子loop的方法只用往wakeup写入即可，当epoll监听到写事件的时候，就会调用wakeup之前设置的事件发生处理函数进行处理（也就将写事件写入的读出来）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来唤醒loop所在的线程的  向wakeupfd_写一个数据，wakeupChannel就发生读事件，当前loop线程就会被唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当多线程的情况如何正确调用函数呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quit_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果是在其它线程中，调用的quit   在一个subloop(woker)中，调用了mainLoop(IO)的quit</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>()) <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>简单来说，1.loop在自己的线程中调用quit  2.在非loop的线程中，调用loop的quit。</p><ul><li><p>小注意点·</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>()) <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒相应的，需要执行上面回调操作的loop的线程了</span></span><br><span class="line">    <span class="comment">// || callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(); <span class="comment">// 唤醒loop所在线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前的线程直接执行回调函数，但是如果不在的就需要唤醒下。</p><p>这里2个注意点：</p><p>1.怎么判断线程是否是当前线程？</p><p>isInLoopThread() const { return threadId_ ==  CurrentThread::tid(); }</p><p>muduo库设计中使用了这条语句判断。我们只要使用这个函数进行判断。【这个深入的话有点抽象】</p><p>2.(!isInLoopThread() || callingPendingFunctors_)</p><p>如果不在当前线程，唤醒比较好理解。还有一种情况需要唤醒是正在执行回调函数，如果不唤醒，那么这个回调函数就不知道要什么时候才能执行，也可能不执行。因此需要唤醒一下。</p></li><li><p>其他</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventLoop的方法 =》 Poller的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个点在Channel调用过程中已经说明。</p></li></ul><h3 id="线程模块">线程模块</h3><p>这部分体现了One loop one thread的思想，也是muduo的核心！</p><h4 id="Thread类">Thread类</h4><p>Thread类主要是创建线程，然后执行相应的回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(ThreadFunc, <span class="type">const</span> std::string &amp;name = std::string())</span></span>;</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">tid</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tid_; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numCreated_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDefaultName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    <span class="type">bool</span> joined_;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; thread_;</span><br><span class="line">    <span class="type">pid_t</span> tid_;</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">static</span> std::atomic_int numCreated_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="EventLoopThread类">EventLoopThread类</h4><p>这个类体现了One loop one thread的思想，就是一个线程负责一个loop循环。</p><p>这个类主要的工作是将eventloop和thread封装，正好一个loop一个线程。</p><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li>EventLoop *loop_：对应的loop。</li><li>_ bool exiting_：是否退出。</li><li>Thread thread_：线程类。</li><li>std::mutex mutex_：互斥锁。</li><li><em>std::condition_variable cond</em>：条件变量。</li><li>ThreadInitCallback callback_：线程初始化回调函数。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li>开启loop</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_.<span class="built_in">start</span>(); <span class="comment">// 启动底层的新线程</span></span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (loop_ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个方法，实在单独的新线程里面运行的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 创建一个独立的eventloop，和上面的线程是一一对应的，one loop per thread</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// EventLoop loop  =&gt; Poller.poll</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是创建loop，然后线程中不断的loop循环。</p><h4 id="EventLoopPoolThread类">EventLoopPoolThread类</h4><p>eventloop池，从最开始的架构图就可以知道，muduo有主Loop和若干个子loop。这些loop就是这个类产生的。</p><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li>EventLoop *baseLoop_：这是主EventLoop，通常在主线程中运行。</li><li><em>std::string name</em>： EventLoopThreadPool的名称。</li><li>bool started _ ：表示EventLoopThreadPool是否已经启动。</li><li>int numThreads _ ： 线程池中线程的数量。</li><li>int next _ ： 下一个要被处理的线程的索引。</li><li>std::vector&lt; std::unique_ptr&lt; EventLoopThread&gt; &gt; threads_： 存储线程池中所有线程的容器，使用unique_ptr管理每个线程的生命周期。</li><li>_std::vector&lt;EventLoop *&gt; loops： 存储所有EventLoop的指针的容器，用于分发任务。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li><p>启动线程池，并且在每个线程中创建并启动一个EventLoop。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[name_.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s%d&quot;</span>, name_.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        EventLoopThread *t = <span class="keyword">new</span> <span class="built_in">EventLoopThread</span>(cb, buf);</span><br><span class="line">        threads_.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>()); <span class="comment">// 底层创建线程，绑定一个新的EventLoop，并返回该loop的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个服务端只有一个线程，运行着baseloop</span></span><br><span class="line">    <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主Loop_默认以轮询的方式分配channel给子loop，通过轮询挑选出一个子loop</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop *loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loops_.<span class="built_in">empty</span>()) <span class="comment">// 通过轮询获取下一个处理事件的loop</span></span><br><span class="line">    &#123;</span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span> (next_ &gt;= loops_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            next_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="网络模块">网络模块</h3><h4 id="Acceptor类">Acceptor类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>Accetpor封装了服务器专门用于监听是否有客户端连接的套接字fd以及相关处理方法。主要是对其他类的方法调用进行封装。</p><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li>acceptSocket_：这个是服务器监听套接字的文件描述符。</li><li>acceptChannel_：这是个Channel类，把acceptSocket _ 及其感兴趣事件和事件对应的处理函数都封装进去。</li><li>EventLoop *loop：监听套接字的fd由哪个EventLoop负责循环监听以及处理相应事件，其实这个EventLoop就是main EventLoop。</li><li>newConnectionCallback_: TcpServer构造函数中将TcpServer::newConnection( )函数注册给了这个成员变量。这个TcpServer::newConnection函数的功能是公平的选择一个subEventLoop，并把已经接受的连接分发给这个subEventLoop。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li><p>开启链接监听</p><p>listen( )：该函数底层调用了linux的函数listen( )，开启对acceptSocket _ 的监听同时将acceptChannel及其感兴趣事件（可读事件）注册到main EventLoop 的事件监听器上。换言之就是让main EventLoop事件监听器去监听acceptSocket_。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>(); <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理新用户连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop)</span><br><span class="line">    , <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">    , <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>())</span><br><span class="line">    , <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// bind</span></span><br><span class="line">    <span class="comment">// TcpServer::start() Acceptor.listen  有新用户的连接，要执行一个回调（connfd=》channel=》subloop）</span></span><br><span class="line">    <span class="comment">// baseLoop =&gt; acceptChannel_(listenfd) =&gt; </span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleRead( )：这是一个私有成员方法，这个方法是要注册到acceptChannel_ 上的，在构造accept对象的时候设置给acceptchannel对象， 同时handleRead( )方法内部还调用了成员变量newConnectionCallback_保存的函数。当main EventLoop监听到acceptChannel _ 上发生了可读事件时（新用户连接事件），就是调用这个handleRead( )方法。</p></li></ul><h4 id="Buffer类">Buffer类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>Buffer类其实是封装了一个用户缓冲区，以及向这个缓冲区写数据读数据等一系列控制方法。</p><blockquote><p><strong>算法</strong></p></blockquote><p>这张图已经可以很好的说明这个类的具体功能。</p><p>可以和CS144 TCP协议中的buffer进行比对下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502231632156.png" alt="image-20240502231632156"></p><blockquote><p><strong>成员方法</strong></p></blockquote><ul><li>ssize_t Buffer::readFd(int fd, int* saveErrno);：客户端发来数据，readFd从该TCP接收缓冲区中将数据读出来并放到Buffer中。</li><li>ssize_t Buffer::writeFd(int fd, int* saveErrno);：服务端要向这条TCP连接发送数据，通过该方法将Buffer中的数据拷贝到TCP发送缓冲区中。</li></ul><p>巧妙的设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从fd上读取数据  Poller工作在LT模式</span></span><br><span class="line"><span class="comment"> * Buffer缓冲区是有大小的！ 但是从fd上读数据的时候，却不知道tcp数据最终的大小</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); <span class="comment">// 这是Buffer底层缓冲区剩余的可写空间大小</span></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// extrabuf里面也写入了数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：可以让用户一次性把所有TCP接收缓冲区的所有数据全部都读出来并放到用户自定义的缓冲区Buffer中。用户自定义缓冲区Buffer是有大小限制的，我们一开始不知道TCP接收缓冲区中的数据量有多少，如果一次性读出来会不会导致Buffer装不下而溢出。所以在readFd( )函数中会在栈上创建一个临时空间extrabuf，然后使用readv的分散读特性，将TCP缓冲区中的数据先拷贝到Buffer中，如果Buffer容量不够，就把剩余的数据都拷贝到extrabuf中，然后再调整Buffer的容量(动态扩容)，再把extrabuf的数据拷贝到Buffer中。当这个函数结束后，extrabuf也会被释放。另外extrabuf是在栈上开辟的空间，速度比在堆上开辟还要快。</p><h4 id="TcpConnection-TcpServer类">TcpConnection/TcpServer类</h4><p>这个类是集大成的类，需要清楚的知道具体的回调函数的调用。</p><p>TCP网络编程的本质是处理下面这几个事件：</p><ul><li>连接的建立。</li><li>连接的断开。（包括主动断开和被动断开）</li><li>消息到达，客户端连接文件描述符可读。</li><li>消息发送，向客户端连接文件描述符写数据。</li></ul><p>先来看看整体的图示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503110725342.png" alt=""></p><h5 id="使用示例">使用示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/Logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">            <span class="type">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        server_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接建立或者断开的回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                Timestamp time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 写端   EPOLLHUP =》 closeCallback_</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpServer server_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;EchoServer-01&quot;</span>)</span></span>; <span class="comment">// Acceptor non-blocking listenfd  create bind </span></span><br><span class="line">    server.<span class="built_in">start</span>(); <span class="comment">// listen  loopthread  listenfd =&gt; acceptChannel =&gt; mainLoop =&gt;</span></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// 启动mainLoop的底层Poller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：using TcpConnectionPtr = std::shared_ptr&lt; TcpConnection &gt; ;</p><h5 id="连接建立">连接建立</h5><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503105422549.png" alt="image-20240503105422549"></p><p>大体的整个流程如上图所示：</p><ul><li><p>TcpServer::TcpServer()<br>当我们创建一个TcpServer对象，即执行代码TcpServer server(&amp;loop, listenAddr);调用了TcpServer的构造函数，TcpServer构造函数最主要的就是类的内部实例化了一个Acceptor对象，并往这个Acceptor对象注册了一个回调函数TcpServer::newConnection()。</p></li><li><p>Acceptor::Acceptor()<br>当我们在TcpServer构造函数实例化Acceptor对象时，Acceptor的构造函数中实例化了一个Channel对象，即acceptChannel _ ，该Channel对象封装了服务器监听套接字文件描述符（尚未注册到main EventLoop的事件监听器上）。接着Acceptor构造函数将Acceptor::handleRead()方法注册进acceptChannel_ 中，这也意味着，日后如果事件监听器监听到acceptChannel_发生可读事件，将会调用Acceptor::handleRead()函数。</p><p>至此，TcpServer对象创建完毕，用户调用TcpServer::start()方法，开启TcpServer。主要就是调用Acceptor::listen()函数（底层是调用了linux的函数listen()）监听服务器套接字，以及将acceptChannel_注册到main EventLoop的事件监听器上监听它的可读事件（新用户连接事件）接着用户调用loop.loop()，即调用了EventLoop::loop()函数，该函数就会循环的获取事件监听器的监听结果，并且根据监听结果调用注册在事件监听器上的Channel对象的事件处理函数。</p></li><li><p>Acceptor::handleRead()<br>当程序如果执行到了这个函数里面，说明acceptChannel_ 发生可读事件，程序处理新客户连接请求。该函数首先调用了Linux的函数accept()接受新客户连接。接着调用了TcpServer::newConnection()函数，这个函数是在步骤1中注册给Acceptor并由成员变量newConnectionCallback_保存。</p></li><li><p>TcpServer::newConnection()<br>该函数的主要功能就是将建立好的连接进行封装（封装成TcpConnection对象），并使用选择算法公平的选择一个sub EventLoop，并调用TcpConnection::connectEstablished()将TcpConnection::channel_注册到刚刚选择的sub EventLoop上。</p></li></ul><h5 id="消息处理">消息处理</h5><p>SubEventLoop中的EventLoop::loop()函数内部会<strong>循环的执行</strong>上图中的步骤1和步骤2。步骤1就是调用Poller::poll()方法获取事件监听结果，这个事件监听结果是一个Channel集合，每一个Channel封装着 [一个fd] 及 [fd感兴趣的事件] 和 [事件监听器监听到该fd实际发生的事件]。步骤2就是调用每一个Channel的Channel::HandlerEvent方法。该方法会根据每一个Channel的感兴趣事件以及实际发生的事件调用提前注册在Channel内的对应的事件处理函数（readCallback_、writeCallback_、closeCallback_、errorCallback _  )。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503105957775.png" alt="image-20240503105957775"></p><blockquote><p><strong>消息读取</strong></p></blockquote><p>readCallback_保存的函数其实是TcpConnection::handleRead( )，<strong>消息读取的处理逻辑也就是由这个函数提供的</strong>，我们稍微剖析一下这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>; </span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="comment">//从fd读到了数据，并且放在了inputBuffer_上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TcpConnection::handleRead( )函数首先调用Buffer_.readFd(channel_-&gt;fd(), &amp;saveErrno)，该函数底层调用Linux的函数readv( )，将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中（inputBuffer_）。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在savedErrno中。</p><ul><li>当readFd( )返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用messageCallback_中保存的用户自定义的读取消息后的处理函数。</li><li>readFd( )返回值等于0，说明客户端连接关闭，这时候应该调用TcpConnection::handleClose( )来处理连接关闭事件</li><li>readFd( )返回值等于-1，说明发生了错误，调用TcpConnection::handleError( )来处理savedErrno的错误事件。Moduo库只支持LT模式，所以读事件不会出现EAGAIN的错误，所以一旦出现错误，说明肯定是比较不好的非正常错误了。而EAGAIN错误只不过是非阻塞IO调用时的一种常见错误而已。</li></ul><blockquote><p><strong>消息发送</strong></p></blockquote><p>当用户调用了TcpConnetion::send(buf)函数时，相当于要求muduo库把数据buf发送给该Tcp连接的客户端。此时该TcpConnection注册在事件监听器上的感兴趣事件中是没有可写事件的。TcpConnection::send(buf)函数内部其实是调用了Linux的函数write( )</p><p>如果TCP发送缓冲区内不能一次性容纳buf：</p><ul><li>这时候write( )函数buf数据尽可能地拷贝到TCP发送缓冲区中，并且将errno设置为EWOULDBLOCK。</li><li>剩余未拷贝到TCP发送缓冲区中的buf数据会被存放在TcpConnection::outputBuffer_中。并且向事件监听器上注册该TcpConnection::channel_的可写事件。</li><li>事件监听器监听到该Tcp连接可写事件，就会调用TcpConnection::handleWrite( )函数把TcpConnection::outputBuffer_中剩余的数据发送出去。_<ul><li>在TcpConnection::handleWrite( )函数中，通过调用Buffer::writeFd()函数将outputBuffer_的数据写入到Tcp发送缓冲区，如果Tcp发送缓冲区能容纳全部剩余的未发送数据，那最好不过了。如果Tcp发送缓冲区依旧没法容纳剩余的未发送数据，那就尽可能地将数据拷贝到Tcp发送缓冲区中，继续保持可写事件的监听。</li></ul></li><li>当数据全部拷贝到Tcp发送缓冲区之后，就会调用用户自定义的【写完后的事件处理函数】，并且移除该TcpConnection在事件监听器上的可写事件。（移除可写事件是为了提高效率，不会让epoll_wait() 毫无意义的频繁触发可写事件。因为大多数时候是没有数据需要发送的，频繁触发可写事件但又没有数据可写。）</li></ul><p><strong>TcpConnection::send和TcpConnection::handleWrite的区别：</strong></p><ul><li>sendInLoop 的目的是尝试立即将数据写入内核空间。如果一次就能写完，那么就没问题。但如果写入操作被阻塞，或者只写入了部分数据，那么剩下的数据就会被放到 outputBuffer_ 中，然后通过注册写事件 enableWriting()，在有空间可写的时候，再继续写入剩下的数据。这个函数的调用通常是在应用程序想要发送数据的时候。</li><li>handleWrite 则是在内核通知应用程序可以写入数据的时候调用的，即当套接字的发送缓冲区有足够的空间可以接收更多数据时。这个函数的目的是尽可能地将 outputBuffer_ 中的数据写入到内核空间，直到写入全部数据或者内核空间无法接收更多数据为止。然后，如果 outputBuffer_ 中的数据全部写入完成，那么就取消对写事件的关注 disableWriting()，因为此时不需要再写数据了。</li><li>总的来说，sendInLoop 是应用程序主动发送数据，handleWrite 是在收到内核的可写通知后尝试写入数据。这两个函数共同实现了数据的异步写入：sendInLoop 负责将应用程序的数据放入 outputBuffer_ ，并尝试写入内核；handleWrite 负责在内核准备好接收数据时，将 outputBuffer_ 中的数据写入内核。</li></ul><p>在阅读源码的时候，有个疑问？也就是之前在学习buffer设计的时候，buffer既支持写也支持读，而且缓冲区的设计就有readerIndex_ 和writerIndex_，那为什么之后TcpConnnection中又放2个缓冲区buffer呢？</p><p>GPT回答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在muduo网络库中，接收数据的缓冲区inputBuffer_和发送数据的缓冲区outputBuffer_ 都是独立的，这是因为在网络编程中，接收和发送数据的操作通常是异步的，也就是说，它们可以在不同的时间、以不同的速度发生，因此，它们需要各自的缓冲区来维护它们的状态。</span><br><span class="line"></span><br><span class="line">具体来说，inputBuffer_被用来存储从网络中接收到的数据，直到应用程序准备好处理这些数据为止。同样，outputBuffer_ 被用来存储应用程序准备发送到网络中的数据，直到这些数据被实际发送为止。</span><br><span class="line"></span><br><span class="line">虽然你提到的一个缓冲区可以处理读写操作，但这只适用于单一的读写操作。在网络编程中，接收和发送数据的操作是分离的，并且经常需要在不同的时间进行。因此，使用两个独立的缓冲区可以使得接收和发送数据的操作更加灵活和高效。</span><br></pre></td></tr></table></figure><h5 id="连接断开">连接断开</h5><blockquote><p><strong>连接被动断开</strong></p></blockquote><p>服务端TcpConnection::handleRead()中感知到客户端把连接断开了。<br>TcpConnection::handleRead( )函数内部调用了Linux的函数readv( )，当readv( )返回0的时候，服务端就知道客户端断开连接了。然后就接着调用TcpConnection::handleClose( )。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503111746345.png" alt="image-20240503111746345"></p><ol><li>在执行TcpConnection::handle_Close()的时候，该函数还是在SubEventLoop线程中运行的，接着调用closeCallback_(connPtr)回调函数，该函数保存的其实是TcpServer::removeConnection( )函数</li><li>TcpServer::removeConnection( )函数调用了remvoveConnectionInLoop( )函数，该函数的运行是在MainEventLoop线程中执行的，这里涉及到线程切换技术。</li><li>removeConnectionInLoop( )函数：TcpServer对象中有一个connections_ 成员变量，这是一个unordered_map，负责保存【string --&gt; TcpConnection】的映射，其实就是保存着Tcp连接的名字到TcpConnection对象的映射。因为这个Tcp连接要关闭了，所以也要把这个TcpConnection对象从connections_中删掉。然后再调用TcpConnection::connectDestroyed函数。<br>另外为什么removeConnectionInLoop()要在MainEventLoop中运行，因为该函数主要是从TcpServer对象中删除某条数据。而TcpServer对象是属于MainEventLoop的。这也是贯彻了One Loop Per Thread的理念。</li><li>TcpConnection::connectDestroyed( )函数的执行是又跳回到了subEventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外SubEventLoop中的Poller类对象还保存着这条Tcp连接的channel_，所以调用channel_.remove( )将这个Tcp连接的channel对象从Poller内的数据结构中删除。</li></ol><blockquote><p><strong>连接主动断开</strong></p></blockquote><p>服务器主动关闭导致连接断开。当服务器主动关闭时，调用TcpServer::~TcpServer()析构函数。</p><p>这里在提示一下EventLoop::runInLoop()函数的意义，假如你有一个EventLoop对象 loop_，当你调用了loop_-&gt;runInLoop(function)函数时，这个function函数的执行会在这个loop_绑定的线程上运行！<br>所以我们画了下面这幅图，在创建TcpConnection对象时，Acceptor都要将这个对象分发给一个SubEventLoop来管理。这个TcpConnection对象的一切函数执行都要在其管理的SubEventLoop线程中运行。再一次贯彻One Loop Per Thread的设计模式。比如要想彻底删除一个TcpConnection对象，就必须要调用这个对象的connecDestroyed()方法，这个方法执行完后才能释放这个对象的堆内存。每个TcpConnection对象的connectDestroyed()方法都必须在这个TcpConnection对象所属的SubEventLoop绑定的线程中执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503110725342.png" alt=""></p><p>所有上面的TcpServer::~TcpServer()函数就是干这事儿的，不断循环的让这个TcpConnection对象所属的SubEventLoop线程执行TcpConnection::connectDestroyed()函数，同时在MainEventLoop的TcpServer::~TcpServer()函数中调用item.second.reset()释放保管TcpConnection对象的共享智能指针，以达到释放TcpConnection对象的堆内存空间的目的。<br>但是这里面其实有一个问题需要解决，TcpConnection::connectDestroyed()函数的执行以及这个TcpConnection对象的堆内存释放操作不在同一个线程中运行，所以要考虑怎么保证一个TcpConnectino对象的堆内存释放操作是在TcpConnection::connectDestroyed()调用完后。<br>这个析构函数巧妙利用了共享智能指针的特点，当没有共享智能指针指向这个TcpConnection对象时（引用计数为0），这个TcpConnection对象就会被析构删除（堆内存释放）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//connections类型为std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : connections_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.<span class="built_in">reset</span>(); </span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先TcpServer::connections_是一个unordered_map&lt;string, TcpConnectionPtr&gt;，其中TcpConnectionPtr的含义是指向TcpConnection的shared_ptr。</li><li>在一开始，每一个TcpConnection对象都被一个共享智能指针TcpConnetionPtr持有，当执行了TcpConnectionPtr conn(item.second)时，这个TcpConnetion对象就被conn和这个item.second共同持有，但是这个conn的生存周期很短，只要离开了当前的这一次for循环，conn就会被释放。</li><li>紧接着调用item.second.reset()释放掉TcpServer中保存的该TcpConnectino对象的智能指针。此时在当前情况下，只剩下conn还持有这个TcpConnection对象，因此当前TcpConnection对象还不会被析构。</li><li>接着调用了conn-&gt;getLoop()-&gt;runInLoop(bind(&amp;TcpConnection::connectDestroyed, conn));<br>这句话的含义是让SubEventLoop线程去执行TcpConnection::connectDestroyed()函数。当你把这个conn的成员函数传进去的时候，conn所指向的资源的引用计数会加1。因为传给runInLoop的不只有函数，还有这个函数所属的对象conn。</li><li>SubEventLoop线程开始运行TcpConnection::connectDestroyed()</li><li>MainEventLoop线程当前这一轮for循环跑完，共享智能指针conn离开代码块，因此被析构，但是TcpConnection对象还不会被释放，因为还有一个共享智能指针指向这个TcpConnection对象，而且这个智能指针在TcpConnection::connectDestroyed()中，只不过这个智能指针你看不到，它在这个函数中是一个隐式的this的存在。当这个函数执行完后，智能指针就真的被释放了。到此，就没有任何智能指针指向这个TcpConnection对象了。TcpConnection对象就彻底被析构删除了。</li></ul>]]></content>
    
    
    <summary type="html">深入剖析muduo网络库</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>时间函数</title>
    <link href="https://penge666.github.io/posts/83c8f10.html"/>
    <id>https://penge666.github.io/posts/83c8f10.html</id>
    <published>2024-04-30T09:05:22.000Z</published>
    <updated>2024-04-30T11:17:17.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在C++日志系统中，打印时间是必不可少的一个操作。</p><p>在 Linux C 语言编程中，有两种时间表示方式：</p><ul><li><p>一种是日历时间（calendar time），用于表示自纪元（Epoch）以来的秒数，他可以转换成我们日常看到的时间。</p></li><li><p>一种是处理器时间（processor time），用于表示程序在 CPU 上执行的时间。本文主要关注日历时间的处理。</p></li></ul><blockquote><p><strong>时间戳的概念</strong></p></blockquote><p>时间戳是一种用数字表示时间的方式。它是一个简单的计数器，记录了某个特定事件发生时的时间和日期。</p><p>你可以把时间戳看作一个独一无二的数字标记，表示了某个时刻的时间。这个数字通常是从某个参考点（通常是纪元）开始不断增加的。</p><p>时间戳可以精确到秒、毫秒甚至更小的单位，取决于使用的系统和编程语言。使用时间戳，我们可以轻松地对事件按照时间顺序进行排序和比较，而不用担心日期格式、时区等复杂的问题。</p><p>时间戳在计算机科学和软件开发中非常有用。它可以用来记录事件发生的顺序、计算时间差、创建时间戳序列、做数据分析等等。许多操作系统和编程语言都提供了用于获取和处理时间戳的函数和工具，使我们可以方便地使用它们。</p><p>简而言之，<strong>时间戳就是用数字来表示特定时刻的时间和日期，方便我们在计算机中处理和比较时间</strong>。</p><h2 id="时间函数">时间函数</h2><h3 id="time">time()</h3><p>time()函数是 C 和 C++ 中最基本的时间函数，它返回自 1970 年 1 月 1 日起的秒数。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span></span>;</span><br></pre></td></tr></table></figure><p>参数的作用：</p><ul><li>当参数为NULL时：time_t这个整型值通过返回值返回。</li><li>当参数不为NULL时：time_t我们需要的这个整型值通过参数指针得到。</li></ul><p>time_t类型</p><ul><li><strong>time_t</strong>是一个用于表示时间的数据类型，它在 C 语言中广泛使用。可以把它看作是一个整数类型，<strong>用于存储时间戳</strong>。</li></ul><p>使用示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time;</span><br><span class="line">    <span class="built_in">time</span>(&amp;current_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)current_time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面也是可以的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time;</span><br><span class="line">    current_time=<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)current_time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gettimeofday">gettimeofday()</h3><p>gettimeofday() 这个函数在 Unix 和 Linux 系统中常用，它可以获取到微秒级别的时间，更加精确。</p><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_sec: %d\n&quot;</span>, tv.tv_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_usec: %d\n&quot;</span>, tv.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="localtime">localtime()</h3><p>localtime() 函数的功能是将 time_t 类型的时间转换为一个 tm 结构体类型的时间。</p><p>localtime() 函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* <span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span>* timer);</span><br></pre></td></tr></table></figure><ul><li>参数</li></ul><p>timer：要转换的时间。</p><ul><li>返回值</li></ul><p>返回一个指向 tm 结构体变量的指针，该变量存储了当前时间的各个组成部分。</p><p>tm结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">/* Seconds (0-60) */</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">/* Minutes (0-59) */</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">/* Hours (0-23) */</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">/* Day of the month (1-31) */</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">/* Month (0-11) */</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">/* Year - 1900 */</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">/* Day of the week (0-6, Sunday = 0) */</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">/* Day in the year (0-365, 1 Jan = 0) */</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">/* Daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">time_t</span> current_time;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span>* local_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前时间</span></span><br><span class="line">  current_time = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换为本地时间结构体</span></span><br><span class="line">  local_time = <span class="built_in">localtime</span>(&amp;current_time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否转换成功</span></span><br><span class="line">  <span class="keyword">if</span> (local_time != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">             local_time-&gt;tm_year + <span class="number">1900</span>, <span class="comment">// 年份</span></span><br><span class="line">             local_time-&gt;tm_mon + <span class="number">1</span>,     <span class="comment">// 月份</span></span><br><span class="line">             local_time-&gt;tm_mday,        <span class="comment">// 日</span></span><br><span class="line">             local_time-&gt;tm_hour,        <span class="comment">// 小时</span></span><br><span class="line">             local_time-&gt;tm_min,         <span class="comment">// 分钟</span></span><br><span class="line">             local_time-&gt;tm_sec          <span class="comment">// 秒</span></span><br><span class="line">      );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;时间转换失败\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-04-30 18:54:30</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>localtime函数不是线程安全的。在多线程应用里面，应该用localtime_r函数替代localtime函数，因为localtime_r是线程安全的。</p><h3 id="gmtime">gmtime()</h3><p>类似 localtime()，但返回的是格林尼治标准时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间</span></span><br><span class="line">    std::<span class="type">time_t</span> current_time = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 gmtime 转换为格林尼治标准时间</span></span><br><span class="line">    std::tm* gm_time = std::<span class="built_in">gmtime</span>(&amp;current_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UTC time: &quot;</span> &lt;&lt; gm_time-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">              &lt;&lt; gm_time-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">              &lt;&lt; gm_time-&gt;tm_sec &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strftime">strftime()</h3><p>strftime() 函数的作用是按照指定的格式将时间结构体转换为字符串表示。</p><p>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure><p>strftime参数解析：</p><ul><li><p>s：一个指向字符数组的指针，用于存储格式化后的时间字符串。这个字符数组必须具有足够的空间来存储生成的字符串。</p></li><li><p>maxsize：表示存储时间字符串的字符数组的最大长度。这是为了避免溢出。</p></li><li><p>format：一个指向格式化字符串的指针，用于定义时间字符串的输出格式。格式字符串包含特定的格式占位符，如 %Y 表示年份，%m 表示月份等。</p></li><li><p>timeptr：一个指向 struct tm 结构体的指针，其中包含了要格式化的时间信息。这个结构体存储了年、月、日、时、分、秒等时间字段的值。</p></li></ul><p>strftime返回值解析</p><ul><li>函数 strftime() 的返回值是一个 size_t 类型的整数，表示成功写入目标字符串 s 的字符数（不包括末尾的空字符）。</li></ul><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time;</span><br><span class="line">    <span class="built_in">time</span>(&amp;current_time);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="type">local_t</span> = <span class="built_in">localtime</span>(&amp;current_time);</span><br><span class="line">    <span class="type">char</span> time_str[<span class="number">64</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">strftime</span>(time_str, <span class="built_in">sizeof</span>(time_str), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, <span class="type">local_t</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %s\n&quot;</span>, time_str);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时间为: 2024-04-30 19:05:43</span><br></pre></td></tr></table></figure><h3 id="chrono库">chrono库</h3><p>这是 C++11 中引入的新的时间库，可以方便地获取高精度时间，并进行时间的算术运算。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/679451085">C++ std::chrono库使用指南 (实现C++ 获取日期,时间戳,计时等功能)</a></li><li><a href="https://zhuanlan.zhihu.com/p/662738124">再也不被时间束缚：C++ stdchrono时间库全面解析</a></li></ul><h2 id="参考资料">参考资料</h2><ul><li><p><a href="https://developer.aliyun.com/article/1350147">Linux C语言之时间函数精讲</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/679451085">C++ std::chrono库使用指南 (实现C++ 获取日期,时间戳,计时等功能)</a></p></li></ul>]]></content>
    
    
    <summary type="html">走进时间函数的世界</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux惊群效应</title>
    <link href="https://penge666.github.io/posts/e5c92e8d.html"/>
    <id>https://penge666.github.io/posts/e5c92e8d.html</id>
    <published>2024-04-30T02:36:29.000Z</published>
    <updated>2024-04-30T03:08:41.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本博客主要介绍什么是惊群，惊群在线程和进程中的具体表现，惊群的系统消耗和惊群的处理方法。</p><h2 id="介绍">介绍</h2><p>惊群效应也有人叫做雷鸣群体效应，不过叫什么，简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。</p><p>这里打个有趣的比方，就像在学校的湖里面用面包🍞喂天鹅，当你往一群天鹅中间扔一撮面包🍞，所有的天鹅各自都被惊动前来抢夺这可口的食物，但是最终注定只有一个天鹅抢到食物，没有抢到的天鹅只好回去继续等待。</p><blockquote><p><strong>惊群效应存在的问题</strong></p></blockquote><p>（1）系统对用户进程/线程频繁地做无效的调度，上下文切换系统性能大打折扣。</p><p>（2）为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。</p><h2 id="惊群效应示例">惊群效应示例</h2><h3 id="accept">accept</h3><p>场景：主进程创建了socket、bind、listen之后，fork()出来多个进程，每个子进程都开始循环处理（accept）这个listen_fd。每个进程都阻塞在accept上，当一个新的连接到来时候，所有的进程都会被唤醒，但是其中只有一个进程会接受成功，其余皆失败，重新休眠。</p><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 10</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="built_in">listen</span>(fd, <span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PROCESS_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (connfd == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">snprintf</span>(sendbuff, <span class="built_in">sizeof</span>(sendbuff), <span class="string">&quot;接收到accept事件的进程PID = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">send</span>(connfd, sendbuff, <span class="built_in">strlen</span>(sendbuff) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d accept success\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d accept a connection failed: %s\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int status;</span></span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/test  g++ main.cpp -o main -pthread</span><br><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/test  strace -f ./main</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/180053751">Linux神器strace的使用方法及实践</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[pid 171338] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171338] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171338] accept(3, NULL, NULLstrace: Process 171339 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171339</span><br><span class="line">[pid 171339] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171339] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171339] accept(3, NULL, NULLstrace: Process 171340 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171340</span><br><span class="line">[pid 171340] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171340] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171340] accept(3, NULL, NULLstrace: Process 171341 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171341</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171341] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">strace: Process 171342 attached</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171342</span><br><span class="line">[pid 171341] accept(3, NULL, NULL &lt;unfinished ...&gt;</span><br><span class="line">[pid 171342] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171342] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171342] accept(3, NULL, NULLstrace: Process 171343 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171343</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171343] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">[pid 171343] accept(3, NULL, NULLstrace: Process 171344 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171344</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171344] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">[pid 171344] accept(3, NULL, NULLstrace: Process 171345 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171345</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171345] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">strace: Process 171346 attached</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171346</span><br><span class="line">[pid 171345] accept(3, NULL, NULL &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171346] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">[pid 171346] accept(3, NULL, NULLstrace: Process 171347 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171347</span><br><span class="line">[pid 171347] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] wait4(-1,  &lt;unfinished ...&gt;</span><br><span class="line">[pid 171347] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171347] accept(3, NULL, NULL &lt;unfinished ...&gt;</span><br></pre></td></tr></table></figure><p>之后，在启用一个终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 1234</span><br></pre></td></tr></table></figure><p>看看发生了什么变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[pid 172089] fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x9), ...&#125;) = 0</span><br><span class="line">[pid 172089] brk(NULL)                  = 0x55f621f04000</span><br><span class="line">[pid 172089] brk(0x55f621f25000)        = 0x55f621f25000</span><br><span class="line">[pid 172089] write(1, <span class="string">&quot;process 172089 accept a connecti&quot;</span>..., 51process 172089 accept a connection failed: Success</span><br><span class="line">) = 51</span><br><span class="line">[pid 172089] close(4)                   = 0</span><br><span class="line">[pid 172089] accept(3, NULL, NULL^C &lt;unfinished ...&gt;</span><br><span class="line">[pid 172098] &lt;... accept resumed&gt;)      = ? ERESTARTSYS (To be restarted <span class="keyword">if</span> SA_RESTART is <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><p>很明显当telnet连接的时候只有一个进程accept成功，也就说明了这里并没有发生惊群。</p><p>其实在linux2.6版本以后，linux内核已经解决了accept（）函数的“惊群”现象，大概的处理方式就是，当内核接收到一个客户连接后，只会唤醒等待队列上的第一个进程（线程）,所以如果服务器采用accept阻塞调用方式，在最新的linux系统中已经没有“惊群效应”了</p><h3 id="epoll">epoll</h3><p>场景：如果多个进程/线程阻塞在监听同一个监听socket fd的epoll_wait上，当有一个新的连接到来时，所有的进程都会被唤醒。</p><p>主进程创建socket，bind，listen后，将该socket加入到epoll中，然后fork出多个子进程，每个进程都阻塞在epoll_wait上，如果有事件到来，则判断该事件是否是该socket上的事件如果是，说明有新的连接到来了，则进行接受操作。为了简化处理，忽略后续的读写以及对接受返回的新的套接字的处理，直接断开连接。<br>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"><span class="comment">// socket创建和绑定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock_creat_bind</span><span class="params">(<span class="type">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(port));</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">return</span> sock_fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用fcntl设置文件或者函数调用的状态标志</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_nonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    val |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl set&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd, epoll_fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: [port] %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = <span class="built_in">sock_creat_bind</span>(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket and bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">make_nonblocking</span>(sock_fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;make non blocking&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sock_fd, SOMAXCONN) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((epoll_fd = <span class="built_in">epoll_create</span>(MAXEVENTS)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    event.data.fd = sock_fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock_fd, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*buffer where events are returned*/</span></span><br><span class="line">    events = <span class="built_in">static_cast</span>&lt;epoll_event *&gt;(<span class="built_in">calloc</span>(MAXEVENTS, <span class="built_in">sizeof</span>(event)));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PROCESS_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> num, j;</span><br><span class="line">                num = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process %d returnt from epoll_wait\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp; EPOLLIN)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sock_fd == events[i].data.fd)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 收到关于监听套接字的通知，意味着一盒或者多个传入连接</span></span><br><span class="line">                        <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                        <span class="type">socklen_t</span> in_len = <span class="built_in">sizeof</span>(in_addr);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">accept</span>(sock_fd, &amp;in_addr, &amp;in_len) &lt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;process %d accept failed!\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;process %d accept successful!\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> ✘ penge@penge-virtual-machine  ~/Desktop/MordenCpp/test  ./main 1234  </span><br><span class="line">process 173413 returnt from epoll_wait</span><br><span class="line">process 173412 returnt from epoll_wait</span><br><span class="line">process 173411 returnt from epoll_wait</span><br><span class="line">process 173410 returnt from epoll_wait</span><br><span class="line">process 173409 returnt from epoll_wait</span><br><span class="line">process 173408 returnt from epoll_wait</span><br><span class="line">process 173407 returnt from epoll_wait</span><br><span class="line">process 173406 returnt from epoll_wait</span><br><span class="line">process 173405 returnt from epoll_wait</span><br><span class="line">process 173404 returnt from epoll_wait</span><br><span class="line">process 173407 accept successful!</span><br><span class="line">process 173409 accept failed!</span><br><span class="line">process 173410 accept failed!</span><br><span class="line">process 173411 accept failed!</span><br><span class="line">process 173412 accept failed!</span><br><span class="line">process 173406 accept failed!</span><br><span class="line">process 173404 accept failed!</span><br><span class="line">process 173413 accept failed!</span><br><span class="line">process 173405 accept failed!</span><br><span class="line">process 173408 accept failed!</span><br></pre></td></tr></table></figure><p>显然，发生了惊群效应。</p><blockquote><p>怎么判断发生了惊群呢？</p></blockquote><p>我们根据strace的返回信息可以确定:</p><p>(1) 系统只会让一个进程真正的接受这个连接，而剩余的进程会获得一个EAGAIN信号。</p><p>(2）通过返回结果和进程执行的系统调用判断。</p><blockquote><p>为什么内核处理了accept的惊群，却不处理epoll_wait的惊群呢？</p></blockquote><p>accept确实应该只能被一个进程调用成功，内核很清楚这一点。但epoll不一样，他监听的文件描述符，除了可能后续被accept调用外，还有可能是其他网络IO事件的，而其他IO事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以，对epoll的惊群，内核则不予处理。</p><h2 id="解决方法">解决方法</h2><p>解决方式一共有三种</p><ol><li>accept_mutex（应用层的解决方案）</li><li>EPOLLEXCLUSIVE（内核层的解决方案）</li><li>SO_REUSEPORT（内核层的解决方案）</li></ol><h3 id="accept-mutex">accept_mutex</h3><p>看到 mutex 可能你就知道了，锁嘛！这也是对于高并发处理的 ”基操“ 遇事不决加锁，没错，加锁肯定能解决问题。</p><p>感兴趣的可以看看这部分的<a href="https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/event/ngx_event_accept.c#L328">代码实现</a>。</p><h3 id="EPOLLEXCLUSIVE">EPOLLEXCLUSIVE</h3><p>EPOLLEXCLUSIVE 是 2016 年 4.5+ 内核新添加的一个 epoll 的标识。它降低了多个进程/线程通过 epoll_ctl 添加共享 fd 引发的惊群概率，使得一个事件发生时，只唤醒一个正在 epoll_wait 阻塞等待唤醒的进程（而不是全部唤醒）。</p><p>关键是：每次内核只唤醒一个睡眠的进程处理资源。</p><h3 id="SO-REUSEPORT">SO_REUSEPORT</h3><p>Linux内核的3.9版本带来了SO_REUSEPORT特性，该特性支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，允许多个套接字bind()以及listen()同一个TCP或UDP端口，并且在内核层面实现负载均衡。</p><ul><li>在未开启SO_REUSEPORT的时候，由一个监听socket将新接收的连接请求交给各个工作者处理，看图示：<ul><li><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240430110045200.png" alt="image-20240430110045200"></li></ul></li><li>在使用SO_REUSEPORT后，多个进程可以同时监听同一个IP：端口，然后由内核决定将新链接发送给哪个进程，显然会降低每个工人接收新链接时锁竞争。<ul><li><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240430110103466.png" alt="image-20240430110103466"></li></ul></li></ul><blockquote><p><strong>SO_REUSEPORT解决了什么问题</strong></p></blockquote><p>（1）允许多个套接字bind()/listen()同一个tcp/udp端口。每一个线程拥有自己的服务器套接字，在服务器套接字上没有锁的竞争。</p><p>（2）内核层面实现负载均衡</p><p>（3）安全层面，监听同一个端口的套接字只能位于同一个用户下面。</p><p>（4）处理新建连接时，查找listener的时候，能够支持在监听相同IP和端口的多个sock之间均衡选择。</p><blockquote><p><strong>当一个连接到来的时候，系统到底是怎么决定那个套接字来处理它？</strong></p></blockquote><p>对于不同内核，存在两种模式，这两种模式并不共存，一种叫做热备份模式，另一种叫做负载均衡模式，3.9内核以后，全部改为负载均衡模式。</p><ul><li>热备份模式：一般而言，会将所有的reuseport同一个IP地址/端口的套接字挂在一个链表上，取第一个即可，工作的只有一个，其他的作为备份存在，如果该套接字挂了，它会被从链表删除，然后第二个便会成为第一个。</li><li>负载均衡模式：和热备份模式一样，所有reuseport同一个IP地址/端口的套接字会挂在一个链表上，你也可以认为是一个数组，这样会更加方便，当有连接到来时，用数据包的源IP/源端口作为一个HASH函数的输入，将结果对reuseport套接字数量取模，得到一个索引，该索引指示的数组位置对应的套接字便是工作套接字。这样就可以达到负载均衡的目的，从而降低某个服务的压力。</li></ul><h2 id="参考资料">参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/666017070">Nginx 是如何解决惊群效应的？</a></li><li><a href="https://blog.csdn.net/lyztyycode/article/details/78648798">Linux惊群效应详解</a></li></ul>]]></content>
    
    
    <summary type="html">一篇让我想起在学校喂天鹅的故事</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://penge666.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习笔记</title>
    <link href="https://penge666.github.io/posts/f5ef6bcf.html"/>
    <id>https://penge666.github.io/posts/f5ef6bcf.html</id>
    <published>2024-04-29T14:56:09.000Z</published>
    <updated>2024-05-15T12:38:27.656Z</updated>
    
    <content type="html"><![CDATA[<p><strong>时势造英雄，英雄亦造时势</strong></p><p>好文收集</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP</a></li></ul><p>全局认识</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240514215632960.png" alt="image-20240514215632960"></p><h2 id="HTTP">HTTP</h2><h3 id="HTTP发展史">HTTP发展史</h3><ul><li><p>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；</p><p>论文中他确立了三项关键技术</p><ul><li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li><li>HTML：即超文本标记语言，描述超文本文档；</li><li>HTTP：即超文本传输协议，用来传输超文本；</li></ul></li><li><p>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</p><p>请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /mypage.html</span><br></pre></td></tr></table></figure><p>响应</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  这是一个非常简单的 HTML 页面</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</p><ul><li>增加了 HEAD、POST 等新方法；</li><li>增加了响应状态码，标记可能的错误原因；</li><li>引入了协议版本号概念；</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li><li>传输的数据不再仅限于文本。</li></ul></li><li><p>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</p><ul><li>增加了 PUT、DELETE 等新的方法；</li><li>增加了缓存管理和控制；</li><li>明确了连接管理，允许持久连接；</li><li>允许响应数据分块（chunked），利于传输大文件；</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li></ul></li><li><p>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</p><ul><li>二进制协议，不再是纯文本；</li><li>可发起多个请求，废弃了 1.1 里的管道；</li><li>使用专用算法压缩头部，减少数据传输量；</li><li>允许服务器主动向客户端推送数据；</li><li>增强了安全性，“事实上”要求加密通信。</li></ul></li><li><p>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</p></li></ul><h3 id="简单说一下HTTP">简单说一下HTTP</h3><p>（1）<strong>HTTP</strong>：<strong>超⽂本传输协议（HyperText Transfer Protocol），<strong>用于超文本传输，使用</strong>TCP</strong>。</p><p>（2）<strong>超文本</strong>：即<strong>超越了普通文本的文本</strong>，它是⽂字、图⽚、视频等的混合体，具备<strong>超链接</strong>，能从⼀个超⽂本跳转到另外⼀个超⽂本。</p><p>（3）<strong>HTML：超文本标记语言</strong>，是一种标识性的语言。<strong>HTML 文本是由 HTML 命令组成的描述性文本，是最常见的超文本</strong>。</p><p>（4）<strong>URL</strong>：HTTP使用<strong>统一资源定位符</strong>（URL）来标识与定位服务器上的资源，如常见的网址。</p><p>（5） <strong>浏览器</strong>：浏览器（Web Broser），是检索、查看互联网上网页资源的应用程序，是使用 HTTP 协议的<strong>主要载体</strong>。</p><p>（6）<strong>HTTP 协议用于客户端和服务器之间的通信</strong>。用户在客户端使用浏览器，通过点击超链接或者输入URL来获取HTTP服务器上的资源，这些资源通过HTTP协议传送给客户端。</p><p><strong>特点</strong></p><ol><li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li><li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；</li><li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li><li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li><li>HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</li></ol><p><strong>解释无状态</strong></p><p>通俗解释</p><p>First，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。</p><p>Second，浏览器还想要 B 文件，由于无状态，服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。</p><h3 id="URI和URL的区别">URI和URL的区别</h3><p>(1) <strong>URI：统一资源标识符（uniform resource identifier），用来在Web上标识一个资源</strong>。Web上的可用资源，如HTML文档、图像、视频片段、程序等都是用URI来定位的。</p><p>(2) <strong>URL：统一资源定位符（uniform resource locator），它是一种具体的URI</strong>，即URL可以用来<strong>标识一个资源</strong>，而且还指明了如何<strong>定位这个资源</strong>。URL一般由三部组成：</p><ul><li><p><strong>协议(或称为服务方式)</strong></p></li><li><p><strong>存有该资源的主机IP地址(有时也包括端口号)</strong></p></li><li><p><strong>主机资源的具体地址。如目录和文件名等</strong>。</p></li></ul><p>补充：URN：Uniform Resource Name，统一资源名称。</p><p>记住：</p><p>URL 一定是 URI<br>URL + URN 就是 URI</p><ul><li><a href="https://xie.infoq.cn/article/16baba28f0df19d70d00d4604">https://xie.infoq.cn/article/16baba28f0df19d70d00d4604</a></li></ul><h3 id="HTTP-报文和组成格式">HTTP 报文和组成格式</h3><p>(1) HTTP 报文主要由三大部分组成：</p><p>①　<strong>起始行（start line）：<strong>描述请求或响应的</strong>基本信息</strong>；</p><p>②　<strong>头部字段（header）：<strong>使用 key-value 形式</strong>更详细地说明报文</strong>；</p><p>③　<strong>消息正文（entity）</strong>：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</p><p>(2) 其中<strong>起始行和头部字段</strong>并称为<strong>请求头或者响应头</strong>，统称为 <strong>Heade</strong>r；<strong>消息正文</strong>也叫做实体，称为 <strong>body</strong>。</p><p>(3) <strong>HTTP 协议规定每次发送的报文必须要有 Header，但是可以没有 body</strong>，也就是说头部信息是必须的，实体信息可以没有。<strong>而且在 Header 和 body 之间必须要有一个空行（CRLF）。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515105317326.png" alt="image-20240515105317326"></p><p>(4) HTTP有两种报文：<strong>请求报文和响应报文</strong></p><p>请求报文</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515105526308.png" alt="image-20240515105526308"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1     </span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">sec-ch-ua: <span class="string">&quot; Not A;Brand&quot;</span>;v=<span class="string">&quot;99&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;96&quot;</span>, <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;96&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cookie: BIDUPSID=8B0207CE0B6364E5934651E84F17999B; PSTM=1619707475; </span><br></pre></td></tr></table></figure><ol><li><strong>GET / HTTP/1.1</strong>：这是请求行，表示客户端希望使用HTTP/1.1协议，通过GET方法获取服务器根目录(“/”)的资源。</li><li><strong>Host: <a href="https://www.baidu.com/">www.baidu.com</a></strong>：这是请求头的一部分，指定了请求的目标服务器的主机名。</li><li><strong>Connection: keep-alive</strong>：这表示客户端希望服务器保持连接，以便后续请求可以复用这个连接。</li><li><strong>Cache-Control: max-age=0</strong>：这是告诉服务器，客户端不接受超过0秒的响应。【设置缓存用的】</li><li><strong>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</strong>：这表示客户端能接受的响应类型。</li><li><strong>Accept-Encoding: gzip, deflate, br</strong>：表示客户端可以接受的编码类型。</li><li><strong>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</strong>：表示客户端接受的语言类型。</li><li><strong>Cookie: BIDUPSID=8B0207CE0B6364E5934651E84F17999B; PSTM=1619707475</strong>：客户端存储的cookie信息。</li></ol><p>响应报文</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515105542984.png" alt="image-20240515105542984"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Bdpagetype: 1</span><br><span class="line">Bdqid: 0xfb0d743100040ad2</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Date: Fri, 24 Dec 2021 08:20:44 GMT</span><br><span class="line">Expires: Fri, 24 Dec 2021 08:20:44 GMT</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">Set-Cookie: BDSVRTM=17; path=/</span><br><span class="line">Set-Cookie: BD_HOME=1; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=35635_34439_35104_35628_35488_35436_35456_34584_35491_35584_35586_34873_35317_26350_35610_35562; path=/; domain=.baidu.com</span><br><span class="line">Strict-Transport-Security: max-age=172800</span><br><span class="line">Traceid: 1640334044050133761018090243032019634898</span><br><span class="line">X-Frame-Options: sameorigin</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><ul><li><strong>Cache-Control: private</strong>：“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。</li></ul><h3 id="常见的HTTP请求方法">常见的HTTP请求方法</h3><p><strong>必须是大写的形式</strong></p><p>(1) <strong>HTTP请求方法是请求报文的请求行的第一个字段，决定此次请求的类型</strong>。</p><p>(2) HTTP1.0 定义了三种请求方法： <strong>GET, POST 和 HEAD方法</strong>。</p><p>(3) HTTP1.1 新增了六种请求方法：<strong>OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515105937803.png" alt="image-20240515105937803"></p><h3 id="请求方法中的安全与幂等">请求方法中的安全与幂等</h3><p>安全：不会对服务器上的资源造成实质的修改。【GET和HEAD】</p><p>幂等：多次执行相同的操作，结果也都是相同的。</p><p>GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p><p>Note：PUT是幂等，POST 不是。</p><p>POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p><h3 id="常见的HTTP状态码">常见的HTTP状态码</h3><p>(1) <strong>状态码由三位数字组成，第一个数字定义了响应的类别，共分五种类别</strong>:</p><p>①　<strong>1xx：指示信息</strong> – 表示请求已接收，继续下一步处理</p><p>②　<strong>2xx：成功</strong> – 表示请求已成功处理</p><p>③　<strong>3xx：重定向</strong>  –  表示需要更改请求对象</p><p>④　<strong>4xx：客户端错误</strong> – 请求有错误</p><p>⑤　<strong>5xx：服务器端错误</strong> – 服务器未能实现合法的请求</p><p>(2) 下面来说一些比较常见的状态码</p><p>①　<strong>「100 Continue」</strong>：初始的请求已经接受，<strong>客户应当继续发送请求的其余部分</strong></p><p>②　<strong>「200 OK」</strong>： 表示<strong>⼀切正常</strong>。</p><p>③　<strong>「204 No Content」</strong>：也是常见的成功状态码，<strong>但响应头没有 body 数据</strong>。</p><p>④　<strong>「206 Partial Content」</strong>：<strong>应用于 HTTP 分块下载或断点续传</strong>，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</p><p>⑤　<strong>「301 Moved Permanently」</strong>：<strong>表示永久重定向</strong>，说明资源不存在了，需⽤新的URL访问。</p><p>⑥　<strong>「302 Found」</strong>：<strong>表示临时重定向</strong>，说明资源还在，但暂时要用另⼀个URL来访问。</p><p>⑦　<strong>「304 Not Modified」</strong>：<strong>不具有跳转的含义</strong>，表示资源未修改，<strong>重定向已存在的缓冲⽂件</strong>，也称缓存重定向，⽤于缓存控制。</p><p>⑧　<strong>「400 Bad Request」</strong>：<strong>表示客户端请求的报⽂有错误</strong>，但只是个笼统的错误。</p><p>⑨　<strong>「401 Unauthorized」</strong>：该状态码表示发送的<strong>请求需要有认证信息</strong></p><p>⑩　<strong>「403 Forbidden」</strong>：表示<strong>服务器禁⽌访问资源</strong>，并不是客户端的请求出错。</p><p>⑪　<strong>「404 Not Found」</strong>：表示<strong>请求的资源在服务器上不存在或未找到</strong>。</p><p>⑫　<strong>「500 Internal Server Error」</strong>：与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p><p>⑬　<strong>「501 Not Implemented」</strong>：表示<strong>客户端请求的功能还不⽀持</strong>，类似“即将开业，敬请期待”的意思。</p><p>⑭　<strong>「502 Bad Gateway」</strong>：<strong>通常是服务器作为网关或代理时返回的错误码</strong>，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。</p><p>⑮　<strong>「503 Service Unavailable」</strong>：<strong>表示服务器当前很忙</strong>，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。</p><h3 id="HTTP长连接和短连接">HTTP长连接和短连接</h3><p>(1) <strong>在HTTP/1.0中默认使用短连接</strong>。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次TCP连接，任务结束就中断TCP连接。</p><p>(2) <strong>从HTTP/1.1起，默认使用长连接</strong>，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接。</p><p>头部字样：<strong>Connection: keep-alive</strong></p><h3 id="转发和重定向">转发和重定向</h3><ul><li><a href="https://blog.csdn.net/m0_45899013/article/details/106928429#:~:text=%E9%87%8D%E5%AE%9A%E5%90%91%20%28Redirect%29%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95,%E5%B0%86%E5%90%84%E7%A7%8D%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B8%AA%E6%96%B9%E5%90%91%E8%BD%AC%E5%88%B0%E5%85%B6%E5%AE%83%E4%BD%8D%E7%BD%AE%20%EF%BC%88%E5%A6%82%EF%BC%9A%E7%BD%91%E9%A1%B5%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E5%9F%9F%E5%90%8D%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%9A%84%E5%8F%98%E5%8C%96%E4%B9%9F%E6%98%AF%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%BB%8F%E7%94%B1%E8%B7%AF%E5%BE%84%E7%9A%84%E4%B8%80%E7%A7%8D%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%89%E3%80%82">转发和重定向（完整理解及总结）</a></li><li><a href="https://zhuanlan.zhihu.com/p/604721025">面试官：请求转发和请求重定向有什么区别？</a></li></ul><h3 id="说说Cookie和Session">说说Cookie和Session</h3><p>(1) <strong>Cookie</strong>：</p><p>①　由于<strong>HTTP是无状态的</strong>，服务器不会去记忆客户端的状态，所以不需要额外的资源来记录状态信息，这能<strong>减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务</strong>。</p><p>②　<strong>但也因为无状态，服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦</strong>。例如登录-&gt;添加购物⻋-&gt;下单-&gt;结算-&gt;⽀付，这些操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。</p><p>③　<strong>为了解决无状态引起的问题，引入了cookie机制</strong>。Cookie 是在客户端第⼀次请求后，服务器响应报文使用 Set-Cookie 字段发送“key=value”形式的 Cookie 值发送到用户浏览器并保存在本地的一小块数据。它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一客户端。为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 等；</p><p>④　<strong>Cookie的用途</strong>：会话状态管理、用户个性化设置、浏览器行为跟踪。</p><p>⑤　<strong>Cookie的缺点</strong>：每次请求都会需要携带Cookie 数据，因此会带来<strong>额外的性能开销</strong>。Cookie存放在本地浏览器，容易被篡改，<strong>不够安全</strong>。</p><p>(2) <strong>Session</strong>：</p><p>①　<strong>Session和Cookie类似，都是用来存储用户信息</strong>。</p><p>②　<strong>Session 存储在服务器端，通常存储在服务器上的文件、数据库或者内存中</strong>。</p><p>③　<strong>Session以键值对的方式进行存储</strong>，用户信息存储于Session，使用Session ID标识。</p><p>④　<strong>在客户端登录完成之后，服务器会创建对应的session存储用户信息</strong>，然后把Session ID 发送给客户端进行保存。客户端后续访问服务器时会带着Session ID，服务器拿到 Session ID之后，则会在相应的数据中查找，如果找到对应的 session 就可以确认用户信息。</p><p>⑤　<strong>Session的缺点</strong>：所有用户的数据都存放在服务器，容易造成服务器压力过大。</p><h3 id="Cookie和Session的区别">Cookie和Session的区别</h3><p>(1) <strong>存储位置</strong>：Cookie存放在客户端，Session存放在服务端。</p><p>(2) <strong>安全性</strong>：Cookie存放在客户端，容易被篡改，Session存储在服务端，数据比较安全。</p><p>(3) <strong>存储类型</strong>：Cookie只能存放字符串，Session可存放各种数据类型。</p><p>(4) <strong>空间限制</strong>：Cookie大小受限于浏览器，session大小受限于系统内存或者数据库大小。</p><h3 id="Cookie和Session的适应场景">Cookie和Session的适应场景</h3><p>(1) Cookie只能存储字符串，Session则可以存储任何数据，因此<strong>在考虑数据复杂性时首选 Session</strong>。</p><p>(2) Cookie 存储在浏览器中，容易被恶意查看。Session存储在服务端，存储的数据比较安全。因此<strong>考虑数据安全性时首选Session</strong>。</p><p>(3) 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此<strong>不建议将所有的用户信息都存储到 Session 中，应该是两者混用</strong>。</p><h3 id="谈谈代理">谈谈代理</h3><p>代理就是多了个中间人。</p><p><strong>作用</strong></p><ul><li><strong>健康检查</strong>：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；</li><li><strong>安全防护</strong>：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；</li><li><strong>加密卸载</strong>：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；</li><li><strong>数据过滤</strong>：拦截上下行的数据，任意指定策略修改请求或者响应；</li><li><strong>内容缓存</strong>：暂存、复用服务器响应</li></ul><p>代理服务器需要使用字段“Via”标记自己的身份，多个代理会形成一个列表；</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515163313460.png" alt="image-20240515163313460"></p><p>如果想要知道客户端的真实 IP 地址，可以使用字段“X-Forwarded-For”和“X-Real-IP”。</p><h3 id="URL长度限制">URL长度限制</h3><p>(1) <strong>实际上HTTP协议没有对传输的数据大小进行限制，也没有对URL长度进行限制</strong>。</p><p>(2) 对 URL 限制的大多是<strong>浏览器和服务器</strong>。因为处理长URL要消耗比较多的资源，为了考虑性能和安全，两者会对URL长度加限制。</p><h3 id="一个-TCP-连接中多个HTTP-请求可以同时发送吗">一个 TCP 连接中多个HTTP 请求可以同时发送吗</h3><p>(1) <strong>HTTP1.0</strong>不支持。</p><p>(2) <strong>HTTP1.1</strong>可以发送多个HTTP请求，但无法做到同时发送与同时响应。</p><p>(3) <strong>HTTP2.0</strong>完全支持。</p><h3 id="浏览器对同一域名建立的TCP-连接数的限制">浏览器对同一域名建立的TCP 连接数的限制</h3><p>(1) 有。<strong>Chrome 最多允许对同一个 Host 建立六个 TCP 连接</strong>。不同的浏览器有一些区别。</p><p>(2) **建立多个TCP连接的操作常发生在HTTP1.1，**因为不支持多路复用，资源只能顺序加载，这样会导致用户体验不佳，因此常会多开几个TCP连接提升传输速度。</p><h2 id="HTTPS">HTTPS</h2><h3 id="SSL-TLS协议">SSL/TLS协议</h3><p>(1) <strong>HTTP 由于是明⽂传输</strong>，意味着在传输过程中的信息，对外部是完全可见的，因此技术人员可以很方便进行抓包读取数据，为我们调试⼯作带了极⼤的便利性。</p><p>(2) 明文传输所带来的缺陷就是<strong>不安全</strong>。在数据安全上存在以下三个⻛险：</p><p>①　使用明文进行通信，内容可能会被<strong>窃听</strong>；</p><p>②　不验证通信方的身份，通信方的身份有可能遭遇<strong>伪装</strong>；</p><p>③　无法证明报文的完整性，报文有可能遭<strong>篡改</strong>。</p><p>(3) 为了解决这个问题，<strong>在HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议</strong>。后面常将HTTP与SSL/TLS合并称为HTTPS。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515173423396.png" alt="image-20240515173423396"></p><p>(4) <strong>SSL：代表安全套接字层（Secure Sockets Layer）</strong>。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间传输的数据的一个<strong>特殊应用层</strong>。</p><p>(5) <strong>TLS：SSL层所用的协议(SSL 发展到 v3 将其改名为TLS，传输层安全，Transport Layer Security)</strong>，是用来认证用户和服务，加密数据，维护数据的完整性的应用层协议。</p><p>补充：OpenSSL：它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议。</p><h3 id="HTTPS是什么">HTTPS是什么</h3><p><strong>HTTPS 并不是新协议，而是让 HTTP 先和 SSL通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信</strong>。通过使用 SSL，HTTPS 具有了<strong>加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong>。</p><h3 id="加密是什么">加密是什么</h3><p><strong>加密就是对明文数据按某种特殊算法进行处理，使其成为不可读的一段代码</strong>，这段代码被称为**“密文“<strong>。密文可以通过</strong>”密钥“**解密，还原出原来的明文。通过这种方法可以保护数据，不被非法窃取和阅读。</p><h3 id="密钥的类型">密钥的类型</h3><p>(1) <strong>对称密钥</strong>：由一组相同的密钥对组成，<strong>加密和解密使用同一个密钥</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515185517217.png" alt="image-20240515185517217"></p><p>(2) <strong>非对称密钥</strong>：由一组不同的密钥对组成，<strong>加密与解密必须使用不同的密钥</strong>，这两个密钥分别叫做<strong>公钥和私钥</strong>。公钥是可以公开给所有人的，而私钥需要自己保密的。<strong>使用公钥加密的数据只有使用私钥才能解开。使用私钥加密的数据只有使用公钥才能解开。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515185539396.png" alt="image-20240515185539396"></p><p>(3) 实际上私钥不是用来加密的，他是一种<strong>签名手段</strong>，准确的说法应该是 <strong>「私钥签名，公钥验签」</strong>，一般所说的非对称密钥指的是<strong>公钥加密，私钥解密</strong>。</p><h3 id="利用密钥给数据加密">利用密钥给数据加密</h3><p>(1) <strong>对称密钥加密</strong>：使用对称密钥来加密和解密数据【服务器和网站持有同一把钥匙】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515185708745.png" alt="image-20240515185708745"></p><p>①　<strong>优点</strong>：数据加密和解密的运算速度快</p><p>②　<strong>缺点</strong>：通信双方在交换密钥时必须明文通信，无法安全地将密钥传输给对方</p><p>(2) <strong>非对称密钥加密</strong>：使用非对称密钥来加密和解密数据，用公钥进行加密，再用密钥进行解密。</p><p>【服务器原先持有公钥和私钥，现在将公钥给你，然后你用公钥加密发给服务器，服务器再用私钥解开你发的内容】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515185722653.png" alt="image-20240515185722653"></p><p>①　<strong>优点</strong>：由于公钥的公开性，可以安全地将密钥传输给对方。</p><p>②　<strong>缺点</strong>：数据加密和解密的运算速度慢。</p><p>(3) 非对称加密和非对称加密都有一个共同缺点，<strong>它们只能保证通信的内容不会泄漏，即“防窃听”，却没能解决“伪装”和“篡改”</strong>，不能保证通信方的身份有效性。</p><h3 id="HTTPS采用的是对称密钥加密还是非对称密钥加密？">HTTPS采用的是对称密钥加密还是非对称密钥加密？</h3><p>HTTPS采用了<strong>混合加密</strong>，这种加密方式结合了对称密钥加密和非对称密钥加密各自的优点，<strong>保证安全性的前提下让加密解密速度变快</strong>。</p><p>(1) 首先使用一组非对称密钥来加密传输一组对称密钥，来保证传输过程的<strong>安全性</strong>。</p><p>(2) 通信双方再使用对称密钥来加密通信过程中的数据，来保证通信过程的<strong>效率</strong>。</p><p>(3) <strong>混合加密只保证“防窃听”，想解决“伪装”和“篡改”需使用“签名”与“数字签名”</strong>。</p><ol><li>Client发起请求（端口443)【Server中有公钥和私钥,只发送公钥】</li><li>Server返回公钥证书给Client</li><li>Client验证证书</li><li>Client生成对称密钥，用公钥加密后发给Server</li><li>Server使用私钥解密，得到对称密钥</li><li>C/S双方使用对称密钥:</li></ol><ul><li>加密明文并发送</li><li>解密密文得到明文</li></ul><h3 id="签名">签名</h3><p>(1) <strong>签名是一种身份认证机制</strong>，它保证了每一个通信方都拥有自己的专属标签，其他人难以伪造，而且其他人能够验证这个标签，确认它确实属于某一个通信方。</p><p>(2) 签名机制的实现可以用非对称密钥解决，我们可以<strong>用私钥进行签名，再用公钥进行验签</strong>。</p><p>(3) <strong>在通信之前，发送方利用私钥对通信内容加密生成签名，将签名连同通信内容一同发送，对方可利用公钥解密该签名，确保签名的正确性</strong>。</p><p>(4) 由于<strong>私钥的保密性</strong>，其他人无法伪装。又由于<strong>公钥的公开性</strong>，任何一个人都可以通过公钥解开私钥加密的数据来进行身份验证。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515193813500.png" alt="image-20240515193813500"></p><p>缺点</p><p>签名是利用非对称密钥的加密解密来实现的，而非对称密钥的加密解密依赖于复杂的数学运算，当数据量大的时候，计算签名会非常耗时。为了解决这一问题，引入了<strong>摘要和数字签名</strong>。</p><h3 id="摘要">摘要</h3><p>(1) <strong>一段信息，经过摘要算法处理而得到的一串定长的哈希值，就是摘要(dijest)。</strong></p><p>(2) 信息可以是任意长度，而摘要是定长，<strong>摘要算法将无限长的数据映射成有限长的数据。</strong></p><p>(3) 摘要是不可逆转的，它<strong>不存在解密，从摘要反推原信息也很难。</strong></p><p>(4) <strong>原数据如果发生变化，那么计算出来的摘要也会发生变化。如果两个数据算出来的摘要是一样的，说明两个数据是完全相同。</strong></p><h3 id="数字签名">数字签名</h3><p>(1) <strong>数字签名需要先对通信数据生成摘要，再对摘要进行签名运算，得到的签名即数字签名。</strong></p><p>(2) 在通信时，发送方先生成数字签名，将数字签名连同通信内容一同发送，对方可利用公钥解密该数字签名，得到一段摘要。（<strong>如果公钥解密失败，说明对方身份被“伪装”</strong>）</p><p>(3) 第二步则对通信内容使用摘要算法生成摘要（前提是摘要算法公开），与上一段摘要进行比对看是否一致，<strong>可验证内容是否被“篡改”</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515195505420.png" alt="image-20240515195505420"></p><p>【可以理解：就是对原来的文件进行类似md5算法得到一串字符串后用私钥签名，将前面后的文件和签名发给对方，对方用公钥获取md5算法，与原文信息（自己进行运算）一遍，查看是否相等】</p><h3 id="数字签名和签名的不同">数字签名和签名的不同</h3><p>(1) <strong>签名</strong>：直接对通信数据利用私钥生成签名。</p><p>(2) <strong>数字签名</strong>：先对通信数据生成摘要，再对摘要利用私钥生成签名。</p><h3 id="利用混合加密和数字签名是否充分保证了通信安全">利用混合加密和数字签名是否充分保证了通信安全</h3><p>(1) 利用<strong>混合加密</strong>，我们可以对数据进行加密传输，具备**“防窃听”**。</p><p>(2) 利用<strong>数字签名</strong>，我们可以验证对方身份和比对数据完整性，具备**“防篡改”和“防伪装”**。</p><p>(3) 混合加密和数字签名他们都利用了<strong>非对称密钥加密技术</strong>，那么就必须保证一个前提：<strong>某个通信方的公钥能够通过网络安全地传输给对方，而不会被其他人篡改或伪装</strong>。</p><p>(4) 如下所示，在传输公钥这一步没能做到“防篡改”和“防伪装”，导致后续的通信均失败。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515200009081.png" alt="image-20240515200009081"></p><p>(5) 上面提到，<strong>数字签名可以保证“防篡改”和“仿伪装”，但数字签名前提是安全地把公钥传输给对方，这就导致了死锁</strong>，为了解决这个问题，我们引入了**“数字证书”和第三方机构“CA”**。</p><h3 id="CA是什么">CA是什么</h3><p>**数字证书认证机构（CA，Certificate Authority），<strong>是客户端与服务器双方都可信赖的第三方机构，它具备颁布</strong>“数字证书”**的职能。</p><h3 id="数字证书是什么">数字证书是什么</h3><p>(1) <strong>数字证书是一个标志通信方身份信息的数字认证，人们可以在网上用它来识别对方身份。</strong></p><p>(2) <strong>数字证书的制作流程：<strong>某一个通信方向“CA”提出证书申请，“CA”会将</strong>证书的颁布机构、证书有效期、证书持有者的公钥、证书持有者身份</strong>等信息用**“CA”的私钥**进行签名运算，生成签名。之后再将签名和这些信息存放在一起，这就是“数字证书”。</p><p>(3) **数字证书的使用流程：**某一个通信方向“CA”申请一个数字证书，然后将该证书发送给通信对象，对方获取证书后利用“CA”的公钥进行验签，验证通过即可证明对方身份，并且获取对方的公钥，之后就可以利用对方公钥来进行混合加密和数字签名，确保接下来通信过程的安全。</p><p>简单来说，计算机中没有什么东西是加一层不能解决的，如果不能解决，就加2层。</p><h3 id="数字证书的可靠性保证">数字证书的可靠性保证</h3><p>数字证书需要由“CA”颁布，为了证明“CA”是合法的且其数字证书是可靠的，在各个“CA”之间设立了层级关系，**下层“CA”的数字证书是需要上层“CA”签名的，**而最上层的根“CA”的数字证书（根证书）是自签的，<strong>根证书由操作系统和浏览器预装在计算机内部的</strong>。</p><h3 id="数字签名和数字证书的区别">数字签名和数字证书的区别</h3><p>(1) <strong>数字证书本身就包含了数字签名</strong>，数字证书将一些重要数据和对应的数字签名进行打包。</p><p>(2) <strong>数字签名可由任何一方制作，数字证书只能由CA颁布。</strong></p><h3 id="数字证书的使用过程中，CA的公钥能否被伪造">数字证书的使用过程中，CA的公钥能否被伪造</h3><p>(1) **大部分主机内部都预先安装了根证书，**里面记录了可信赖的CA机构信息及其公钥。</p><p>(2) 即使根证书无法使用，<strong>接受方也可进行网上查询对比，判断CA公钥的真实性</strong>。</p><h3 id="说说HTTPS的通信过程">说说HTTPS的通信过程</h3><p>(1) <strong>HTTPS使用了混合加密+数字签名+数字证书的机制。</strong></p><p>(2) **混合加密：**在通信正式开始前，先使用一组非对称密钥来加密传输一组对称密钥，这样双方就获得了一组相同的对称密钥，之后的通信过程都使用对称密钥来加密传输数据，确保数据的机密性，<strong>实现“防窃听”，同时还具有较高的加密解密效率。</strong>【防止被中间人看到】</p><p>(3) <strong>数字签名：<strong>在通信时，先对通信数据生成数字签名，发送数据时连同数字签名一同发送。对方可利用公钥验证该数字签名，得到一段摘要。之后对方也可以对通信内容使用摘要算法生成摘要，对比上一步验签得到的摘要，看是否相同，通过这一步可以实现</strong>“防伪装”和“防篡改”。</strong>【防止信息和发之前的不一样】</p><p>(4) **数字证书：为了确保公钥安全性，**先由某一通信方向“CA”申请数字证书，通信方获得数字证书后发送给通信对象，对方获取证书后利用“CA”的公钥进行验签，<strong>验证通过即可证明对方身份，并且获取对方的公钥，之后的通信就可以利用该公钥完成“混合加密”和“数字签名”</strong>【防止是对方发的】</p><h3 id="HTTPS和HTTP的区别">HTTPS和HTTP的区别</h3><p>(1) HTTPS采用了混合加密+数字签名+数字证书，<strong>安全性更高。</strong></p><p>(2) HTTPS协议需要到“CA”申请数字证书，一般免费证书较少，因而<strong>需要一定费用。</strong></p><p>(3) HTTP和HTTPS使用的端口不一样，<strong>前者是80，后者是443。</strong></p><h3 id="HTTP各版本的特点">HTTP各版本的特点</h3><p>(1) <strong>HTTP1.0</strong>:</p><p>①　<strong>简单、快速、灵活</strong></p><p>②　<strong>短连接：短连接的含义是限制每次连接只处理一个请求</strong>。服务器处理完客户的一次请求后就会断开连接，这种方式比较简单，能节省服务器的资源消耗。</p><p>③　<strong>无状态：无状态是指协议对于事务处理没有记忆能力</strong>，客户端发送HTTP请求后，服务器根据请求响应数据，但它不会记录客户端的信息，无法判断某次请求与上一次请求是否来自同一客户端。</p><p>(2) <strong>HTTP1.1</strong>：</p><p>①　<strong>长连接</strong>：默认持久连接，<strong>只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接</strong>，可以发送多次HTTP请求 。</p><p>②　<strong>管线化</strong>：客户端可以发出多个HTTP请求，<strong>只要前一个请求发送出去之后就可以继续发送第二个请求</strong>，而不用一个个等待响应之后再发送，但是服务器同一时间只能处理一个HTTP请求，后续到达的HTTP请求需要排队等待。</p><p>③　<strong>断点续传</strong>：就是可以将一个大数据，分段传输，客户端可以慢慢显示。</p><p>(3) <strong>HTTP2.0</strong>：</p><p>①　<strong>二进制编码</strong>：HTTP2.0采用二进制格式而非文本格式</p><p>②　<strong>多路复用</strong>：HTTP2.0是完全多路复用的，<strong>客户端可以同时发送多个HTTP请求，服务器也可以同时进行处理</strong>，不用进行排队。</p><p>③　<strong>报头压缩</strong>：HTTP2.0使用报头压缩，降低了头部开销</p><p>④　<strong>推送缓存</strong>：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。</p><p>参考资料：</p><ul><li><a href="https://suqingyu.com/2023/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88HTTP%EF%BC%89%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%80%BB%E7%BB%93/#%E5%89%8D%E6%8F%90%E5%9F%BA%E7%A1%80">计算机网络（HTTP）笔记与总结|</a></li></ul>]]></content>
    
    
    <summary type="html">HTTP协议</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP通信过程</title>
    <link href="https://penge666.github.io/posts/d78d2a72.html"/>
    <id>https://penge666.github.io/posts/d78d2a72.html</id>
    <published>2024-04-29T12:42:02.000Z</published>
    <updated>2024-05-15T12:56:56.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本篇Blog搭建一个“<strong>最小化</strong>”的环境，在这个环境里仅有 HTTP 协议的两个端点：请求方和应答方，去除一切多余的环节，快速掌握 HTTP 的本质。</p><h2 id="环境">环境</h2><p><strong>实验环境</strong></p><ul><li>Wireshark</li><li>Chrome/Firefox</li><li>Telnet</li><li>OpenResty</li></ul><p><strong>简单介绍</strong></p><p>Wireshark是著名的网络抓包工具，能够截获在 TCP/IP 协议栈中传输的所有流量，并按协议类型、地址、端口等任意过滤。</p><p>Telnet是一个经典的虚拟终端，基于 TCP 协议远程登录主机，我们可以使用它来模拟浏览器的行为，连接服务器后手动发送 HTTP 请求，把浏览器的干扰也彻底排除，能够从最原始的层面去研究 HTTP 协议。</p><p>OpenResty是基于 Nginx，利用了 Nginx 模块化、可扩展的特性，开发了一系列的增强模块，并把它们打包整合，形成了一个**“一站式”的 Web 开发平台**。OpenResty 其中一个关键模块是 ngx_lua，它为 Nginx 引入了脚本语言 Lua。</p><p><strong>下载安装</strong></p><p>下载release：<a href="https://github.com/chronolaw/http_study.git">https://github.com/chronolaw/http_study.git</a></p><p>Telnet：打开 Windows 的设置窗口，搜索“Telnet”，就会找到“启用或关闭 Windows 功能”，在这个窗口里找到“Telnet 客户端”，打上对钩。</p><p>OpenResty：<a href="http://openresty.org/">http://openresty.org/</a></p><p>解压在http_study下，并修改成openresty</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">D:.</span><br><span class="line">├─openresty</span><br><span class="line">│  ├─conf</span><br><span class="line">│  ├─html</span><br><span class="line">│  ├─include</span><br><span class="line">│  │  └─luajit-2.1</span><br><span class="line">│  ├─logs</span><br><span class="line">│  ├─lua</span><br><span class="line">│  │  └─jit</span><br><span class="line">│  ├─lualib</span><br><span class="line">│  │  ├─ngx</span><br><span class="line">│  │  │  └─ssl</span><br><span class="line">│  │  ├─redis</span><br><span class="line">│  │  └─resty</span><br><span class="line">│  │      ├─core</span><br><span class="line">│  │      ├─dns</span><br><span class="line">│  │      ├─<span class="built_in">limit</span></span><br><span class="line">│  │      ├─lrucache</span><br><span class="line">│  │      ├─upstream</span><br><span class="line">│  │      └─websocket</span><br><span class="line">│  └─pod</span><br><span class="line">│      ├─array-var-nginx-module-0.06</span><br><span class="line">│      ├─drizzle-nginx-module-0.1.12</span><br><span class="line">│      ├─echo-nginx-module-0.63</span><br><span class="line">│      ├─encrypted-session-nginx-module-0.09</span><br><span class="line">│      ├─form-input-nginx-module-0.12</span><br><span class="line">│      ├─headers-more-nginx-module-0.37</span><br><span class="line">│      ├─iconv-nginx-module-0.14</span><br><span class="line">│      ├─lua-5.1.5</span><br><span class="line">│      ├─lua-cjson-2.1.0.13</span><br><span class="line">│      ├─lua-rds-parser-0.06</span><br><span class="line">│      ├─lua-redis-parser-0.13</span><br><span class="line">│      ├─lua-resty-core-0.1.28</span><br><span class="line">│      ├─lua-resty-dns-0.23</span><br><span class="line">│      ├─lua-resty-limit-traffic-0.09</span><br><span class="line">│      ├─lua-resty-lock-0.09</span><br><span class="line">│      ├─lua-resty-lrucache-0.13</span><br><span class="line">│      ├─lua-resty-memcached-0.17</span><br><span class="line">│      ├─lua-resty-mysql-0.27</span><br><span class="line">│      ├─lua-resty-redis-0.30</span><br><span class="line">│      ├─lua-resty-shell-0.03</span><br><span class="line">│      ├─lua-resty-signal-0.03</span><br><span class="line">│      ├─lua-resty-string-0.15</span><br><span class="line">│      ├─lua-resty-upload-0.11</span><br><span class="line">│      ├─lua-resty-upstream-healthcheck-0.08</span><br><span class="line">│      ├─lua-resty-websocket-0.11</span><br><span class="line">│      ├─lua-tablepool-0.03</span><br><span class="line">│      ├─luajit-2.1</span><br><span class="line">│      ├─luajit-2.1-20231117</span><br><span class="line">│      ├─memc-nginx-module-0.20</span><br><span class="line">│      ├─nginx</span><br><span class="line">│      ├─ngx_coolkit-0.2</span><br><span class="line">│      ├─ngx_devel_kit-0.3.3</span><br><span class="line">│      ├─ngx_lua-0.10.26</span><br><span class="line">│      ├─ngx_lua_upstream-0.07</span><br><span class="line">│      ├─ngx_postgres-1.0</span><br><span class="line">│      ├─ngx_stream_lua-0.0.14</span><br><span class="line">│      ├─opm-0.0.8</span><br><span class="line">│      ├─rds-csv-nginx-module-0.09</span><br><span class="line">│      ├─rds-json-nginx-module-0.16</span><br><span class="line">│      ├─redis-nginx-module-0.3.9</span><br><span class="line">│      ├─redis2-nginx-module-0.15</span><br><span class="line">│      ├─resty-cli-0.30</span><br><span class="line">│      ├─set-misc-nginx-module-0.33</span><br><span class="line">│      ├─srcache-nginx-module-0.33</span><br><span class="line">│      └─xss-nginx-module-0.06</span><br><span class="line">├─python</span><br><span class="line">├─wireshark</span><br><span class="line">└─www</span><br><span class="line">    ├─cache</span><br><span class="line">    ├─conf</span><br><span class="line">    │  ├─http</span><br><span class="line">    │  │  └─servers</span><br><span class="line">    │  ├─ssl</span><br><span class="line">    │  └─ssl_bak</span><br><span class="line">    ├─html</span><br><span class="line">    ├─logs</span><br><span class="line">    ├─lua</span><br><span class="line">    │  └─resty</span><br><span class="line">    ├─mime</span><br><span class="line">    └─temp</span><br></pre></td></tr></table></figure><p>修改C:\WINDOWS\system32\drivers\etc\host文件，添加以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       www.chrono.com</span><br><span class="line">127.0.0.1       www.metroid.net</span><br><span class="line">127.0.0.1       origin.io</span><br></pre></td></tr></table></figure><p>补充：hosts文件的作用</p><p>hosts文件是一个用于储存计算机网络中各节点信息的计算机文件；作用是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址。</p><ul><li>加快域名解析</li><li>构建映射关系</li><li>屏蔽网站或广告</li><li>调试、测试</li></ul><p>在 http_study 的“www”目录下有四个批处理文件，分别是：</p><ul><li>start：启动 OpenResty 服务器；</li><li>stop：停止 OpenResty 服务器；</li><li>reload：重启 OpenResty 服务器；</li><li>list：列出已经启动的 OpenResty 服务器进程。</li></ul><h2 id="实践">实践</h2><p>使用Wireshark抓包。</p><p>抓包结果：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515104056238.png" alt="image-20240515104056238"></p><p>用图示说明</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240515104122463.png" alt="image-20240515104122463"></p><p>总结：</p><ol><li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li><li>浏览器用 TCP 的三次握手与服务器建立连接；</li><li>浏览器向服务器发送拼好的报文；</li><li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li><li>浏览器解析报文，渲染输出页面。</li></ol><p>参考资料：</p><p>《自己动手，搭建HTTP实验环境》</p>]]></content>
    
    
    <summary type="html">最小化观察HTTP通信过程</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://penge666.github.io/posts/51aeee82.html"/>
    <id>https://penge666.github.io/posts/51aeee82.html</id>
    <published>2024-04-27T08:57:46.000Z</published>
    <updated>2024-04-27T13:16:30.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>计算机网络基础，是一名计算机学生必须牢牢掌握的基本功。</p><p>这里安利下斯坦福大学开设的CS144课程，给想进一步了解TCP协议具体实现的小伙伴。</p><p>课程🔗：<a href="https://cs144.github.io/">https://cs144.github.io/</a></p><p>这门课将带你从0到1实现一个属于自己的能在网络上通信的 TCP/IP 协议栈。</p><p>好了，开始基本的知识点梳理~</p><h2 id="TCP和UDP的区别">TCP和UDP的区别</h2><p><strong>UDP头部</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173840722.png" alt="image-20240427173840722"></p><p>字段含义</p><ul><li><p>端口：长度16位，指定发送方所使用的端口号，若不需要对方回发消息，则可全置为0。</p></li><li><p>目的端口：长度16位，指定接收方所使用的端口号。</p></li><li><p>UDP总长度：长度16位，指定了UDP数据报的总长度。</p></li><li><p>校验和：长度16位，用于UDP的差错检测，防止UDP报文出错，同时伪首部参与计算，避免UDP用户数据报传送到错误的目的地。UDP的首部，数据部分，伪首部都会参与检验和的计算，各字段是按照16比特为单位进行计算的，因此数据部分是要保证是16比特的倍数，不够用0填充。</p></li></ul><p><strong>TCP头部</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173903612.png" alt="image-20240427173903612"></p><p>字段含义</p><ul><li><p>16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序。</p></li><li><p>32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</p></li><li><p>32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</p></li><li><p>4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</p></li><li><p>6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）。</p></li><li><p>16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p></li><li><p>16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</p></li><li><p>16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</p></li></ul><p><strong>区别</strong></p><ul><li><p>TCP<strong>面向连接</strong>；UDP是无连接的，即发送数据之前不需要建立连接。</p></li><li><p>TCP提供<strong>可靠的服务</strong>；UDP不保证可靠交付。</p></li><li><p>TCP<strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP是面向报文的。</p></li><li><p>TCP有<strong>拥塞控制</strong>；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</p></li><li><p>每一条TCP连接只能是<strong>点到点</strong>的；UDP支持一对一、一对多、多对一和多对多的通信方式。</p></li><li><p>TCP首部开销20字节；UDP的首部开销小，只有8个字节。</p></li></ul><p><strong>常见的应用协议</strong></p><p>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</p><ul><li><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口80</li><li><strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)</li><li><strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25</li><li><strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口23</li><li><strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22</li></ul><p>基于UDP的应用层协议：DNS、TFTP、SNMP</p><ul><li><strong>DNS</strong> : Domain Name Service (域名服务),默认端口 53</li><li><strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69</li><li><strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。</li></ul><blockquote><p><strong>TCP是如何确保可靠性的呢？</strong></p></blockquote><ul><li>首先，TCP的连接是基于<strong>三次握手</strong>，而断开则是基于<strong>四次挥手</strong>。确保连接和断开的可靠性。</li><li>其次，TCP的可靠性，还体现在<strong>有状态</strong>;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li><li>再次，TCP的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK应答、<strong>超时重传(发送方)</strong>、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</li></ul><h2 id="TCP的三次握手">TCP的三次握手</h2><p>假设发送端为客户端，接收端为服务端。</p><p>开始时客户端和服务端的状态都是<code>CLOSED</code></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427171700576.png" alt="image-20240427171700576"></p><ul><li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位<code>SYN=1</code>，序列号<code>seq=x</code>。第一次握手前客户端的状态为<code>CLOSE</code>，第一次握手后客户端的状态为<code>SYN-SENT</code>。此时服务端的状态为<code>LISTEN</code>。</li><li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位<code>SYN=1</code>，<code>ACK=1</code>，序列号<code>seq=y</code>，确认号<code>ack=x+1</code>。第二次握手前服务端的状态为<code>LISTEN</code>，第二次握手后服务端的状态为<code>SYN-RCVD</code>，此时客户端的状态为<code>SYN-SENT</code>。（其中<code>SYN=1</code>表示要和客户端建立一个连接，<code>ACK=1</code>表示确认序号有效）。</li><li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位<code>ACK=1</code>，序列号<code>seq=x+1</code>，确认号<code>ack=y+1</code>。第三次握手前客户端的状态为<code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为<code>ESTABLISHED</code>。<strong>此时连接建立完成。</strong></li></ul><blockquote><p><strong>两次握手可以吗？</strong></p></blockquote><p>防止重复连接</p><ul><li>三次握手的主要原因是为了防止旧的重复连接引起连接混乱问题。</li><li>比如在网络状况比较复杂或者网络状况比较差的情况下，发送方可能会连续发送多次建立连接的请求。</li><li>如果 TCP 握手的次数只有两次，那么接收方只能选择接受请求或者拒绝接受请求，但它并不清楚这次的请求是正常的请求，还是由于网络环境问题而导致的过期请求，如果是过期请求的话就会造成错误的连接。</li><li>所以如果 TCP 是三次握手的话，那么客户端在接收到服务器端 SEQ+1 的消息之后，就可以判断当前的连接是否为历史连接，如果判断为历史连接的话就会发送终止报文（RST）给服务器端终止连接；如果判断当前连接不是历史连接的话就会发送指令给服务器端来建立连接。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427172057128.png" alt="image-20240427172057128"></p><h2 id="TCP的四次挥手">TCP的四次挥手</h2><p>客户端A发完数据，要关闭连接。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427172134551.png" alt="image-20240427172134551"></p><ol><li>A的应用进程先向其TCP发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭TCP连接，进入<code>FIN-WAIT-1</code>（终止等待1）状态，等待B的确认。</li><li>B收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B进入<code>CLOSE-WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li><li>A收到B的确认后，进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待B发出的连接释放报文段。</li><li>B发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B进入<code>LAST-ACK</code>（最后确认）状态，等待A的确认。</li><li>A收到B的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A进入<code>TIME-WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>（最大报文段生存时间）后，A才进入<code>CLOSED</code>状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。</li></ol><blockquote><p><strong>什么TIME_WAIT状态？</strong></p></blockquote><p>TIME-WAIT状态指的是第四次挥手后，主动中断连接方所处的状态，这个状态下，主动方尚未完全关闭TCP连接，端口不可复用。</p><blockquote><p><strong>为什么TIME-WAIT状态需要等待2MSL?</strong></p></blockquote><ul><li><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个<code>ACK</code>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在<code>2MSL</code>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到<code>CLOSED</code>状态，若A在<code>TIME-WAIT</code>状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到<code>CLOSED</code>状态。</li><li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个<code>ACK</code>报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li></ul><h2 id="TCP的状态转换图">TCP的状态转换图</h2><p>状态转换图几乎出现在每一本有关TCP的教材中，可谓是经典中的经典。</p><p>TCP通信过程包括三个步骤：建立TCP连接通道（三次握手）、数据传输、断开TCP连接通道（四次挥手）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427171057056.png" alt="image-20240427171057056"></p><p>而整个过程可以表示成<strong>TCP状态状态转换图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427171502114.png" alt="image-20240427171502114"></p><p>详细学习这篇内容：<a href="https://www.coonote.com/tcpip/tcpip-tutorial.html">TCP/IP 教程</a></p><h2 id="TCP的滑动窗口机制">TCP的滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。</p><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427172810673.png" alt="image-20240427172810673"></p><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h2 id="TCP拥塞控制">TCP拥塞控制</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173017396.png" alt="image-20240427173017396"></p><p><strong>慢开始</strong></p><p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p><p>当 cwnd &lt; ssthresh 时，使用慢开始算法。</p><p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p><p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p><strong>拥塞避免</strong></p><p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p><strong>快重传</strong></p><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p><p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p><h2 id="其他">其他</h2><h3 id="粘包">粘包</h3><p>粘包指TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p><strong>Note</strong>:只有UDP协议不存在粘包。这是由于UDP有消息保护边界，不会发生粘包拆包问题。</p><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><ul><li><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p></li><li><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p></li></ul><p>粘包和拆包示意图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173217720.png" alt="image-20240427173217720"></p><p>上图中演示了以下几种情况：</p><ul><li>正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；</li><li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；</li><li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；</li><li>拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。</li></ul><p><strong>解决办法</strong>：</p><ul><li>发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li><li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li><li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>通过自定义协议进行粘包和拆包的处理。</li></ul><h3 id="SYN-flood攻击">SYN-flood攻击</h3><p>SYN 洪泛攻击 (SYN flood attack)</p><p>原理</p><ul><li>利用三次握手的过程漏洞</li><li>大量发送第一次握手（假IP)的报文</li><li>攻击方忽略第二次握手的报文</li><li>被攻击方多个TCP连接处于(SYNC-RCVD)阶段，耗费大量资源</li><li>最终因为资源耗尽，拒绝服务(DoS)</li></ul><h2 id="参考资料">参考资料</h2><ul><li><a href="https://joytsing.cn/posts/42952/#toc-heading-2">TCP协议中三次握手和四次挥手</a></li><li><a href="https://www.coonote.com/tcpip/tcpip-tutorial.html">TCP/IP 教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/356225028">面试题：聊聊TCP的粘包、拆包以及解决方案</a></li></ul>]]></content>
    
    
    <summary type="html">通俗易懂理解TCP协议</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP队头阻塞</title>
    <link href="https://penge666.github.io/posts/9b06a28b.html"/>
    <id>https://penge666.github.io/posts/9b06a28b.html</id>
    <published>2024-04-27T05:20:46.000Z</published>
    <updated>2024-04-27T13:17:14.272Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自：<a href="https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/">Head-of-Line Blocking in QUIC and HTTP/3: The Details</a></p><p>您可能已经听说，经过4年的工作，新的 HTTP/3 和 QUIC 协议终于接近正式标准化。预览版现在可以在服务器和浏览器中进行测试。</p><p>与 HTTP/2 相比，HTTP/3 有很大的性能改进，这主要是因为它将底层传输协议从 TCP 改为基于 UDP 的 QUIC。在这篇文章中，我们将深入了解其中的一项改进，即<strong>消除队头阻塞</strong>（Head-of-Line blocking, 简写：HOL blocking）问题。这很有用，因为我读过很多关于这实际上意味着什么以及它在现实中有多大帮助的误解。解决队头阻塞也是 HTTP/3 和 QUIC 以及 HTTP/2 背后的主要动机之一，因此它也为协议演进的原因提供了一个极好的视角。</p><p>我将首先介绍队头阻塞问题，然后在整个 HTTP 历史中跟踪它的不同形式。我们还将研究它如何与其他系统交互，如优先级和拥塞控制。我们的目标是帮助人们对 HTTP/3 的性能改进做出正确的判断，而这（剧透）可能不像营销材料中所说的那样令人惊讶。</p><p><strong>目录：</strong></p><ol><li>什么是队头阻塞？</li><li>HTTP/1.1 的队头阻塞</li><li>HTTP/2（基于 TCP）的队头阻塞</li><li>HTTP/3（基于 QUIC）的队头阻塞</li><li>总结与结论</li></ol><p><strong>彩蛋内容：</strong></p><ul><li>彩蛋：HTTP/1.1 管道</li><li>彩蛋：TLS 队头阻塞</li><li>彩蛋：传输拥堵控制</li><li>彩蛋：多路复用是否重要？</li></ul><h2 id="什么是队头阻塞（Head-of-Line-blocking）？">什么是队头阻塞（<strong>Head-of-Line blocking</strong>）？</h2><p>很难给你一个单一的队头阻塞（HOL blocking）的技术定义，因为这篇博客文章单独描述了它的四个不同变体。然而，一个简单的定义是：</p><blockquote><p>当单个（慢）对象阻止其他/后续的对象前进时</p></blockquote><p>现实生活中一个很好的比喻就是只有一个收银台的杂货店。一个顾客买了很多东西，最后会耽误排在他后面的人，因为顾客是以先进先出（First In, First Out）的方式服务的。另一个例子是只有单行道的高速公路。在这条路上发生一起车祸，可能会使整个通道堵塞很长一段时间。因此，即使是在“头部（head）”一个单一的问题可以“阻塞（block）”整条“线（line）”。</p><p>这个概念一直是最难解决的 Web 性能问题之一。为了理解这一点，让我们从 HTTP/1.1 开始讲起。</p><h2 id="HTTP-1-1-的队头阻塞">HTTP/1.1 的队头阻塞</h2><p>HTTP/1.1是一种更简单的协议。一个协议仍然可以基于文本并在网络上可读的时代。如下图1所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132357401.png" alt="image-20240427132357401"></p><center>图1：服务器 HTTP/1.1 响应 script.js</center><p>在本例中，浏览器基于 HTTP/1.1上 请求简单的<code>script.js</code>文件（绿色），图1显示了服务器对该请求的响应。我们可以看到 HTTP 方面本身很简单：它只是在明文文件内容或“有效荷载”（payload）前面直接添加一些文本“headers”（红色）。然后，头（Headers）+ 有效荷载（payload）被传递到底层 TCP（橙色），以便真实传输到客户端。对于这个例子，假设我们不能将整个文件放入一个 TCP 包中，并且必须将它分成两部分。</p><p><em>注意：实际上，当使用 HTTPS 时，HTTP 和 TCP 之间有另一个安全层，通常使用 TLS 协议。不过，为了清晰起见，我们在这里省略了这一点。我在结尾加入了一个额外的彩蛋部分，详细说明了 TLS 特定的队头阻塞变体以及 QUIC 如何避免它。阅读完正文后，请随意阅读它（以及其他的彩蛋部分）。</em></p><p>现在让我们看看当浏览器也请求<code>style.css</code>时发生了什么，如图2：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132410754.png" alt="image-20240427132410754"></p><center>图2：服务器 HTTP/1.1 响应 script.js 和 sytle.css</center><p>在本例中，当<code>script.js</code>的响应传输之后，我们发送<code>style.css</code>（紫色）。<code>style.css</code>的头部（headers）和内容只是附加在 JavaScript（JS）文件之后。接收者使用<strong>Content-Length</strong> header 来知道每个响应的结束位置和另一个响应的开始位置（在我们的简化示例中，<code>script.js</code>是1000字节，而<code>style.css</code>只有600字节）。</p><p>在这个包含两个小文件的简单示例中，所有这些似乎都很合理。但是，假设 JS 文件比 CSS 大得多（比如说 1MB 而不是 1KB）。这种情况下，在下载整个JS文件之前，CSS 必须等待，尽管它要小得多，其实可以更早地解析/使用。更直接地将其可视化，使用数字 1 表示<code>large_script.js</code>和 2 表示<code>style.css</code>，我们会得到这样的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111111111111122</span><br></pre></td></tr></table></figure><p>你可以看到这是一个队头阻塞问题的例子！现在你可能会想：这很容易解决！只需让浏览器在JS文件之前请求CSS文件！然而，至关重要的是，浏览器无法预先知道这两个文件中的哪一个在请求时会成为更大的文件。这是因为没有办法在HTML中指明文件有多大（类似这样的东西很不错，HTML工作组：<code>&lt;img src=&quot;thisisfine.jpg&quot; size=&quot;15000&quot; /&gt;</code>）。</p><p>这个问题的“真正”解决方案是采用<strong>多路复用（multiplexing）</strong>。如果我们可以将每个文件的有效荷载（header）分成更小的片（pieces）或“块”（chunks），我们就可以在网络上混合或“交错”（interleave）这些块：为 JS 发送一个块，为 CSS 发送一个块，然后再发送另一个用于 JS，等等，直到文件被下载为止。使用这种方法，较小的CSS文件将更早地下载（并且可用），同时只将较大的JS文件延迟一点。用数字形象化我们会得到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12121111111111111111111111111111111111111</span><br></pre></td></tr></table></figure><p>然而不幸的是，由于协议存在一些基础的限制，这种多路复用在 HTTP/1.1 中是不可能的。为了理解这一点，我们甚至不需要继续查看大资源对小资源（large-vs-small）场景，因为它已经在我们的示例中显示了两个较小的文件。如图3，我们只为两个资源交错4个块：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427211652242.png" alt="image-20240427211652242"></p><center>图3：服务器 HTTP/1.1 多路复用 script.js 和 style.css</center><p>这里的主要问题是 HTTP/1.1 是一个纯文本协议，它只在有效荷载（payload）的前面附加头（headers）。它不会进一步区分单个（大块）资源与其他资源。让我们用一个例子来说明这一点，如果我们尝试了它会发生什么。在图3中，浏览器开始分析<code>script.js</code>并期望后面有1000个字节（Content-Length）的有效荷载。但是，它只接收450个 JS 字节（第一个块），然后开始读取<code>sytle.css</code>的头部。它最终将 CSS 头部和第一个 CSS 块解释为JS的一部分，因为这两个文件的有效荷载和头都是纯文本。更糟糕的是，它在读取1000个字节后停止，直到第二个<code>script.js</code>块的一半。此时，它看不到有效的新报头，必须删除 TCP 数据包3（packet 3）的其余部分。然后浏览器传递它认为的内容<code>script.js</code>到JS解析器，它失败了因为不是有效的 JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">600</span></span><br><span class="line"></span><br><span class="line">.<span class="property">h1</span> &#123; font-<span class="attr">size</span>: 4em; &#125;</span><br><span class="line">func</span><br></pre></td></tr></table></figure><p>同样，您可以说有一个简单的解决方案：让浏览器查找<code>HTTP/1.1 &#123;statusCode&#125; &#123;statusString&#125;\n</code>模式来查看新的头块何时开始。这可能适用于 TCP 数据包2（packet 2），但在数据包3（packet 3）中会失败：浏览器如何知道绿色的<code>script.js</code>块在哪里结束和紫色<code>style.css</code>块从哪里开始？</p><p>这是 HTTP/1.1 协议设计方式的一个基础限制。如果您只有一个 HTTP/1.1 连接，那么在您切换到发送新资源之前，必须<strong>完整地</strong>传输资源响应。如果前面的资源创建缓慢（例如，从数据库查询动态生成的<code>index.html</code>）或者，如上所述，如果前面的资源很大。这些问题可能会引起队头阻塞问题。</p><p>这就是为什么浏览器开始为 HTTP/1.1 上的每个页面加载<a href="https://link.zhihu.com/?target=http%3A//www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">打开多个并行 TCP 连接</a>（通常为6个）。这样，请求可以分布在这些单独的连接上，并且不再有队头阻塞。也就是说，除非每页有超过6个资源…这当然是很常见的。这就是在多个域名上“分片”（sharding）资源的实践(<a href="https://link.zhihu.com/?target=http%3A//img.mysite.com/">img.mysite.com</a>, <a href="http://static.mysite.com">static.mysite.com</a>, 等）和 CDN 的由来。由于每个单独的域名有6个连接，浏览器将为每个页面加载总共打开 30-ish 个 TCP 连接。这是可行的，但有相当大的开销：建立一个新的 TCP 连接可能是昂贵的（例如在服务器上的状态和内存方面，以及设置 TLS 加密的计算），并且需要消耗一些时间（特别是对于 HTTPS 连接，因为 TLS 需要自己的握手）。</p><p>由于这个问题不能用 HTTP/1.1 解决，而且并行 TCP 连接的补丁解决方案也不能随着时间的推移扩展得太好，很明显需要一种全新的方法，这就是后来的 HTTP/2。</p><p><em>注意：阅读本文的老哥可能会表示想知道 HTTP/1.1 管道（pipelining）。我决定不在这里讨论这一点，以保持整个故事的流畅性，但对更深入的技术感兴趣的人可以阅读结尾的彩蛋部分。</em></p><h2 id="HTTP-2（基于-TCP）的队头阻塞"><strong>HTTP/2（基于 TCP）的队头阻塞</strong></h2><p>那么，让我们回顾一下。HTTP/1.1 有一个队头阻塞问题，一个大的或慢的响应会延迟后面的其他响应。这主要是因为协议本质上是纯文本的，在资源块（resource chunks）之间不使用分隔符。作为一种解决办法，浏览器打开许多并行TCP连接，这既不高效，也不可扩展。</p><p>因此，HTTP/2 的目标非常明确：<strong>我们能够回到单个 TCP 连接，解决队头阻塞问题</strong>。换一种说法：我们希望能够正确地复用资源块（resource chunks）。这在 HTTP/1.1 中是不可能的，因为没有办法分辨一个块属于哪个资源，或者它在哪里结束，另一个块从哪里开始。HTTP/2 非常优雅地解决了这一问题，它在资源块之前添加了<strong>帧（frames）</strong>。如图4所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132443159.png" alt="image-20240427132443159"></p><center>图4：HTTP/1.1 vs HTTP/2 响应 script.js</center><p>HTTP/2 在每个块前面放置一个所谓的数据帧（DATA frame）。这些数据帧主要包含两个关键的元数据。首先：下面的块属于哪个资源。每个资源的“字节流（bytestream）”都被分配了一个唯一的数字，即<strong>流id（stream id）</strong>。第二：块的大小是多少。协议还有许多其他帧类型，图5也显示了头部帧（HEADERS frame）。这再次使用流id（stream id）来指出这些头（headers）属于哪个响应，这样甚至可以将头（headers）从它们的实际响应数据中分离出来。</p><p>使用这些帧，HTTP/2 确实允许在一个连接上正确地复用多个资源，参见图5：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132510915.png" alt="image-20240427132510915"></p><center>图5：HTTP/2 多路复用响应 script.js 和 style.css</center><p>与图3中的示例不同，浏览器现在可以完美地处理这种情况。它首先处理<code>script.js</code>的头部帧（HEADERS frame），然后是第一个JS块的数据帧（DATA frame）。从数据帧（DATA frame）中包含的块长度来看，浏览器知道它只延伸到 TCP 数据包1的末尾，并且需要从 TCP 数据包2开始寻找一个全新的帧。在那里它确实找到了<code>style.css</code>的头（HEADERS）， 下一个数据帧（DATA frame）含有与第一个数据帧（1）不同的流 id（2），因此浏览器知道这属于不同的资源。同样的情况也适用于 TCP 数据包3，其中数据帧（DATA frame）流 id 用于将响应块“解复用”（de-multiplex）到正确的资源“流”（streams）。</p><p>因此，通过“framing”单个消息，HTTP/2 比 HTTP/1.1 更加灵活。它允许在单个 TCP 连接上通过交错排列块来多路传输多个资源。它还解决了第一个资源缓慢时的队头阻塞问题：而不必等待查询数据库生成的<code>index.html</code>，服务器可以在等待<code>index.html</code>时开始发送其他资源。</p><p>HTTP/2 的方式一个重要结果是，我们突然需要一种方法让浏览器与服务器通信，单个连接的带宽如何跨资源分布（distributed）。换一种说法：资源块应该如何“调度（scheduled）”或交错（interleaved）。如果我们再次用 1 和 2 来表示，我们会发现对于 HTTP/1.1，唯一的选项是11112222（我们称之为顺序的（sequential））。然而， HTTP/2 有更多的自由：</p><ul><li>公平多路复用（例如两个渐进的 JPEGs）：12121212</li><li>加权多路复用（2是1的两倍）：22122122121</li><li>反向顺序调度（例如2是密钥服务器推送的资源）：22221111</li><li>部分调度（流1被中止且未完整发送）：112222</li></ul><p>使用哪种方法是由 HTTP/2 中所谓的“优先级（prioritization）”系统驱动的，所选择的方法对Web 性能有很大的影响。然而，这本身就是一个非常复杂的话题，你不需要在接下来的博客文章中理解它，所以我不把它放在这里讲了。</p><p>我想您会同意，通过 HTTP/2 的帧（frames）及其优先级设置，它确实解决了 HTTP/1.1 的队头阻塞问题。这意味着我在这里的工作完成了，我们都可以回家了。对吗？好吧，没那么简单。我们已经解决了 HTTP/1.1 的队头阻塞，是的，但是 TCP 的队头阻塞呢？</p><h2 id="TCP-队头阻塞">TCP 队头阻塞</h2><p>事实证明，HTTP/2 只解决了 HTTP 级别的队头阻塞，我们可以称之为“应用层”队头阻塞。然而，在典型的网络模型中，还需要考虑下面的其他层。您可以在图6中清楚地看到这一点：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132530740.png" alt="image-20240427132530740"></p><center>图6：典型网络模型中的几个协议层</center><p>HTTP 位于顶层，但首先由安全层的 TLS 支持（请参阅“彩蛋 TLS”部分），然后接着再由传输层的 TCP 传输。这些协议中的每一层都用一些元数据包装来自其上一层的数据。例如，在我们的 HTTP(S) 数据中预先加上 TCP 包头（packet header），然后将其放入 IP 包等，这样就可以在协议之间实现相对简洁的分离。这反过来又有利于它们的可重用性：像 TCP 这样的传输层协议不必关心它正在传输什么类型的数据（可以是 HTTP，也可以是 FTP，也可以是 SSH，谁知道呢），而且 IP 对于 TCP 和 UDP 都能很好地工作。</p><p>然而，如果我们想将多个 HTTP/2 资源多路传输到一个 TCP 连接上，这确实会产生重要的后果。如图7：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132541483.png" alt="image-20240427132541483"></p><center>图7：HTTP/2 和 TCP 在透视图上的差异</center><p>虽然我们和浏览器都知道我们正在获取 JavaScript 和 CSS 文件，但 HTTP/2 不需要知道这一点。它只知道它在使用来自不同资源流 id （stream id）的块。然而，**TCP 甚至不知道它在传输 HTTP！**TCP 所知道的就是它被赋予了一系列字节，它必须从一台计算机传输另一台计算机。为此，它使用特定最大大小（maximum size）的数据包，通常大约为1450字节。每个数据包只跟踪它携带的数据的那一部分（字节范围），这样原始数据就可以按照正确的顺序重建。</p><p>换言之，这两个层之间的透视图是不匹配的：HTTP/2 可以看到多个独立的资源字节流（bytestream），而 TCP 只看到一个不透明的字节流（bytestreams）。图7的TCP数据包3就是一个例子：TCP 只知道它正在传输的任何内容的字节 750 到字节1 599。另一方面，HTTP/2 知道数据包3中实际上有两个独立资源的两个块。<em>（注意：实际上，每个 HTTP/2 帧（如 DATA 和 HEADERS）的大小也有几个字节。为了简单起见，我没有计算额外的开销或这里的 HEADERS 帧，以使数字更直观。）</em></p><p>所有这些看起来都是不必要的细节，直到你意识到互联网是一个根本不可靠的网络。在从一个端点到另一个端点的传输过程中，数据包会丢失和延迟。TCP 的可靠性正是其最受欢迎的原因之一。它只需重<strong>新传输丢失数据包的副本</strong>就可以做到这一点。</p><p>我们现在可以理解传输层是如何导致队头阻塞的。再次思考下图7并问自己：如果 TCP 数据包2在网络中丢失，但数据包1和数据包3已经到达，会发生什么情况？请记住，TCP并不知道它正在承载 HTTP/2，只知道它需要按顺序传递数据。因此，它知道数据包1的内容可以安全使用，并将这些内容传递给浏览器。然而，它发现数据包1中的字节和数据包3中的字节（放数据包2 的地方）之间存在间隙，因此还不能将数据包3传递给浏览器。TCP 将数据包3保存在其接收缓冲区（receive buffer）中，直到它接收到数据包2的重传副本（这至少需要往返服务器一次），之后它可以按照正确的顺序将这两个数据包都传递给浏览器。换个说法：<strong>丢失的数据包2 队头阻塞（HOL blocking）数据包3！</strong></p><p>您可能不清楚为什么这是个问题，所以让我们更深入地研究图7中 HTTP 层的 TCP 包中的实际内容。我们可以看到，TCP 数据包2只携带流id 2（CSS文件）的数据，数据包3同时携带流1（JS文件）和流2的数据。在 HTTP 级别，我们知道这两个流是独立的，并且由数据帧（DATA frame）清楚地描述出来。因此，理论上我们可以完美地将数据包3传递给浏览器，而不必等待数据包2到达。浏览器将看到流id为1的数据帧，并且能够直接使用它。只有流2必须被挂起，等待数据包2的重新传输。这将比我们从 TCP 的方式中得到的效率更高，TCP 的方式最终会阻塞流1和流2。</p><p>另一个例子是数据包1丢失，但是接收到2和3的情况。TCP将再次阻止数据包2和3，等待1。但是，我们可以看到，在HTTP/2级别，流2的数据（CSS文件）完全存在于数据包2和3中，不必等待数据包1的重新传输。浏览器本可以完美地解析/处理/使用 CSS 文件，但却被困在等待 JS 文件的重新传输。</p><p>总之，TCP 不知道 HTTP/2 的独立流（streams）这一事实意味着 <strong>TCP 层队头阻塞（由于丢失或延迟的数据包）也最终导致 HTTP 队头阻塞！</strong></p><p>现在，您可能会问自己：那重点是什么？如果我们仍然有 TCP 队头阻塞，为什么还要使用HTTP/2 呢？好吧，主要原因是虽然数据包丢失确实发生在网络上，但还是比较少见的。特别是在有线网络中，包丢失率只有 0.01%。即使是在最差的蜂窝网络上，在现实中，您也很少看到丢包率高于2%。这与数据包丢失和抖动（网络中的延迟变化）通常是<strong>突发性</strong>的这一事实结合在一起的。包丢失率为2%并不意味着每100个包中总是有2个包丢失（例如数据包 42 和 96）。实际上，可能更像是在总共500个包中丢失10个<strong>连续的</strong>包（例如数据包255到265）。这是因为数据包丢失通常是由网络路径中的路由器内存缓冲区暂时溢出引起的，这些缓冲区开始丢弃无法存储的数据包。不过，细节在这里并不重要。重要的是：是的，TCP 队头阻塞是真实存在的，但是它对 Web 性能的影响要比HTTP/1.1 队头阻塞小得多，HTTP/1.1 队头阻塞几乎可以保证每次都会遇到它，而且它也会受到 TCP 队头阻塞的影响！</p><p>然而，当比较单个连接上的 HTTP/2 和单个连接上的 HTTP/1.1 时，这个基本上是真的。正如我们之前所看到的，实际上它并不是这样工作的，因为 HTTP/1.1 通常会打开多个连接。这使得 HTTP/1.1 不仅在一定程度上减轻了 HTTP 级别，而且减轻了 TCP 级别的队头阻塞。因此，在某些情况下，单个连接上的 HTTP/2 很难比6个连接上的 HTTP/1.1 快，甚至与 HTTP/1.1 一样快。这主要是由于 TCP 的**“拥塞控制”（congestion control）**机制。然而，这是另一个非常深入的话题，并不是我们讨论队头阻塞（HOL blocking）的核心，所以我把它移到了末尾的另一个彩蛋部分。</p><p>总之，事实上，我们看到（也许出乎意料），<strong>HTTP/2 目前部署在浏览器和服务器中，在大多数情况下通常与 HTTP/1.1 一样快或略快</strong>。在我看来，这部分是因为网站在优化 HTTP/2 方面做得更好，部分原因是浏览器仍然经常打开多个并行 HTTP/2 连接，从而使两者兼得。</p><p>然而，也有一些情况（特别是在数据包丢失率较高的低速网络上），6个连接的 HTTP/1.1 仍然比一个连接的 HTTP/2 更为出色，这通常是由于 TCP 级别的队头阻塞问题造成的。正是这个事实极大地推动了新的 QUIC 传输协议的开发，以取代 TCP。</p><h2 id="HTTP-3（基于-QUIC）的队头阻塞">HTTP/3（基于 QUIC）的队头阻塞</h2><p>在那之后，我们终于可以开始谈论新的东西了！但首先，让我们总结一下我们目前所学到的：</p><ul><li>HTTP/1.1 有队头阻塞，因为它需要完整地发送响应，并且不能多路复用它们</li><li>HTTP/2 通过引入“帧”（frames）标识每个资源块属于哪个“流”（stream）来解决这个问题</li><li>然而，TCP 不知道这些单独的“流”（streams），只是把所有的东西看作一个大流（1 big stream）</li><li>如果一个 TCP 包丢失，所有后续的包都需要等待它的重传，即使它们包含来自不同流的无关联数据。TCP 具有传输层队头阻塞。</li></ul><p>我敢肯定你现在可以预测我们如何解决 TCP 的问题，对吧？毕竟，解决方案很简单：我们“只是”需要<strong>让传输层知道不同的、独立的流</strong>！这样，如果一个流的数据丢失，传输层本身就知道它不需要阻塞其他流。</p><p>尽管这个解决方案概念简单，但在现实中却很难实现。由于各种原因，不可能改变 TCP 本身使其具有流意识（stream-aware）。选择的替代方法是以 QUIC 的形式实现一个全新的传输层协议。为了使 QUIC 现实中可以部署在因特网上，它运行在不可靠的 UDP 协议之上。然而，非常重要的是，这并不意味着 QUIC 本身也是不可靠的！在许多方面，QUIC 应该被看作是一个 TCP 2.0。它包括 TCP 的所有特性（可靠性、拥塞控制、流量控制、排序等）的最佳版本，以及更多其他特性。QUIC还完全集成了TLS（参见图6），并且不允许未加密的连接。因为 QUIC 与 TCP 如此不同，这也意味着我们不能仅仅在其上运行 HTTP/2，这就是为什么创建了 HTTP/3（稍后我们将详细讨论这个问题）。这篇博文已经足够长了，不需要更详细地讨论QUIC，因此我将只关注我们需要了解当前队头阻塞讨论的几个部分。如图8所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132618174.png" alt="image-20240427132618174"></p><center>图8：HTTP/1.1 vs HTTP/2 vs HTTP/3 响应 script.js</center><p>我们观察到，让 QUIC 知道不同的流（streams）是非常简单的。QUIC 受到 HTTP/2 帧方式（framing-approach）的启发，还添加了自己的帧（frames）；在本例中是流帧（STREAM frame）。流id（stream id）以前在 HTTP/2 的数据帧（DATA frame）中，现在被<strong>下移到传输层的 QUIC 流帧（STREAM frame）中</strong>。这也说明了如果我们想使用 QUIC，我们需要一个新版本的 HTTP 的原因之一：如果我们只在 QUIC 之上运行 HTTP/2，那么我们将有两个（可能冲突的）“流层”（stream layers）。相反，HTTP/3 从 HTTP 层删除了流的概念（它的数据帧（DATA frames）没有流id），而是重新使用底层的 QUIC 流。</p><p><em>注意：这并不意味着 QUIC 突然知道 JS 或 CSS 文件，甚至知道它正在传输 HTTP；和 TCP 一样，QUIC 应该是一个通用的、可重用的协议。它只知道有独立的流（streams），它可以单独处理，而不必知道它们到底是什么。</em></p><p>现在我们了解了QUIC的流帧（STREAM frames），也很容易看出它们如何帮助解决图9中的传输层队头阻塞：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132627615.png" alt="image-20240427132627615"></p><center>图9：TCP 和 QUIC 在透视图上的差异</center><p>与 HTTP/2 的数据帧（DATA frames）非常相似，<strong>QUIC 的流帧（STREAM frames）分别跟踪每个流的字节范围</strong>。这与 TCP 不同，TCP 只是将所有流数据附加到一个大 blob 中。像以前一样，让我们考虑一下如果 QUIC 数据包2丢失，而 1 和 3 到达会发生什么。与 TCP 类似，数据包1中流1（stream 1）的数据可以直接传递到浏览器。然而，对于数据包3，QUIC 可以比 TCP 更聪明。它查看流1的字节范围，发现这个流帧（STREAM frame）完全遵循流id 1的第一个流帧 STREAM frame（字节 450 跟在字节 449 之后，因此数据中没有字节间隙）。它可以立即将这些数据提供给浏览器进行处理。然而，对于流id 2，QUIC确实看到了一个缺口（它还没有接收到字节0-299，这些字节在丢失的 QUIC 数据包2中）。它将保存该流帧（STREAM frame），直到 QUIC 数据包2的重传（retransmission）到达。再次将其与 TCP 进行对比，后者也将数据流1的数据保留在数据包3中！</p><p>类似的情况发生在另一种情形下，数据包1丢失，但2和3到达。QUIC 知道它已经接收到流2（stream 2）的所有预期数据，并将其传递给浏览器，只保留流1（stream 1）。我们可以看到，对于这个例子，QUIC 确实解决了 TCP 的队头阻塞！</p><p>不过，这种方式有几个重要的后果。最有影响的是 <strong>QUIC 数据可能不再以与发送时完全相同的顺序发送到浏览器</strong>。对于 TCP，如果您发送数据包1、2和3，它们的内容将以完全相同的顺序发送到浏览器（这就是导致队头阻塞的第一个原因）。然而，对于 QUIC，在上面的第二个示例中，在数据包1丢失的情况下，浏览器首先看到数据包2的内容，然后是数据包3的最后一部分，然后是数据包1的（重传），然后是数据包3的第一部分。换言之：<strong>QUIC 在单个资源流中保留了顺序，但不再跨单个流（individual streams）进行排序</strong>。</p><p>这是需要 HTTP/3 的第二个也是最重要的原因，因为事实证明，HTTP/2 中的几个系统非常严重地依赖于 TCP 跨流（across streams）的完全确定性排序。例如，HTTP/2 的优先级系统通过传输更改树数据结构（tree data structure ）布局的操作（例如，将资源5添加为资源6的子级）工作的。如果这些操作应用的顺序与发送顺序不同（现在通过 QUIC 是可能出现的），客户端和服务端的优先级状态可能不同。HTTP/2 的头压缩系统 HPACK 也会发生类似的情况。理解这里的细节并不重要，只需要得出结论：要让这些 HTTP/2 系统直接应用 QUIC 是非常困难的。因此，<strong>对于 HTTP/3，有些系统使用完全不同的方法</strong>。例如，QPACK 是 HTTP/3 的 HPACK 版本，它允许在潜在的队头阻塞和压缩性能之间进行自我选择的权衡。HTTP/2 的优先级系统甚至被完全删除，很可能会被 HTTP/3 的简化版本所取代。所有这些都是因为，与 TCP 不同，QUIC 不能完全保证首先发送的数据也会首先被接收。</p><p>所以，所有 QUIC 和重新设想 HTTP 版本的这些工作都是为了消除传输层队头阻塞。我当然希望这是值得的…</p><h2 id="QUIC-和-HTTP-3-真的完全消除了队头阻塞？">QUIC 和 HTTP/3 真的完全消除了队头阻塞？</h2><p>如果你允许我说一点不好的话，我想引用自己几个段落前的话：</p><blockquote><p>QUIC在单个资源流中保留排序</p></blockquote><p>你想想，这很符合逻辑。它基本上是这样说的：如果你有一个 JavaScript 文件，该文件需要重新组装（re-assembled），就像它是由开发人员创建的一样（或者，老实说，通过 webpack），否则代码将无法工作。任何类型的文件都是一样的：把图片随机地放在一起意味着你阿姨寄来的一些奇怪的电子圣诞卡（甚至更奇怪的）。这意味着，<strong>即使在QUIC中，我们仍然有一种队头阻塞的形式</strong>：如果在单个流中有一个字节间隙，那么流的后面部分仍然会被阻塞，直到这个间隙被填满。</p><p>这有一个关键的含义：QUIC 的队头阻塞移除只有在<strong>多个资源流同时活动时</strong>才有效。这样，如果其中一个流上有包丢失，其他流仍然可以继续。这就是我们在上面图9的例子中看到的。然而，如果在某一时刻只有一个流在活动，任何丢包都会影响到这条孤独的流，我们仍然会被阻塞，即使在 QUIC。所以，真正的问题是：<strong>我们会经常有多个并发流（simultaneous streams）吗？</strong></p><p>正如对 HTTP/2 所解释的，这是可以通过使用适当的资源调度器/多路复用方法来配置的。流1和流2可以被发送 1122、2121、1221 等，并且浏览器可以使用优先级系统指定它希望服务器遵循的方案（对于 HTTP/3 仍然如此）。所以浏览器可以说：嘿！我注意到这个连接有严重的数据包丢失。我将让服务器以 121212 模式而不是 111222 向我发送资源。这样，如果1的一个数据包丢失，2仍然可以继续工作。然而，这种模式的问题是，<strong>121212 模式（或者类似的）对资源加载性能通常不是最优的。</strong></p><p>这是另一个复杂的话题，我现在不想太深入。但是，通过我们的 JS 和 CSS 文件的简单示例，基本概念很容易理解。正如您可能知道的那样，浏览器需要接收整个 JS 或 CSS 文件，然后才能实际执行/应用它（虽然有些浏览器已经可以开始编译/解析部分下载的文件，但它们仍然需要等待它们完整后才能实际使用它们）。但是，大量多路复用这些文件的资源块最终会延迟它们：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用多路复用（较慢）：</span><br><span class="line">---------------------------</span><br><span class="line">                              流1（Stream 1）只有到这里才能使用</span><br><span class="line">                              ▼</span><br><span class="line">12121212121212121212121212121212</span><br><span class="line">                               ▲</span><br><span class="line">                               流2（Stream 2）在这里下载完毕</span><br><span class="line"></span><br><span class="line">未使用多路复用/顺序（流1（Stream 1）更快）：</span><br><span class="line">------------------------------------------------------</span><br><span class="line">                 流1（Stream 1）在这里下载完毕，可以更早地使用</span><br><span class="line">                 ▼   </span><br><span class="line">11111111111111111122222222222222</span><br><span class="line">                               ▲</span><br><span class="line">                               流2（Stream 2）还是在这里下载完毕</span><br></pre></td></tr></table></figure><p>现在，这个话题有很多细微差别，当然也存在多路复用方法更快的情况（例如，如果其中一个文件比另一个文件小得多，正如本文前面讨论的那样）。然而，一般来说，对于大多数页面和大多数资源类型，我们可以说顺序方法最有效。</p><p>现在，这是什么意思？对于最佳性能，我们有<strong>两个相互冲突的性能优化建议</strong>：</p><ol><li>从 QUIC 的队头阻塞移除中获利：多路复用发送资源（12121212）</li><li>为了确保浏览器能够尽快处理核心资源：按顺序发送资源（11112222）</li></ol><p>那么，哪一个是正确的？或者至少：哪一个应该优先于另一个？可悲的是，目前我还不能给你一个明确的答案，因为这是我正在研究的一个主题。这之所以困难，主要是因为<strong>数据包丢失模式很难预测</strong>。</p><p>正如我们在上面讨论过的，包丢失通常是突发性的和分组的。这意味着我们上面 12121212 的例子已经过于简化了。图10给出了一个更真实的概述。在这里，我们假设在下载2个流（绿色和紫色）时，我们有一个8个丢失包的突发事件：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132717355.png" alt="image-20240427132717355"></p><center>图10：HTTP/3 over QUIC 流多路复用对防止队头阻塞的影响。每个矩形是一个单独的QUIC包，为一个流传输数据。红叉表示丢失的包。</center><p>在图10的顶部第一行中，我们可以看到（通常）对资源加载性能更好的顺序情况。在这里，我们看到 QUIC 对消除队头阻塞确实没有那么大的帮助：在丢包之后收到的绿包不能被浏览器处理，因为它们属于经历丢包的同一个流。第二个（紫色）流的数据尚未收到，因此无法处理。</p><p>这与中间一行不同，中间一行（偶然！）丢失的8个数据包都来自绿色流。这意味着浏览器可以处理最后收到的紫色数据包。然而，正如前面所讨论的，如果浏览器是 JS 或 CSS 文件，如果有更多的紫色数据出现，浏览器可能不会从中受益太多。因此，在这里，我们从 QUIC 的队头阻塞移除中获得了一些好处（因为紫色没有被绿色阻止），但是可能会牺牲整体资源加载性能（因为多路复用会导致文件稍后完成）。</p><p>最下面一行几乎是最糟糕的情况。8个丢失的数据包分布在两个流中。这意味着这两个流现在都被队头阻塞了：不是因为它们像TCP那样在等待对方，而是因为每个流仍然需要自己排序。</p><p><em>注意：这也是为什么大多数 QUIC 实现很少同时创建包含来自多个流（streams）的数据包（packets）的原因。如果其中一个数据包丢失，则会立即导致单个数据包中所有流的队头阻塞！</em></p><p>因此，我们看到可能存在某种最佳位置（中间一行），在这里，<strong>队头阻塞预防和资源加载性能之间的权衡可能是值得的</strong>。然而，正如我们所说，丢包模式很难预测。不会总是8个数据包。它们不会总是一样的8个数据包。如果我们搞错了，丢失的数据包只向左移动了一个，我们突然也少了一个紫色的包，这基本上使我们降级到与最下面一行相似的位置…</p><p>我想你会同意我的观点，那听起来很复杂，甚至可能太复杂了。即便如此，问题是这会有多大帮助。如前所述，包丢失在许多网络类型中通常比较少见，可能（也许？）太罕见了，看不到 QUIC 移除队头阻塞的影响。另一方面，已经有很好的文档证明无论您使用的是 HTTP/2 还是 HTTP/3，每个资源的数据包（图10的最后一行）对资源加载性能都是相当不利的。</p><p>因此，有人可能会说，虽然 QUIC 和 HTTP/3 不再受到应用层或传输层队头阻塞的影响，但这在现实中可能并不重要。我不能确定这一点，因为我们还没有完全完成 QUIC 和 HTTP/3 的实现，所以我也没有最后的度量（measurements）。然而，我个人的直觉（这是由我的几个早期实验的结果支持的）说，<strong>QUIC 消除队头阻塞可能实际上对 Web 性能没有太大帮助</strong>，因为理想情况下，您不希望为了资源加载性能而对许多流进行多路复用。而且，如果你真的想让它工作得很好，你就必须非常巧妙地调整你的多路复用方式来适应连接类型，因为你绝对不想在包丢失非常低的快速网络上进行大量的多路复用（因为它们无论如何都不会遭受太多的队头阻塞）。就我个人而言，我不认为会发生这种事。</p><p><em>注意：在这里，在结尾，你可能已经注意到我的故事有点不一致。一开始，我说 HTTP/1.1 的问题是它不允许多路复用。最后，我说多路复用在现实中并不那么重要。为了帮助解决这个明显的矛盾，我添加了另一个额外的彩蛋部分</em></p><h2 id="总结与结论">总结与结论</h2><p>在这篇（很长，我知道）的文章中，我们一直在追踪队头阻塞。我们首先讨论了为什么 HTTP/1.1 会受到应用层队头阻塞的影响。这主要是因为 HTTP/1.1 没有识别单个资源块的方法。HTTP/2 使用帧来标记这些块并启用多路复用。这解决了 HTTP/1.1 的问题，但遗憾的是HTTP/2 仍然受到底层 TCP 的限制。由于 TCP 将 HTTP/2 数据抽象为一个单一的、有序的、但不透明的流，因此如果数据包在网络上丢失或严重延迟，它将遭受队头阻塞。QUIC 通过将 HTTP/2 的一些概念引入传输层来解决这个问题。这反过来会产生严重的影响，因为跨流的数据不再是完全有序的。这最终导致需要一个全新的版本 HTTP/3，它只运行在 QUIC 之上（而 HTTP/2 只运行在 TCP 之上，请参见图6）。</p><p>我们需要所有这些上下文来批判性地思考 QUIC（以及 HTTP/3）中的队头阻塞移除在现实中对 Web 性能的实际帮助有多大。我们看到它可能只会对有大量数据包丢失的网络产生很大的影响。我们还讨论了为什么即使这样，您仍然需要多路复用资源，并看运气丢包对多路复用的影响怎么样。我们看到了为什么这样做实际上弊大于利，因为资源多路复用通常不是 Web 性能的最佳方案。我们得出的结论是，虽然现在确定这一点还为时过早，<strong>但在大多数情况下，QUIC 和 HTTP/3 的队头阻塞移除可能不会对 Web 性能起到多大作用</strong>。</p><p>那么…这又给我们留下什么样的 Web 性能评价呢？忽略 QUIC 和 HTTP/3，坚持 HTTP/2 + TCP？我当然不希望！<strong>我仍然相信 HTTP/3 总体上将比 HTTP/2 快</strong>，因为 QUIC 还包括其他性能改进。例如，它比 TCP 在网络上的开销更小，在拥塞控制方面更加灵活，而且最重要的是，它具有 0-RTT 连接建立特性。我觉得<strong>特别是 0-RTT 将提供最多的Web性能好处</strong>，尽管也有很多挑战。以后我会写另一篇关于 0-RTT 的博客文章，但是如果你迫不及待想知道更多关于放大攻击预防、重放攻击、初始拥塞窗口大小等的信息，请看我的另一篇 YouTube 讲座或阅读我最近的论文。</p><p>如果你喜欢所有这些，并希望在未来有更多的交流，请关注我的 twitter <a href="https://link.zhihu.com/?target=https%3A//twitter.com/programmingart">@programmingart</a>。</p><p>这篇文章的“在线文档”版本可以在  github 上找到。如果您有关于如何改进它的建议，请让我知道！</p><p>感谢您的阅读！</p><h2 id="彩蛋：HTTP-1-1-管道（pipelining）">彩蛋：HTTP/1.1 管道（<strong>pipelining</strong>）</h2><p>HTTP/1.1 包含了一个名为“管道“（pipelining）的特性，在我看来这是经常被误解的。我看过很多文章，甚至书籍中都有人声称 HTTP/1.1 管道解决了队头阻塞问题。我甚至见过一些人说管道和正确的多路复用是一样的。两种说法都是错误的。</p><p>我发现用类似彩蛋图1中的插图来解释 HTTP/1.1 管道是最简单的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132814642.png" alt="image-20240427132814642"></p><center>彩蛋图1：HTTP/1.1 管道</center><p>如果没有管道（pipelining）（彩蛋图1的左侧），浏览器必须等待发送第二个资源请求，直到第一个请求的响应被完全接收（同样使用 Content-Length）。这会为每个请求增加一个往返时间（RTT）延迟，这对Web性能不利。</p><p>有了管道（彩蛋图1的中间部分），浏览器不必等待任何响应数据，现在可以背靠背地发送请求。这样，我们在连接过程中节省了一些 RTTs，使得加载过程更快。<em>另请注意，请回顾图2：您会看到实际上也在使用管道，因为服务器在 TCP 数据包2中打包 <code>script.js</code> 以及 <code>style.css</code> 的响应数据。当然，只有在服务器同时接收到这两个请求时，这才是可能的。</em></p><p>然而，最重要的是，这种管道只适用于来自浏览器的请求。正如HTTP/1.1 规范所说：</p><blockquote><p>服务器必须按照接收请求的顺序发送对这些[管道化]请求的响应。</p></blockquote><p>因此，我们看到，实际的响应块（response chunks）多路复用（如彩蛋图1右侧所示）在 HTTP/1.1 管道中仍然是不可能的。换一种说法：<strong>管道解决了请求的队头阻塞，而不是响应的队头阻塞</strong>。可悲的是，响应队头阻塞是导致 Web 性能问题最多的原因。</p><p>更糟糕的是，大多数浏览器实际上并没有在现实中使用 HTTP/1.1 管道，因为这会使队头阻塞在多个并行 TCP 连接的设置中变得更加不可预测。为了理解这一点，让我们设想一个设置，其中通过两个 TCP 连接从服务器请求三个文件 A（大）、B（小）和 C（小）。A 和 B 在不同的连接上被请求。现在，浏览器应该在哪个连接上传输对 C 的请求？正如我们之前所说，它不知道 A 还是 B 将成为最大/最慢的资源。</p><p>如果它猜对了（B），它就可以在传输 A 所需的时间内同时下载 B 和 C，从而获得了很好的加速效果。但是，如果猜测是错误的（A），B 的连接将长时间处于空闲状态，而 C 则在 A 后面被阻塞。这是因为 HTTP/1.1 也没有提供一种在请求被发送后“中止”的方法（HTTP/2 和 HTTP/3 允许这样做）。因此，浏览器不能简单地通过 B 的连接请求 C，因为它最终会请求两次 C。</p><p>为了解决所有这些问题，现代浏览器不使用管道，甚至会主动延迟对某些已发现资源（例如图像）的请求一段时间，以查看是否找到更重要的文件（例如 JS 和 CSS），以确保高优先级资源不会被阻塞。</p><p>很明显，HTTP/1.1 管道的失败是 HTTP/2 使用截然不同方法的另一个动机。然而，由于 HTTP/2 的优先级系统指导多路复用在现实中常常无法执行，一些浏览器甚至采取了延迟 HTTP/2 资源请求的方式来获得最佳性能。</p><h2 id="彩蛋：TLS-队头阻塞">彩蛋：TLS 队头阻塞</h2><p>如上所述，TLS 协议为应用层协议（如 HTTP）提供加密（和其他功能）。它通过将从 HTTP 获取的数据包装到 TLS 记录中，TLS 记录在概念上类似于 HTTP/2 帧（frames）或 TCP 数据包（packets）。例如，它们在开始时包含一些元数据，以标识记录的长度。然后，对该记录及其 HTTP 内容进行加密并传递给 TCP 进行传输。</p><p>就 CPU 使用率而言，加密可能是一项昂贵的操作，因此一次加密一个好数据块通常是一个好主意，因为这通常更有效。实际上，TLS 可以以高达 16KB 的块加密资源，这足以填充大约 11 个典型的 TCP 包（give 或 take）。</p><p>然而，至关重要的是，TLS 只能对整个记录进行解密，这就是为什么会出现 TLS 队头阻塞的情况。假设 TLS 记录分散在 11 个 TCP 包上，最后一个 TCP 包丢失。由于 TLS 记录是不完整的，它不能被解密，因此被卡在等待最后一个 TCP 包的重传。注意，在这个特定的情况下，没有 TCP 队头阻塞：在编号11之后没有数据包被卡住等待重新传输。换言之，如果我们在本例中使用纯 HTTP 而不是 HTTPS，那么前10个包中的 HTTP 数据可能已经被移动到浏览器中进行处理。然而，因为我们需要整个11包的 TLS 记录才能解密它，所以我们有了一种新形式的队头阻塞。</p><p>虽然这是一个非常具体的情况，在现实中可能不会经常发生，但在设计 QUIC 协议时，它仍然被考虑在内。因为那里的目标是彻底消除所有形式的队头阻塞（或至少尽可能多地消除），甚至这种边缘情况也必须被移除。这就是为什么 QUIC 集成了 TLS，它总是以每个包为基础加密数据，并且不直接使用 TLS 记录。正如我们所看到的，与使用更大的块相比，这效率更低，需要更多的 CPU，这也是为什么 QUIC 在当前实现中仍然比 TCP 慢的主要原因之一。</p><h2 id="彩蛋：传输拥塞控制">彩蛋：传输拥塞控制</h2><p>传输层协议如 TCP 和 QUIC 包括一种称为拥塞控制（Congestion Control）的机制。拥塞控制器的主要工作是确保网络不会同时被过多的数据过载。如果没有缓冲区的话，数据包就会溢出。所以，它通常只发送一点数据（通常是 14KB），看看是否能通过。如果数据到达，接收方将确认发送回发送方。只要所有发送的数据都得到确认，发送方就在每次 RTT 时将其发送速率加倍，直到观察到丢包事件（这意味着网络过载（1 位），它需要后退（1 位））。这就是 TCP 连接如何“探测”其可用带宽。</p><p><em>注：以上描述只是拥塞控制的一种方法。目前，其他方法也越来越流行，其中主要是</em> <a href="https://link.zhihu.com/?target=https%3A//research.google/pubs/pub45646/">BBR 算法</a><em>。BBR 并没有直接观察数据包丢失，而是大量考虑 RTT 波动来确定网络是否过载，这意味着它通常通过探测带宽来减少数据包丢失。</em></p><p>关键是：<strong>拥塞控制机制对每个 TCP（和 QUIC）连接都是独立的</strong>！这反过来也会影响到 HTTP层 的 Web 性能。首先，这意味着 HTTP/2 的单个连接最初只发送 14KB。然而，HTTP/1.1 的6个连接在它们的第一次传输中发送 14KB，大约是 84KB！随着时间的推移，这将变得复杂，因为每个 HTTP/1.1 连接使用每个 RTT 将其数据加倍。第二，只有在数据包丢失的情况下，连接才会降低其发送速率。对于 HTTP/2 的单个连接，即使是一个包丢失也意味着它将减慢速度（除了导致 TCP 队头阻塞之外！）。然而，对于 HTTP/1.1，只有一个连接上的一个包丢失只会减慢这一个连接的速度：其他5个连接可以保持正常的发送和增长。</p><p>这一切使一件事变得非常清楚：<strong>HTTP/2 的多路复用与 HTTP/1.1 的同时下载资源是不一样的</strong>（我还看到一些人声称这一点）。单个 HTTP/2 连接的可用带宽只是在不同文件之间分布/共享，但是块仍然是按顺序发送的。这与 HTTP/1.1 不同，后者以真正的并行方式发送内容。</p><p>现在，您可能会想知道：那么，<strong>HTTP/2 怎么可能比 HTTP/1.1 快呢</strong>？这是一个很好的问题，也是我断断续续问自己很久的问题。一个明显的答案是，如果你有超过6个文件。这就是 HTTP/2 在当时的市场营销方式：将一个图像分割成小正方形，然后通过 HTTP/1.1 vs HTTP/2 加载它们。这主要展示了 HTTP/2 的队头阻塞移除。然而，对于普通/真实的网站来说，事情很快就会变得更加微妙。这取决于资源的数量、大小、使用的优先级/多路复用方案、到服务器的 RTT、实际有多少丢包以及何时发生、同时链路上有多少其他流量、使用的拥塞控制器逻辑，等等。HTTP/1.1 可能会丢失的一个例子是在可用带宽有限的网络上：6个 HTTP/1.1 连接各自增加其发送速率，导致它们很快使网络过载，之后它们都必须后退，必须通过反复试验找到它们共存的带宽限制（在 HTTP/2 之前，人们认为 HTTP/1.1 的并行连接可能是因特网上数据包丢失的主要原因）。单个 HTTP/2 连接增长较慢，但在包丢失事件后恢复速度更快，并且更快地找到最佳带宽。另一个带有注释的拥塞窗口的更详细的，HTTP/2 更快的示例可以看[这张图片（不适用于胆小的人）。</p><p>QUIC 和 HTTP/3 将面临类似的挑战，就像 HTTP/2 一样，HTTP/3 将使用单一的底层 QUIC 连接。然后，您可能会说 QUIC 连接在概念上有点像多个 TCP 连接，因为每个 QUIC 流都可以看作一个TCP连接，因为丢失检测是在每个流的基础上完成的。然而，关键的是，QUIC 的拥塞控制仍然是在连接级别完成的，而不是针对每个流。这意味着，即使流在概念上是独立的，它们仍然会影响 QUIC 的单连接拥塞控制器，如果流中有任何一个丢失，就会导致速度减慢。换句话说：单个 HTTP/3+QUIC 连接仍然不会像 6 个 HTTP/1.1 连接那样快速增长，类似于一个连接上的 HTTP/2+TCP 增长速度并不快。</p><h2 id="彩蛋：多路复用是否重要？">彩蛋：多路复用是否重要？</h2><p>如上所述，并在本演示文稿中进行了深入解释，通常建议以顺序方式而不是多路传输方式发送大多数网页资源。换一种说法，如果你有两个文件，你通常最好发送 11112222 而不是 12121212。对于需要在应用之前完全接收的资源，如 JS、CSS 和字体，尤其如此。</p><p>如果是这样的话，我们可能会想为什么我们需要多路复用？通过扩展：HTTP/2 甚至 HTTP/3，因为多路复用是 HTTP/1.1 没有的主要特性之一。首先，一些可以增量处理/呈现的文件确实从多路复用中获益。例如，渐进式图像就是这样。第二，如上所述，如果其中一个文件比其他文件小得多，那么它可能会很有用，因为它将更早地下载，而不会对其他文件造成太多的延迟。第三，<strong>多路复用允许改变响应的顺序，并为高优先级的响应中断低优先级的响应</strong>。</p><p>现实中出现的一个很好的例子是在源服务器前面使用 CDN 缓存。假设浏览器从 CDN 请求两个文件。第一个（1）没有被缓存，需要从源文件中获取，这需要一段时间。第二个资源（2）缓存在 CDN 中，因此可以直接传输回浏览器。</p><p>在一个连接上使用 HTTP/1.1，由于队头阻塞，我们必须等待队头完全发送（1），然后才能开始发送（2）。这将给我们带来 11112222，但需要很长的前期等待时间。然而，使用HTTP/2，我们可以立即开始发送（2），利用 CDN 和源节点之间的“思考时间”，并“预热”连接的拥塞控制器。重要的是，如果（1）在（2）完成之前开始到达，我们现在可以简单地开始将（1）的数据注入到响应流中。这样我们就可以得到 22111122，等待的时间要短得多。甚至可以在连接开始时使用服务器推送（Server Push）或103早期提示（103 early hints）等功能。</p><p>因此，虽然像 12121212 这样的完全“轮询”多路复用很少是您想要的 Web 性能，但是多路复用在总体上绝对是一个有用的特性。</p>]]></content>
    
    
    <summary type="html">Head-of-Line Blocking</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
